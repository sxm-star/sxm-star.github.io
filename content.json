{"pages":[{"title":"","text":"404 UH OH! 页面丢失 您所寻找的页面不存在。你可以点击下面的按钮，返回主页。 返回首页","link":"/404.html"},{"title":"","text":".about { font-size: 1.2em; font-weight: bold; color: #4a4a4a; } .about hr{ background-color: #4a4a4a; margin-top: 0; box-shadow: 1px 2px 8px #000; } 关于我 90后一枚计算机软件专业目前从事Java后端开发工作 关于本博客 本博客初始定位就不是一个技术博客，所以也会记录一些生活琐事。PS: 也就是看心情更新的意思！！！ 如果您恰巧来到了本博客，并且博客中的内容对您有些许帮助的话，我也是不胜荣幸呢。 大事件： ● 2017-12-14：入坑Hexo，主题选用的是yilia● 2019-05-17：更换主题为icarus ，并做了些小小的改动● 2020-05-30：升级icarus主题到3.0版本，并做了些小小的改动","link":"/about/index.html"},{"title":"友情链接","text":"排名不分先后，大概就是按顺序一直往后加吧~~~ 加载中，稍等几秒... 如您希望交换友情链接，可以发邮件[trainoo@163.com]给我~本博客暂未开通留言功能，也不打算开通，所以邮件吧，感谢理解！ 本站友链信息如下：网站名称：Trainoo网站地址：https://trainoo.gitee.io/头像地址：https://trainoo.gitee.io/img/header.png网站简介：A simple man living a simple life","link":"/friend/index.html"},{"title":"文章分类","text":"","link":"/categories/index.html"},{"title":"gallery","text":"","link":"/gallery/index.html"},{"title":"links","text":"","link":"/links/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"timeline","text":"","link":"/timeline/index.html"}],"posts":[{"title":"PHP整体了解","text":"PHP相关名词介绍 Cygwin Cygwin是一个在windows平台上运行的类UNIX模拟环境，是cygnus solutions公司开发的自由软件 Apache httpd与Nginx 都是WEB服务器，各有利弊，不赘述 XAMPP,适合快速一键搭建开发环境 XAMPP（Apache+MySQL+PHP+PERL）是一个功能强大的建站集成软件包。这个软件包原来的名字是 LAMPP，但是为了避免误解，最新的几个版本就改名为 XAMPP 了。它可以在Windows、Linux、Solaris、MacOX等多种操作系统下安装使用，支持多语言：英文、简体中文、繁体中文、韩文、俄文、日文等。 Eclipse PDT，ZendStudio，PhpStorm三大流行开发工具 Eclipse PDT的全称是Eclipse PHP Development Tools,是一款很不错的PHP开发工具Zend Studio是Zend Technologies公司开发的PHP语言集成开发环境(IDE)PhpStorm 是 JetBrains 公司开发的一款商业的 PHP 集成开发工具（个人推荐） PHP开发环境搭建下载xampp： https://www.apachefriends.org/index.html，选对应的系统平台,一路next安装即可 注意下载xampp-osx-版本号-installer，而不要下载xampp-osx-版本号-vm Windows平台 安装 PhpStorm之后，可以打开项目目录指向到 xampp的htdoc目录下，修改php示例代码，另外下载Cygwin模拟 Linux环境操作 MAC平台 xampp-vm的htdoc目录在 /Users/你本地用户名/.bitnami/stackman/machines/xampp/volumes/root/htdocs，xampp挂载到了 /opt/lamppxampp-installer的htdoc目录在 /Applications下 bin -&gt; xamppfiles/bin cgi-bin -&gt; xamppfiles/cgi-bin etc -&gt; xamppfiles/etc htdocs -&gt; xamppfiles/htdocs logs -&gt; xamppfiles/logs manager-osx.app -&gt; xamppfiles/manager-osx.app uninstall.app xamppfiles phpstorm-》Preferences -》Languages &amp; Frameworks 下的 php,配置成xampp安装目录下的bin目录下的 php linux平台同上，安装完之后，xampp在 /opt/lampp目录下,其它同理。 PHP基础语法 PHP标记符 &lt;?php ?&gt; 区分大小写 主要是指变量名区分大小写 常量通常也区分，但常量也可以自己设定为不区分（不推荐） 但函数名不区分 而系统中使用的关键字也不区分大小写，比如if， else， for 语句结束符，用分号 一个php标记块中的最后一个分号可省略 php结束标记省略则不能省略最后一个分号 注意：通常，在“能够出现”变量的语法中，只要出现＄符号，并在其后出现紧挨着的字符，就会被识别为一个变量，即使不存在该变量 常量与变量 变量定义是 $变量名 ，示例：$age = 10 $age = 10; echo $age; 删除unset()：就是断开变量名跟数据之间的“引用关系”；isset(变量名)：• 判断变量是否存在，即引用是否为null &lt;?php $v1 = 1; if( isset($v1) ){ echo &quot;&lt;br /&gt;v1存在&quot;; } unset($v1); if( !isset($v1) ){ echo &quot;&lt;br /&gt;v1断开了与数据的引用&quot;; } ?&gt; 常量定义–php5之后的定义是 const YEAR = 2014; echo 但const语法只能在“最顶层”的代码域中使用（不能在大括号中）,也即，const语法不能在函数中或条件语句中或其他表示一个“范围”的语句中使用 常量定义–php5之前常量定义如下： define(&quot;YEAR&quot;,2014); echo YEAR; 常量变量的区别： 定义形式不同： 使用形式不同：常量无需$符号 可变程度不同：常量的值不可以改变，常量也不可以销毁 作用范围不同：常量具有超全局作用域 （函数内外都可以直接使用） 可用类型不同：常量只能存储标量类型：int，float，string，bool 判断常量是否存在：defined() // 判断的结果为布尔值。 常用形式：if ( defined (某常量名） == false ){ .....这里可以去定义该常量；} // 实际上，可以这样： $result = defined (某常量名）; //结果是true或false 行业规则中，有如下几种常用的命名规则： 1，驼峰命名法：示例：name， myName， myFatherName 2，帕斯卡命名法：示例：Name， MyName， MyFatherName 3，下划线间隔法：示例：name， my_ame， my_father_name 变量间的传值方式 1，这里讨论的传值方式是指：一个变量对另一个变量 2，它不仅仅适用于赋值语句，也适用于其他有同样含义的语句，比如：函数的实参到形参 3，传值方式只有2种：值传递，引用传递 4，php中，所有变量，默认都是值传递。 5，要想使用引用传递，必须使用引用传递的符号： &amp; &lt;?php $v1 = 1; $v2 = $v1; //此时发生传值问题 $v3 = $v1+10;//此时没有传值问题 $v2++; echo &quot;&lt;br /&gt;v1=$v1, v2=$v2&quot;; echo &quot;&lt;br /&gt;&quot;; echo &quot;&lt;br /&gt;&quot;; echo &quot;&lt;br /&gt;&quot;; $v10 = 10; $v20 = &amp;$v10; //此时发生传值问题,注意符号：&amp; $v20++; echo &quot;&lt;br /&gt;v10=$v10, v20=$v20&quot;; echo &quot;&lt;br /&gt;&quot;; unset($v20); echo &quot;&lt;br /&gt;v10=$v10, v20=$v20&quot;; //v1=1, v2=2 //v10=11, v20=11 //v10=11, v20= ?&gt; 可变变量所谓可变变量，就是一个变量的名，又是一个变量。 可变变量的语法是php的很特殊的语法——其他语言中少见。$v1 = “abc”; //这是一个字符串变量，其内容是字符串“abc”$abc = 10; //这是一个普通变量，其内容是数字10echo $$v1; //此时，就是所谓“可变变量”怎么理解：1，凡是$符号出现，就会有可能理解为是一个变量2，这里第一个“$”出现了，则php就视图将其解释为一个变量，变量名是$v1;3，我们有知道，$v1的值是”abc”，4，那么，第一个“$”符号后面的变量名，就得到为“abc”5，即：echo 试图输出的是变量$abc， 自然是数字10实际上，理论上，可变变量的嵌套还可以更多，比如：$$$def; 预定义变量 综述：1：预定义变量又叫超全局变量，包括：$_GET, $_POST, $_SERVER, $_REQUEST, $GLOBALS, $_COOKIE, $_SESSION, ……….（大约10个）2：作用域问题php中，自定义的变量的作用域，分两种：全局作用域（函数外），局部作用域（函数内）。但：预定义变量的作用域称为“超全局作用域”：全局作用域 + 局部作用域的总和（函数内外全都可用）3：数据类型问题：超全局变量都是数组！ &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt; &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;zh-cn&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot; /&gt; &lt;title&gt;网页标题&lt;/title&gt; &lt;meta name=&quot;keywords&quot; content=&quot;关键字列表&quot; /&gt; &lt;meta name=&quot;description&quot; content=&quot;网页描述&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;&quot; /&gt; &lt;style type=&quot;text/css&quot;&gt;&lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;?php if( $_POST ) //如果有post数据 { $data1 = $_POST['n1']; //相应接收每个表单项的数据值 $data2 = $_POST['n2']; //特别注意：表单项的值字符串类型 $fuhao = $_POST['yunsuanfu']; if( is_numeric($data1) &amp;&amp; is_numeric($data2) ) //$data1是数字 并且 $data2 是数字 { //开始计算 switch($fuhao){ case &quot;+&quot;: $result = $data1 + $data2; break; case &quot;-&quot;: $result = $data1 - $data2; break; case &quot;*&quot;: $result = $data1 * $data2; break; case &quot;/&quot;: if($data2 == 0){ $result = &quot;除数不能为0&quot;; } else{ $result = $data1 / $data2; } break; } echo &quot;计算结果为： $result&quot;; } else{ //否则： echo &quot;请输入数字进行计算&quot;; } } else{ echo &quot;请从正确的页面输入数据并提交！&quot;; } ?&gt; &lt;/body&gt; &lt;/html&gt; $_REQUEST数组，其实并不是一个独立的数据来源，而是$_POST数据和$_GET数据的“总和”,即$_REQUEST数组中包括了所有$_POST数据和$_GET数据——其实是由系统内部自动存储的。通常，$_POST数据和$_GET数据不会“同时出现”，$_REQUEST数组就代表了其中之一。 下面来看看：get和post数据同时提交的情形：此时，一般就只有一种html语法形式会出现该情形，如下： &lt;form action=&quot;abc.php?a=5&amp;b=10&quot; method=&quot;POST&quot; &gt; 项目1： &lt;input type=”text” name=”uName” /&gt; 项目2： &lt;input type=”password” name=”uPswd” /&gt; &lt;input type=”submit” value=”提交” /&gt; &lt;/form&gt; // 则此时，uName和uPswd两个数据以post方式提交给abc.php, // 并，同时：a=5和b=10两个数据，以get方式提交给abc.php // 则在页面abc.php中： // 这样取得get数据： $v1 = $_GET[‘a’]; $v2 = $_GET[‘b’]; // 这样取得post数据： $v3 = $_POST[‘uName’]; $v4 = $_POST[‘uPswd’]; // 但，也可以这样取（全有了）： $v1 = $_REQUEST[‘a’]; $v2 = $_REQUEST[‘b’]; $v3 = $_REQUEST[‘uName’] $v4 = $_REQUEST[‘uPswd’] 当get数据和post数据同时提交并其中有重名的时候，情况怎么样呢？说明：1，尽量避免重名；2，如果重名了，此时$_REQUEST只会记录（存储）其中一个数据（要么post数据，要么get数据）3，至于记录的是哪个，是有php.ini中的一个设置项来决定：3.1 request_order = “GP”; //这是默认值，G代表GET，P代表POST3.2 含义是：先存储GET数据，再存储POST3.3 可见如果重名，此时POST就会覆盖GET数据3.4 改为：request_order = “PG”， 顺序反过来 $_SERVER变量（数组）,该变量存储了服务器端或客户端的一些请求信息或设置信息，比较多，而且不同的服务器和不同的请求页面，其数据项都可能不同。常用的有：REMOTE_ADDR, 用户的IP地址SERVER_ADDR: 服务器端的IP地址SERVER_NAME: 服务器名（主机名）DOCUMENT_ROOT: 站点绝对路径（其实就是主机设置中的DocumentRootPHP_SELF：当前网页的文件路径QUERY_STRING: 表示一个get请求的整体字符串，类似这样：http://www.abc.com/abc.php?a=5&amp;b=10连接地址中的 “a=5&amp;b=10” $GLOBALS变量（数组）,似乎是一个多余的变量：它只是把我们自己定义的所有全局变量存储到该数组中：变量名就是该数组的下标（键名），变量值就是对应的值。 魔术常量魔术常量其实是一种值会随着一定的条件（环境）而变化的常量，形式和使用上是常量，但实际上，其值会改变。 比如：__DIR__（当前网页文件的所在目录），__FILE__（当前网页文件），__LINE__（当前这一行） 魔术常量其实类似变量，其值随着不同代码而变化，不区分大小写 &lt;?php echo &quot;&lt;BR /&gt;当前网页文件所在目录为：&quot; . __DIR__; echo &quot;&lt;BR /&gt;当前网页文件为：&quot; . __FILE__; echo &quot;&lt;BR /&gt;当前为第&quot; . __LINE__ . &quot;行&quot;; echo &quot;&lt;BR /&gt;当前为第&quot; . __LINE__ . &quot;行&quot;; echo &quot;&lt;BR /&gt;当前为第&quot; . __LINE__ . &quot;行&quot;; ?&gt; 函数 //无参函数 function msg(){ echo 'hello'; } msg(); //有参函数 function sum($a,$b){ return $a + $b; } echo sum(3,4); 两种字符串连接方式 //第一种方式 echo 'hello'.'world'; //第二种方式 $year = 2014; $month = 11; echo &quot;year is $year month is $month&quot;; php常用函数库参考手册： https://www.php.net/manual/zh/ 时间函数 &lt;?php echo time().'&lt;br&gt;'; echo date_default_timezone_get() .'&lt;br&gt;'; echo date('Y-m-d H:i:s') . '&lt;br&gt;'; date_default_timezone_set('Asia/Shanghai'); echo date('Y-m-d H:i:s') . '&lt;br&gt;'; echo date('Y-m-d H:i:s',1607065475) . '&lt;br&gt;'; ?&gt; json格式数据的操作 &lt;?php $arr = array(1,2,3,4,5,6,&quot;hello&quot;,&quot;world&quot;); print_r($arr); echo json_encode($arr) . '&lt;br&gt;'; $arrJsonStr = '[1,2,3,4,5,6,&quot;hello&quot;,&quot;world&quot;]'; $arrObj = json_decode($arrJsonStr); echo $arrObj[0]. $arrObj[count($arrObj)-1] . '&lt;br&gt;'; $map =array('name'=&gt;'xm','age'=&gt;22); print_r($map); echo json_encode($map) . '&lt;br&gt;'; $pensonJsonStr = '{&quot;name&quot;:&quot;shily&quot;,&quot;sex&quot;:&quot;女&quot;,&quot;age&quot;:&quot;23&quot;}'; $personObj = json_decode($pensonJsonStr); echo 'json转对象获取到的字段数据'.$personObj-&gt;name . $personObj-&gt;sex . $personObj-&gt;age ?&gt; 文件操作 文件写 &lt;?php $file = fopen(&quot;dataFile&quot;,&quot;w&quot;); if($file){ fwrite($file,&quot;hello world&quot;); fclose($file); }else{ echo '创建文件失败'; } ?&gt; 文件读 $file = fopen(&quot;dataFile&quot;,&quot;r&quot;); if ($file){ $content = fgets($file); //只能读一行; echo $content.&quot;&lt;br&gt;&quot;; }else{ echo &quot;打开文件失败&quot;; } while (!feof($file)){ echo fgets($file) . '&lt;br&gt;';//循环读直到文件末尾 } fclose($file); 一次性读取所有内容 echo file_get_contents(&quot;dataFile&quot;); 生成图片 &lt;?php header(&quot;Content-type:image/png&quot;); $img = imagecreate(400,400); imagecolorallocate($img,255,255,255); imagerectangle($img,20,20,100,100,23); imagepng($img); ?&gt; 图片水印(从已有图片加载，添加水印) &lt;?php header(&quot;Content-type:image/png&quot;); $img = imagecreatefrompng(&quot;s.png&quot;); imagestring($img,50,50,50,&quot;ecit.cn&quot; ,imagecolorallocate($img,0,0,255)); imagepng($img) ?&gt;","link":"/2014/11/18/PHP/php%E6%95%B4%E4%BD%93%E4%BB%8B%E7%BB%8D/"},{"title":"C-基本数据类型-条件结构-循环控制","text":"基本数据类型常量和变量常量 在程序执行过程中，其值不发生改变的量称为常量。 在程序中，常量可以不经说明而直接使用。 常量分类 直接常量（字面常量/字面值）对应数据类型的常量，包括：整型常量：12U、0L、-3实型常量：4.6F、-1.23字符常量：‘a’、‘b’字符串常量: “Hello” 符号常量符号常量定义成宏的形式：**#define 符号常量 值**习惯上符号常量使用大写字母 变量 在程序执行过程中，其值可以改变的量称为变量。 一个变量应该有一个名字，在内存中占据一定的存储单元。 变量定义必须放在变量使用之前，一般放在函数体的开头部分。 要区分变量名和变量值是两个不同的概念 变量的声明 主要是告诉编译器变量的类型和名字，在使用之前知道有这样一个变量的存在，它并不分配存储空间。格式: 数据类型 变量名；如： int count; double radio; 变量的定义和初始化 为变量分配存储空间，同时指明变量的类型和名字。格式: 数据类型 变量名 = 变量值如： int count = 100； //定义时初始化 在C语言中，变量有且只能定义一次，但声明可以有多次 数据类型 数据类型是按照定义变量的性质，表示形式，占据存储空间的多少，构造特点来划分的。在C语言中，数据类型可以分为：基本数据类型、构造数据类型、指针类型、空类型四大类型。C语言中有自带的数据类型，也可以自定义数据类型。 数据类型分类 整型整型数据在内存中的存放形式是以补码表示的 正数的补码和原码相同 负数的补码：第一位是符号位，除符号位，每一位求反后加 1 。 字符型 C语言中字符是用单引号括起来 如:’a’、’1’、’A’等 字符型用于存储字符，对应ASCII编码的二进制形式存储，占用 1个字节 如：字符’a’的ASCII代码为97 C语言把字符类型看作一种特别短的整数类型，允许参与算术运算。 ASCII编码 美国信息互换标准代码的简写，是基于英语的一种编码方式，用于计算机的信息传输。 ASCII共定义了256个代码(从 0-255)，从 0-32位为控制字符（ASCII control characters），从 33-127位为可打印字符。从 0-127是标准的ASCII编码，从128-255是扩展的ASCII编码。 标准ASCII代码中，最高位为奇偶校验位。 所谓奇偶校验位是指在代码传送过程中用来检验是否出现错误的一种方法，一般分奇校验，偶校验两种。 字符串常量 字符串常量占的内存字节数等于字符中字节数加 1. 增加的一个字节中存放字符“\\0”这是字符串结束的标志。 格式化输入输出函数 printf函数的使用语法printf(“格式控制字符串”,输出列表) scanf函数的使用语法scanf(“格式控制字符串”,地址列表) 扩展：1 只读变量 和 常量只读变量 只能读的普通变量，可以称其为“不能改变的变量”。 只读变量的定义 类型const只读变量名 = 值；//const和类型可以对调 在C语言中可通过指针来修改只读变量的值，但编译时会抛出警告。在C++中是不允许来修改只读变量的值，编译无法通过。 区别 只读变量是个变量，定义时需要给它分配内存空间或者说是缓冲。而常量不是变量，是一个静态的值，不需要为它分配内存空间。只读变量不能用来作为定义数组的维数，也不能放在case关键字后面，而常量可以。 扩展：2 浮点型浮点型变量 单精度(float型) 占4个字节（32位）内存空间 精度为6（6位小数） 双精度(double型) 占8个字节（64位）内存空间 精度为15（15位小数） 长双精度(long double型) 至少占 8个字节（64位）内存空间 浮点型存储方式 扩展：3 枚举类型 枚举类型的声明enum 枚举类型名 {枚举值1，…,枚举值n};在枚举值中应列出所有可用值，这些值也称为枚举元素 枚举变量的定义 方式一enum 枚举类型名 枚举变量1，枚举变量2,…,枚举变量n; 方式二enum 枚举类型名{枚举值1，…,枚举值n} 枚举变量列表； 方式三enum {枚举值1，…,枚举值n} 枚举变量列表； 枚举类型的注意点 枚举类型也属于整型 枚举元素本身由系统定义了一个表示序号的数值，从0开始顺序定义为0，1，2，。。。 枚举值是符号常量不是变量，不能在程序中用赋值语句再对它赋值 在声明枚举类型可同时对枚举值赋值enum weekday{sun=0,mou=1,tue=2,wed=3,thu=4,fri=5,sat=6} 扩展：4 字符输入和输出函数条件结构条件语句上条件语句下条件运算符循环控制while和do-while循环for循环跳转语句","link":"/2012/10/23/c/C-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E6%9D%A1%E4%BB%B6%E7%BB%93%E6%9E%84-%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6/"},{"title":"GCC、GDB介绍","text":"GCC介绍GCC的发展 GNU(意为非洲牛羚)项目，又称 革奴计划，是由Richard Stallman在1983年创办。 1985年，Richard Stallman又创立了自由软件基金会（Free Software Foundation,简称FSF）来为GNU提供技术、法律以及财政支持。 编译器GCC就是GNU开发出来的一款编译器软件，GCC是GNU CC的简称。 GCC符合 ANSI C 标准，能够编译C、C++、Object C 等语言编写的程序。GCC还是一个交叉平台编译器，能够在当前CPU平台为多种不同架构的硬件平台开发软件，因此适合嵌入式领域的开发编译。 GCC是免费的，可移植。支持Windows，Linux等操作系统。Windows 中文下又叫 MinGW。下载地址：http://www.mingw.org GCC的基本语法 gcc [options] [filenames] options: 编译器所需要的编译选项 filenames: 要编译的文件名（通常是文件路径） options常用编译选项基本选项： -c: 只是编译不链接，生成目标文件 “.o” -S: 只是编译不汇编，生成汇编代码 -E: 只进行预编译，不做其它处理 -g: 在可执行程序中包含标准调试信息 -o file: 指定输出文件 -v: 打印出编译器内部编译各过程的命令行信息和编译器的版本 **-std=name:**指定C语言的标准（如：c99等） -l dir: 在头文件的搜索路径列表中添加 dir 目录 优化选项：-O选项，基本优化：减小代码的长度和执行时间，效果等价于 -O1，其中包括线程跳转和延迟退栈。-O2选项，最大优化： 除完成所有 -O1级别的优化之外，同时还要进行一些额外的调整工作，如处理器指令调度等。-O3： 除完成所有 -O2 级别的优化之外，还包括循环展开和其他一些与处理器特性相关的优化工作。 数字越大优化的等级越高，也就意味着程序的运行速度越快。一般选用 -O2选项，它在优化长度、编译时间和代码大小之间取得了一个比较理想的平衡点。 示例程序： #include&lt;stdio.h&gt; int main(void) { double counter; double result; double temp; for(counter = 0; counter &lt; 4000.0 * 4000.0 * 4000.0 / 20.0 + 2030; counter += (5 - 3 + 2 + 1) / 4){ temp = counter / 1239; result = counter; } printf(&quot;Result is %lf \\n&quot;,result); return 0; } 不优化执行时间查看优化后执行时间查看 警告和出错选项： -ansi: 支持符合ANSI标准的C程序 **-pedantic:**允许发出 ANSI C标准所列出的全部警告信息 -pedantic-error: 允许发出 ANSI C标准所列出的全部错误信息 **-w:**关闭所有警告 -Wall: 允许发出gcc所提供的所有有用的报警信息 制作库文件选项：-L dir : 在库文件的搜索路径列表中添加 dir 目录-static： 链接静态库-lname: 链接名为 name 的库文件-shared： 表明是使用共享库 GDBGDB调试器 GDB是GNU开源组织发布的一个强大的Unix/Linux下的程序调试工具，没有图形化的友好界面，但是它强大的功能也足以与微软的VC等工具相媲美。 GDB的作用 启动用户程序后，可以按照用户的要求随意运行程序。 可让被调试的程序在用户所设定的断点处停住 当程序被停住时，可以检查此时用户程序中所发生的事 可动态改变用户程序的执行环境 GDB调试的编译选项gcc -g [其它选项] [文件名] gdb进行调试的是可执行文件而不是源代码，对 .c 源文件进行编译一定要加上选项 “-g”,这样编译出的可执行文件才包含调试信息。 gdb调试流程调试命令：l(list): 查看所载入的文件b(break)：设置断点，程序运行到断点即可停止info b: 查看设置的断点情况r(run): 从第一行开始运行代码，或者指定行开始，可在r后面加上行号**p n:**查看变量n 的值n(next): 单步运行下一行代码（遇到函数不会进入函数）**s(step):**单步运行下一行代码(遇到函数会进入函数)c(continue): 恢复程序的运行，执行剩余的程序 示例 #include&lt;stdio.h&gt; int sum(int size) { int i = 0; int sum = 0; for(i = 1;i&lt;=size;i++){ sum = sum + i; } return sum; } int main(void) { printf(&quot;请输入 一个数字 n,将完成1+ ···+ n的和 \\n&quot;); int size; scanf(&quot;%d&quot;,&amp;size); int result = sum(size); printf(&quot;1+···+n的和是 ：%d \\n&quot;,result); } 执行 gcc -g -o sum sum.c 执行 gdb sum 进入调试阶段","link":"/2012/10/22/c/c-gcc-gdb/"},{"title":"C-图形库的选择GTK","text":"C-图形库的介绍更好的GUI选择 不跨平台的：Booland C++ 的VCL（微软同时代MFC起来的，比微软MFC 好用多了） 跨平台的纯C ： GTK 跨平台的C++ ：WxWidgets（推荐）, QT , Gtk++, DirectUI(dulib、迅雷Bolt) GTK选择 简单，强大 Flat API,不需要面向对象知识，用纯面向过程编写代码 GTK的思想和 JavaScript BOM 、Android UI、IOS非常类似，方便轻松学习后者","link":"/2012/12/20/c/c%E5%9B%BE%E5%BD%A2%E5%BA%93%E7%9A%84%E9%80%89%E6%8B%A9/"},{"title":"补码","text":"补码 在计算机系统中，数值一律用补码来表示（存储）。补码的引入主要是为了解决两个问题： 对有符号和无符号数统一处理； 按加法的方式来处理减法。 背景 考虑用8位数据的最高位来表示符号，1表示负，0表示正。 00000000b:0 00000001b:1 00000010b:2 01111111b:127 10000000b:? 10000001b:-2 11111111b:-127 从上面就可以发现两个问题 ：0就出现了两种表示；1加-1 结果变成了 -2. 因此开始出现了反码。总结：负数求补码规律：原码 → 按位取反 → 加1的到补码形式示例：+7的原码（0000111）→ 按位取反(1111000) → 加1 (1111001)所以 -7 的补码是 11111001 。","link":"/2012/10/23/c/%E8%A1%A5%E7%A0%81/"},{"title":"docker环境搭建记录","text":"记得先关闭掉 sellinux 查看一下当前 sellinux 是否是 enabled例如:root@iZbp16i3yrwgguxdfh3co5Z:/etc/selinux# sestatusSELinux status: enabled 关闭 sellinux 操作,SELINUX=disabled cd /etc/selinux vi config SELINUX=disabled 保存，然后重启 reboot","link":"/2017/12/01/docker/docker%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"title":"Groovy-第一篇","text":"Groovy介绍 Groovy是JAVA平台上脚本语言，抽象程度更高可以更简单快速的开发，可以编写更少的代码。 与JAVA语言无缝集成，可称为超级JAVA 使用“类JAVA语法”，JAVA程序员可以快速过渡。 Groovy与JAVA二进制兼容，都生成字节码，所以可以与使用JAVA语言所编写的框架和组件完美集成，并且效率安全方面比其他脚本语言要高。 Groovy对象就是JAVA对象，使用与JDK相同的API。 可以保护整个JAVA产业在JAVA上的巨大投资。 在中小型项目可以替代JAVA，在大型JAVA项目中可以嵌入Groovy应用 Groovy的特征 Groovy = java -重复的样板代码 +可选的动态类型 +闭包（closures） +领域规范语言（DSL） +生成器（Builders） +元编程(metaprogramming)Groovy 是没有类型/修饰符/return/Iterator,不需要导入集合的JAVA。Groovy丢掉了许多JAVA的包袱。不能确定变量类型时将变量类型设为Object。DSL：domain specific languages生成器：可以生成XML/HTML/Swing数状数据结构元编程：运行时对类增加行为，类似于AOP。 搭建Groovy开发环境所需准备-JDK1.5或者更高版本 配置好环境变量-Groovy-1.5.4或者更高版本 Groovy安装完会自动配置。-Eclipse IDE 、MyEclipse 或者idea IDE 均可-MySQL 数据库-Jad反编译工具及Eclipse插件（可选） Eclipse的Groovy插件URL：http://dist.springsource.org/release/GRECLIPSE/e4.3-j8/参考：https://github.com/groovy/groovy-eclipse/wiki","link":"/2017/09/01/groovy/groovy-2017-09-01/"},{"title":"Groovy-第二篇（语法）","text":"Groovy自动导入如下包 groovy.lang.*groovy.util.*java.lang.*java.util.*java.util.regex.*java.net.*java.io.*java.math.BigDecimaljava.math.BigInteger Groovy脚本测试Groovy的脚本测试可以用 groovyConsole命令启动窗口 来测试示例： 数值 Groovy的一切都是对象。可以自动装箱与拆箱。 整数123，-12，0都是Integer类的对象。定义变量（使用动态类型）： def price=100等同于： Integer price = new Integer(100) 3.times {print ‘Hello world!’} //这个是指输出三次打印语句输出如下： groovy&gt; 3.times {print ‘Hello world!’} Hello world!Hello world!Hello world! 语句可以不用“；”结尾。 浮点数1.5，-3.14都是BigDecimal类的对象。数值类型：Integer 15 Long 100L 100lFloat 1.23f,4.56F Double 1.23d 4.56Djava.math.BigInteger 123g,456Gjava.math.BigDecimal 1.23,1.23g,1.23G 表达式与运算符 基于方法的运算符 a==b 等价 a.equals(b)","link":"/2017/09/02/groovy/groovy-2017-09-02/"},{"title":"网易蜂巢","text":"介绍网易蜂巢是网易推出的一款采用 Docker容器化技术的云计算平台，支持极速创建容器或服务，支持自定义镜像构建，提供云关系数据库、负载均衡、云安全等丰富后端服务。官网地址 https://c.163.com/ 蜂巢产品 蜂巢特点 保证环境的一致性 开发自助运维 一键发布部署 自动弹性扩容 创建容器 网易蜂巢后台管理页面","link":"/2017/10/08/javaee/%E7%BD%91%E6%98%93%E8%9C%82%E5%B7%A2/"},{"title":"Babel","text":"介绍 Babel 通过语法转换器支持最新版本的 JavaScript 。 这些插件允许你立刻使用新语法，无需等待浏览器支持。 全局安装 npm install –global babel-cli babel –help 便可查看安装是否完成 某个项目单独安装 新建一个目录，示例 mkdir babel 新建 package.json文件 ，示例 cd babel &amp;&amp; npm init 一路回车 新建 babel ,示例: npm install –save-dev babel-cli 查看安装成功与否,示例： babel/node_modules/.bin/babel –help 回车查看 可以用atom打开进行编辑 cd babel &amp;&amp; atom ./ 回车 es6 转es5 还需要安装插件前提 test.js //es 6箭头函数写法 let dessert = x =&gt;x++; npm install –save-dev babel-preset-es2015 babel test.js –presets=es2015，可以看到转es2015的效果&quot;use strict&quot;; //es 6箭头函数写法 var dessert = function dessert(x) { return x++; }; babel test.js –presets=es2015 –out-file test-compile.js 可以指定把转换后的重新输出到指定文集babel –watch test.js –presets=es2015 –out-file test-compile.js 可以实时监测显示指定把转换后的重新输出到指定文集babel src –out-file src_compile.js 可以把整个src目录下的转码编译放到 新的js文件里babel src –out-dir lib 可以把整个src目录下的转码编译放到 新的lib目录下其他插件类似 同理，可以设置 React 的编译插件 npm install –save-dev babel-preset-react babel-polyfill插件，为了完整使用 ES6 的 API ，我们只能安装这个插件 npm install -save-dev babel-polyfill Babel 默认只转换新的 JavaScript 句法（syntax），而不转换新的 API ，比如 Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise 等全局对象，以及一些定义在全局对象上的方法（比如 Object.assign）都不会转码。Babel 默认不转码的 API 非常多，详细清单可以查看 definitions.js 文件 babel-core注意的坑从babel 6.0开始不再提供浏览器版本，而是需要构建工具构建出来。如果没有，或者不想用构建工具，可以安装5.x的babel-core模块来获取npm install babel-core@5这样才会在babel-core目录下找到 browser.js和 browser-polyfill.js 浏览器实时解析es6 语法 npm install –save-dev browser-sync 新建index.html文件 引入 babel-core的js文件 !&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;./node_modules/babel-core/browser.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./node_modules/babel-core/browser-polyfill.js&quot; &gt;&lt;/script&gt; &lt;script src=&quot;./test.js&quot; type=&quot;text/babel&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; //es 6箭头函数写法 let dessert = x =&gt;x++; let fruit=['🍎','🍌']; let food=[...fruit,'🌰'] document.body.innerText=food; console.log(food); 启动服务 browser-sync start –server效果","link":"/2017/10/08/javascript/babel/"},{"title":"ES6深入理解迭代器与生成器第二篇","text":"引入下面是一段标准的for循环代码，通过变量i来跟踪colors数组的索引，循环每次执行时，如果i小于数组长度len则加1，并执行下一次循环 var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]; for (var i = 0, len = colors.length; i &lt; len; i++) { console.log(colors[i]); } 虽然循环语句语法简单，但如果将多个循环嵌套则需要追踪多个变量，代码复杂度会大大增加，一不小心就错误使用了其他for循环的跟踪变量，从而导致程序出错。迭代器的出现旨在消除这种复杂性并减少循环中的错误 迭代器迭代器是一种特殊对象，它具有一些专门为迭代过程设计的专有接口，所有的迭代器对象都有一个next()方法，每次调用都返回一个结果对象。结果对象有两个属性：一个是value，表示下一个将要返回的值；另一个是done，它是一个布尔类型的值，当没有更多可返回数据时返回true。迭代器还会保存一个内部指针，用来指向当前集合中值的位置，每调用一次next()方法，都会返回下一个可用的值如果在最后一个值返回后再调用next()方法，那么返回的对象中属性done的值为true，属性value则包含迭代器最终返回的值，这个返回值不是数据集的一部分，它与函数的返回值类似，是函数调用过程中最后一次给调用者传递信息的方法，如果没有相关数据则返回undefined下面用ES5的语法创建一个迭代器 function createIterator(items) { var i = 0; return { next: function() { var done = (i &gt;= items.length); var value = !done ? items[i++] : undefined; return { done: done, value: value }; } }; } var iterator = createIterator([1, 2, 3]); console.log(iterator.next()); // &quot;{ value: 1, done: false }&quot; console.log(iterator.next()); // &quot;{ value: 2, done: false }&quot; console.log(iterator.next()); // &quot;{ value: 3, done: false }&quot; console.log(iterator.next()); // &quot;{ value: undefined, done: true }&quot; // 之后的所有调用 console.log(iterator.next()); // &quot;{ value: undefined, done: true }&quot; 上面这个示例很复杂，而在ES6中，迭代器的编写规则也同样复杂，但ES6同时还引入了一个生成器对象，它可以让创建迭代器对象的过程变得更简单 生成器 生成器是一种返回迭代器的函数，通过function关键字后的星号(*)来表示，函数中会用到新的关键字yield。星号可以紧挨着function关键字，也可以在中间添加一个空格 // 生成器 function *createIterator() { yield 1; yield 2; yield 3; } // 生成器能像正规函数那样被调用，但会返回一个迭代器 let iterator = createIterator(); console.log(iterator.next().value); // 1 console.log(iterator.next().value); // 2 console.log(iterator.next().value); // 3 在这个示例中，createlterator()前的星号表明它是一个生成器；yield关键字也是ES6的新特性，可以通过它来指定调用迭代器的next()方法时的返回值及返回顺序。生成迭代器后，连续3次调用它的next()方法返回3个不同的值，分别是1、2和3。生成器的调用过程与其他函数一样，最终返回的是创建好的迭代器 生成器函数最有趣的部分是，每当执行完一条yield语句后函数就会自动停止执行。举个例子，在上面这段代码中，执行完语句yield 1之后，函数便不再执行 其他任何语句，直到再次调用迭代器的next()方法才会继续执行yield 2语句。生成器函数的这种中止函数执行的能力有很多有趣的应用 使用yield关键字可以返回任何值或表达式，所以可以通过生成器函数批量地给迭代器添加元素。例如，可以在循环中使用yield关键字 function *createIterator(items) { for (let i = 0; i &lt; items.length; i++) { yield items[i]; } } let iterator = createIterator([1, 2, 3]); console.log(iterator.next()); // &quot;{ value: 1, done: false }&quot; console.log(iterator.next()); // &quot;{ value: 2, done: false }&quot; console.log(iterator.next()); // &quot;{ value: 3, done: false }&quot; console.log(iterator.next()); // &quot;{ value: undefined, done: true }&quot; // 之后的所有调用 console.log(iterator.next()); // &quot;{ value: undefined, done: true }&quot; 在此示例中，给生成器函数createlterator()传入一个items数组，而在函数内部，for循环不断从数组中生成新的元素放入迭代器中，每遇到一个yield语句循环都会停止；每次调用迭代器的next()方法，循环会继续运行并执行下一条yield语句 生成器函数是ES6中的一个重要特性，可以将其用于所有支持函数使用的地方 【使用限制】yield关键字只可在生成器内部使用，在其他地方使用会导致程序抛出错误 function *createIterator(items) { items.forEach(function(item) { // 语法错误 yield item + 1; }); } 从字面上看，yield关键字确实在createlterator()函数内部，但是它与return关键字一样，二者都不能穿透函数边界。嵌套函数中的return语句不能用作外部函数的返回语句，而此处嵌套函数中的yield语句会导致程序抛出语法错误 ES5风格的对象字面量中，可以通过函数表达式来创建生成器var o = { createIterator: function *(items) { for (let i = 0; i &lt; items.length; i++) { yield items[i]; } } }; let iterator = o.createIterator([1, 2, 3]); ES6的函数方法的简写方式来创建生成器var o = { *createIterator(items) { for (let i = 0; i &lt; items.length; i++) { yield items[i]; } } }; let iterator = o.createIterator([1, 2, 3]) 状态机生成器的一个常用功能是生成状态机 let state = function*(){ while(1){ yield 'A'; yield 'B'; yield 'C'; } } let status = state(); console.log(status.next().value);//'A' console.log(status.next().value);//'B' console.log(status.next().value);//'C' console.log(status.next().value);//'A' console.log(status.next().value);//'B' 可迭代对象 可迭代对象具有Symbol.iterator属性，是一种与迭代器密切相关的对象。Symbol.iterator通过指定的函数可以返回一个作用于附属对象的迭代器。在ES6中，所有的集合对象(数组、Set集合及Map集合)和字符串都是可迭代对象，这些对象中都有默认的迭代器。ES6中新加入的特性for-of循环需要用到可迭代对象的这些功能[注意]由于生成器默认会为Symbol.iterator属性赋值，因此所有通过生成器创建的迭代器都是可迭代对象一开始，我们曾提到过循环内部索引跟踪的相关问题，要解决这个问题，需要两个工具：一个是迭代器，另一个是for-of循环。如此一来，便不需要再跟踪整个集合的索引，只需关注集合中要处理的内容for-of循环每执行一次都会调用可迭代对象的next()方法，并将迭代器返回的结果对象的value属性存储在一个变量中，循环将持续执行这一过程直到返回对象的done属性的值为true。这里有个示例 let values = [1, 2, 3]; for (let num of values) { //1 //2 //3 console.log(num); } 这段for-of循环的代码通过调用values数组的Symbol.iterator方法来获取迭代器，这一过程是在JS引擎背后完成的。随后迭代器的next()方法被多次调用，从其返回对象的value属性读取值并存储在变量num中，依次为1、2和3，当结果对象的done属性值为true时循环退出，所以num不会被赋值为undefined如果只需迭代数组或集合中的值，用for-of循环代替for循环是个不错的选择。相比传统的for循环，for-of循环的控制条件更简单，不需要追踪复杂的条件，所以更少出错[注意]如果将for-of语句用于不可迭代对象、null或undefined将会导致程序抛出错误 访问默认迭代器可以通过Symbol.iterator来访问对象默认的迭代器 let values = [1, 2, 3]; let iterator = values[Symbol.iterator](); console.log(iterator.next()); // &quot;{ value: 1, done: false }&quot; console.log(iterator.next()); // &quot;{ value: 2, done: false }&quot; console.log(iterator.next()); // &quot;{ value: 3, done: false }&quot; console.log(iterator.next()); // &quot;{ value: undefined, done: true }&quot; 在这段代码中，通过Symbol.iterator获取了数组values的默认迭代器，并用它遍历数组中的元素。在JS引擎中执行for-of循环语句时也会有类似的处理过程 由于具有Symbol.iterator属性的对象都有默认的迭代器，因此可以用它来检测对象是否为可迭代对象function isIterable(object) { return typeof object[Symbol.iterator] === &quot;function&quot;; } console.log(isIterable([1, 2, 3])); // true console.log(isIterable(&quot;Hello&quot;)); // true console.log(isIterable(new Map())); // true console.log(isIterable(new Set())); // true console.log(isIterable(new WeakMap())); // false console.log(isIterable(new WeakSet())); // false 这里的islterable()函数可以检查指定对象中是否存在默认的函数类型迭代器，而for-of循环在执行前也会做相似的检查 除了使用内建的可迭代对象类型的Symbol.iterator，也可以使用Symbol.iterator来创建属于自己的迭代器默认情况下，开发者定义的对象都是不可迭代对象，但如果给Symbol.iterator属性添加一个生成器，则可以将其变为可迭代对象 let collection = { items: [], *[Symbol.iterator]() { for (let item of this.items) { yield item; } } }; collection.items.push(1); collection.items.push(2); collection.items.push(3); for (let x of collection) { //1 //2 //3 console.log(x); } 在这个示例中，先创建一个生成器(注意，星号仍然在属性名前)并将其赋值给对象的Symbol.iterator属性来创建默认的迭代器；而在生成器中，通过for-of循环迭代this.items并用yield返回每一个值。collection对象默认迭代器的返回值由迭代器this.items自动生成，而非手动遍历来定义返回值 集合对象迭代器在ES6中有3种类型的集合对象：数组、Map集合与Set集合,为了更好地访问对象中的内容，这3种对象都内建了以下三种迭代器 entries() 返回一个迭代器，其值为多个键值对 values() 返回一个迭代器，其值为集合的值 keys() 返回一个迭代器，其值为集合中的所有键名 entries()迭代器let colors = [ &quot;red&quot;, &quot;green&quot;, &quot;blue&quot; ]; let tracking = new Set([1234, 5678, 9012]); let data = new Map(); data.set(&quot;title&quot;, &quot;Understanding ES6&quot;); data.set(&quot;format&quot;, &quot;ebook&quot;); for (let entry of colors.entries()) { console.log(entry); } for (let entry of tracking.entries()) { console.log(entry); } for (let entry of data.entries()) { console.log(entry); } [0, &quot;red&quot;] [1, &quot;green&quot;] [2, &quot;blue&quot;] [1234, 1234] [5678, 5678] [9012, 9012] [&quot;title&quot;, &quot;Understanding ES6&quot;] [&quot;format&quot;, &quot;ebook&quot;] values()迭代器let colors = [ &quot;red&quot;, &quot;green&quot;, &quot;blue&quot; ]; let tracking = new Set([1234, 5678, 9012]); let data = new Map(); data.set(&quot;title&quot;, &quot;Understanding ES6&quot;); data.set(&quot;format&quot;, &quot;ebook&quot;); for (let value of colors.values()) { console.log(value); } for (let value of tracking.values()) { console.log(value); } for (let value of data.values()) { console.log(value); } 输出: &quot;red&quot; &quot;green&quot; &quot;blue&quot; 1234 5678 9012 &quot;Understanding ES6&quot; &quot;ebook&quot; keys()迭代器let colors = [ &quot;red&quot;, &quot;green&quot;, &quot;blue&quot; ]; let tracking = new Set([1234, 5678, 9012]); let data = new Map(); data.set(&quot;title&quot;, &quot;Understanding ES6&quot;); data.set(&quot;format&quot;, &quot;ebook&quot;); for (let key of colors.keys()) { console.log(key); } for (let key of tracking.keys()) { console.log(key); } for (let key of data.keys()) { console.log(key); } 输出 0 1 2 1234 5678 9012 &quot;title&quot; &quot;format&quot; 不同集合类型的默认迭代器每个集合类型都有一个默认的迭代器，在for-of循环中，如果没有显式指定则使用默认的迭代器。数组和Set集合的默认迭代器是values()方法，Map集合的默认迭代器是entries()方法。有了这些默认的迭代器，可以更轻松地在for-of循环中使用集合对象 let colors = [ &quot;red&quot;, &quot;green&quot;, &quot;blue&quot; ]; let tracking = new Set([1234, 5678, 9012]); let data = new Map(); data.set(&quot;title&quot;, &quot;Understanding ES6&quot;); data.set(&quot;format&quot;, &quot;print&quot;); // 与使用 colors.values() 相同 for (let value of colors) { console.log(value); } // 与使用 tracking.values() 相同 for (let num of tracking) { console.log(num); } // 与使用 data.entries() 相同 for (let entry of data) { console.log(entry); } 输出 &quot;red&quot; &quot;green&quot; &quot;blue&quot; 1234 5678 9012 [&quot;title&quot;, &quot;Understanding ES6&quot;] [&quot;format&quot;, &quot;print&quot;] 而WeakSet集合与WeakMap集合就没有内建的迭代器，由于要管理弱引用，因而无法确切地知道集合中存在的值，也就无法迭代这些集合了 字符串迭代器自ES5发布以后，JS字符串慢慢变得更像数组了，例如，ES5正式规定可以通过方括号访问字符串中的字符(也就是说，text[0]可以获取字符串text的第一个字符，并以此类推)。由于方括号操作的是编码单元而非字符，因此无法正确访问双字节字符 var message = &quot;A 𠮷 B&quot; ; for (let i=0; i &lt; message.length; i++) { console.log(message[i]); } 输出 ： A B 由于双字节字符被视作两个独立的编码单元，从而最终在A与B之间打印出4个空行所幸，ES6的目标是全面支持Unicode，并且我们可以通过改变字符串的默认迭代器来解决这个问题，使其操作字符而不是编码单元。现在，修改前一个示例中字符串的默认迭代器，让for-of循环输出正确的内容 var message = &quot;A 𠮷 B&quot; ; for (let c of message) { console.log(c); } 输出: A 𠮷 B NodeList迭代器 DOM标准中有一个NodeList类型，document对象中的所有元素都用这个类型来表示。对于编写Web浏览器环境中的JS开发者来说，需要花点儿功夫去理解NodeList对象和数组之间的差异。二者都使用length属性来表示集合中元素的数量，都可以通过方括号来访问集合中的独立元素。而在内部实现中，二者的表现非常不一致，因而会造成很多困扰自从ES6添加了默认迭代器后，DOM定义中的NodeList类型(定义在HTML标准而不是ES6标准中)也拥有了默认迭代器，其行为与数组的默认迭代器完全一致。所以可以将NodeList应用于for-of循环及其他支持对象默认迭代器的地方 var divs = document.getElementsByTagName(&quot;div&quot;); for (let div of divs) { console.log(div.id); } 在这段代码中，通过调用getElementsByTagName()方法获取到document对象中所有div元素的列表，在for-of循环中遍历列表中的每一个元素并输出元素ID，实际上是按照处理数组的方式来处理NodeList的","link":"/2017/10/06/javascript/es6%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8%E7%AC%AC%E4%BA%8C%E7%AF%87/"},{"title":"ES初次体验第一篇","text":"ES的块级作用域let、constjavascript的变量作用域只有全局作用域和函数作用域,ES中出现块级作用域,let表示变量、const表示常量。let和const都是块级作用域。 说白了 {}大括号内的代码块即为let 和 const的作用域。 function aa() { if(bool) { let test = 'hello man' } else { //test 在此处访问不到 console.log(test) } } let的作用域是在它所在当前代码块，但不会被提升到当前函数的最顶部。 再来说说const。 const name = 'aaaa' name = 'bbb' //再次赋值此时会报错 《JavaScript高级程序设计》中提到，所有函数的参数都是按值传递的 经典的例子var funcs = [] for (var i = 0; i &lt; 10; i++) { funcs.push(function() { console.log(i) }) } funcs.forEach(function(func) { func() }) 由js作用域链可得知结果 输出 10 十次 但是如果我们想依次输出0到9呢？两种解决方法。直接上代码。 // ES5告诉我们可以利用闭包解决这个问题 var func = [] for (var i = 0; i &lt; 10; i++) { func.push((function(value) { return function() { console.log(value) } }(i))) } func.forEach(function(func) { func() }) // es6 for (let i = 0; i &lt; 10; i++) { func.push(function() { console.log(i) }) } func.forEach(function(func) { func() }) let 解构数组特性 let 解构对象特性 模板字符串es6模板字符简直是开发者的福音啊，解决了ES5在字符串功能上的痛点。第一个用途，基本的字符串格式化。将表达式嵌入字符串中进行拼接。用${}来界定。 //es5 var name = 'song' console.log('hello' + name) //es6 const name = 'song' console.log(`hello ${name}`) //hello song 第二个用途，在ES5时我们通过反斜杠()来做多行字符串或者字符串一行行拼接。ES6反引号(``)直接搞定 // es5 var msg = &quot;Hi \\ man! &quot; // es6 const template = `&lt;div&gt; &lt;span&gt;hello world&lt;/span&gt; &lt;/div&gt;` 对于字符串es6当然也提供了很多厉害的方法。说几个常用的。 // 1.includes：判断是否包含然后直接返回布尔值 let str = 'hahay' console.log(str.includes('y')) // true // 2.repeat: 获取字符串重复n次 let s = 'he' console.log(s.repeat(3)) // 'hehehe' //如果你带入小数, Math.floor(num) 来处理 函数默认参数在ES5我们给函数定义参数默认值是怎么样？ function action(num) { num = num || 200 //当传入num时，num为传入的值 //当没传入参数时，num即有了默认值200 return num } // 但细心观察肯定会发现，num传入为0的时候就是false， 此时num = 200 与我们的实际要的效果明显不一样 ES6为参数提供了默认值。在定义函数时便初始化了这个参数，以便在参数没有被传递进去时使用。 function action(num = 200) { console.log(num) } action() //200 action(300) //300 展开操作符 spread(…) 剩余操作符 rest(…) 解构对象参数 获取函数名字 var breakfast = function () {} console.log(breakfast.name); 输出结果 breakfast var breakfast = function superMan() {} console.log(breakfast.name); 输出结果 superMan ES6箭头函数转码 es5当你的函数有且仅有一个参数的时候，是可以省略掉括号的。当你函数返回有且仅有一个表达式的时候可以省略{}本地使用：1、首先安装babel-cli（用于在终端使用babel） npm install -g babel-cli2、然后安装babel-preset-es2015插件 npm install –save babel-preset-es2015当安装过第一步时 很多人只是执行了第一步，还需要安装插件，并且在使用的过程中去指定编译版本。$ babel index.js –out-file compiled.js或$ babel index.js -o compiled.js执行：babel es6.js –presets es2015以前好像不用指定版本，不知道是哪里出错了，现在本地编译需要指定一下版本，或者默认指定一下版本。否则编译无效果。 拓展的对象表达式 ES6 支持class关键字定义类 很接近JAVA的关键字了 ES6 get set 关键字 class chef{ constructor(food){ this.food = food; this.dish = []; } set menu(dish){ this.dish.push(dish); } get menu(){ return this.dish; } cook(){ console.log(this.food); } } let sxm = new chef(&quot;apple&quot;); sxm.cook(); console.log(sxm.menu='💪'); console.log(sxm.menu='☕️') 输出： apple 💪 ☕️ 与Java一样作用的关键字static、extends 与Java一样的 Set let set = new Set(); set.add('🍎'); set.add('🍌'); set.add('🍊'); set.add('🍊'); set.forEach(item=&gt;{ console.log(item); }); set.delete('🍊'); console.log(set); set.clear(); console.log(set); 与JAVA一样的 Map import 和 export//全部导入 import people from './example' //有一种特殊情况，即允许你将整个模块当作单一对象进行导入 //该模块的所有导出都会作为对象的属性存在 import * as example from &quot;./example.js&quot; console.log(example.name) console.log(example.age) console.log(example.getName()) //导入部分 import {name, age} from './example' // 导出默认, 有且只有一个默认 export default App // 部分导出 export class App extend Component {}; 总结 当用export default people导出时，就用 import people 导入（不带大括号） 一个文件里，有且只能有一个export default。但可以有多个export。 当用export name 时，就用import { name }导入（记得带上大括号） 当一个文件里，既有一个export default people, 又有多个export name 或者 export age时，导入就用 import people, { name, age } 当一个文件里出现n多个 export 导出很多模块，导入时除了一个一个导入，也可以用import * as example","link":"/2017/10/04/javascript/es%E5%88%9D%E6%AC%A1%E4%BD%93%E9%AA%8C%E7%AC%AC%E4%B8%80%E7%AF%87/"},{"title":"jspm","text":"简介 JavaScript 模块的写法有几种，比如 AMD，CommonJS .. 还有标准化的 ES6 的写法 .. jspm 支持加载所有的用这些方法写的 JavaScript 模块 在你的应用里，现在就可以使用 ES6 提供的标准写法 .. 至于怎么去载入模块可以交给 jspm 去处理 .. 也就是你只需要了解 ES6 的模块写法 .. jspm 还是一个为浏览器上用的东西准备的一个包管理 .. 比如它可以让你去从不同的源去安装不同的包 .. 默认的源有 npm ，还有 github .. 安装好你需要的包以后，在你的代码里，只需要一行代码，就可以使用这些包提供的功能 .. 不用担心其它的事情 . . 在开发的时候，jspm 可以使用 Traceur 或者 Babel ，实时的在浏览器上编译 JavaScript ，把 es6 的代码编译成 es5 的代码 ..在正式发布应用的时候，可以优化创建的模块，把模块依赖的东西打成一个包 安装jspm npm install jspm -g //在全局范围安装jspm，就可以在任何地方使用jspm命令了 jspm // 完成后输入jspm，会返回一些帮组信息 cd ~/desktop mkdir reactProject // 创建项目文件夹 cd reactProject npm init // 创建package.json，一路回车即可 ls // 查看文件夹，就会一个package.json文件 npm install jspm --save-dev // 把 jspm添加到项目开发依赖 ls // node_modules package.json两个文件 jspm init // 为jspm创建配置文件config.js， 一系列问题，可一路回车 ls // 会发现有config.js , jspm_packages（jspm安装的一些包） node_modules package.json 安装包 jspm installjspm install jquery=github:components/jqueryjspm uninstall jquery 使用ES6模块, BrowserSync 使用 npm install -g browser-sync // 安装Node后，通过npm安装BrowserSync(自动刷新) 使用BrowserSync： browser-sync start –server 开启服务 打包bundle 功能打开浏览器的开发者工具 .. 再打开 network 这个选项卡 .. 在这里你会看到被下载的一些东西 .. 这里有挺多 js 文件 .. main.js .. fruit.js ，jquery.js 等等 ..jspm 支持 bundle，也就是打包的功能，就是把一些资源打包成一个东西 .. 比如下面我们去把 main.js 这个模块打包成一个东西 ..打包用的是 jspm bundle 命令 进入项目目录 jspm bundle app/main app/build.js // 将app文件夹下的main.js里面的js都打包到build.js中 完成以后，会在 app 目录下面创建一个叫 build.js 的文件 .. 回到编辑器 .. 用一个 script 标签 .. 把 app 下的 build.js 嵌入进来 .. 保存 .. 再回到浏览器 .. 在 network 这个选项卡里，会少了很多 js 文件，因为我们把它们打成了一个包 .. 就是这个 build.js ..","link":"/2017/10/09/javascript/jspm/"},{"title":"JS 初次体验第一篇","text":"js在浏览器的交互式运行新建一个index.html &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 新建一个js.js 文件 var person = {}; // 第一种方式定义对象 并且设置属性 初始化值的方式 person.name = &quot;宋烜明&quot;; person[&quot;age&quot;] = 18; console.log(person); var person2 = {name:&quot;宋烜明2&quot;,age:19}; // 第二种方式定义对象 并且设置属性 初始化值的方式 console.log(person2); 用浏览器打开index,右击审查元素，点击console 就可以开始查看js运行 js对象里的属性和数组var person = {}; // 第一种方式定义对象 并且设置属性 初始化值的方式 person.name = &quot;宋烜明&quot;; person[&quot;age&quot;] = 18; person.albums = [&quot;91.png&quot;,'92.gif',93.jpeg]; //对象里的数组 console.log(person); js对象属性的更新与删除操作 为对象添加方法 循环输出对象属性 文档对象模型DOM（document object model） DOM方法介绍 查询选择器其它访问属性的方法创建新元素并添加元素 在指定的位置插入节点 处理事件通过属性设置事件方法机制 为对象绑定事件addEventListener 事件传播&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; ul{ display:inline-block } li{ float:left; margin: 15px } &lt;/style&gt; &lt;body style=&quot;text-align:center&quot;&gt; &lt;h2&gt;事件&lt;/h2&gt; &lt;ul style=&quot;list-style-type:none;&quot; class=&quot;list-group&quot;&gt; &lt;li id=&quot;img1&quot;&gt;&lt;img src=&quot;../Downloads/1.jpg&quot; width=&quot;100&quot; height=&quot;100&quot; alt=&quot;1&quot;/&gt;&lt;h6&gt;111&lt;/h6&gt;&lt;/li&gt; &lt;li id=&quot;img2&quot;&gt;&lt;img src=&quot;../Downloads/2.jpg&quot; width=&quot;100&quot; height=&quot;100&quot; alt=&quot;2&quot;/&gt;&lt;h6&gt;222&lt;/h6&gt;&lt;/li&gt; &lt;li id=&quot;img3&quot;&gt;&lt;img src=&quot;../Downloads/3.png&quot; width=&quot;100&quot; height=&quot;100&quot; alt=&quot;3&quot;/&gt;&lt;h6&gt;333&lt;/h6&gt;&lt;/li&gt; &lt;li id=&quot;img4&quot;&gt;&lt;img src=&quot;../Downloads/4.gif&quot; width=&quot;100&quot; height=&quot;100&quot; alt=&quot;4&quot;/&gt;&lt;h6&gt;444&lt;/h6&gt;&lt;/li&gt; &lt;/ul&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; var ulele = document.querySelector(&quot;.list-group&quot;); ulele.addEventListener(&quot;click&quot;,function(event){ console.log(event.target.alt)},false); 效果 ul绑定的事件会传播至其子元素里面如果js开头启用 window.onload 则不需要关注 js文件导入的位置访问不到元素的问题由子向父 冒泡执行监听事件 传播由父向子 捕获方式执行监听事件 传播停止事件传播方式","link":"/2014/10/01/javascript/js%E5%88%9D%E6%AC%A1%E4%BD%93%E9%AA%8C%E7%AC%AC%E4%B8%80%E7%AF%87/"},{"title":"JS深入理解变量作用域第二篇","text":"代码一var i=10; function a() { alert(i); // 先在函数体内查找变量 i,未找到，向上级作用域查找，找到输出 10 }; a(); 代码二var i=10; function a() { alert(i); // 先在函数体内查找变量 i,找到i，不再向上级作用域查找，找到输出 i值(但是初始化在下面) undefine var i = 2; }; a(); 代码三var i = 10; function a() { console.log(i); //先在函数体内查找变量i,未找到i(必须是var关键字声明才算)，向上级作用域查找，找到输出i值 10 i = 100; // 没有var声明，则意思是 i提升为全局变量，再次赋值为 100 } a(); console.log(i); //输出 i值为 100 代码四 var a,b; (function(){ console.log(a); console.log(b); var a = b = 3; console.log(a); console.log(b); })(); console.log(a); console.log(b); 结果输出 undefined undefined 3 3 undefined 3 代码等价于 var a,b; (function(){ alert(a); alert(b); var a = 3; b = 3; alert(a); alert(b); })(); alert(a); alert(b); 这主要是Js中没有用var声明的变量都是全局变量，而且是顶层对象的属性 代码五&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;/&gt; &lt;title&gt;ajax&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; function buttonInit(){ for(var i=1;i&lt;4;i++){ var b=document.getElementById(&quot;button&quot;+i); b.addEventListener(&quot;click&quot;,function(){ alert(&quot;Button&quot;+i);},false); } } window.onload=buttonInit; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button id=&quot;button1&quot;&gt;Button1&lt;/button&gt; &lt;button id=&quot;button2&quot;&gt;Button2&lt;/button&gt; &lt;button id=&quot;button3&quot;&gt;Button3&lt;/button&gt; &lt;/body&gt; &lt;/html&gt; 当文档加载完毕，给几个按钮注册点击事件，当我们点击按钮时，会弹出什么提示框呢？很容易犯错，对是的，三个按钮都是弹出：”Button4”,你答对了吗？当注册事件结束后，i的值为4，当点击按钮时，事件函数即function(){ alert(“Button”+i);}这个匿名函数中没有i,根据作用域链，所以到buttonInit函数中找，此时i的值为4所以弹出”button4“。","link":"/2014/10/02/javascript/js%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%AC%AC%E4%BA%8C%E7%AF%87/"},{"title":"react","text":"jspm安装react、react-dom、Semantic UI安装指定版本的react $ jspm install react@0.14.0-rc1安装指定版本的react-dom $ jspm install react-dom@0.14.0-rc1安装 semantic-ui $ jspm install semantic-ui安装 css插件 $ jspm install css BrowserSync，react项目正常启动 通过npm安装browserSync，命令npm install -g browser-sync 如果你想启动后，增加一些监听文件修改时，自动刷新页面，则启动命令为 browser-sync start –server –no-notify –files ‘xxxx’ (xxx为具体的文件名，相对路径，有多个时，可用逗号分开，如 ‘index.html, app/main.js’); 到此，我们可以看到React项目正常启动后，出现页面。在 main.js 里导入 import ‘semantic-ui/semantic.min.css!’","link":"/2017/10/10/javascript/react/"},{"title":"认识JavaScript","text":"JavaScript简介","link":"/2013/04/01/javascript/%E8%AE%A4%E8%AF%86JavaScript-2013-04-01/"},{"title":"MAC-Homebrew神器命令工具","text":"MAC-Homebrew 必备神器介绍 HomeBrew就是MacOS下最著名的包管理器，我使用它的目的就是让MacOS下的命令行和Linux下一样顺手。 安装brew Homebrew 默认会被安装在 /usr/local/ 目录。但是该目录非普通用户所有，相关操作需要管理员权限，普通用户需要 sudo 权限。若想免去 sudo 的麻烦，可更改目录的属主sudo chown -R whoami /usr/local /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 上面这句话的意思是使用curl命令行下载安装脚步install，然后用ruby解析执行这个安装脚步 在 ~ 路径下设置MAC配置 .bash_profile echo 'export PATH=&quot;/usr/local/bin:$PATH&quot;' &gt;&gt; ~/.bash_profile 安装完毕，可以查看一下版本 brew -v 安装完毕，可以查看brew系统配置信息 brew config #显示示例： HOMEBREW_VERSION: 1.3.4-75-g1d82197 ORIGIN: https://github.com/Homebrew/brew HEAD: 1d821975465f7426dab12395aa553cfc5e26fcea Last commit: 2 hours ago Core tap ORIGIN: https://github.com/Homebrew/homebrew-core Core tap HEAD: 1c42e9e0e86f56aa7857c1e86370c04f5bac5b6b Core tap last commit: 79 minutes ago HOMEBREW_PREFIX: /usr/local HOMEBREW_REPOSITORY: /usr/local/Homebrew HOMEBREW_CELLAR: /usr/local/Cellar HOMEBREW_BOTTLE_DOMAIN: https://homebrew.bintray.com CPU: octa-core 64-bit haswell Homebrew Ruby: 2.3.3 =&gt; /usr/local/Homebrew/Library/Homebrew/vendor/portable-ruby/2.3.3/bin/ruby Clang: 9.0 build 900 Git: 2.12.0 =&gt; /usr/local/bin/git Perl: /usr/bin/perl Python: /usr/local/opt/python/libexec/bin/python =&gt; /usr/local/Cellar/python/2.7.13_1/Frameworks/Python.framework/Versions/2.7/bin/python2.7 Ruby: /usr/local/bin/ruby =&gt; /usr/local/Cellar/ruby/2.4.2/bin/ruby Java: 1.8.0_101, 1.7.0_80, 1.6.0_65-b14-468 macOS: 10.12.6-x86_64 Xcode: 9.0 CLT: N/A X11: 2.7.11 =&gt; /opt/X11 基本操作，软件安装，卸载，更新，查看安装一个包brew install &lt;formula&gt; //安装后台服务或者命令 brew cask install &lt;formula&gt; //安装图形化软件 但是麻烦的是你往往不记得包名或者记不全，这里有两个方法，第一个是使用brew search进行搜索，比如你想找vim这个包，但你只记得了前面两个字母，最后一个m给忘记了，这时候你可以尝试下面但命令： 搜索安装包brew search vi 结果出来了，但是结果太多了，包括了很多不是vi开头的包，这个时候你就得用正则表达式来搜索，这对小白来说也是非常痛苦的，因为要学会正则表达式也得看一本书，但是一旦你熟悉它之后，你会发现你会在每个搜索的场景下都希望它支持正则表达式的搜索，正如你熟悉了编辑器vim之后，希望处处都是vim模式一样。 brew search /正则表达式/ # 标准格式 brew search /^vi/ #规定了只能是vi开头 brew search /^vi\\\\w$/ #规定只能是vi开头并且只有三个字母 查看包信息，从中我们可以得知有哪些选项可选brew info &lt;formula&gt; #查看这个包的信息，从中我们可以得知有哪些选项可选。 #示例 brew install vim --HEAD --with-override-system-vi --with-lua 然后，homebrew就会帮我们解决编译过程中的任何依赖了. 显示包依赖关系brew deps [package_name] 卸载包操作brew uninstall &lt;package_name&gt; #如果卸载全部版本那么使用 --force选项。 更新包操作brew upgrade [ package_name ] #新过时的包，不带包名就跟新所有包 更新HomeBrew自身brew update 清除缓存brew cleanup [包名] 列出已安装的包brew list 列出过时的包brew outdated 扩展第三方列表的添加或者删除brew [un]tap &lt;github_userid/repo_name&gt; #添加或者删除仓库 #注意repo_name只是实际仓库名的一部分，而实际仓库名的前缀必须是homebrew-。比如:brew tap neovim/neovim # 这样实际仓库名就是homebrew-neovim 列出当前已经tapped的仓库brew tap ==&gt; Auto-updated Homebrew! Updated 1 tap (homebrew/core). No changes to formulae. caskroom/cask homebrew/core homebrew/dupes neovim/neovim #总共列出了四个仓库，其中前面三个是默认自带的。如果你要增加的仓库已经存在于homebrew/core中了(名字一样)，你必须显性的安装 brew install vim # installs from homebrew/core brew install username/repo/vim # installs from your custom repo 没有tap的 举例说明一下，Mac OS 比较歧视 PHP ，所以每次系统更新都会把常用的开发包（Ruby、Python 等）也顺带着更新到最新版本。（吐槽：Java 都已经被抛弃不再默认安装了），而 brew 居然也不包含 PHP 的包，那怎么办呢？brew tap josegonzalez/php命令完成之后，执行（当前最新是 php 5.5 版本，请根据需要替换）brew install php55 由于 Mac OS X 中的服务是由 launchctl 管理，对于习惯 Linux 的用户，不一定习惯这种服务管理方式。这就不得不提一下扩展源 gapple/services 提供的 Homebrew-services 了，它提供了类似管理 Linux 服务的命令。先安装扩展源brew tap gapple/services Homebrew中一些路径的解释Cellar:文件夹存放的是所有包安装所在路径，包括二进制，文档和配置文件，按照这样Cellar/包名/版本号/的形式来安放。’ opt:由于版本号随着跟新而改变的，所以需要一个固定不变的路径作为我们访问二进制和文档的路径，这就是opt的作用。 Homebrew:brew程序所在路径. bin:所有包安装之后二进制都会链接到这个路径下 share:所有包安装之后的文档都会链接到这个路径下 etc:同上，所有包的配置文件 lib:同上，所有包相关库文件 Caskroom:app文件 HomeBrew隐藏命令服务管理 当我们安装了众多需要挂载的服务，需要重启或停止的时候，都特别希望 Mac 可以有个统一的命令可以管理服务的状态，比如 services 命令甚至说 /etc/init.d/ 也可以啊！ brew services command [formula] usage: [sudo] brew services [--help] &lt;command&gt; [&lt;formula&gt;] Small wrapper around `launchctl` for supported formulae, commands available: cleanup Get rid of stale services and unused plists list List all services managed by `brew services` restart Gracefully restart selected service start Start selected service stop Stop selected service Options, sudo and paths: sudo When run as root, operates on /Library/LaunchDaemons (run at boot!) Run at boot: /Library/LaunchDaemons Run at login: /Users/sxm/Library/LaunchAgents 实用的命令居然没有包含在 brew –help 帮助里面！我们再也不用发愁记住 launchctl load/unload 的坑爹命令了！ 重启，关闭服务示例brew services restart nginx #重启 Nigix 就那么简单 brew services stop mysql #停止MySQL服务 查看系统通过 brew 安装的服务brew services list 清除已卸载无用的启动配置文件brew services cleanup 版本切换 通过brew安装的php可以通过brew link和brew unlink来切换不同版本。 #例如： brew list brew unlink php56 brew link php55 php-version是一个帮助管理从brew安装的php版本切换的工具 brew install php-version #然后执行 source $(brew --prefix php-version)/php-version.sh #直接执行 就可以看到现有的版本，比如我自己的 php-version $ php-version 5.5.15 * 5.5.16 5.5.17 #然后使用以下命令切换即可 php-version 5.5.15 HomeBrew中国镜像源 Mac 终端跑入即可cd /usr/local/git remote set-url origin http://mirrors.ustc.edu.cn/homebrew.git#或者这个：git remote set-url origin git://mirrors.tuna.tsinghua.edu.cn/homebrew.gitbrew update 也可以使用coding.net提供的镜像cd /usr/local &amp;&amp; git remote set-url origin https://git.coding.net/homebrew/homebrew.gitbrew update 卸载Homebrewrm -rf Cellar $ brew prune $ rm -rf Library .git .gitignore bin/brew *.md share/man/man1/brew.1 $ rm -rf ~/Library/Caches/Homebrew ~/Library/Logs/Homebrew /Library/Caches/Homebrew Linux系统也支持安装Homebrew Homebrew 也被移植到了 Linux 上，称为 Linuxbrew。虽然各种 Linux 发行都带有自己的包管理工具，诸如 apt-get、yum、pacman、emerge 等等，但对那些工作于服务器版本但没有管理员权限的 Linux 用户来说，Linuxbrew 仍有用武之地，可通过它无须管理员权限安装一些管理员没有提供的或者比系统中更新的包。它的项目主页http://brew.sh/linuxbrew/。在安装 Linuxbrew 之前，需要先准备好依赖。例如在 Fedora 上，先执行如下命令: sudo yum groupinstall 'Development Tools' $ sudo yum install curl git ruby bzip2-devel curl-devel expat-devel ncurses-devel zlib-devel 接着，将 Linuxbrew 从 GitHub 克隆下来： mkdir ~/Developer/ $ git clone https://github.com/Homebrew/linuxbrew.git ~/Developer/linuxbrew 简单配置 echo &quot;export PATH=\\$HOME/Developer/linuxbrew/bin:\\$PATH export C_INCLUDE_PATH=\\$HOME/Developer/linuxbrew/include export LIBRARY_PATH=\\$HOME/Developer/linuxbrew/lib&quot; &gt;&gt; ~/.bashrc 然后执行 source ~/.bashrc 这样子 Linuxbrew 就算装好了。","link":"/2016/10/05/mac/MAC-Homebrew-2016-07-01/"},{"title":"MAC彩蛋闲聊","text":"Quick Look半透明文件夹功能 打开终端，输入：defaults write com.apple.finder QLEnableXRayFolders 1输入完后，按下reture 键，再打开活动监视器，点选 Finder 后，按左上角的 结束程序，并选择结束钮。此时 Finder 会被关闭，然后我们在点一下 Dock 上的 Finder 图示，就可以重新启动 Finder. 终端kill 和 killallkill对象是进程ID kill -9 proc_id killall对象是进程名字 killall -9 proc_name 注：信号代码可以省略；我们常用的信号代码是 -9 ，表示强制终止； MAC 下的top命令以前只是在 linux 机器上使用 top 命令。常用的快键键是:p 键 - 按 cpu 使用率排序m 键 - 按内存使用量排序这 2 个快捷键在 mac 上都不一样。对应的是，先输入 o，然后输入 cpu 则按 cpu 使用量排序，输入 rsize 则按内存使用量排序。如果记不清了，可以在 top 的界面上按 ?，在弹出的帮助界面中即可看到。 MAC终端切换JDK版本 使用 export &amp; alias 的方式切换 JDK，那么就有可能会导致一些项目可以编译成功一些不能。一种更好的思路是限制 export &amp; alias 的作用范围，即可以将其对 JDK 环境变量的设置作用于某个具体的项目，即作用到具体的目录。这个思路虽好，但是使用 export &amp; alias 的方式实现起来就比较困难。这里推荐 JEnv 这个小工具，它可以帮我们更好地管理 &amp; 切换不同版本的 JDK。安装jenv工具 brew install jenv 然后配置 Shell 添加如下配置参数 如果你是用的 bash 则执行下述命令: echo 'export PATH=&quot;$HOME/.jenv/bin:$PATH&quot;' &gt;&gt; ~/.bash_profile echo 'eval &quot;$(jenv init -)&quot;' &gt;&gt; ~/.bash_profile 如果你是用的 zsh 则执行下述命令 echo 'export PATH=&quot;$HOME/.jenv/bin:$PATH&quot;' &gt;&gt; ~/.zshrc echo 'eval &quot;$(jenv init -)&quot;' &gt;&gt; ~/.zshrc 最后我们使用上述使用到的 /usr/libexec/java_home -V 命令罗列出已经安装的 JDK 路径： sxm:Desktop$ /usr/libexec/java_home -V Matching Java Virtual Machines (3): 9.0.4, x86_64: &quot;Java SE 9.0.4&quot; /Library/Java/JavaVirtualMachines/jdk-9.0.4.jdk/Contents/Home 1.8.0_152, x86_64: &quot;Java SE 8&quot; /Library/Java/JavaVirtualMachines/jdk1.8.0_152.jdk/Contents/Home 1.7.0_80, x86_64: &quot;Java SE 7&quot; /Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home 查看是否有~/.jenv/versions路径,没有则就需要创建 sudo mkdir -p ~/.jenv/versions 再使用 jenv add 命令挨个将上述路径添加即可 sudo jenv add /Library/Java/JavaVirtualMachines/jdk-9.0.4.jdk/Contents/Home sudo jenv add /Library/Java/JavaVirtualMachines/jdk1.8.0_152.jdk/Contents/Home sudo jenv add /Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home 完成上述配置后使用 JEnv 的 versions 命令查看已经被添加至 JEnv 管理的 JDK 版本： sxm:Desktop$ jenv versions * system (set by /Users/sxm/.jenv/version) 1.7 1.7.0.80 1.8 1.8.0.152 9.0 9.0.4 oracle64-1.7.0.80 oracle64-1.8.0.152 oracle64-9.0.4 JEnv 的精髓是 shell、local 和 global 三个参数命令。shell 用于设置终端窗口生命周期内使用的 JDK 版本；local 用于设置当前目录下使用的 JDK 版本；而 global 用于设置全局使用的 JDK 版本。这三个命令的使用方式都一样 jenv shell/local/global 1.7 上述命令最后的 “1.7” 即我们在 JEnv 中设置的不同 JDK 版本的别名。这里如果我们想在当前终端窗口中使用 JDK 8，我们只需执行： jenv shell 1.8 local 命令不像 shell 那样有生命周期，一旦在某个目录下使用 local 设置了 JDK 版本，就会在该目录下生成一个 “.java-version” 文件，该文件中记录了当前目录所使用的 JDK 版本，只要你不删除该文件，则设置会一直有效。最后的 global 命令就不说了很好理解","link":"/2016/10/05/mac/mac%E5%BD%A9%E8%9B%8B%E9%97%B2%E8%81%8A/"},{"title":"类之间的关系","text":"泛化关系类和类之间的继承关系以及接口与接口之间的继承关系 实现关系类对接口的实现 关联关系类与类之间的连接，一个类可以知道另一个类的属性和方法，在JAVA语言中使用成员变量体现 聚合关系聚合关系，是关联关系的一种，是较强的关联关系，是整体和部分的关系，如：汽车和轮胎，它与关联关系不同，关联关系的类处在同一个层次上，而聚合关系的类处在不平等的层次上，一个代表整体，一个代表部分，在 java 语言中使用实例变量体现 //ClassRoom就是整体 public class ClassRoom{ //ClassRoom和List集合属于关联关系，在同一个层级上。 //ClassRoom和Student属于聚合关系，一个是整体，一个是部分 List&lt;Student&gt; stus; //student就是部分 } 合成关系合成关系，是关系的一种，比聚合关系强的关联关系，如：人和四肢，整体对象决定部分对象的生命周期，部分对象每一时刻只与一个对象发生合成关系，在 java 语言中使用实例变量体现 依赖关系依赖关系，依赖关系是比关联关系弱的关系，在 java 语言中体现为返回值，参数，局部变量和静态方法调用 public class Test{ public void m1(){ //局部变量 User u = new User(); } } class User{} 总结类与类之间的关系 1、依赖:形参局部变量 2、关联:属性 聚合:属性整体与部分不一致的生命周期人与手 组合:属性整体与部分一致的生命周期人与大脑 3、继承:父子类关系 4、实现:接口与实现类关系","link":"/2014/04/28/javase/JAVA-%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/"},{"title":"JAVA-Annotation","text":"Annotation **从JDK 5开始，Java 增加了对元数据(MetaData) 的支持，也就是Annotation (即注解，也被翻译为注释)**，下面所介绍的Annotation，其实是代码里的特殊标记，这些标记可以在编译、类加载、运行时被读取，并执行相应的处理。通过使用注解，程序开发人员可以在不改变原有逻辑的情况下，在源文件中嵌入一些补充的信息。代码分析工具、开发工具和部署工具可以通过这些补充信息进行验证或者进行部署。 Annotation提供了一种为程序元素设置元数据的方法，从某些方面来看，Annotation 就像修饰符一样，可用于修饰包、类、构造器、方法、成员变量、参数、局部变量的声明，这些信息被存储在Annotation的“name=value”对中。 元数据的作用，大致可分为三种： 编写文档，通过代码里标识的元数据生成文档； 代码分析，通过代码里标识的元数据对代码进行分析； 编写检查，通过代码里标识的元数据让编译器能实现基本的编译检查 5种基本的Annotation @Override 限定重写父类方法； @Deprecated 用于表示程序元素(类，方法)已过时； @SuppressWarning 抑制编译器警告 @SafeVarargs 它是Java7专门为抑制“堆污染”警告提供的，Java7新出现的注解 @SafeVarargs public static void faultyMethod(List&lt;String&gt;... listStrArray) { // Java语言不允许创建泛型数组，因此listArray只能被当成List[]处理 // 此时相当于把List&lt;String&gt;赋给了List，已经发生了“擦除” List[] listArray = listStrArray; List&lt;Integer&gt; myList = new ArrayList&lt;Integer&gt;(); myList.add(new Random().nextInt(100)); // 把listArray的第一个元素赋为myList listArray[0] = myList; String s = listStrArray[0].get(0); } @FunctionalInterface 前面已经提到，Java 8规定:如果接口中只有一一个抽象方法(可以包含多个默认方法或多个static方法),该接口就是函数式接口。@FunctionalInterface就是用来指定某个接口必须是函数式接口。函数式接口就是为Java 8的Lambda表达式准备的，Java8允许使用Lambda表达式创建函数式接口的实例，因此Java8专门增加了@FunctionalInterface. @FunctionalInterface public interface FunctionInterface { static void foo(){ System.out.println(&quot;foo类方法&quot;); } default void bar(){ System.out.println(&quot;bar 默认方法&quot;); } void test(); //只定义一个抽象方法 } 自定义注解Annotation 在interface关键字前面使用@符号声明Annotation类型声明注解的属性 注解属性的作用：原来写在配置文件中的信息，可以通过注解的属性进行描述。 Annotation的属性声明方式：String name()或 String[] likes(); 属性默认值声明方式：String name() default “xxx”; 特殊属性value：如果注解中有一个名称为value的属性，那么使用注解时可以省略value=“xxx”，如@MyAnnotation(“xxx”) @Retention:只能用于修饰一个Annotation定义，用于指定该Annotation可以保留的域，包含一个RetentionPolicy类型的成员变量，通过这个变量指定域。 RetentionPolicy.CLASS:编译器将把注解记录在Class文件中，当运行JAVA程序时，JVM不会保留注解，这是默认值。 RetentionPolicy.RUNTIME:编译器将把注解记录在class文件中，当运行JAVA程序时，JVM会保留注解，程序可以通过反射获取该注解。 RetentionPolicy.SOURCE:编译器直接丢弃这种策略的注解。 @Target:指定注解用于修饰类的哪个成员，@Target包含了一个名为value,类型为ElementType的成员变量。 ElementType.ANNOTATION_TYPE 应用于注解类型声明. ElementType.CONSTRUCTOR 构造方法声明. ElementType.FIELD 应用于字段声明. ElementType.LOCAL_VARIABLE 应用于局部变量. ElementType.METHOD 应用于方法声明. ElementType.PACKAGE 应用于包声明. ElementType.PARAMETER 应用于参数声明. ElementType.TYPE 应用于类，接口(包括注释类型)或枚举声明. @Inherited 被它修饰的Annotation将具有继承性，如果某个类使用了被@Inherited修饰的Annotation，则其子类将自动具有该注解 @Documented： 通过javadoc tool 处理该注释，仅作为文档。 定义简单的AnnotationAnnotation定义格式： [public] @interface Annotation名称{ 数据类型 变量名称() ; } 示例定义并使用 public @interface MyDefaultAnnotationNoneParam{ // 定义Annotation } @MyDefaultAnnotationNoneParam // 使用自定义的Annotation class Demo { } 向Annotation中设置内容public @interface MyDefaultAnnotationSingleParam{ // 定义Annotation public String value() ; // 接收设置的内容 } @MyDefaultAnnotationSingleParam(&quot;大中华&quot;) // 使用自定义的Annotation，特殊属性value可以省略 class Demo { } //或者 @MyDefaultAnnotationSingleParam(value = &quot;大中华&quot;) // 使用自定义的Annotation class Demo { } 使用Annotation接收多个参数public @interface MyDefaultAnnotationMoreParam{ // 定义Annotation public String key() ; // 接收设置的内容 public String value() ; // 接收设置的内容 } @MyDefaultAnnotationMoreParam(key = &quot;CHINA&quot;, value = &quot;大中华&quot;) // 使用自定义的Annotation class Demo { } 接收一组参数public @interface MyDefaultAnnotationArrayParam{ // 定义Annotation public String[] value() ; // 接收设置的内容，是一个字符串数组 } @MyDefaultAnnotationArrayParam(value = { &quot;CHINA&quot;, &quot;ECIT&quot; }) // 使用自定义的Annotation class Demo { } 指定默认值 如果在一个定义好的Annotation中已经定义好了若干个属性，但是在使用Annotation时并没有指定其具体的内容，则在编译时也会出现错误，示例public @interface MyDefaultAnnotationValue{ // 定义Annotation public String key() ; // 接收设置的内容 public String value() ; // 接收设置的内容 } //错误的使用Annotation @MyDefaultAnnotationValue // 使用自定义的Annotation class Demo { } 定义默认值，格式[public] @interface Annotation名称{ 数据类型 变量名称() default 默认值; } public @interface MyDefaultAnnotationValue { // 定义Annotation public String key() default &quot;CHINA&quot;; // 接收设置的内容 public String value() default &quot;大中华&quot;; // 接收设置的内容 } 使用枚举限制设置的内容 Annotation中也可以通过枚举来限制Annotation的取值范围。public enum MyName { // 定义枚举，里面有两个内容 CHINA, ECIT ; } public @interface MyDefaultAnnotationEnum { // 定义Annotation public MyName name() default MyName.ECIT ; // 只能设置枚举中的取值，默认值为Enum中的内容 } @MyDefaultAnnotationEnum(name = MyName.CHINA) // 使用自定义的Annotation class Demo { } Retention和RetentionPolicy 在Annotation，可以使用Retention定义一个Annotation的保存范围，此Annotation的定义如下： @Documented @Retention(value=RUNTIME) @Target(value=ANNOTATION_TYPE) public @interface Retention{ RetentionPolicy value() ; } 在以上的Rentetion定义中存在了一个RententionPolicy的变量，此变量用于指定Annotation的保存范围，RetentionPolicy包含三种范围 |No| | 范围 | 描述||:——–:|:———-:|:————:||1 | | SOURCE | 此Annotation类型的信息只会保留在程序源文件之中（*.java），编译之后不会保存在编译好的类文件（*.class）之中||2 | | CLASS | 此Annotation类型将保留在程序源文件（*.java）和编译之后的类文件（*.class）之中，在使用此类的时候，这些Annotation信息将不会被加载到虚拟机（JVM）之中，如果一个Annotation声明时没有指定范围，则默认是此范围||3 | | RUNTIME | 此Annotation类型的信息保留在源文件（*.java）、类文件（*.class）在执行时也会加载到JVM之中| 定义在RUNTIME范围有效的Annotationimport java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; @Retention(value=RetentionPolicy.RUNTIME) // 此Annotation在执行时起作用 public @interface MyDefaultRetentionAnnotation { public String name() default &quot;中华&quot; ; // 只能设置枚举中的取值 } 通过反射取得Annotation 如果要想让一个Annotation起作用，则必须结合反射机制。在Class类中存在以下几种与Annotation操作有关的方法 No 方法 类型 描述 1 public A getAnnotation(Class annotationClass) 普通 如果在一个元素中存在注释，则取得注解 2 public Annotation[] getAnnotations() 普通 返回此元素上的所有注解 3 public Annotation[] getDeclaredAnnotations() 普通 返回直接存放在此元素上的所有注解 4 public boolean isAnnotation() 普通 判断元素是否表示一个注解 5 public boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) 普通 判断一个元素上是否存在注解 package com.ecit.annotation; public class SimpleBeanOne { @SuppressWarnings(&quot;unchecked&quot;) // 使用@SuppressWarnings的Annotation @Deprecated // 使用@Deprecated的Annotation @Override // 使用@Override的Annotation public String toString() { // 覆写toString()方法 return &quot;Hello World!!!&quot; ; // 返回信息 } } import java.lang.annotation.Annotation; import java.lang.reflect.Method; public class ReflectDemo01 { public static void main(String args[]) throws Exception {// 所有异常抛出 Class&lt;?&gt; c = null ; // 取得Class实例 c = Class.forName(&quot;com.ecit.annotation.SimpleBeanOne&quot;) ; Method toM = c.getMethod(&quot;toString&quot;); // 取得toString()方法 Annotation an[] = toM.getAnnotations(); // 取得全部的Annotation for (Annotation a : an) { // foreach输出 System.out.println(a); // 直接输出信息 } } } // 输出结果: // @java.lang.Deprecated() 以上的程序是取得了一个元素所声明的全部RUNTIME的Annotation，但是有时候需要取得的是某个指定的Annotation，所以此时在取得之前就必须进行明确的判断，使用isAnnotationPresent()方法进行判断package com.ecit.annotation; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; @Retention(value=RetentionPolicy.RUNTIME) // 此Annotation在类执行时依然有效 public @interface MyDefaultAnnotationReflect { public String key() default &quot;CHINA&quot; ; public String value() default &quot;中国&quot; ; } package com.ecit.annotation; public class SimpleBeanTwo { @SuppressWarnings(&quot;unchecked&quot;) // 使用@SuppressWarnings的Annotation @Deprecated // 使用@Deprecated的Annotation @Override // 使用@Override的Annotation // 使用自定义的Annotation并设置两个属性内容 @MyDefaultAnnotationReflect(key = &quot;ecit&quot;, value = &quot;东华&quot;) public String toString() { // 覆写toString()方法 return &quot;Hello!&quot; ; // 返回信息 } } import java.lang.reflect.Method; public class ReflectDemo02 { public static void main(String args[]) throws Exception { Class&lt;?&gt; c = null ; // 取得Class实例 c = Class.forName(&quot;com.ecit.annotation.SimpleBeanTwo&quot;) ; Method toM = c.getMethod(&quot;toString&quot;); // 取得toString()方法 if (toM.isAnnotationPresent(MyDefaultAnnotationReflect.class)) { MyDefaultAnnotationReflect mda = null; // 声明自定义的Annotation对象 // 取得自定义的Annotation mda = toM.getAnnotation(MyDefaultAnnotationReflect.class); String key = mda.key(); // 得到Annotation中指定变量的内容 String value = mda.value();// 得到Annotation中指定变量的内容 System.out.println(&quot;key = &quot; + key);// 输出Annotation中的key System.out.println(&quot;value = &quot; + value);// 输出Annotation中的value } } } // 输出结果: // key = ecit // value = 东华 深入Annotation 如果一个Annotation没有明确的指明定义的位置，则可以在任意的位置使用，例如之前所讲解的全部的Annotation因为没有指定应用位置，所以是可以在任意的位置上进行定义的。 任意使用Annotation@MyDefaultAnnotationReflect(key = &quot;ecit&quot;, value = &quot;东华&quot;) public class SimpleBean { // 使用自定义的Annotation并设置两个属性内容 @MyDefaultAnnotationReflect(key = &quot;ecit&quot;, value = &quot;东华&quot;) public String toString() { // 覆写toString()方法 return &quot;Hello LiXingHua!!!&quot; ; // 返回信息 } } @Target 如果希望一个自定义的Annotation只能在指定的位置上出现，例如：只能在类上或只能在方法中声明，则必须使用@Target注释。 @Target明确的指出了一个Annotation的使用位置，此注释的定义如下@Documented @Retention(value=RUNTIME) @Target(value=ANNOTATION_TYPE) public @interface Target{ public abstract ElementType[] value } ElementType的保存范围 No 范围 描述 1 public static final ElementType ANNOTATION_TYPE 只能用在注释声明上 2 public static final ElementType CONSTRUCTOR 只能用在构造方法声明上 3 public static final ElementType FIELD 只能用在字段声明（包括枚举常量）上 4 public static final ElementType LOCAL_VARIABLE 只能用在局部变量声明上 5 public static final ElementType METHOD 只能用在方法的声明上 6 public static final ElementType PACKAGE 只能用在包的声明上 7 public static final ElementType PARAMETER 只能用在参数的声明上 8 public static final ElementType TYPE 只能用在类、接口、枚举类型上 import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; @Target(ElementType.TYPE) // 此Annotation只能用在类上 @Retention(value=RetentionPolicy.RUNTIME) // 此Annotation在类执行时依然有效 public @interface MyTargetAnnotation { public String key() default &quot;ECIT&quot; ; public String value() default &quot;中国&quot; ; } 定义一个Annotation可以出现在类、方法上 import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; @Target({ElementType.TYPE,ElementType.METHOD})// 此Annotation只能用在类及方法上 @Retention(value=RetentionPolicy.RUNTIME) // 此Annotation在类执行时依然有效 public @interface MyTargetAnnotation { public String key() default &quot;ECIT&quot; ; public String value() default &quot;中国&quot; ; } @Documented注释 任何一个自定义的Annotation实际上都是通过@Documented进行注释的，在生成javadoc的时候可以通过@Documented将一些文档的说明信息写进去，@Documented的使用格式如下： @Documented[public] @interface Annotation名称{ 数据类型 变量名称() ; } 使用@Documented标注之后，此Annotation在生成javadoc时候就可以加入类或方法的一些说明信息，这样可以便于用户了解类或方法的作用。 import java.lang.annotation.Documented; @Documented public @interface MyDocumentedAnnotation { public String key() ; public String value() ; } @MyDocumentedAnnotation(key = &quot;china&quot;, value = &quot;中国&quot;) public class SimpleBeanDocumented { /** * 此方法在对象输出时调用，返回对象的信息 */ @MyDocumentedAnnotation(key = &quot;ecit&quot;, value = &quot;东华&quot;) public String toString() { return &quot;Hello LiXingHua!!!&quot;; } } @Inherited注释 @Inherited用于标注一个父类的注释是否可以被子类所继承，如果一个Annotation，需要被其子类所继承的话，则在声明的时候直接使用@Inherited注释即可。 Inherited的Annotation定义如下：@Documented @Retention(value=RUNTIME) @Target(value=ANNOTATION_TYPE) public @interface Inherited{ } 注解继承演示package com.ecit.annotation; import java.lang.annotation.Documented; import java.lang.annotation.Inherited; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; @Documented @Inherited // 此Annotation可以被继承 @Retention(value=RetentionPolicy.RUNTIME) // 此Annotation在类执行时依然有效 public @interface MyInheritedAnnotation { public String name() ; // 定义name变量接收内容 } package com.ecit.model; @MyInheritedAnnotation(name = &quot;中国&quot;) // 使用自定义的Annotation public class Person { // 定义Person类 } package com.ecit.model; public class Student extends Person { // 继承Person类 } import java.lang.annotation.Annotation; public class ReflectInheritedDemo { public static void main(String args[]) throws Exception { Class&lt;?&gt; c = null ; // 取得Class实例 c = Class.forName(&quot;com.ecit.model.Student&quot;) ; Annotation ann[] = c.getAnnotations(); for (Annotation a : ann) { // 输出全部的Annotation System.out.println(a); } if (c.isAnnotationPresent(MyInheritedAnnotation.class)) { MyInheritedAnnotation mda = null; // 声明自定义的Annotation对象 // 取得自定义的Annotation，此Annotation是从父类继承而来 mda = c.getAnnotation(MyInheritedAnnotation.class); String name = mda.name(); // 得到自定义Annotation指定变量内容 System.out.println(&quot;name = &quot; + name);// 输出name变量的内容 } } } 综合使用注解为按钮添加监听事件package com.ecit.annotation; import java.lang.annotation.*; import java.awt.event.*; @Target(ElementType.FIELD) @Retention(RetentionPolicy.RUNTIME) public @interface ActionListenerFor { //定义一个成员变量，用于设置元数据 //该listener成员变量用于保存监听器实现类 Class&lt;? extends ActionListener&gt; listener(); } import com.ecit.annotation.ActionListenerFor; import javax.swing.*; import java.awt.event.ActionListener; import java.lang.reflect.Field; public class ActionListenerInstaller { // 处理Annotation的方法，其中obj是包含Annotation的对象 public static void processAnnotations(Object obj) { try { // 获取obj对象的类 Class cl = obj.getClass(); // 获取指定obj对象的所有Field，并遍历每个Field for (Field f : cl.getDeclaredFields()) { // 将指定Field设置成可自由访问。 f.setAccessible(true); // 获取指定Field上ActionListenerFor类型的Annotation ActionListenerFor a = f.getAnnotation(ActionListenerFor.class); // 获取f Field实际对应的对象 Object fObj = f.get(obj); // 如果f是AbstractButton的实例，且a不为null if (a != null &amp;&amp; fObj != null &amp;&amp; fObj instanceof AbstractButton) { // 获取a注释里的元数据listner（它是一个监听器类） Class&lt;? extends ActionListener&gt; listenerClazz = a.listener(); // 使用反射来创建listner类的对象 ActionListener al = listenerClazz.newInstance(); AbstractButton ab = (AbstractButton)fObj; // 为ab按钮添加事件监听器 ab.addActionListener(al); } } } catch (Exception e) { e.printStackTrace(); } } } import javax.swing.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; public class AnnotationTest { private JFrame mainWin = new JFrame(&quot;使用注释绑定事件监听器&quot;); // 使用Annotation为ok按钮绑定事件监听器 @ActionListenerFor(listener=OkListener.class) private JButton ok = new JButton(&quot;确定&quot;); // 使用Annotation为cancel按钮绑定事件监听器 @ActionListenerFor(listener=CancelListener.class) private JButton cancel = new JButton(&quot;取消&quot;); public void init() { // 初始化界面的方法 JPanel jp = new JPanel(); jp.add(ok); jp.add(cancel); mainWin.add(jp); ActionListenerInstaller.processAnnotations(this); // 处理该对象的注解 mainWin.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); mainWin.pack(); mainWin.setVisible(true); } public static void main(String[] args) { new AnnotationTest().init(); } } // 定义ok按钮的事件监听器实现类 class OkListener implements ActionListener { public void actionPerformed(ActionEvent evt) { JOptionPane.showMessageDialog(null , &quot;单击了确认按钮&quot;); } } // 定义cancel按钮的事件监听器实现类 class CancelListener implements ActionListener { public void actionPerformed(ActionEvent evt) { JOptionPane.showMessageDialog(null , &quot;单击了取消按钮&quot;); } }","link":"/2013/09/15/javase/JAVASE-Annotation-15/"},{"title":"JAVA-GUI图形界面","text":"AWTAWT (Abstract Windowing Toolkit），抽象窗口工具包，是 SUN 公司在发布 JDK1.0 的时一个重要组成部分，是 Java 提供的用来建立和设置 Java 的图形用户界面的基本工具。AWT 中的所有工具类都保存在java.awt 包中，此包中的所有操作类可用来建立与平台无关的图形用户界面（GUI）的类，这些类又被称为组件（components）。 AWT包组成在整个AWT包中提供的所有工具类，主要分为以下三种:◆组件: Component◆容器: Container◆布局管理器: LayoutManager 组件 在图形界面中，用户经常会看到一个个的按钮、标签、菜单等，那么这些实际上就是一个个的组件。这些组件都会在一个窗体上显示。Component 在整个AWT包中，所有的组件类(例如:按钮、文本框等)都是从Component和MenuComponent扩展而来的，这些类会继承这两个类的公共操作。图形界面最麻烦的实际上就在于类的继承关系，一定要记住Componenet是所有组件的最大父类。 容器 所有的AWT组件都应该放到容器之中。在容器之中，所有的组件都可以设置在容器中的位置、大小等等，所有的容器都是Component的子类，在AWT中包含以下几种容器。容器本身也是一种组件。 布局管理器 使用布局管理器可以使容器中的组件按照指定的位置进行摆放，另外的一个好处是，即使容器改变了大小，布局管理器也可以准确的把组件放到指定的位置，这样就可以有效的保证版面不会混乱。在AWT中所有的布局管理器都是LayoutManager的子类。 Swing简介 AWT大量的引入了Windows函数，所以经常被称为重量级组件，在Java2中提供了轻量级的图形界面组件–Swing， Swing使用Java语言实现，是以AWT平台为基础构建起来的新组件，直接使用Swing可以更加轻松的构建用户界面。 在Java中所 有的Swing都保存在javax.swing包中，从包的名称中(javax)就可以清楚的发现此包是一个扩展包，所有的组件是从JComponent扩展出来的。 JComponent的常用子类 JFrame 如果现在要使用Swing创建一个窗口，则直接使用JFrame类即可，此类是Component的子类JFrame类的常用操作方法 No. 方法 类型 描述 1 public JFrame() throws HeadlessException 构造 创建-个普通的窗体对象 2 public JFrame(String title) throws HeadlessException 构造 创建-一个窗体对象，并指定标题 3 public void setSize(int width, int height) 普通 设置窗体大小 4 public void setSize(Dimension d) 普通 通过Dimension设置窗体大小 5 public void setBackground(Color c) 普通 设置窗体的背景颜色 6 public void setLocation(int x,int y) 普通 设置组件的显示位置 7 public void setLocation(Point p) 普通 通过Point来设置组件的显示位置 8 public void setVisible(booleanb) 普通 显示或隐藏组件 9 public Component add(Component comp) 普通 向容器中增加组件 10 public void setLayout(LayoutManager mgr) 普通 设置布局管理器，如果设置为null表示不使用 11 public void pack() 普通 调整窗口大小，以适合其子组件的首选大小和布局 12 public Container getContentPane() 普通 返回此窗体的容器对象 import javax.swing.JFrame ; import java.awt.Color ; public class JFrameDemo01{ public static void main(String args[]){ JFrame f = new JFrame(&quot;第一个Swing窗体&quot;) ; f.setSize(500,180) ; // 设置组件的大小 f.setBackground(Color.WHITE) ; // 将背景设置成白色 f.setLocation(300,200) ; // 设置组件的显示位置 f.setVisible(true) ; // 让组件可见 } } Dimension类 在JFrame中设置窗体的大小，也可以使用Dimension类完成，此类封装的就是组件的显示宽度和高度，此类的常用操作方法如下： No. 方法 类型 描述 1 public Dimension() 构造 创建- -个Dimension实例 2 public void setSize(double width,double height) 普通 设置显示的宽和高 3 public void setSize( int width,int height) 普通 设置显示的宽和高 4 public double getWidth() 普通 返回组件的宽 5 public double getHeight() 普通 返回组件的高 Point类 组件的显示位置也可以使用Point类指定，此类封装的是显示位置的X、Y坐标，此类的常用操作方法如下： No. 方法 类型 描述 1 public Point() 构造 在坐标原点创建对象 2 public Point(int x,int y) 构造 在指定的坐标点创建对象 3 public void setLocation(double x,double y) 普邇 设置X、Y坐标 4 public void setLocation(int xint y) 普通 设置X、Y坐标 5 public void move(int x,int y) 普通 将此组件移动到指定坐标位置，此方法与setLocation(int, int)相同. 6 public void translate(int ax,int dy) 普通 平移(x,y)位置的点，沿x轴平移dx,沿y轴平移dy,移动 后得到点(x+ dx,y+ dy) JLabel类 JLabel表示一个标签，标签及时只用于显示信息的一个组件。JLabel类的常用方法和常量 No. 方法及常量 类型 描述 1 public static final int LEFT 常量 标签文本左对齐 2 public static final int CENTER 常量 标签文本居中对齐 3 public static final int RIGHT 常量 标签文本右对齐 4 public JLabel() throws HeadlessException 构造 创建一个JILabel对象 5 public JLabel(String text) throws HeadlessException 构造 创建-个标签并指定文本内容，默认为左对齐 6 public Label(String text,int alignment) throws HeadlessException 构造 创建一个标签并指定文本内容以及对齐方式，可以使用JLabel.LEFT、JLabel.RIGHT、JLabel.CENTER三个值 7 public JILabel(String text,Icon icon,int horizontalAlignment) 构造 创建具有指定文本、图像和水平对齐方式的JILabel对象 8 public JLabelTcon image,int horizontalAlignment) 构造 创建具有指定图像和水平对齐方式的JLabel实例 9 public void setText(String text) 普通 设置标签的文本 10 public String getText() 普通 取得标签的文本 11 public void setAligment(int alignment) 普通 设置标签的对齐方式 12 public void setIcon(Icon icon) 普通 设置指定的图象 import java.awt.Dimension ; import java.awt.Color ; import java.awt.Point ; import javax.swing.JLabel ; import javax.swing.JFrame ; public class JLabelDemo01{ public static void main(String args[]){ JFrame frame = new JFrame(&quot;Welcome To ECIT&quot;) ; JLabel lab = new JLabel(&quot;中国&quot;,JLabel.CENTER) ; // 实例化标签对象 frame.add(lab) ; // 将组件件入到面板之中 Dimension dim = new Dimension() ; frame.setBackground(Color.WHITE) ;//设置窗体的背景颜色 dim.setSize(500,180) ; frame.setSize(dim) ; Point point = new Point(300,200) ; // 设置坐标 frame.setLocation(point) ; frame.setVisible(true) ; } } 更改JLabel的文字样式 如果现在要想更改使用的字体，则可以直接使用Component类中定义的以下方法:public void setFont(Font f)◆在设置的时候使用了java.awt.Font类来表示字体，Font类的常用操作方法及常量如下 No. 方法及常量 类型 描述 1 public static final int BOLD 常量 文字显示为粗体 2 public static final int ITALIC 常量 文字显示风格为斜体 3 public static fimal int PLAIN 常量 文字显示风格为普通祥式 4 public Font(String name .int style,int size) 构造 实例化对象，指定显示风格及大小 5 public String getFontName() 普通 得到字体的名称 import java.awt.Dimension ; import java.awt.Color ; import java.awt.Font ; import java.awt.Point ; import javax.swing.JLabel ; import javax.swing.JFrame ; public class JLabelDemo02{ public static void main(String args[]){ JFrame frame = new JFrame(&quot;Welcome To ECIT&quot;) ; JLabel lab = new JLabel(&quot;China is very great!&quot;,JLabel.CENTER) ; // 实例化标签对象 Font fnt = new Font(&quot;Serief&quot;,Font.ITALIC + Font.BOLD,28) ; lab.setFont(fnt) ; frame.add(lab) ; // 将组件件入到面板之中 Dimension dim = new Dimension() ; frame.setBackground(Color.WHITE) ;//设置窗体的背景颜色 dim.setSize(500,170) ; frame.setSize(dim) ; Point point = new Point(300,200) ; // 设置坐标 frame.setLocation(point) ; frame.setVisible(true) ; } } 得到全部可用字体import java.awt.GraphicsEnvironment ; public class GetAllFonts{ public static void main(String args[]){ GraphicsEnvironment eq = GraphicsEnvironment.getLocalGraphicsEnvironment() ; String fontNames[] = eq.getAvailableFontFamilyNames() ; for(int x=0;x&lt;fontNames.length;x++){ System.out.println(fontNames[x]) ; } } } Jlabel设置显示图片import java.awt.Dimension ; import java.awt.Color ; import java.awt.Font ; import java.awt.Point ; import java.io.File ; import javax.swing.JLabel ; import javax.swing.JFrame ; import javax.swing.Icon ; import javax.swing.ImageIcon ; public class JLabelDemo04{ public static void main(String args[]){ JFrame frame = new JFrame(&quot;Welcome To ECIT&quot;) ; String picPath = &quot;/Users/sxm/Downloads/app/images/icon_268.png&quot; ; Icon icon = new ImageIcon(picPath) ; JLabel lab = new JLabel(&quot;中国&quot;,icon,JLabel.CENTER) ; // 实例化标签对象 Font fnt = new Font(&quot;Serief&quot;,Font.ITALIC + Font.BOLD,28) ; lab.setFont(fnt) ; lab.setForeground(Color.RED) ; lab.setBackground(Color.YELLOW) ;//设置窗体的背景颜色 frame.add(lab) ; // 将组件件入到面板之中 Dimension dim = new Dimension() ; frame.setBackground(Color.WHITE) ;//设置窗体的背景颜色 dim.setSize(300,160) ; frame.setSize(dim) ; Point point = new Point(300,200) ; // 设置坐标 frame.setLocation(point) ; frame.setVisible(true) ; } } JButton组件 JButton组件表示一个普通的按钮，直接使用此类就可以直接在窗体中增加一个按钮。 No 方法 类型 描述 1 public JButton() throws HeadlessException 构造 创建一个Button对象 2 public JButton(String label) throws HeadlessException 构造 创建一个Button对象， 同时指定其显示内容 3 public JButton(Icon icon) 构造 创建一个带图片的按钮 4 public JButton(String text,Icon icom) 构造 创建一个带图片和文字的按钮 5 public void setLabel(String label) 普通 设置Button的显示内容 6 public String getLabel() 普通 得到Button的显示内容 7 public void setBounds(int x,int y,int width,int height) 普通 设置组件的大小及显示方式 8 public void setMnemonic(int mnemonic) 普通 设置按钮的快捷键 import javax.swing.JFrame ; import javax.swing.JButton ; import javax.swing.Icon ; import javax.swing.ImageIcon ; import java.io.File ; import java.awt.Font ; public class JButtonDemo02{ public static void main(String args[]){ JFrame frame = new JFrame(&quot;Welcome To ECIT&quot;) ; String picPath = &quot;/Users/sxm/Downloads/APP网站html模板/images/ysfx_1.jpg&quot; ; Icon icon = new ImageIcon(picPath) ; JButton but = new JButton(&quot;按钮点击&quot;,icon) ; frame.add(but) ; frame.setSize(300,160) ; frame.setLocation(300,200) ; frame.setVisible(true) ; } } 布局管理器FlowLayout FlowLayout属于流式布局管理器，使用此种布局方式，所有的组件会像流水一样依次进行排列，FlowLayout类的常用方法及常量如下。 No 方法及常量 类型 描述 1 public static final int CENTER 常量 居中对齐 2 public static final int LEADING 常量 与容器的开始端对齐方式一样 3 public static final int LEFT 常量 左对齐 4 public static final int RIGHT 常量 右对齐 5 public static final int TRAILING 常量 与容器的结束端对齐方式一样 6 public FlowLayout() 构造 构造一个新的FlowLayout,居中对齐，默认的水平和垂直间距是5个单位 7 public FlowLayout(int aligm) 构造 构造一个FlowLayout,并指定对齐方式 8 public FlowLayout(int align,int hgap,int vgap) 构造 指定对齐方式、水平、垂直间距 流式布局居中样式 import java.awt.FlowLayout ; import javax.swing.JFrame ; import javax.swing.JButton ; public class FlowLayoutDemo01{ public static void main(String args[]){ JFrame frame = new JFrame(&quot;Welcome To ECIT&quot;) ; frame.setLayout(new FlowLayout(FlowLayout.CENTER,3,3)) ; JButton but = null ; for(int i=0;i&lt;9;i++){ but = new JButton(&quot;按钮_&quot;+ i) ; frame.add(but) ; } frame.setSize(280,123) ; frame.setVisible(true) ; } } 容器开始端对齐 import java.awt.FlowLayout ; import javax.swing.JFrame ; import javax.swing.JButton ; public class FlowLayoutDemo01{ public static void main(String args[]){ JFrame frame = new JFrame(&quot;Welcome To ECIT&quot;) ; frame.setLayout(new FlowLayout(FlowLayout.LEADING,0,0)) ; JButton but = null ; for(int i=0;i&lt;9;i++){ but = new JButton(&quot;按钮_&quot;+ i) ; frame.add(but) ; } frame.setSize(680,150) ; frame.setVisible(true) ; } } 流式布局右对齐 import java.awt.FlowLayout ; import javax.swing.JFrame ; import javax.swing.JButton ; public class FlowLayoutDemo01{ public static void main(String args[]){ JFrame frame = new JFrame(&quot;Welcome To ECIT&quot;) ; frame.setLayout(new FlowLayout(FlowLayout.RIGHT,0,0)) ; JButton but = null ; for(int i=0;i&lt;9;i++){ but = new JButton(&quot;按钮_&quot;+ i) ; frame.add(but) ; } frame.setSize(680,150) ; frame.setVisible(true) ; } }; BorderLayout BorderLayout将一个窗体的版面划分成东、西、南、北、中五个区域，可以直接将需要的组件放到这五个区域中即可。import java.awt.BorderLayout ; import javax.swing.JFrame ; import javax.swing.JButton ; public class BorderLayoutDemo01{ public static void main(String args[]){ JFrame frame = new JFrame(&quot;Welcome To ECIT&quot;) ; frame.setLayout(new BorderLayout(3,3)) ; frame.add(new JButton(&quot;东（EAST）&quot;),BorderLayout.EAST) ; frame.add(new JButton(&quot;西（WEST）&quot;),BorderLayout.WEST) ; frame.add(new JButton(&quot;南（SOUTH）&quot;),BorderLayout.SOUTH) ; frame.add(new JButton(&quot;北（NORTH）&quot;),BorderLayout.NORTH) ; frame.add(new JButton(&quot;中（CENTER）&quot;),BorderLayout.CENTER) ; frame.setSize(280,123) ; frame.setVisible(true) ; } } GridLayout GridLayout布局管理器是以表格的形式进行管理的，在使用此布局管理器的时候必须设置显示的行数和列数，常用的方法如下所示。 No 方法 类型 描述 1 public GridLayout(int rows,int cols) 构造 构造一个指定行和列的布局管理器 2 public GridLayout(int rows,int cols,int hgap,int vgap) 构造 构造时指定行和列、水平和垂直间距 import java.awt.GridLayout ; import javax.swing.JFrame ; import javax.swing.JButton ; public class GridLayoutDemo01{ public static void main(String args[]){ JFrame frame = new JFrame(&quot;Welcome To ECIT&quot;) ; frame.setLayout(new GridLayout(3,5,3,3)) ; //3行5列 间距3 JButton but = null ; for(int i=0;i&lt;13;i++){ but = new JButton(&quot;按钮-&quot;+ i) ; frame.add(but) ; } frame.pack() ; frame.setVisible(true) ; } } CardLayout卡片式布局 CardLayout就 是将一组 组件彼此重叠的进行布局，就像- -张张卡片一样，这样每次只会展现一个界面。```javaimport java.awt.CardLayout ;import java.awt.Container ;import javax.swing.JFrame ;import javax.swing.JLabel ;public class CardLayoutDemo01{ public static void main(String args[]){ JFrame frame = new JFrame(“Welcome To ECIT”) ; CardLayout card = new CardLayout() ; frame.setLayout(card) ; Container con = frame.getContentPane() ; con.add(new JLabel(“标签-A”,JLabel.CENTER),”first”) ; con.add(new JLabel(“标签-B”,JLabel.CENTER),”second”) ; con.add(new JLabel(“标签-C”,JLabel.CENTER),”thrid”) ; con.add(new JLabel(“标签-D”,JLabel.CENTER),”fourth”) ; con.add(new JLabel(“标签-E”,JLabel.CENTER),”fifth”) ; frame.pack() ; frame.setVisible(true) ; card.show(con,”thrid”) ; while(true){ try{ Thread.sleep(3000) ; }catch(InterruptedException e){} card.next(con) ; } } } ### JPanel - 最早是直接向Jframe中加入各个组件，但是现在改变,现在的组件可以加入到Jpanel 之中，在Jpanel完成各个组见的排列，之后再将所有的独立的Jpanel直接放在Jframe之中，以完成复杂的图形显示。 ```java import javax.swing.JPanel ; import javax.swing.JButton ; import javax.swing.JLabel ; import javax.swing.JFrame ; public class JPanelDemo01{ public static void main(String args[]){ JFrame frame = new JFrame(&quot;Welcome TO ECIT&quot;) ; // 实例化窗体对象 JPanel pan = new JPanel() ; // 准备好了一个面板 // 现在所有的内容都加入到了JPanel之中 pan.add(new JLabel(&quot;标签-A&quot;)) ; pan.add(new JLabel(&quot;标签-B&quot;)) ; pan.add(new JLabel(&quot;标签-C&quot;)) ; pan.add(new JButton(&quot;按钮-X&quot;)) ; pan.add(new JButton(&quot;按钮-Y&quot;)) ; pan.add(new JButton(&quot;按钮-Z&quot;)) ; frame.add(pan) ;// 将面板加入到窗体之上 frame.pack() ;// 根据组件自动调整大小 frame.setLocation(300,200) ; frame.setVisible(true) ; } } JSplitPane JSplitPane主要功能是分割面板，可以将一个窗体分为两个 子窗体，可以是水平排列也可以是垂直排列 JSplitPane类的主要方法及常量 No 方法及常量 类型 描述 1 public static final int HORIZONTAL_SPLIT 常量 表示水平分割 2 public static final int VERTICAL_SPLIT 常量 表示垂直分割 3 public JSplitPane(int newOrientation) 构造 创建对象，并指明分割方式 4 public JSplitPane(int newOrientation, boolean newContinuousLayout, Component newLeftComponent, Component newRightComponent) 构造 创建对象、指明分割方式、分割条改变是否重绘图象以及两端的显示组件 5 public void setDividerLocation(double proportionalLocation) 普通 设置分割条的位置，按百分比 6 public void setOneTouchExpandable(boolean newValue) 普通 设置是否提供快速展开/折叠的功能 7 public void setDividerSize(int newSize) 普通 设置分割条大小 import javax.swing.JPanel ; import javax.swing.JButton ; import javax.swing.JLabel ; import javax.swing.JFrame ; import java.awt.Container ; import javax.swing.JSplitPane ; public class JSplitPaneDemo01{ public static void main(String args[]){ JFrame frame = new JFrame(&quot;Welcome TO ECIT&quot;) ; // 实例化窗体对象 Container cont = frame.getContentPane() ; JPanel pan = new JPanel() ; // 准备好了一个面板 JSplitPane lfsplit = null ; // 左右分割 JSplitPane tpsplit = null ; // 上下分割 lfsplit = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,new JButton(&quot;左按钮&quot;),new JButton(&quot;右按钮&quot;)) ; lfsplit.setDividerSize(10) ; // 设置左右分割条的分割线大小 lfsplit.setOneTouchExpandable(true) ; tpsplit = new JSplitPane(JSplitPane.VERTICAL_SPLIT,lfsplit,new JLabel(&quot;下标签&quot;)) ; tpsplit.setDividerSize(10) ; // 设置上下分割条的分割线大小 tpsplit.setOneTouchExpandable(true) ; cont.add(tpsplit) ; frame.pack() ;// 根据组件自动调整大小 frame.setLocation(300,200) ; frame.setVisible(true) ; } } JTabbedPane选项卡面板 选项卡面板是一个很常用的Swing组件，在window下，右击我的电脑，查看属性，就是一个典型的选修卡面板。当然还有最经典的谷歌浏览器，也是选项卡的一个典型。Swing中的选项卡使用JTabbedPane类来实现，下面就来介绍JTabbedPane的使用 |No| 方法及常量| 类型 | 描述||1 | static final int TOP | 常量 | 表示指向框项部位置||2 | static final int BOTTOM |常量 | 表示指向框底部位置||3 | static final int LEFT |常量 |表示指向框左部位置||4 | static final int RIGHT |常量 | 表示指向框右部位置||5 | public JTabbedPane(int tabPlacerment) |构造| 创建对象，并指定选项卡布局||6 | public void addTab(String title,Component component) | 普通| 添加一个有标题，没有图标的组件||7 | public void addTab(String title,Icon icon,Component component) | 普通 | 添加一个有标题，有图标的组件||8 | public void addTab(String title,Icon icon,Component component, String tip) |普通 | 掭加一个有标题，有图标，有提示信息的组件| import java.io.File ; import java.awt.Container ; import javax.swing.JPanel ; import javax.swing.JButton ; import javax.swing.ImageIcon ; import javax.swing.JLabel ; import javax.swing.JFrame ; import javax.swing.JTabbedPane ; public class JTabbedPaneDemo01 { public static void main(String args[]){ JFrame frame = new JFrame(&quot;Welcome TO ECIT&quot;) ; // 实例化窗体对象 Container cont = frame.getContentPane() ; JTabbedPane tab = null ; tab = new JTabbedPane(JTabbedPane.TOP) ;// 设置标签在顶部显示 JPanel pan1 = new JPanel() ; JPanel pan2 = new JPanel() ; JButton but = new JButton(&quot;按钮&quot;) ; JLabel lab = new JLabel(&quot;标签&quot;) ; pan1.add(but) ; pan2.add(lab) ; String picPath = &quot;/Users/sxm/Desktop/icon.png&quot; ; tab.addTab(&quot;图片选项&quot;,new ImageIcon(picPath),pan1,&quot;图象&quot;) ; tab.addTab(&quot;文字选项&quot;,pan2) ; cont.add(tab) ; frame.setSize(330,120) ;// 根据组件自动调整大小 frame.setLocation(300,200) ; frame.setVisible(true) ; } } JScrollPane滚动条面板 在一般的图形界面中如果显示的区域不够大了，往往会出现滚动条以方便用户浏览，在Swing中JScrollPane的 主要功能就是为显示的内容加入水平滚动条。JScrollPane 主要由JViewport和JScrollBar两部分组成，前者主要是显示–个矩形的区域让用户浏览，而后者主要是形成水平或垂直的滚动条 import java.io.File ; import java.awt.Container ; import javax.swing.JPanel ; import javax.swing.JButton ; import javax.swing.ImageIcon ; import javax.swing.Icon ; import javax.swing.JLabel ; import javax.swing.JFrame ; import javax.swing.JScrollPane ; public class JScrollPaneDemo01 { public static void main(String args[]){ JFrame frame = new JFrame(&quot;Welcome TO ECIT&quot;) ; // 实例化窗体对象 Container cont = frame.getContentPane() ; String picPath = &quot;/Users/sxm/Desktop/icon.png&quot; ; Icon icon = new ImageIcon(picPath) ; // 实例化Icon对象 JPanel pan = new JPanel() ; JLabel lab = new JLabel(icon) ; JScrollPane scr1 = null ; // 设置垂直和水平的滚动条一直显示 scr1 = new JScrollPane(pan,JScrollPane.VERTICAL_SCROLLBAR_ALWAYS ,JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS) ; pan.add(lab) ; cont.add(scr1) ; frame.setSize(230,120) ;// 根据组件自动调整大小 frame.setLocation(300,200) ; frame.setVisible(true) ; } } JInternalFrame内部窗体 JInternalFrame 支持在 JFrame 窗口内部显示一个完整的子窗口，并提供了许多本机窗体功能的轻量级对象，包括拖动、关闭、变成图标、调整大小、标题显示和支持菜单栏等。 在实际使用中，通常将 JInternalFrame 添加到 JDesktopPane 中，由其来维护和显示 JInternalFrame。 JInternalFrame 的实例创建后，其具体使用方法和 JFrame 类似。import java.io.File ; import java.awt.Container ; import javax.swing.JPanel ; import javax.swing.JButton ; import javax.swing.ImageIcon ; import javax.swing.Icon ; import javax.swing.JLabel ; import javax.swing.JFrame ; import javax.swing.JDesktopPane ; import javax.swing.JInternalFrame ; import javax.swing.JScrollPane ; import java.awt.BorderLayout ; public class JInternalFrameDemo01 { public static void main(String args[]){ JFrame frame = new JFrame(&quot;Welcome TO ECIT&quot;) ; // 实例化窗体对象 Container cont = frame.getContentPane() ; JDesktopPane desk = new JDesktopPane() ; // 定义窗体的容器 cont.add(desk,BorderLayout.CENTER) ; // 设置显示样式 cont.add(new JLabel(&quot;内部窗体&quot;),BorderLayout.SOUTH) ; JInternalFrame jif = null ; String picPath = &quot;/Users/sxm/Desktop/icon.png&quot; ; Icon icon = new ImageIcon(picPath) ; // 实例化Icon对象 JPanel pan = null ; for(int i=0;i&lt;3;i++){ jif = new JInternalFrame(&quot;ECIT-&quot; + i,true,true,true,true) ; pan = new JPanel() ; pan.add(new JLabel(icon)) ; // 加入标签 jif.setLocation(35 - i * 10 , 35 - i * 10) ; // 设置显示位置 jif.add(pan) ; jif.pack() ; jif.setVisible(true) ; desk.add(jif) ; } frame.setSize(230,120) ;// 根据组件自动调整大小 frame.setLocation(300,200) ; frame.setVisible(true) ; } } JToggleButton不弹起的按钮组件(开关按钮) JButton提供了- -个按钮的基本实现，但是此按钮每次单击之后都会恢复自动弹起，如果现在希望点中-一个按钮之后不在自动弹起，而是在第二次点此按钮的时候弹起，则就必须使用JToggleButton类。import javax.swing.JFrame ; import javax.swing.JToggleButton ; import java.awt.GridLayout ; public class JToggleButtonDemo01{ public static void main(String args[]){ JFrame frame = new JFrame(&quot;Welcome To ECIT&quot;) ; JToggleButton but1 = new JToggleButton(&quot;已选中&quot;,true) ; // 默认选中 JToggleButton but2 = new JToggleButton(&quot;未选中&quot;) ; JToggleButton but3 = new JToggleButton(&quot;按我&quot;) ; frame.setLayout(new GridLayout(3,1)) ; // 设置排版样式 frame.add(but1) ; frame.add(but2) ; frame.add(but3) ; frame.setSize(200,100) ; frame.setLocation(300,200) ; frame.setVisible(true) ; } } JTextComponent文本组件JTextField单行文本输入框import java.awt.GridLayout ; import javax.swing.JFrame ; import javax.swing.JTextField ; import javax.swing.JLabel ; public class JTextDemo01{ public static void main(String args[]){ JFrame frame = new JFrame(&quot;Welcome To MLDN&quot;) ; JTextField name = new JTextField(30) ; JTextField noed = new JTextField(&quot;ECIT&quot;,10) ; JLabel nameLab = new JLabel(&quot;输入用户姓名：&quot;) ; JLabel noedLab = new JLabel(&quot;不可编辑文本：&quot;) ; name.setColumns(30) ; noed.setColumns(10) ; noed.setEnabled(false) ; // 表示不可编辑 frame.setLayout(new GridLayout(2,2)) ; frame.add(nameLab) ; frame.add(name) ; frame.add(noedLab) ; frame.add(noed) ; frame.setSize(300,100) ; frame.setLocation(300,200) ; frame.setVisible(true) ; } } JPasswordField密码框import java.awt.GridLayout ; import javax.swing.JFrame ; import javax.swing.JPasswordField ; import javax.swing.JLabel ; public class JPasswordDemo01{ public static void main(String args[]){ JFrame frame = new JFrame(&quot;Welcome To ECIT&quot;) ; JPasswordField jpf1 = new JPasswordField() ; JPasswordField jpf2 = new JPasswordField() ; jpf2.setEchoChar('#') ; // 设置回显 JLabel lab1 = new JLabel(&quot;默认的回显：&quot;) ; JLabel lab2 = new JLabel(&quot;回显设置“#”：&quot;) ; lab1.setBounds(10,10,100,20) ; lab2.setBounds(10,40,100,20) ; jpf1.setBounds(110,10,80,20) ; jpf2.setBounds(110,40,50,20) ; frame.setLayout(null) ; frame.add(lab1) ; frame.add(jpf1) ; frame.add(lab2) ; frame.add(jpf2) ; frame.setSize(300,100) ; frame.setLocation(300,200) ; frame.setVisible(true) ; } } JTextArea多行文本import java.awt.GridLayout ; import javax.swing.JFrame ; import javax.swing.JTextArea ; import javax.swing.JScrollPane ; import javax.swing.JLabel ; public class JTextAreaDemo02{ public static void main(String args[]){ JFrame frame = new JFrame(&quot;Welcome To ECIT&quot;) ; JTextArea jta = new JTextArea(3,10) ; // 设置大小 JLabel lab = new JLabel(&quot;多行文本域：&quot;) ; JScrollPane scr = new JScrollPane(jta,JScrollPane.VERTICAL_SCROLLBAR_ALWAYS ,JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS ) ; frame.setLayout(new GridLayout(2,1)) ; frame.add(lab) ; frame.add(scr) ; frame.setSize(300,150) ; frame.setLocation(300,200) ; frame.setVisible(true) ; } } JRadioButton单选按钮 单选钮就是在给出的多个显示信息中指定选择一个， 在Swing中可以使用JRadionButton完成一组 单选钮的操作，JRadionButton类的 常用方法如下。 No 方法 类型 描述 1 public JRadioButton(Icon icon) 构造 建立一个单选钮，并指定图片 2 public JRadioButton(Icon icon,boolean selected) 构造 建立一个单选钮，并指定图片和其是否选定 3 public JRadioButton(String text) 构造 建立一个单选钮，并指定其文字，默认为不选定 4 public JRadioButton(String text,boolean selected) 构造 建立一个单选钮，并指定文字和其是否选定 5 public JRadioButton(String text,Icon icon,boolean selected) 构造 建立一个单选钮，并指定图片、文字和其是否选定 6 public void setSelected(boolean b) 普通 设置是否选中 7 public boolean isSelectedO 普通 返回是否被选中 8 public void setText(String text) 普通 设置显示文本 9 public void setIcon(Icon defaultIcon) 普通 设置图片 import java.awt.Container ; import java.awt.GridLayout ; import java.awt.event.WindowAdapter ; import java.awt.event.WindowEvent ; import javax.swing.JFrame ; import javax.swing.JPanel ; import javax.swing.JRadioButton ; import javax.swing.ButtonGroup ; import javax.swing.BorderFactory ; class MyRadio{ private JFrame frame = new JFrame(&quot;Welcome TO ECIT&quot;) ; private Container cont = frame.getContentPane() ; private JRadioButton jrb1 = new JRadioButton(&quot;游戏&quot;) ; private JRadioButton jrb2 = new JRadioButton(&quot;跑步&quot;) ; private JRadioButton jrb3 = new JRadioButton(&quot;赛车&quot;) ; private JPanel pan = new JPanel() ; public MyRadio(){ pan.setBorder(BorderFactory.createTitledBorder(&quot;请选择最喜爱的爱好&quot;)) ; // 设置一个边框的显示条 pan.setLayout(new GridLayout(1,3)) ; pan.add(this.jrb1) ; pan.add(this.jrb2) ; pan.add(this.jrb3) ; ButtonGroup group = new ButtonGroup() ; group.add(this.jrb1) ; group.add(this.jrb2) ; group.add(this.jrb3) ; cont.add(pan) ; this.frame.setSize(300,80) ; this.frame.setVisible(true) ; this.frame.addWindowListener(new WindowAdapter(){ public void windowClosing(WindowEvent obj){ System.exit(1) ; } }) ; } }; public class JRadioButtonDemo02{ public static void main(String args[]){ new MyRadio() ; } } JCheckBox复选框import java.awt.Container ; import java.awt.GridLayout ; import java.awt.event.WindowAdapter ; import java.awt.event.WindowEvent ; import javax.swing.JFrame ; import javax.swing.JPanel ; import javax.swing.JCheckBox ; import javax.swing.BorderFactory ; class MyCheckBox{ private JFrame frame = new JFrame(&quot;Welcome To ECIT&quot;) ; // 定义窗体 private Container cont = frame.getContentPane() ; // 得到窗体容器 private JCheckBox jcb1 = new JCheckBox(&quot;游戏&quot;) ; // 定义一个复选框 private JCheckBox jcb2 = new JCheckBox(&quot;游泳&quot;) ; // 定义一个复选框 private JCheckBox jcb3 = new JCheckBox(&quot;跑步&quot;) ; // 定义一个复选框 private JPanel pan = new JPanel() ; public MyCheckBox(){ pan.setBorder(BorderFactory.createTitledBorder(&quot;请选择最喜爱的运动&quot;)) ; pan.setLayout(new GridLayout(1,3)) ; // 设置组件的排版 pan.add(this.jcb1) ; // 增加组件 pan.add(this.jcb2) ; // 增加组件 pan.add(this.jcb3) ; // 增加组件 cont.add(pan) ; // 将面板加入到容器之中 this.frame.setSize(330,80) ; this.frame.setVisible(true) ; // 设置可显示 this.frame.addWindowListener(new WindowAdapter(){ public void windowClosing(WindowEvent arg){ System.exit(1) ; } }) ; } } public class JCheckBoxDemo01{ public static void main(String args[]){ new MyCheckBox() ; } } JList列表框 列表框可以同时将多个选项信息以列表的方式展现给用户，使用JList可以构建一个列表框 No. 方法 类型 描述 1 public JList(ListModel dataModel) 构造 根据ListModel构造JList 2 public JList(Object[] listData) 构造 根据对象数组构造JList 3 public JList(Vector&lt;?&gt; listData) 构造 根据一个Vector构造JList 4 public void setSelectionMode(int selectionMode) 普通 设置选择模式，是多选还是单选 5 public ListModel getModel() 普通 返回列表框的列表模型 6 public int[] getSelectedIndices() 普通 返回所选择的全部数组 List是可以进行多选或单选的，如果要想设置则使用,对于列表框是多选还是单选可以通过ListSelectionModel接口完成 No. 常量 类型 描述 1 static final int MULTIPLE INTERVAL SELECTION 常量 一次选择一个或多个连续的索引范围 2 static final int SINGLE INTERVAL SELECTION 常量 一次选择一个连续范围的值 3 static final int SINGLE SELECTION 常量 一次选择一个值 import javax.swing.JFrame ; import javax.swing.JList ; import java.util.Vector ; import javax.swing.BorderFactory ; import javax.swing.ListSelectionModel ; import javax.swing.JScrollPane ; import java.awt.Container ; import java.awt.GridLayout ; import java.awt.event.WindowAdapter ; import java.awt.event.WindowEvent ; class MyList{ private JFrame frame = new JFrame(&quot;Welcome To ECIT&quot;) ; private Container cont = frame.getContentPane() ; // 得到窗体容器 private JList list1 = null ; private JList list2 = null ; public MyList(){ this.frame.setLayout(new GridLayout(1,3)) ; // 定义排版 String nations[] = {&quot;中国&quot;,&quot;巴西&quot;,&quot;美国&quot;,&quot;韩国&quot;,&quot;意大利&quot;,&quot;法国&quot;} ; Vector&lt;String&gt; v = new Vector&lt;String&gt;() ; v.add(&quot;百度&quot;) ; v.add(&quot;雅虎&quot;) ; v.add(&quot;谷歌&quot;) ; this.list1 = new JList(nations) ; this.list2 = new JList(v) ; this.list1.setBorder(BorderFactory.createTitledBorder(&quot;你喜欢去那个国家旅游？&quot;)) ; this.list2.setBorder(BorderFactory.createTitledBorder(&quot;你喜欢网站？&quot;)) ; this.list1.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION) ;// 多选 this.list2.setSelectionMode(ListSelectionModel.SINGLE_SELECTION) ;// 单选 this.cont.add(new JScrollPane(this.list1)) ; this.cont.add(this.list2) ; this.frame.setSize(330,180) ; this.frame.setVisible(true) ; this.frame.addWindowListener(new WindowAdapter(){ public void windowClosing(WindowEvent a){ System.exit(1) ; } }) ; } } public class JListDemo01{ public static void main(String args[]){ new MyList() ; } } JComboBox下拉列表框之前学习过了JList, JList, 本身只是一个列表框，如果要想完成一个下拉的列表框，则就需要使用JComboBox完成。 import javax.swing.JFrame ; import java.awt.Container ; import java.awt.event.WindowEvent ; import java.awt.event.WindowAdapter ; import java.awt.GridLayout ; import javax.swing.JComboBox ; import javax.swing.JLabel ; import javax.swing.BorderFactory ; import java.util.Vector ; class MyComboBox{ private JFrame frame = new JFrame(&quot;Welcome TO ECIT&quot;) ; private Container cont = frame.getContentPane() ; // 得到容器 private JComboBox jcb1 = null ; private JComboBox jcb2 = null ; public MyComboBox(){ this.frame.setLayout(new GridLayout(2,2)) ; // 定义排版 String nations[] = {&quot;中国&quot;,&quot;巴西&quot;,&quot;美国&quot;,&quot;韩国&quot;,&quot;意大利&quot;,&quot;法国&quot;} ; Vector&lt;String&gt; v = new Vector&lt;String&gt;() ; v.add(&quot;Java&quot;) ; // 增加内容 v.add(&quot;C#&quot;) ; // 增加内容 v.add(&quot;C++&quot;) ; // 增加内容 this.jcb1 = new JComboBox(nations) ; // 实例化下拉列表框 this.jcb2 = new JComboBox(v) ; // 实例化下拉列表框 // 为每一个下拉框增加一个边框 this.jcb1.setBorder(BorderFactory.createTitledBorder(&quot;你喜欢去那个国家旅游？&quot;)) ; this.jcb2.setBorder(BorderFactory.createTitledBorder(&quot;你喜欢的网站？&quot;)) ; cont.add(this.jcb1) ; cont.add(this.jcb2) ; cont.add(new JLabel(&quot;下拉列表框&quot;)) ; this.frame.setSize(300,150) ; this.frame.setVisible(true) ; this.frame.addWindowListener(new WindowAdapter(){ public void windowClosing(WindowEvent e){ System.exit(1) ; } }) ; } } public class JComboBoxDemo01{ public static void main(String args[]){ new MyComboBox() ; } } 菜单组件JMenu、JMenuBar、JMenuItem若在Java中实现菜单，则可以使用JMenu组件，当然，如果要使用JMenu则首先要了解JMenuBar组件，JMenuBar组 件的功能是用来摆放JMenu组件，当建立完许多的JMenu组件之后，需要通过JMenuBar组件来将JMenu组件加入到窗口中 import java.awt.event.WindowAdapter ; import java.awt.event.WindowEvent ; import java.awt.event.ActionListener ; import java.awt.event.ActionEvent ; import java.awt.Container ; import java.io.File ; import javax.swing.JFrame ; import javax.swing.ImageIcon ; import javax.swing.JTextArea ; import javax.swing.JScrollPane ; import javax.swing.JMenu ; import javax.swing.KeyStroke ; import javax.swing.JMenuBar ; import javax.swing.JMenuItem ; public class JMenuDemo03{ public static void main(String args[]){ JFrame frame = new JFrame(&quot;Welcome To ECIT&quot;) ; final JTextArea text = new JTextArea() ; text.setEditable(true) ; // 可编辑 frame.getContentPane().add(new JScrollPane(text)) ; // 加入滚动条 JMenu menuFile = new JMenu(&quot;文件&quot;) ; menuFile.setIcon(new ImageIcon(&quot;d:&quot;+File.separator+&quot;icons&quot;+File.separator+&quot;file.gif&quot;)) ; JMenuBar menuBar = new JMenuBar() ; menuBar.add(menuFile) ; JMenuItem newItem = new JMenuItem(&quot;新建&quot;,new ImageIcon(&quot;d:&quot;+File.separator+&quot;icons&quot;+File.separator+&quot;new.gif&quot;)) ; JMenuItem openItem = new JMenuItem(&quot;打开&quot;,new ImageIcon(&quot;d:&quot;+File.separator+&quot;icons&quot;+File.separator+&quot;open.gif&quot;)) ; JMenuItem closeItem = new JMenuItem(&quot;关闭&quot;,new ImageIcon(&quot;d:&quot;+File.separator+&quot;icons&quot;+File.separator+&quot;close.gif&quot;)) ; JMenuItem exitItem = new JMenuItem(&quot;退出&quot;,new ImageIcon(&quot;d:&quot;+File.separator+&quot;icons&quot;+File.separator+&quot;exit.gif&quot;)) ; // 此时定义完了四个菜单的选项，定义完成之后，增加快捷键 newItem.setMnemonic('N') ; openItem.setMnemonic('O') ; closeItem.setMnemonic('C') ; exitItem.setMnemonic('E') ; newItem.setAccelerator(KeyStroke.getKeyStroke('N',java.awt.Event.CTRL_MASK)) ; openItem.setAccelerator(KeyStroke.getKeyStroke('O',java.awt.Event.CTRL_MASK)) ; closeItem.setAccelerator(KeyStroke.getKeyStroke('C',java.awt.Event.ALT_MASK)) ; exitItem.setAccelerator(KeyStroke.getKeyStroke('E',java.awt.Event.ALT_MASK)) ; newItem.addActionListener(new ActionListener(){ public void actionPerformed(ActionEvent e){ text.append(&quot;=== 选择了“新建”菜单项\\n&quot;) ; } }) ; openItem.addActionListener(new ActionListener(){ public void actionPerformed(ActionEvent e){ text.append(&quot;=== 选择了“打开”菜单项\\n&quot;) ; } }) ; closeItem.addActionListener(new ActionListener(){ public void actionPerformed(ActionEvent e){ text.append(&quot;=== 选择了“关闭”菜单项\\n&quot;) ; } }) ; exitItem.addActionListener(new ActionListener(){ public void actionPerformed(ActionEvent e){ text.append(&quot;=== 选择了“退出”菜单项\\n&quot;) ; } }) ; menuFile.add(newItem) ; menuFile.add(openItem) ; menuFile.add(closeItem) ; menuFile.add(exitItem) ; frame.setJMenuBar(menuBar) ; // 菜单是需要通过此方法增加的 frame.addWindowListener(new WindowAdapter(){ public void windowClosing(WindowEvent e){ System.exit(1) ; } }) ; frame.setVisible(true) ; frame.setSize(300,100) ; frame.setLocation(300,200) ; } } JFileChooser文件选择框 在使用记事本或者word的时候，可以通过文件选择框选择要打开或保存的文件，在Swing中可以使用JFileChooser组件实现此功能import java.io.File ; import java.io.FileInputStream ; import java.io.FileOutputStream ; import java.io.PrintStream ; import java.util.Scanner ; import java.awt.BorderLayout ; import java.awt.event.WindowAdapter ; import java.awt.event.WindowEvent ; import java.awt.event.ActionEvent ; import java.awt.event.ActionListener ; import javax.swing.JFrame ; import javax.swing.JTextArea ; import javax.swing.JLabel ; import javax.swing.JButton ; import javax.swing.JPanel ; import javax.swing.JFileChooser ; import javax.swing.JScrollPane ; class Note implements ActionListener{ private JTextArea area = new JTextArea(8,10) ; // 定义文本区 private JFrame frame = new JFrame(&quot;Welcome To MLDN&quot;) ; private JButton open = new JButton(&quot;打开文件&quot;) ; private JButton save = new JButton(&quot;保存文件&quot;) ; private JLabel label = new JLabel(&quot;现在没有打开的文件&quot;) ; private JPanel butPan = new JPanel() ; public Note(){ this.butPan.add(open) ; // 在面板中加入按钮 this.butPan.add(save) ; // 在面板中加入按钮 this.frame.setLayout(new BorderLayout(3,3)) ; this.frame.add(this.label,BorderLayout.NORTH) ; this.frame.add(this.butPan,BorderLayout.SOUTH) ; this.frame.add(new JScrollPane(this.area),BorderLayout.CENTER) ; this.frame.setSize(330,180) ; this.frame.setVisible(true) ; this.frame.addWindowListener( new WindowAdapter() { public void windowClosing(WindowEvent e){ System.exit(1) ; } } ) ; this.open.addActionListener(this) ; this.save.addActionListener(this) ; } public void actionPerformed(ActionEvent e){ File file = null ; // 接收文件 int result = 0 ; // 接收操作状态 JFileChooser fileChooser = new JFileChooser() ; // 文件选择框 if(e.getSource()==this.open){ // 表示执行的是打开操作 this.area.setText(&quot;&quot;) ; // 打开将文字区域的内容清空 fileChooser.setApproveButtonText(&quot;确定&quot;) ; fileChooser.setDialogTitle(&quot;打开文件&quot;) ; result = fileChooser.showOpenDialog(this.frame) ; if(result==JFileChooser.APPROVE_OPTION){ // 选择的是确定按钮 file = fileChooser.getSelectedFile() ; // 得到选择的文件 this.label.setText(&quot;打开的文件名称为：&quot; + file.getName()) ; }else if(result==JFileChooser.CANCEL_OPTION){ this.label.setText(&quot;没有选择任何文件&quot;) ; }else{ this.label.setText(&quot;操作出现错误&quot;) ; } if(file!=null){ try{ Scanner scan = new Scanner(new FileInputStream(file)) ; scan.useDelimiter(&quot;\\n&quot;) ; while(scan.hasNext()){ this.area.append(scan.next()) ; this.area.append(&quot;\\n&quot;) ; } scan.close() ; }catch(Exception e1){} } } if(e.getSource()==this.save){ // 判断是否是保存操作 result = fileChooser.showSaveDialog(this.frame) ; // 显示保存框 if(result==JFileChooser.APPROVE_OPTION){ // 选择的是确定按钮 file = fileChooser.getSelectedFile() ; // 得到选择的文件 this.label.setText(&quot;选择的存储文件名称为：&quot; + file.getName()) ; }else if(result==JFileChooser.CANCEL_OPTION){ this.label.setText(&quot;没有选择任何文件&quot;) ; }else{ this.label.setText(&quot;操作出现错误&quot;) ; } if(file!=null){ try{ PrintStream out = new PrintStream(new FileOutputStream(file)) ; out.print(this.area.getText()) ; out.close() ; }catch(Exception e1){} } } } } public class JFileChooserDemo{ public static void main(String args[]){ new Note() ; } } 表格JTable 表格组件提供了以行和列的形式显示数据的视图。在程序开发中是一个非常重要的组件，尤其在需要将-堆数据有条理的展现给用户的时候，表格设计更能显示出它的重要性。 在Swing中 可以通过JTable组件非常轻松的构造出所需要的表格，并且也提供了一些方法来管理这些表格的内容。 No. 方法 类型 描述 1 public JTable(Object[][] rowData,Object[] columnNames) 构造 创建一个JTable对象，设置显示数据和表格的标题 2 public JTable(Vector rowData,Vector columnNames) 构造 创建一个JTable对象，通过Vector设置显示数据和显示的标题 3 public JTable(TableModel dm) 构造 使用TableModel创建表格 4 public TableColumnModel getColumnModel() 普通 返回TableColumModel对象 import java.awt.event.WindowAdapter ; import java.awt.event.WindowEvent ; import javax.swing.JTable ; import javax.swing.JScrollPane ; import javax.swing.JFrame ; public class JTableDemo01{ public static void main(String args[]){ JFrame frame = new JFrame(&quot;Welcome To MLDN&quot;) ; String[] titles = {&quot;姓名&quot;,&quot;年龄&quot;,&quot;性别&quot;,&quot;数学成绩&quot;,&quot;英语成绩&quot;,&quot;总分&quot;,&quot;是否及格&quot;} ; Object [][] userInfo = { {&quot;李华&quot;,30,&quot;男&quot;,89,97,186,true} , {&quot;李康&quot;,23,&quot;女&quot;,90,93,183,false} } ; // 定义数据 JTable table = new JTable(userInfo,titles) ; // 建立表格 JScrollPane scr = new JScrollPane(table) ; frame.add(scr) ; frame.setSize(370,90) ; frame.setVisible(true) ; frame.addWindowListener(new WindowAdapter(){ public void windowClosing(WindowEvent e){ System.exit(1) ; } }); } }","link":"/2013/10/01/javase/JAVASE-GUI/"},{"title":"JAVA-GUI事件机制","text":"事件和监听器 每当一个按钮按下时，实际上按钮的状态就发生了改变，那么此时就会产生一个事件，而如果要想处理此事件，则就需要事件的监听者不断的监听事件的变化，并根据这些事件进行相应的处理。 在Swing编程中， 依然使用了最早AWT的事件处理方式，所有的事件类(基本上任意的一个组件都有对应的事件)都是EventObject 类的子类 事件处理 中一般都是提供事件的监听操作接口，而且为了开发方便，提供了一系列的Adapater 类,方便用户的使用。。","link":"/2013/10/02/javase/JAVASE-GUI%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/"},{"title":"JAVA中的IO流","text":"File类File类是唯一与文件本身操作有关的类，指的文件的创建、删除、重命名、取得文件大小和修改日期。一个File对象代表硬盘中实际存在的一个文件或者目录。 File类提供的构造方法public File(String pathname) ：通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例。public File(String parent, String child) ：从父路径名字符串和子路径名字符串创建新的 File实例。public File(File parent, String child) ：从父抽象路径名和子路径名字符串创建新的 File实例public File(URI uri):根据给定的URI创建文件 // 文件路径名 String path = &quot;D:\\\\demo.java&quot;; File file1 = new File(path); // 通过父路径和子路径字符串 String parent = &quot;D:\\\\java_pro&quot;; String child = &quot;ThreadDemo.java&quot;; File file3 = new File(parent, child); --------相当于D:\\\\java_pro\\\\ThreadDemo.java // 通过父级File对象和子路径字符串 File parentDir = new File(&quot;D:\\\\java_pro&quot;); String child = &quot;ThreadDemo.java&quot;; File file4 = new File(parentDir, child); --------相当于D:\\\\java_pro\\\\ThreadDemo.java //根据给定的URI创建文件 File file2 = new File(new URI(&quot;file:/Users/sxm/Desktop&quot;)); File类提供的常用方法 访问文件名相关的方法 String getName():返回此ile对象所表示的文件名或路径名（如果是路径，则返回最后一级子路径名）。 String getPath():返回此File对象所对应的路径名。 File getAbsoluteFile():返回此File对象的绝对路径。 String getAbsolutePath():返回此File对象所对应的绝对路径名。 String getParent():返回此File对象所对应目录（最后一级子目录）的父目录名。 boolean renameTo（File newName）:重命名此File对象所对应的文件或目录，如果重命名成功，则返回true；否则返回 false 文件检测相关的方法 boolean exists():判断File对象所对应的文件或目录是否存在。 boolean canWrite():判断File对象所对应的文件和目录是否可写。 boolean canRead():判断File对象所对应的文件和目录是否可读。 boolean isFile():判断File对象所对应的是否是文件，而不是目录。 boolean isDirectory():判断File对象所对应的是否是目录，而不是文件。 boolean isAbsolute():判断File对象所对应的文件或目录是否是绝对路径。该方法消除了不同平台的差异，可以直接判断File对象是否为绝对路径。在UNIX/Linux/BSD等系统上，如果路径名开头是一条斜线（/），则表明该Fil对象对应一个绝对路径；在 Windows等系统上，如果路径开头是盘符，则说明它是一个绝对路径。 获取常规文件信息 long lastModified():返回文件的最后修改时间。 long length():返回文件内容的长度。 文件操作相关的方法 boolean createNewFile():当此file对象所对应的文件不存在时，该方法将新建一个该File对象所指定的新文件，如果创建成功则返回true；否则返回 false boolean delete():删除File对象所对应的文件或路径。 static File createTempFile(String prefix,String suffix):在默认的临时文件目录中创建一个临时的空文件，使用给定前缀、系统生成的随机数和给定后缀作为文件名。这是一个静态方法，可以直接通过File类来调用。 prefix参数必须至少是3字节长。建议前缀使用一个短的、有意义的字符串，比如＂hjb＂或＂mail＂。 suffix参数可以为null，在这种情况下，将使用默认的后缀“.tmp”。 static File createTempFile(String prefix,String suffix,File directory):在 directory所指定的目录中创建一个临时的空文件，使用给定前缀、系统生成的随机数和给定后缀作为文件名。这是一个 静态方法，可以直接通过File类来调用。 void deleteOnExit():注册一个删除钩子，指定当Java虚拟机退出时，删除File对象所对应的文件和目录。 目录操作相关的方法 boolean mkdir():试图创建一个File对象所对应的目录，如果创建成功，则返回true；否则返回 false调用该方法时File对象必须对应一个路径，而不是一个文件。 String[] list():列出File对象的所有子文件名和路径名，返回 String数组。 File[］ listFiles():列出File对象的所有子文件和路径，返回File数组。 static File[] listRoots():列出系统所有的根路径。这是一个静态方法，可以直接通过File类 文件操作示例: import java.io.*; import java.net.*; public class FileTest{ public static void main(String[] args) throws Exception{ // 以当前路径来创建一个File对象 File file = new File(System.getProperty(&quot;user.dir&quot;)); // 直接获取文件名，输出一点 System.out.println(&quot;file.getName()--&gt;&quot;+file.getName()); // 获取相对路径的父路径可能出错，下面代码输出null System.out.println(&quot;file.getParent()--&gt;&quot;+file.getParent()); // 获取绝对路径 System.out.println(&quot;file.getAbsoluteFile()--&gt;&quot;+file.getAbsoluteFile()); // 获取上一级路径 System.out.println(&quot;file.getAbsoluteFile().getParent()--&gt;&quot;+file.getAbsoluteFile().getParent()); // 在当前路径下创建一个临时文件 File tmpFile = File.createTempFile(&quot;aaa&quot;, &quot;.txt&quot;, file); System.out.println(&quot;tmpFile:--&gt;&quot;+tmpFile.getAbsoluteFile()); // 指定当JVM退出时删除该文件 tmpFile.deleteOnExit(); // 以系统当前时间作为新文件名来创建新文件 File newFile = new File(System.currentTimeMillis() + &quot;&quot;); System.out.println(&quot;newFile对象是否存在：&quot; + newFile.exists()); // 以指定newFile对象来创建一个文件 newFile.createNewFile(); // 以newFile对象来创建一个目录，因为newFile已经存在， // 所以下面方法返回false，即无法创建该目录 newFile.mkdir(); // 使用list()方法来列出当前路径下的所有文件和路径 String[] fileList = file.list(); System.out.println(&quot;====当前路径下所有文件和路径如下====&quot;); for (String fileName : fileList) { System.out.println(fileName); } // listRoots()静态方法列出所有的磁盘根路径。 File[] roots = File.listRoots(); System.out.println(&quot;====系统所有根路径如下====&quot;); for (File root : roots) { System.out.println(root); } } } 文件过滤选择示例: import java.io.*; import java.net.*; public class FileTest{ public static void main(String[] args) throws Exception{ File file = new File(&quot;.&quot;); String[] nameList = file.list(new MyFilenameFilter()); for(String name : nameList) { System.out.println(name); } } } // 实现自己的FilenameFilter实现类 class MyFilenameFilter implements FilenameFilter { public boolean accept(File dir, String name) { // 如果文件名以.java结尾，或者文件对应一个路径，返回true return name.endsWith(&quot;.java&quot;) || new File(name).isDirectory(); } } 使用Java8 lamda改写 import java.io.*; import java.net.*; public class FileTest{ public static void main(String[] args) throws Exception{ File file = new File(&quot;.&quot;); String[] nameList = file.list( (dir,name)-&gt; name.endsWith(&quot;.java&quot;)|| new File(name).isDirectory()); for(String name : nameList) { System.out.println(name); } } } 遍历文件夹下所有文件```javaimport java.io.*;public class FileTest{ public static void main(String[] args) throws Exception{ String dirPath = System.getProperty(“user.dir”); recursionDirectory(new File(dirPath)); } public static void recursionDirectory(File file){ System.out.println(“开始遍历文件树:” + file.getAbsolutePath()); if (!file.isDirectory()) { return; }else{ File[] files = file.listFiles(); for (File fileTemp : files) { if (!fileTemp.isDirectory()) { System.out.println(“遍历–&gt;:” + fileTemp.getAbsolutePath()); }else{ recursionDirectory(fileTemp); } } } } } ## IO流 *Java的IO流是实现输入/输出的基础，它可以方便地实现数据的输入/输出操作，在Java中把不同的输入/输出源(键盘，文件，网络连接等)抽象表述为”流“(stream)，通过流的方式允许Java程序使用相同的方式来访问不同的输入/输出源。* ### 流的分类 #### 根据流向分为输入流和输出流 &lt;font color=&quot;green&quot;&gt;输入流：&lt;/font&gt;只能从中读取数据，而不能向其写入数据。 &lt;font color=&quot;green&quot;&gt;输出流：&lt;/font&gt;只能向其写入数据，而不能从中读取数据。 #### 根据字节类型分为字节流和字符流 **&lt;font color=&quot;green&quot;&gt;字节流：&lt;/font&gt;**以字节为单位，读写数据的流。 **&lt;font color=&quot;green&quot;&gt;字符流：&lt;/font&gt;**以字符为单位，读写数据的流 | 分类 | 输入流 | 输出流 | | :----: | :-------------------: | :--------------------: | | 字节流 | 字节输入流InputStream | 字节输出流OutputStream | | 字符流 | 字符输入流Reader | 字符输出流Writer | ### OutputStream类的常用方法 |方法|描述| |:-----:|:-------:| |void close()|关闭输出流| |void flush()|刷新缓冲区| |void write(byte[] b)|将一个byte数组写入数据流| |void write(byte[] b, int off, int len)|将一个指定范围的byte数组写入数据流| |abstract void write(int b)|将一个字节数据写入数据流| ### InputStream类的常用方法 |方法|描述| |:-----:|:-------:| |int available()|可以取得输入文件的大小| |void close()|关闭输入流| |void mark(int readlimit)|在记录指针当前位置记录一个标记mark| |boolean markSupported()|判断此输入流是否支持mark()操作| |void reset()|将此流的记录指针重新定位到上一次记录标记的位置| |abstract int read()|从输入流读取单个字节| |int read(byte[] b)|从输入流最多读取b.length个字节，并存储在b数组中，返回实际读取的字节数| |int read(byte[] b, int off, int len)|从输入流最多读取len个字节数据,并存储在b数组，从数组off位置开始放入，返回实际读取的字节数| |long skip(long n)|记录指针向前移动n个字节| ### Writer类的常用方法 |方法|描述| |:-----:|:-------:| |void write(char[] cbuf)|将字符数组输出| |abstract void write(char[] cbuf, int off, int len)|将字符数组从off位置开始,长度为len的字符输出流中| |void write(int c)|将指定字符输出流中| |void write(String str)|将str字符串里包含的字符输出到指定输出流中| |void write(String str, int off, int len)|将str字符串里从off位置开始，长度为len的字符输出到指定输出流中| ### Reader类常用方法 |方法|描述| |:-----:|:-------:| |int read()|读取单个字符| |int read(char[] cbuf)|将内容读到字符数组之中，返回读入的长度| ### 输入输出流的体系 ![](/images/javase/输入输出流体系.png) ### 字节-字符转换流 *输入/输出流体系中还提供了两个转换流，这两个转换流用于实现将字节流转换成字符流，其中InputStreamReader将字节输入流转换成字符输入流，OutputStreamWriter将字节输出流转换成字符输出流* ```java import java.io.* ; public class OutputStreamWriterDemo01{ public static void main(String args[]) throws Exception { File f = new File(&quot;d:&quot; + File.separator + &quot;test.txt&quot;) ; Writer out = null ; // 字符输出流 out = new OutputStreamWriter(new FileOutputStream(f)) ; // 字节流变为字符流 out.write(&quot;hello world!!&quot;) ; // 使用字符流输出 out.close() ; } } import java.io.* ; public class InputStreamReaderDemo01{ public static void main(String args[]) throws Exception{ File f = new File(&quot;d:&quot; + File.separator + &quot;test.txt&quot;) ; Reader reader = null ; reader = new InputStreamReader(new FileInputStream(f)) ; // 将字节流变为字符流 char c[] = new char[1024] ; int len = reader.read(c) ; reader.close() ; System.out.println(new String(c,0,len)) ; } } 内存操作流import java.io.* ; public class ByteArrayDemo01{ public static void main(String args[]){ String str = &quot;HELLOWORLD&quot; ; // 定义一个字符串，全部由大写字母组成 ByteArrayInputStream bis = null ; // 内存输入流 ByteArrayOutputStream bos = null ; // 内存输出流 bis = new ByteArrayInputStream(str.getBytes()) ; // 向内存中输出内容 bos = new ByteArrayOutputStream() ; // 准备从内存ByteArrayInputStream中读取内容 int temp = 0 ; while((temp=bis.read())!=-1){ char c = (char) temp ; // 读取的数字变为字符 bos.write(Character.toLowerCase(c)) ; // 将字符变为小写 } // 所有的数据就全部都在ByteArrayOutputStream中 String newStr = bos.toString() ; // 取出内容 try{ bis.close() ; bos.close() ; }catch(IOException e){ e.printStackTrace() ; } System.out.println(newStr) ; } } 线程通讯流-管道流管道流的主要作用是可以进行两个线程间的通讯，分为管道输出流(PipedOutputStream)、管道输入流(PipedInputStream),如果要想进行管道输出，则必须把输出流连接在输入流之上，在PipedOutputStream类有如下方法用于连接管道：public void connect(PipedInputStream snk) throws IOException![管道流连接])(/images/javase/管道流连接.png) import java.io.* ; class Send implements Runnable{ // 线程类 private PipedOutputStream pos = null ; // 管道输出流 public Send(){ this.pos = new PipedOutputStream() ; // 实例化输出流 } public void run(){ String str = &quot;Hello World!!!&quot; ; // 要输出的内容 try{ this.pos.write(str.getBytes()) ; }catch(IOException e){ e.printStackTrace() ; } try{ this.pos.close() ; }catch(IOException e){ e.printStackTrace() ; } } public PipedOutputStream getPos(){ // 得到此线程的管道输出流 return this.pos ; } }; class Receive implements Runnable{ private PipedInputStream pis = null ; // 管道输入流 public Receive(){ this.pis = new PipedInputStream() ; // 实例化输入流 } public void run(){ byte b[] = new byte[1024] ; // 接收内容 int len = 0 ; try{ len = this.pis.read(b) ; // 读取内容 }catch(IOException e){ e.printStackTrace() ; } try{ this.pis.close() ; // 关闭 }catch(IOException e){ e.printStackTrace() ; } System.out.println(&quot;接收的内容为：&quot; + new String(b,0,len)) ; } public PipedInputStream getPis(){ return this.pis ; } }; public class PipedDemo{ public static void main(String args[]){ Send s = new Send() ; Receive r = new Receive() ; try{ s.getPos().connect(r.getPis()) ; // 连接管道 }catch(IOException e){ e.printStackTrace() ; } new Thread(s).start() ; // 启动线程 new Thread(r).start() ; // 启动线程 } } 打印流在整个IO包中，打印流是输出信息最方便的类，主要包含字节打印流(PrintStream)和字符打印流(PrintWriter)。打印流提供了非常方便的打印功能，可以打印任何的数据类型，例如：小数、整数、字符串等。 打印流特点A:只操作目的地,不操作数据源B:可以操作任意类型的数据C:如果启用了自动刷新，在调用println()方法的时候，能够换行并刷新D:可以直接操作文件如果该流的构造方法能够同时接收File和String类型的参数，一般都是可以直接操作文件的！ import java.io.* ; public class PrintDemo01{ public static void main(String arg[]) throws Exception{ PrintStream ps = null ; // 声明打印流对象 // 如果现在是使用FileOuputStream实例化，意味着所有的输出是向文件之中 ps = new PrintStream(new FileOutputStream(new File(&quot;d:&quot; + File.separator + &quot;test.txt&quot;))) ; ps.print(&quot;hello &quot;) ; ps.println(&quot;world!!!&quot;) ; ps.print(&quot;1 + 1 = &quot; + 2) ; ps.close() ; } } import java.io.* ; public class PrintDemo02{ public static void main(String arg[]) throws Exception{ PrintStream ps = null ; // 声明打印流对象 // 如果现在是使用FileOuputStream实例化，意味着所有的输出是向文件之中 ps = new PrintStream(new FileOutputStream(new File(&quot;d:&quot; + File.separator + &quot;test.txt&quot;))) ; String name = &quot;李兴华&quot; ; // 定义字符串 int age = 30 ; // 定义整数 float score = 990.356f ; // 定义小数 char sex = 'M' ; // 定义字符 ps.printf(&quot;姓名：%s；年龄：%d；成绩：%f；性别：%c&quot;,name,age,score,sex) ; ps.close() ; } } 缓冲流Buffer：表示缓冲区的。之前的StringBuffer，缓冲区中的内容可以更改，可以提高效率。如果想接收任意长度的数据，而且避免乱码的产生，就可以使用BufferedReader。 import java.io.* ; public class BufferedReaderDemo01{ public static void main(String args[]){ BufferedReader buf = null ; // 声明对象 buf = new BufferedReader(new InputStreamReader(System.in)) ; // 将字节流变为字符流 String str = null ; // 接收输入内容 System.out.print(&quot;请输入内容：&quot;) ; try{ str = buf.readLine() ; // 读取一行数据 }catch(IOException e){ e.printStackTrace() ; // 输出信息 } System.out.println(&quot;输入的内容为：&quot; + str) ; } } 数据流在io包中，提供了两个与平台无关的数据操作流：数据输出流（DataOutputStream）数据输入流 （DataInputStream）通常数据输出流会按照一定的格式将数据输出，再通过数据输入流按照一定的格式将数据读入。 import java.io.DataOutputStream ; import java.io.File ; import java.io.FileOutputStream ; public class DataOutputStreamDemo{ public static void main(String args[]) throws Exception{ // 所有异常抛出 DataOutputStream dos = null ; // 声明数据输出流对象 File f = new File(&quot;d:&quot; + File.separator + &quot;order.txt&quot;) ; // 文件的保存路径 dos = new DataOutputStream(new FileOutputStream(f)) ; // 实例化数据输出流对象 String names[] = {&quot;衬衣&quot;,&quot;手套&quot;,&quot;围巾&quot;} ; // 商品名称 float prices[] = {98.3f,30.3f,50.5f} ; // 商品价格 int nums[] = {3,2,1} ; // 商品数量 for(int i=0;i&lt;names.length;i++){ // 循环输出 dos.writeChars(names[i]) ; // 写入字符串 dos.writeChar('\\t') ; // 写入分隔符 dos.writeFloat(prices[i]) ; // 写入价格 dos.writeChar('\\t') ; // 写入分隔符 dos.writeInt(nums[i]) ; // 写入数量 dos.writeChar('\\n') ; // 换行 } dos.close() ; // 关闭输出流 } } import java.io.DataInputStream ; import java.io.File ; import java.io.FileInputStream ; public class DataInputStreamDemo{ public static void main(String args[]) throws Exception{ // 所有异常抛出 DataInputStream dis = null ; // 声明数据输入流对象 File f = new File(&quot;d:&quot; + File.separator + &quot;order.txt&quot;) ; // 文件的保存路径 dis = new DataInputStream(new FileInputStream(f)) ; // 实例化数据输入流对象 String name = null ; // 接收名称 float price = 0.0f ; // 接收价格 int num = 0 ; // 接收数量 char temp[] = null ; // 接收商品名称 int len = 0 ; // 保存读取数据的个数 char c = 0 ; // '\\u0000' try{ while(true){ temp = new char[200] ; // 开辟空间 len = 0 ; while((c=dis.readChar())!='\\t'){ // 接收内容 temp[len] = c ; len ++ ; // 读取长度加1 } name = new String(temp,0,len) ; // 将字符数组变为String price = dis.readFloat() ; // 读取价格 dis.readChar() ; // 读取\\t num = dis.readInt() ; // 读取int dis.readChar() ; // 读取\\n System.out.printf(&quot;名称：%s；价格：%5.2f；数量：%d\\n&quot;,name,price,num) ; } }catch(Exception e){} dis.close() ; } } 合并流合并流：从概念上讲就是内容合并在一起了。一般合并流的主要功能就是将两个文件的内容合并成一个文件 import java.io.File ; import java.io.SequenceInputStream ; import java.io.FileInputStream ; import java.io.InputStream ; import java.io.FileOutputStream ; import java.io.OutputStream ; public class SequenceDemo{ public static void main(String args[]) throws Exception { // 所有异常抛出 InputStream is1 = null ; // 输入流1 InputStream is2 = null ; // 输入流1 OutputStream os = null ; // 输出流 SequenceInputStream sis = null ; // 合并流 is1 = new FileInputStream(&quot;d:&quot; + File.separator + &quot;a.txt&quot;) ; is2 = new FileInputStream(&quot;d:&quot; + File.separator + &quot;b.txt&quot;) ; os = new FileOutputStream(&quot;d:&quot; + File.separator + &quot;ab.txt&quot;) ; sis = new SequenceInputStream(is1,is2) ; // 实例化合并流 int temp = 0 ; // 接收内容 while((temp=sis.read())!=-1){ // 循环输出 os.write(temp) ; // 保存内容 } sis.close() ; // 关闭合并流 is1.close() ; // 关闭输入流1` is2.close() ; // 关闭输入流2 os.close() ; // 关闭输出流 } } 压缩流在日常的使用中经常会使用到像WinRAR或WinZIP这样的压缩文件，通过这些软件可以把一个很大的文件进行压缩以方便传输。在JAVA中 为了减少传输时的数据量也提供了专门的压缩流，可以将文件或文件夹压缩成ZIP、JAR、GZIP等文件的格式压缩流的实现 ZIP是一种较为常见的压缩形式，在Java中要想实现ZIP的压缩需要导入java.util.zip包，可以使用此包中的ZipFile、ZipOutputStream、ZipInputStream、ZipEntry几个类完成。 JAR及GZIP文件格式的压缩输入、输出流： 在JAVA IO中，不仅可以实现ZIP压缩格式的输入、输出，也可以实现JAR及GZIP文件格式的压缩： JAR压缩的支持类保存在java.util.jar包中，常用的类有如下几个： JAR压缩输出流：JarOutputStream JAR压缩输入流：JarInputStream JAR文件：JARFile JAR实体：JAREntry GZIP是用于UNIX系统的文件压缩，在Linux中经常会使用到*.gz的文件，就是GZIP格式，GZIP压缩的支持类保存在java.util.zip包中，常用的类有如下几个： GZIP压缩输出流：GZIPOutputStream GZIP压缩输入流：GZIPInputStream正常情况下在IO操作中，所有的类库都是在io包中。 ZipEntry： 在每一个压缩文件中都会存在多个子文件，那么这每一个的子文件在JAVA中就使用ZipEntry表示。ZipEntry类的常用方法： public ZipEntry(String name) 创建对象并指定要创建的ZipEntry名称。 public boolean isDirectory() 判断ZipEntry是否是目录。在实例化ZipEntry的时候，要设置名称，此名称实际上就是压缩文件中的每一个元素中的名称。 ZipFile是一个专门表示压缩文件的类，在JAVA中，每一个压缩文件都可以使用ZipFile表示，还可以使用ZipFile根据压缩后的文件名称找到每一个压缩文件中的ZipEntry并将其进行解压缩操作。1、public ZipFile(File file) throws ZipException,IOException 构造方法 根据File类实例化ZipFile对象。2、public ZipEntry getEntry(String name) 根据名称找到其对应的ZipEntry。3、public InputStream getInputStream(ZipEntry entry) throws IOException 根据ZipEntry取得InputStream对象。4、public String getName() 得到压缩文件的路径名称。ZipFile在实例化的时候必须接收File类的实例，此File类的实例是指向一个压缩的*.zip文件。首先需要为ZipFile实例化，实例化时需要接收File类的引用。 import java.io.File ; import java.io.FileInputStream ; import java.io.InputStream ; import java.util.zip.ZipEntry ; import java.util.zip.ZipOutputStream ; import java.util.zip.ZipFile ; import java.io.FileOutputStream ; public class ZipFileDemo01{ public static void main(String args[]) throws Exception{ // 所有异常抛出 File file = new File(&quot;d:&quot; + File.separator + &quot;bdn.zip&quot;) ; // 找到压缩文件 ZipFile zipFile = new ZipFile(file) ; // 实例化ZipFile对象 System.out.println(&quot;压缩文件的名称：&quot; + zipFile.getName()) ; // 得到压缩文件的名称 } } import java.io.File ; import java.io.FileInputStream ; import java.io.InputStream ; import java.io.OutputStream ; import java.util.zip.ZipEntry ; import java.util.zip.ZipOutputStream ; import java.util.zip.ZipFile ; import java.io.FileOutputStream ; public class ZipFileDemo02{ public static void main(String args[]) throws Exception{ // 所有异常抛出 File file = new File(&quot;d:&quot; + File.separator + &quot;bdn.zip&quot;) ; // 找到压缩文件 File outputFile = new File(&quot;d:&quot; + File.separator + &quot;bdn_unzip.txt&quot;) ; // 定义解压缩的文件名称 ZipFile zipFile = new ZipFile(file) ; // 实例化ZipFile对象 ZipEntry entry = zipFile.getEntry(&quot;bdn.txt&quot;) ; // 得到一个压缩实体 OutputStream out = new FileOutputStream(outputFile) ; // 实例化输出流 InputStream input = zipFile.getInputStream(entry) ; // 得到一个压缩实体的输入流 int temp = 0 ; while((temp=input.read())!=-1){ out.write(temp) ; } input.close() ; // 关闭输入流 out.close() ; // 关闭输出流 } }; ZipOutputStream：如果要想完成一个文件或文件夹的压缩，要使用ZipOutputStream类完成，ZipOutputStream是OutputStream的子类。public ZipOutputStream(OutputStream out) 创建新的ZIP输出流。public void putNextEntry(ZipEntry e) throws IOException 设置每一个ZipEntry对象。public void setComment(String comment) 设置ZIP文件的注释此类的功能就是完成ZIP格式输出的。 import java.io.File ; import java.io.FileInputStream ; import java.io.InputStream ; import java.util.zip.ZipEntry ; import java.util.zip.ZipInputStream ; import java.io.FileInputStream ; public class ZipInputStreamDemo01{ public static void main(String args[]) throws Exception{ // 所有异常抛出 File zipFile = new File(&quot;d:&quot; + File.separator + &quot;bdn.zip&quot;) ; // 定义压缩文件名称 ZipInputStream input = null ; // 定义压缩输入流 input = new ZipInputStream(new FileInputStream(zipFile)) ; // 实例化ZIpInputStream ZipEntry entry = input.getNextEntry() ; // 得到一个压缩实体 System.out.println(&quot;压缩实体名称：&quot; + entry.getName()) ; input.close() ; } } import java.io.File ; import java.io.OutputStream ; import java.io.InputStream ; import java.util.zip.ZipEntry ; import java.util.zip.ZipFile ; import java.util.zip.ZipInputStream ; import java.io.FileInputStream ; import java.io.FileOutputStream ; public class ZipInputStreamDemo02{ public static void main(String args[]) throws Exception{ // 所有异常抛出 File file = new File(&quot;d:&quot; + File.separator + &quot;bdndir.zip&quot;) ; // 定义压缩文件名称 File outFile = null ; // 输出文件的时候要有文件夹的操作 ZipFile zipFile = new ZipFile(file) ; // 实例化ZipFile对象 ZipInputStream zipInput = null ; // 定义压缩输入流 OutputStream out = null ; // 定义输出流，用于输出每一个实体内容 InputStream input = null ; // 定义输入流，读取每一个ZipEntry ZipEntry entry = null ; // 每一个压缩实体 zipInput = new ZipInputStream(new FileInputStream(file)) ; // 实例化ZIpInputStream while((entry = zipInput.getNextEntry())!=null){ // 得到一个压缩实体 System.out.println(&quot;解压缩&quot; + entry.getName() + &quot;文件。&quot;) ; outFile = new File(&quot;d:&quot; + File.separator + entry.getName()) ; // 定义输出的文件路径 if(!outFile.getParentFile().exists()){ // 如果输出文件夹不存在 outFile.getParentFile().mkdir() ; // 创建文件夹 } if(!outFile.exists()){ // 判断输出文件是否存在 outFile.createNewFile() ; // 创建文件 } input = zipFile.getInputStream(entry) ; // 得到每一个实体的输入流 out = new FileOutputStream(outFile) ; // 实例化文件输出流 int temp = 0 ; while((temp=input.read())!=-1){ out.write(temp) ; } input.close() ; // 关闭输入流 out.close() ; // 关闭输出流 } input.close() ; } } import java.io.File ; import java.io.FileInputStream ; import java.io.InputStream ; import java.util.zip.ZipEntry ; import java.util.zip.ZipOutputStream ; import java.io.FileOutputStream ; public class ZipOutputStreamDemo01{ public static void main(String args[]) throws Exception{ // 所有异常抛出 File file = new File(&quot;d:&quot; + File.separator + &quot;bdn.txt&quot;) ; // 定义要压缩的文件 File zipFile = new File(&quot;d:&quot; + File.separator + &quot;bdn.zip&quot;) ; // 定义压缩文件名称 InputStream input = new FileInputStream(file) ; // 定义文件的输入流 ZipOutputStream zipOut = null ; // 声明压缩流对象 zipOut = new ZipOutputStream(new FileOutputStream(zipFile)) ; zipOut.putNextEntry(new ZipEntry(file.getName())) ; // 设置ZipEntry对象 zipOut.setComment(&quot;www.baidu.cn&quot;) ; // 设置注释 int temp = 0 ; while((temp=input.read())!=-1){ // 读取内容 zipOut.write(temp) ; // 压缩输出 } input.close() ; // 关闭输入流 zipOut.close() ; // 关闭输出流 } } import java.io.File ; import java.io.FileInputStream ; import java.io.InputStream ; import java.util.zip.ZipEntry ; import java.util.zip.ZipOutputStream ; import java.io.FileOutputStream ; public class ZipOutputStreamDemo02{ public static void main(String args[]) throws Exception{ // 所有异常抛出 File file = new File(&quot;d:&quot; + File.separator + &quot;bd&quot;) ; // 定义要压缩的文件夹 File zipFile = new File(&quot;d:&quot; + File.separator + &quot;bddir.zip&quot;) ; // 定义压缩文件名称 InputStream input = null ; // 定义文件输入流 ZipOutputStream zipOut = null ; // 声明压缩流对象 zipOut = new ZipOutputStream(new FileOutputStream(zipFile)) ; zipOut.setComment(&quot;www.baidu.cn&quot;) ; // 设置注释 int temp = 0 ; if(file.isDirectory()){ // 判断是否是文件夹 File lists[] = file.listFiles() ; // 列出全部文件 for(int i=0;i&lt;lists.length;i++){ input = new FileInputStream(lists[i]) ; // 定义文件的输入流 zipOut.putNextEntry(new ZipEntry(file.getName() +File.separator+lists[i].getName())) ; // 设置ZipEntry对象 while((temp=input.read())!=-1){ // 读取内容 zipOut.write(temp) ; // 压缩输出 } input.close() ; // 关闭输入流 } } zipOut.close() ; // 关闭输出流 } } 回退流在JAVA IO中所有的数据都是采用顺序的读取方式，即对于一个输入流来讲都是采用从头到尾的顺序读取的，如果在输入流中某个不需要的内容被读取进来，则只能通过程序将这些不需要的内容处理掉，为了解决这样的处理问题，在JAVA中提供了一种回退输入流（PushbackInputStream、PushbackReader），可以把读取进来的某些数据重新回退到输入流的缓冲区之中。 import java.io.ByteArrayInputStream ; import java.io.PushbackInputStream ; public class PushInputStreamDemo{ public static void main(String args[]) throws Exception { // 所有异常抛出 String str = &quot;www.baidu.cn&quot; ; // 定义字符串 PushbackInputStream push = null ; // 定义回退流对象 ByteArrayInputStream bai = null ; // 定义内存输入流 bai = new ByteArrayInputStream(str.getBytes()) ; // 实例化内存输入流 push = new PushbackInputStream(bai) ; // 从内存中读取数据 System.out.print(&quot;读取之后的数据为：&quot;) ; int temp = 0 ; while((temp=push.read())!=-1){ // 读取内容 if(temp=='.'){ // 判断是否读取到了“.” push.unread(temp) ; // 放回到缓冲区之中 temp = push.read() ; // 再读一遍 System.out.print(&quot;（退回&quot;+(char)temp+&quot;）&quot;) ; }else{ System.out.print((char)temp) ; // 输出内容 } } } }; 字符编码编码：在计算机的世界里，任何的文字都是以指定的编码方式存在的，在JAVA程序的开发中最常见的是以下的几种编码：ISO8859-1、GBK/GB2312、unicode、UTFiso-8859-1编码属于单字节编码，最多只能表示0255的字符范围，主要在英文上应用。GBK/GB2312：中文的国标编码，专门用来表示汉字，是双字节编码。unicode：Java中就是使用此编码方式，也是最标准的一种编码，是使用16进制表示的编码。但此编码不兼容iso8859-1编码。UTF：由于unicode不支持iso8859-1编码，而且容易占用更多的空间，而且对于英文字母也需要使用两个字节编码，这样使用unicode不便于传输和存储，因此产生了utf编码，utf兼容iso8859-1编码，同时也可以用来表示所有的语言字符，不过utf编码是不定长编码，每一个字符的长度从16个字节不等，一般在中文网页中使用此编码，因为这样可以节省空间。 乱码的产生在程序中如果处理不好字符的编码，则就有可能出现乱码问题，如果现在本机的默认编码是GBK，但在程序中使用了iso-8859-1编码，则就会出现字符的乱码情况，就好比两个人交谈，一个人说的是中文，另外一个人说的是其他语言，如果语言不同，则肯定无法沟通。如果没有处理好编码的问题，则肯定在程序中出现乱码。 得到本机的编码显示：使用System类可以取得与系统有关的信息，那么直接使用此类就可以找到系统的默认编码，使用如下方法：public static Properties getProperty() public class CharSetDemo01{ public static void main(String args[]){ System.out.println(&quot;系统默认编码：&quot; + System.getProperty(&quot;file.encoding&quot;)) ; // 获取当前系统编码 } } 因为现在的本机环境，是中文环境，所以是使用GBK进行编码，很明显如果现在在程序中使用了ISO8859-1编码。如果要编码，则需要使用String类的支持。public byte[] getBytes(String charsetName) throws UnsupportedEncodingException可以指定使用的字符编码。 import java.io.OutputStream ; import java.io.FileOutputStream ; import java.io.File ; public class CharSetDemo02{ public static void main(String args[]) throws Exception { File f = new File(&quot;D:&quot; + File.separator + &quot;test.txt&quot;) ; // 实例化File类 OutputStream out = new FileOutputStream(f) ; // 实例化输出流 byte b[] = &quot;中国，你好！&quot;.getBytes(&quot;ISO8859-1&quot;) ; // 转码操作 out.write(b) ; // 保存 out.close() ; // 关闭 } } 对象序列化对象序列化，就是把一个对象变为二进制的数据流的一种方法，通过对象序列化可以方便的实现对象的传输或存储如果一个类的对象想被序列化，则对象所在的类必须实现java.io.Serializable接口。此接口的定义如下：public interface Serializable{ }一个类不能被无缘无故的被序列化。但是，在此接口中没有任何一个方法，此接口属于一个标示接口，表示具备了某种能力。例如：现在定义一个类，此类可以被序列化。 import java.io.Serializable ; public class Person implements Serializable{ private String name ; // 声明name属性，但是此属性不被序列化 private int age ; // 声明age属性 public Person(String name,int age){ // 通过构造设置内容 this.name = name ; this.age = age ; } public String toString(){ // 覆写toString()方法 return &quot;姓名：&quot; + this.name + &quot;；年龄：&quot; + this.age ; } } 对象的序列化和反序列化要想完成对象的输入或输出，还必须依靠对象输出流（ObjectOutputStream）和对象输入流（ObjectInputStream）,使用对象输出流输出序列化对象的步骤，有时也称为序列化，而使用对象输入流读入的过程，有时也称为反序列化在对象进行序列化或反序列化操作的时候，要考虑JDK版本的问题，如果序列化的JDK版本和反序列化的JDK版本不统一则就有可能造成异常。所以在序列化操作中引入了一个serialVersionUID的常量，可以通过此常量来验证版本的一致性，在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体（类）的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现版本不一致的异常。 import java.io.File ; import java.io.IOException ; import java.io.FileOutputStream ; import java.io.OutputStream ; import java.io.ObjectOutputStream ; import java.io.FileInputStream ; import java.io.InputStream ; import java.io.ObjectInputStream ; public class SerDemo03{ public static void main(String args[]) throws Exception{ ser() ; dser() ; } public static void ser() throws Exception { File f = new File(&quot;D:&quot; + File.separator + &quot;test.txt&quot;) ; // 定义保存路径 ObjectOutputStream oos = null ; // 声明对象输出流 OutputStream out = new FileOutputStream(f) ; // 文件输出流 oos = new ObjectOutputStream(out) ; oos.writeObject(new Person(&quot;张三&quot;,30)) ; // 保存对象 oos.close() ; // 关闭 } public static void dser() throws Exception { File f = new File(&quot;D:&quot; + File.separator + &quot;test.txt&quot;) ; // 定义保存路径 ObjectInputStream ois = null ; // 声明对象输入流 InputStream input = new FileInputStream(f) ; // 文件输入流 ois = new ObjectInputStream(input) ; // 实例化对象输入流 Object obj = ois.readObject() ; // 读取对象 ois.close() ; // 关闭 System.out.println(obj) ; } }; Externalizable接口被Serializable接口声明的类其对象的内容都将被序列化，如果现在用户希望可以自己指定序列化的内容，则可以让一个类实现Externalizable接口， import java.io.Externalizable; import java.io.IOException; import java.io.ObjectInput; import java.io.ObjectOutput; public class Person implements Externalizable{ private static final long serialVersionUID = 1L; private String name ; // 声明name属性， private int age ; // 声明age属性 public Person(String name,int age){ // 通过构造设置内容 this.name = name ; this.age = age ; } public String toString(){ // 覆写toString()方法 return &quot;姓名：&quot; + this.name + &quot;；年龄：&quot; + this.age ; } @Override public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException { // TODO Auto-generated method stub this.name = (String)in.readObject(); this.age = in.readInt(); } @Override public void writeExternal(ObjectOutput out) throws IOException { // TODO Auto-generated method stub out.writeObject(this.name); // 保存姓名属性 out.writeInt(this.age); } } transient关键字当使用Serializable接口实现序列化操作时，如果一个对象中的某个属性不希望被序列化的话，则可以使用transient关键字进行声明。 import java.io.Serializable ; public class Person implements Serializable{ private static final long serialVersionUID = 1L; private transient String name ; // 声明name属性，但是此属性不被序列化 private int age ; // 声明age属性 public Person(String name,int age){ // 通过构造设置内容 this.name = name ; this.age = age ; } public String toString(){ // 覆写toString()方法 return &quot;姓名：&quot; + this.name + &quot;；年龄：&quot; + this.age ; } } transient+Serializable接口完全可以取代Externalizable接口的功能。","link":"/2013/09/12/javase/JAVASE-IO%E6%B5%81-12/"},{"title":"JDBC 研磨","text":"JDBC基础 是一种用于执行SQL语句的Java API 它由一组用Java语言编写的类和接口组成 JDBC提供了一种操作数据的标准 JDBC的目标是使Java程序员使用JDBC可以连接任何提供了JDBC驱动程序的数据库系统 JDBC操控数据库步骤 1.注册驱动(只做一次) 方法一注册驱动(不推荐)DriverManager.registerDriver(new Driver()) // 不推荐理由有二： // 一、查看Driver的源代码可以看到，如果采用此种方式，会导致驱动程序注册两次，也就是在内存中会有两个Driver对象。 // 二、程序依赖mysql的api，脱离mysql的jar包，程序将无法编译，将来程序切换底层数据库将会非常麻烦。 方法二注册驱动(推荐)Class.forName(“com.mysql.jdbc.Driver”); //采用此种方式不会导致驱动对象在内存中重复出现，并且采用此种方式，程序仅仅只需要一个字符串，不需要依赖具体的驱动，使程序的灵活性更高。 2.建立连接(Connection) Connection对象的常用方法： createStatement()：创建向数据库发送sql的statement对象 prepareStatement(sql) ：创建向数据库发送预编译sql的PrepareSatement对象 prepareCall(sql)：创建执行存储过程的callableStatement对象。 setAutoCommit(boolean autoCommit)：设置事务是否自动提交。 commit() ：在此连接上提交事务。 rollback() ：在此连接上回滚事务。 3.创建执行SQL的语句(Statement) Statement对象常用方法： executeQuery(String sql) ：用于向数据发送查询语句。 executeUpdate(String sql)：用于向数据库发送insert、update或delete语句 execute(String sql)：用于向数据库发送任意sql语句 addBatch(String sql) ：把多条sql语句放到一个批处理中。 executeBatch()：向数据库发送一批sql语句执行。 4.执行语句 5.处理执行结果(ResultSet) Resultset封装执行结果时，采用的类似于表格的方式。ResultSet对象维护了一个指向表格数据行的游标cursor，初始的时候，游标在第一行之前，调用ResultSet.next() 方法，可以使游标指向具体的数据行，进而调用方法获取该行的数据。 ResultSet既然用于封装执行结果的，所以该对象提供的大部分方法都是用于获取数据的get方法： 获取任意类型的数据getObject(int index)getObject(string columnName) 获取指定类型的数据，例如：getString(int index)getString(String columnName) ResultSet新特性 滚动结果集的一些方法 Statement stmt = conn.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE,ResultSet.CONCUR_UPDATABLE);next()：移动到下一行previous()：移动到前一行absolute(int row)：移动到指定行beforeFirst()：移动resultSet的最前面afterLast() ：移动到resultSet的最后面updateRow() ：更新行数据 6.释放资源 Jdbc程序运行完后，切记要释放程序在运行过程中，创建的那些与数据库进行交互的对象，这些对象通常是ResultSet, Statement和Connection对象。 特别是Connection对象，它是非常稀有的资源，用完后必须马上释放，如果Connection不能及时、正确的关闭，极易导致系统宕机。Connection的使用原则是尽量晚创建，尽量早的释放。 为确保资源释放代码能运行，资源释放代码也一定要放在finally语句中 ConnectionFactory了解 利用工厂模式（简单工厂）提升代码的重用性 封装注册数据库的驱动和获得数据库的连接 利用配置文件 减少硬编码 便于维护package com.ecit.utils; import java.io.IOException; import java.io.InputStream; import java.sql.*; import java.util.Properties; public final class JdbcUtils { private static String URL ; private static String USERNAME ; private static String PASSWORD ; private static String DRIVER ; private JdbcUtils() { } static { //db.properties放在项目的resources目录下 try(InputStream is = JdbcUtils.class.getClassLoader().getResourceAsStream(&quot;db.properties&quot;)){ Properties props = new Properties(); props.load(is); DRIVER=props.getProperty(&quot;jdbc.driver&quot;); URL=props.getProperty(&quot;jdbc.url&quot;); USERNAME=props.getProperty(&quot;jdbc.username&quot;); PASSWORD=props.getProperty(&quot;jdbc.password&quot;); Class.forName(DRIVER); } catch (ClassNotFoundException | IOException e) { throw new ExceptionInInitializerError(e); } } public static Connection getConnection(){ try { return DriverManager.getConnection(URL, USERNAME, PASSWORD); } catch (SQLException e) { throw new RuntimeException(&quot;获取数据库连接失败&quot;,e); } } public static void free(ResultSet rs, Statement st, Connection conn) { try { if (rs != null) rs.close(); } catch (SQLException e) { e.printStackTrace(); } finally { try { if (st != null) st.close(); } catch (SQLException e) { e.printStackTrace(); } finally { if (conn != null) try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } } } } Statement的深入 创建Statement的三种方式 Statement stmt = Connection.createStatement(…) 执行不带参数的简单SQL语句 Connection conn = null; Statement st = null; ResultSet rs = null; try { // 2.建立连接 conn = JdbcUtils.getConnection(); // 3.创建语句 st = conn.createStatement(); // 4.执行语句 rs = st.executeQuery(&quot;select id,username,address,sex,birthday from user&quot;); // 5.处理结果 while (rs.next()) { Date birthday = new Date(rs.getDate(&quot;birthday&quot;).getTime()); int id = rs.getInt(&quot;id&quot;); String username = rs.getString(&quot;username&quot;); String address = rs.getString(&quot;address&quot;); String sex = rs.getString(&quot;sex&quot;); System.out.println(&quot;id\\t&quot; + id +&quot;\\t username\\t&quot; + username + &quot;\\t address\\t&quot; + address + &quot;\\t sex\\t&quot; + sex); } } finally { JdbcUtils.free(rs, st, conn); } PreparedStatement pstmt = Connection.prepareStatement(…) 执行带参数或不带参数的SQL语句 Connection conn = null; PreparedStatement st = null; ResultSet rs = null; try { // 2.建立连接 conn = JdbcUtils.getConnection(); // 3.创建语句 st = conn.prepareStatement(&quot;select id,username,address,sex,birthday from user where username = ?&quot;); st.setString(1,&quot;杨过&quot;); // 4.执行语句 rs = st.executeQuery(); // 5.处理结果 while (rs.next()) { Date birthday = new Date(rs.getDate(&quot;birthday&quot;).getTime()); int id = rs.getInt(&quot;id&quot;); String username = rs.getString(&quot;username&quot;); String address = rs.getString(&quot;address&quot;); String sex = rs.getString(&quot;sex&quot;); System.out.println(&quot;id\\t&quot; + id +&quot;\\t username\\t&quot; + username + &quot;\\t address\\t&quot; + address + &quot;\\t sex\\t&quot; + sex); } } finally { JdbcUtils.free(rs, st, conn); } CallableStatement cstmt = Connection.prepareCall(…) 执行对数据库已存储的 PL/SQL 程序的调用，现在的实际开发中使用过程(存储过程)的地方已经越来越少了，所以对于存储过程的使用，只需要了解下即可，不用深入研究 CallableStatement主要是调用数据库中的存储过程，CallableStatement也是Statement接口的子接口。在使用CallableStatement的时候可以接收过程的返回值。 在JDBC中，如果要想设置过程的返回值类型，可以使用Types完成，在Typs中定义了很多的常量，如果现在返回值类型为int，则使用:Types.INTEGER。 No 方法 类型 描述 1 int getInt( int parameterIndex) throws SQLException 普通 根据编号取出过程的返回值 2 float getFloat( int parameterIndex) throws SQLException 普通 根据编号取出过程的返回值 3 void setInt( String paramneterName ,int x) throws SQLException 普通 设置指定编号的内容 4 void setFloat(String parameterName,float x) throws SQLException 普通 设置指定编号的内容 5 void registerOutParameter(int parameterIndex,int sqlType) throws SQLException 普通 设置返回值的类型，需要使用Types类 DROP PROCEDURE myproc // -- 删除过程 CREATE PROCEDURE myproc(IN p1 int,INOUT p2 int,OUT p3 int) BEGIN SELECT p1,p2,p3 ; -- 输出p1、p2、p3的内容 SET p1=10 ; SET p2=20 ; SET p3=30 ; END DELIMITER ; SET @x1=70 ; -- 定义变量x1，内容为70 SET @x2=80 ; -- 定义变量x2，内容为80 CALL myproc(@x1,@x2,@x3) ; SELECT @x1,@x2,@x3 ; -- IN类型:默认的设置，什么都不声明就表示IN类型，只是将内容传递进来。 -- INOUT类型:表示把值传递到过程中，并且可以保留过程对此值的修改。引用 -- OUT:可以不用传递内容，过程中对此值的操作可以返回。 调用存储过程示例 Connection conn = null; CallableStatement st = null; ResultSet rs = null ; try { // 2.建立连接 conn = JdbcUtils.getConnection(); // 3.创建语句 String sql = &quot;{CALL myproc(?,?,?)}&quot; ; // 调用过程 st = conn.prepareCall(sql) ; st.setInt(1,11); st.setInt(1,70) ; // 设置第一个参数是70 st.setInt(2,80) ; // 设置第二个参数是80 st.registerOutParameter(2,Types.INTEGER) ; st.registerOutParameter(3,Types.INTEGER) ; // 4.执行语句 st.execute() ; // 执行过程 // 5.处理结果 System.out.println(&quot;INOUT的返回值：&quot; + st.getInt(2)) ; System.out.println(&quot;OUT的返回值：&quot; + st.getInt(3)) ; } finally { JdbcUtils.free(rs, st, conn); } 执行SQL语句executeQuery():执行查询语句，返回查询结果集ResultSetexecuteUpdate():执行DML 和 DDL语句，返回int 类型 Connection conn = null; PreparedStatement st = null; try { // 2.建立连接 conn = JdbcUtils.getConnection(); // 3.创建语句 st = conn.prepareStatement(&quot;insert into user(username, sex,address) values (?, ?, ?)&quot;); st.setString(1,&quot;虚竹&quot;); st.setString(2,&quot;男&quot;); st.setString(3,&quot;灵鹫宫&quot;); // 4.执行语句 int rs = st.executeUpdate(); // 5.处理结果 System.out.println(&quot;插入一条记录:&quot; + rs); } finally { JdbcUtils.free(null, st, conn); } execute():执行任何SQL语句，返回boolean类型，指示是否有ResultSet返回 三种Statement的比较 JDBC处理大对象数据 大对象处理主要指的是CLOB和BLOB两种类型的字段，在CLOB可以存储海量文字，例如，存储一部《三国演义》或者是《红楼梦》等。在BLOB中可以存储二进制数据，如图片、电影等等，如果在程序中要想处理这样的大对象操作，则必须使用PreparedStatement完成，所有的内容.要通过IO流的方式从大文本字段中保存和读取。 写入方法 NO 方法 类型 描述 1. void setAsciiStream(int parameterIndex,InputStream x,int length) throws SQLException 普通 将指定的输入流写入数据库的文本字段 2. void setBinaryStream(int parameterIndex,InputStream x,int length) throws SQLException 普通 将二进制的输入流数据写入到二进制字段之中 读取方法 No. 方法 类型 描述 1 InputStream getAsciiStream( int columnIndex) throws SQLException 普通 根据列的编号返回大对象的文本输入流 2 InputStream getAsciiStream(String columnName )throws SQLException 普通 根据列的名称返回大对象的文本输入流 3 Clob getClob(int i) throws SQLException 普通 根据列的编号返回Clob数据 4 Clob getClob(String colName) throws SQLException 普通 根据列名称返回Clob数据 5 InputStream getBinaryStream( int columnIndex)throws SQLException 普通 根据列的编号，返回二进制数据. 6 InputStream getBinaryStream(String columnName)throws SQLException 普通 根据列的名称，返回二进制数据 7 Blob getBlob(int i) throws SQLException 普通 根据列的编号，返回Blob数据 8 Blob getBlob(String colName) throws SQLException 普通 根据列名称，返回Blob数据 处理CLOB数据 CLOB表示大文本数据，在MySQL中提供了LONGTEXT表示大文本数据，此字段的最大保存数据量为4G.CREATE TABLE `airticle` ( `id` int(11) NOT NULL AUTO_INCREMENT, `title` varchar(32) DEFAULT NULL, `content` longtext, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; 写入一本小说 Connection conn = null; PreparedStatement st = null; try { // 2.建立连接 conn = JdbcUtils.getConnection(); st = conn.prepareStatement(&quot;SET NAMES utf8mb4;&quot;); st.executeUpdate(); // 3.创建语句 st = conn.prepareStatement(&quot;INSERT INTO airticle(title,content) VALUES (?,?) &quot;); st.setString(1,&quot;契科夫短篇小说精选&quot;); File f = new File(&quot;/Users/sxm/qkf.txt&quot;) ; InputStream input = new FileInputStream(f) ; st.setAsciiStream(2,input,(int)f.length()); // 4.执行语句 int rs = st.executeUpdate(); // 5.处理结果 System.out.println(&quot;插入一条记录:&quot; + rs); } finally { JdbcUtils.free(null, st, conn); } 读取一本小说 第一种用流 Connection conn = null; PreparedStatement st = null; ResultSet rs = null; try { // 2.建立连接 conn = JdbcUtils.getConnection(); st = conn.prepareStatement(&quot;SET NAMES utf8mb4;&quot;); //处理特殊表情符号 st.executeUpdate(); // 3.创建语句 String sql = &quot;SELECT title,content FROM airticle WHERE id=? &quot; ; st = conn.prepareStatement(sql); st.setInt(1,9); // 4.执行语句 rs = st.executeQuery(); // 5.处理结果 if(rs.next()){ String title = rs.getString(1) ; StringBuffer content = new StringBuffer() ; System.out.println(&quot;标题：&quot; + title) ; InputStream input = rs.getAsciiStream(2) ; Scanner scan = new Scanner(input) ; // 使用Scanner类读取内容 scan.useDelimiter(&quot;\\r\\n&quot;) ; // 将文件换行作为分割符 while(scan.hasNext()){ content.append(scan.next()).append(&quot;\\n&quot;) ; } System.out.println(&quot;内容：&quot; + content) ; input.close() ; } } finally { JdbcUtils.free(rs, st, conn); } 读取一本小说 第二种用CLOB Connection conn = null; PreparedStatement st = null; ResultSet rs = null; try { // 2.建立连接 conn = JdbcUtils.getConnection(); st = conn.prepareStatement(&quot;SET NAMES utf8mb4;&quot;); //处理特殊表情符号 st.executeUpdate(); // 3.创建语句 String sql = &quot;SELECT title,content FROM airticle WHERE id=? &quot; ; st = conn.prepareStatement(sql); st.setInt(1,9); // 4.执行语句 rs = st.executeQuery(); // 5.处理结果 if(rs.next()){ String title = rs.getString(1) ; System.out.println(&quot;标题：&quot; + title) ; Clob c = rs.getClob(2) ; String content = c.getSubString(1,(int)c.length()) ; System.out.println(&quot;内容：&quot; + content ) ; c.truncate(100) ; // 只能读100个内容 System.out.println(&quot;部分读取内容：&quot; + c.getSubString(1,(int)c.length())) ; } } finally { JdbcUtils.free(rs, st, conn); } 处理BLOB数据 BLOB的操作与CLOB是很相似的，只是BLOB专门用于存放二进制数据，如图片、电影等，下面就通过BLOB进行图片的保存与读取。在MySQL中使用LONGBLOB声明，最高可以保存4G大小的内容。例如，有如下的数据库创建脚本:CREATE TABLE `airticle` ( `id` int(11) NOT NULL AUTO_INCREMENT, `title` varchar(32) DEFAULT NULL, `content` longtext, `img` longblob, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8mb4; 写入一张图片Connection conn = null; PreparedStatement st = null; try { // 2.建立连接 conn = JdbcUtils.getConnection(); // 3.创建语句 String sql = &quot;INSERT INTO airticle(title,img) VALUES (?,?) &quot; ; st = conn.prepareStatement(sql); st.setString(1,&quot;契科夫精选&quot;); File f = new File(&quot;/Users/sxm/a92.jpg&quot;) ; // 图片文件 InputStream input = null ; input = new FileInputStream(f) ; st.setBinaryStream(2,input,(int)f.length()) ; // 设置输入流 // 4.执行语句 int rs = st.executeUpdate(); // 5.处理结果 System.out.println(&quot;插入数据:&quot; + rs); } finally { JdbcUtils.free(null, st, conn); } 读取一张图片 第一种用流 Connection conn = null; PreparedStatement st = null; ResultSet rs = null ; try { // 2.建立连接 conn = JdbcUtils.getConnection(); // 3.创建语句 String sql = &quot;SELECT title,img FROM airticle WHERE id=? &quot; ; st = conn.prepareStatement(sql); st.setInt(1,11); // 4.执行语句 rs = st.executeQuery(); // 5.处理结果 if(rs.next()){ String title = rs.getString(1) ; System.out.println(&quot;标题：&quot; + title) ; InputStream input = rs.getBinaryStream(2) ; File f = new File(&quot;/Users/sxm/load.png&quot;) ; // 图片文件 OutputStream out = null ; out = new FileOutputStream(f) ; int temp = 0 ; while((temp=input.read())!=-1){ // 边读边写 out.write(temp) ; } input.close() ; out.close() ; } } finally { JdbcUtils.free(rs, st, conn); } 读取一张图片 第二种BLOB对象读取Connection conn = null; PreparedStatement st = null; ResultSet rs = null ; try { // 2.建立连接 conn = JdbcUtils.getConnection(); // 3.创建语句 String sql = &quot;SELECT title,img FROM airticle WHERE id=? &quot; ; st = conn.prepareStatement(sql); st.setInt(1,11); // 4.执行语句 rs = st.executeQuery(); // 5.处理结果 if(rs.next()){ String title = rs.getString(1) ; System.out.println(&quot;标题：&quot; + title) ; Blob b = rs.getBlob(2) ; File f = new File(&quot;/Users/sxm/load.png&quot;) ; // 图片文件 OutputStream out = null ; out = new FileOutputStream(f) ; out.write(b.getBytes(1,(int)b.length())) ; out.close() ; } } finally { JdbcUtils.free(rs, st, conn); } 事务提交模式和隔离级别 事务(Transaction)其实指的一组操作，里面包含许多个单一的逻辑。只要有一个逻辑没有执行成功,那么都算失败。所有的数据都回归到最初的状态(回滚) 事务的特性ACID 原子性(atomicity)：即表示事务中所有操作是不可再分割的原子单位 一致性(consistency)：在事务处理执行前后，数据库是一致的(两个账户要么都变，或者都不变)。 隔离性(isolcation)：一个事务处理对另一个事务处理没有影响。 持续性(durability)：事务处理的效果能够被永久保存下来 事务提交模式自动提交模式 默认方式，每次执行完一条SQL语句就自动提交事务，每条SQL语句的执行都被单独提交，因此一个事物只有一条SQL语句组成。 手动提交模式（一般启用这种模式） Connnetion.setAutoCommit(false):设置为手动提交模式 Connection.commit():提交事务 Connection.rollback():回滚事务 一个事物中包含若干条SQL语句 回滚部分 当只想撤销事务中的部分操作时可使用SavePoint SavePoint sp = connection.setSavepoint(); connection.rollerbak(sp); connection.commit(); ```javaConnection conn = null ; // 数据库连接Statement stmt = null ; // 定义数据库操作Class.forName(DBDRIVER) ; // 加载驱动程序conn = DriverManager.getConnection(DBURL,DBUSER,DBPASS) ;conn.setAutoCommit(false) ; // 取消掉自动提交stmt = conn.createStatement() ;stmt.executeUpdate(“INSERT INTO user(name,password,age,sex,birthday)” + “ VALUES (‘LL-1’,’hello-1’,11,’男’,’1975-03-05’) “) ;stmt.executeUpdate(“INSERT INTO user(name,password,age,sex,birthday)” + “ VALUES (‘LL-2’,’hello-2’,12,’女’,’1976-03-05’) “) ;Savepoint sp = conn.setSavepoint() ; // 设置保存点stmt.executeUpdate(“INSERT INTO user(name,password,age,sex,birthday)” + “ VALUES (‘LL-4’,’hello-4’,14,’女’,’1965-03-05’) “) ;stmt.executeUpdate(“INSERT INTO user(name,password,age,sex,birthday)” + “ VALUES (‘LL-5’,’hello-5’,15,’女’,’1965-08-05’) “) ;try{ conn.rollback(sp) ; // 回滚到保存点 conn.commit() ; // 所有的操作成功了}catch(Exception e){ e.printStackTrace() ;}stmt.close() ;conn.close() ; // 数据库关闭 ## **没有隔离的情况下，事物并发引发的问题** ![](/images/javase/jdbc/事务并发的读写问题.png) ### 读的问题有三种 - **脏读(dirty read)** &gt;一个事物读取另一个事物未提交的数据，这就会引发”脏读” 读取到的是数据库内存中的数据,而并非真正磁盘上的数据。脏读又称无效数据的读出； 事务1更新了记录，但没有提交，事务2读取了更新后的行，然后事务T1回滚，现在T2读取无效。 - **不可重复读(unrepeatable read)** &gt;一个事物运行期间两次读取相同数据但内容不一致； 事务1读取记录时，事务2更新了记录并提交，事务1再次读取时可以看到事务2修改后的记录。 - **虚读/幻读(phantom read)** &gt;一个事物运行期间两次读取相同**统计数据**但内容不一致，原因是两次读取期 间有其他事物执行了插入或者删除符和**统计条件的数据**并提交。 ### 写的问题一种 - **丢失更新：**就是两个事务在并发下同时进行更新，后一个事务的更新覆盖了前一个事务更新的情况，丢失更新是数据没有保证一致性导致的。比如，事务A 修改了一条记录，事务B 在 事务A 提交的同时也进行了一次修改并且提交。当事务A查询的时候，会发现刚才修改的内容没有被修改，好像丢失了更新。 ![](/images/javase/jdbc/事务丢失更新演示.png) ### **事物隔离级别解决事务读的问题** &gt;通过设置事物的 隔离级别，来解决脏读，不可重复读，幻读等问题 - **五种事物隔离级别** &gt;**TRANSACTION_NONE(0):**不支持事物 &gt;**TRANSACTION_READ_UNCOMMITTED(1):**可读未提交数据 &gt;**TRANSACTION_READ_COMMITTED(2)：** 避免脏读 &gt;**TRANSACTION_REPEATABLE_READ(4):** 避免不可重复读 &gt;**TRANSACTION_SERIALIZABLE(8):**避免幻读 | 隔离级别 | dirty read | unrepeatable read | phantom read | | :------------: | :------------: | :------------: | :------------: | |read uncommitted(1) | y | y | y | | read committed(2) | n | y | y | | repeateable read(4) | n | n | y | | Serializable(8) | n | n | n | **1.隔离级别越高，并发性能越差，一般将隔离级别设为2** **2.Oracle的事物隔离级别：TRANSACTION_READ_COMMITTED（默认）和TRANSACTION_SERIALIZABLE** ### 悲观锁和乐观锁两种手段解决事务并发写的问题 #### 悲观锁-写锁/排它锁(互斥性) **每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁**。如DB的行锁、表锁等，适用于数据一致性比较高的场景， **实现悲观锁利用select ... for update加锁, 操作完成后使用commit来释放锁，** **innodb引擎时, 默认行级锁, 当有明确字段时会锁一行, 如无查询条件或条件字段不明确时, 会锁整个表. 条件为范围时会锁整个表** **查不到数据时, 则不会锁表** **排它锁的互斥性：如果一张表想添加排它锁，前提之前表一定没有加过共享锁和排他锁** ```sql -- 事务A执行以下 start transaction; select * from user where id=123 for update; --示例事务A用了行级锁，如此时事务B也 执行查询条件id=123的行级锁或修改删除操作时必然阻塞，但是若事务B仅是 简单select * from user where id=123，则不会阻塞 update user set nick_name = '命难违' where id=123; commit -- 事务A释放悲观锁 悲观锁优点：1.悲观锁利用数据库中的锁机制来实现数据变化的顺序执行，这是最有效的办法 悲观锁缺点：1.一个事务用悲观锁对数据加锁之后，其他事务将不能对加锁的数据进行除了查询以外的所有操作，如果该事务执行时间很长，那么其他事务将一直等待，那势必影响我们系统的吞吐量。 悲观锁-读锁/共享锁(没有互斥性) 一张表可以添加多个读锁，如果表添加读锁(不是当前事务添加的)，该表不可以修改。 select * from account lock in share mode ; --读锁/共享锁 共享锁非常容易发生死锁,两个事物同时执行共享锁语句，然后都执行更新语句时，大家都在互相等待对方的锁，引发死锁 乐观锁 每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据。通过版本号或时间戳控制，适用于多读少写的场景。如GIT,SVN,CVS等代码版本控制管理器，提交冲突现象就是一个乐观锁使用很好的场景 -- 一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。 start transaction; update user set balance=balance+1, version=version+1 where id=123 and version= #{version}; -- #{version}代表上次读取的版本 commit 乐观锁优点：1.乐观锁不在数据库上加锁，任何事务都可以对数据进行操作，在更新时才进行校验，这样就避免了悲观锁造成的吞吐量下降的劣势。 乐观锁缺点：1.乐观锁因为是通过我们人为实现的，它仅仅适用于我们自己业务中，如果有外来事务插入，那么就可能发生错误。 事务(JTA)跨越多个数据源的事务，使用JTA容器(需要用到weblogic服务器，tomcat不支持)实现事务。 分成两阶段提交。 javax.transaction.UserTransaction tx = (UserTransaction)ctx.lookup(“jndiName&quot;); tx.begin(); //connection1 connection2 (可能来自不同的数据库)… tx.commit();//tx.rollback(); JDBC批处理批处理的作用 一次和数据库交互过程中传输多条SQL语句或参数内容减少和数据库交互次数，提升性能 mysql服务器默认是关闭批处理的，我们需要通过一个参数，让mysql开启批处理的支持。?rewriteBatchedStatements=true 写在配置文件的url后面jdbc.url=jdbc:mysql://127.0.0.1:3306/testDB?charset=utf8mb4&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;rewriteBatchedStatements=true&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai 批处理操作涉及的API **addBatch():**将当前SQL语句交给Statement **executeBatch():**将多条SQL语句在一次和数据库交互过程中执行 **clearBatch():**清除批处理缓存 Statement批处理示例Statement stmt = conn.createStatement() ; stmt.addBatch(&quot;INSERT INTO user(name,password,age,sex,birthday)&quot; + &quot; VALUES ('LX-1','hello-1',11,'男','1975-03-05') &quot;) ; stmt.addBatch(&quot;INSERT INTO user(name,password,age,sex,birthday)&quot; + &quot; VALUES ('LX-2','hello-2',12,'女','1976-03-05') &quot;) ; stmt.addBatch(&quot;INSERT INTO user(name,password,age,sex,birthday)&quot; + &quot; VALUES ('LX-3','hello-3',13,'男','1977-06-01') &quot;) ; stmt.addBatch(&quot;INSERT INTO user(name,password,age,sex,birthday)&quot; + &quot; VALUES ('LX-4','hello-4',14,'女','1965-03-05') &quot;) ; stmt.addBatch(&quot;INSERT INTO user(name,password,age,sex,birthday)&quot; + &quot; VALUES ('LX-5','hello-5',15,'女','1965-08-05') &quot;) ; //上述语句会导致数据库编译sq1语句五次----性能比较差，建议还是采用PreparedStatement的批处理操作 int temp[] = stmt.executeBatch() ; System.out.println(&quot;更新了：&quot; + temp.length+ &quot;条数据。&quot;) ; PreparedStatement批处理示例 使用PreparedStatenent进行批处理,好处是如果连续执行多条结构相同sq1 ,采用预编译,SQL只需要编译一次static void createBatch() throws SQLException { //批量添加数据 Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try { conn = JdbcUtils.getConnection(); String sql = &quot;insert into user(name,birthday, money) values (?, ?, ?) &quot;; ps = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS); for (int i = 0; i &lt; 100050; i++) { ps.setString(1, &quot;batch name&quot; + i); ps.setDate(2, new Date(System.currentTimeMillis())); ps.setFloat(3, 100f + i); ps.addBatch(); if(i%1000==0){ ps.executeBatch(); ps.clearBatch(); } } int[] is = ps.executeBatch(); //拿到最后一批批处理的主键ids } finally { JdbcUtils.free(rs, ps, conn); } } JDBC获取数据库元数据DatabaseMetaData 通过DatabaseMetaData可以获得数据库相关的信息如：数据库版本、数据库名、数据库厂商信息、是否支持事务、是否支持某种事务隔离级别，是否支持滚动结果集等 Connection conn = JdbcUtils.getConnection(); DatabaseMetaData dmd = conn.getMetaData(); // 数据库元数据,实例化对象 System.out.println(&quot;数据库名称：&quot; + dmd.getDatabaseProductName()); System.out.println(&quot;数据库版本：&quot; + dmd.getDatabaseMajorVersion() + &quot;.&quot; + dmd.getDatabaseMinorVersion()); System.out.println(&quot;URL:&quot; + dmd.getURL()); System.out.println(&quot;tx:&quot;+dmd.supportsTransactions()); ResultSetMetaData,封装获取记录对象,灵活性特别高 static List&lt;Map&lt;String, Object&gt;&gt; read(String sql) throws SQLException { Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try { conn = JdbcUtils.getConnection(); ps = conn.prepareStatement(sql); rs = ps.executeQuery(); ResultSetMetaData rsmd = rs.getMetaData(); int count = rsmd.getColumnCount(); String[] colNames = new String[count]; for (int i = 1; i &lt;= count; i++) { colNames[i - 1] = rsmd.getColumnLabel(i); } List&lt;Map&lt;String, Object&gt;&gt; datas = new ArrayList&lt;Map&lt;String, Object&gt;&gt;(); while (rs.next()) { Map&lt;String, Object&gt; data = new HashMap&lt;String, Object&gt;(); for (int i = 0; i &lt; colNames.length; i++) { data.put(colNames[i], rs.getObject(colNames[i])); } datas.add(data); } return datas; } finally { JdbcUtils.free(rs, ps, conn); } } ORM反射 public class ORMTest { public static void main(String[] args) throws SQLException, IllegalAccessException, InvocationTargetException, Exception { List&lt;User&gt; user = getObject( &quot;select id as Id,username as Username,address as Address,sex as Sex,birthday as Birthday from user&quot;, User.class,new ArrayList&lt;User&gt;()); System.out.println(user); } static List&lt;Object&gt; getObjects(String sql, Class clazz) throws SQLException, Exception, IllegalAccessException, InvocationTargetException { Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try { conn = JdbcUtils.getConnection(); ps = conn.prepareStatement(sql); rs = ps.executeQuery(); String[] colNames = getColNames(rs); List&lt;Object&gt; objects = new ArrayList&lt;Object&gt;(); Method[] ms = clazz.getMethods(); while (rs.next()) { Object object = clazz.newInstance(); for (int i = 0; i &lt; colNames.length; i++) { String colName = colNames[i]; String methodName = &quot;set&quot; + colName; for (Method m : ms) { if (methodName.equals(m.getName())) { m.invoke(object, rs.getObject(colName)); break; } } objects.add(object); } } return objects; } finally { JdbcUtils.free(rs, ps, conn); } } private static String[] getColNames(ResultSet rs) throws SQLException { ResultSetMetaData rsmd = rs.getMetaData(); int count = rsmd.getColumnCount(); String[] colNames = new String[count]; for (int i = 1; i &lt;= count; i++) { colNames[i - 1] = rsmd.getColumnLabel(i); } return colNames; } static&lt;E&gt; List&lt;E&gt; getObject(String sql, Class clazz,List&lt;E&gt; list) throws SQLException, Exception, IllegalAccessException, InvocationTargetException { Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try { conn = JdbcUtils.getConnection(); ps = conn.prepareStatement(sql); rs = ps.executeQuery(); String[] colNames = getColNames(rs); Object object = null; Method[] ms = clazz.getMethods(); while(rs.next()) { object = clazz.newInstance(); for (int i = 0; i &lt; colNames.length; i++) { String colName = colNames[i]; String methodName = &quot;set&quot; + colName; for (Method m : ms) { if (methodName.equals(m.getName())) { m.invoke(object, rs.getObject(colName)); break; } } } list.add((E)object); } return list; } finally { JdbcUtils.free(rs, ps, conn); } } } DAO模式DAO模式的使用目的 封装和隐藏数据库的访问细节 将业务逻辑和数据库的访问细节实现隔离 降低耦合度 DAO模式的设计 提供一个DAO接口(如:IStudentDAO) 提供DAO接口的实现类(如：StudentDAOImpl) DAO模式的设计总结如图所示： ORMORM的介绍 E-R多了解一对多 涉及一对多关系 SQL（订单和订单明细） jdbcTemplate的概念和开发jdbcTemplate的概念 封装CRUD的操作，并提供执行CRUD操作的方法封装创建不同的Statement的语句 jdbcTemplate的开发 jdbcTemplate 封装CRUD的操作和创建不同的Statement PreparedStatementSetter 一个用于通过PreparedStatement来设置值替换占位符的接口 RowCallBackHandler 一个用于处理结果集的接口 未附代码","link":"/2013/09/13/javase/JAVASE-JDBC-13/"},{"title":"JAVASE的属性类Properties","text":"Properties类的使用 向普通及XML格式的文件中保存及读取属性 Properties类是一个专门操作属性的类此类是Hastable的子类所有的属性内容都是以字符串的形式保存的Properties类定义：public class Properties extends Hashtable&lt;Object,Object&gt; Properties的第一个例子： public String getProperty(String key, String defaultValue)根据属性的key取得属性的value，如果没有key则返回defaultValue。 import java.util.Properties; public class PropertiesDemo01{ public static void main(String args[]){ Properties pro = new Properties() ; // 创建Properties对象 pro.setProperty(&quot;BJ&quot;,&quot;BeiJing&quot;) ; // 设置属性 pro.setProperty(&quot;TJ&quot;,&quot;TianJin&quot;) ; pro.setProperty(&quot;NJ&quot;,&quot;NanJing&quot;) ; System.out.println(&quot;1、BJ属性存在：&quot; + pro.getProperty(&quot;BJ&quot;)) ; System.out.println(&quot;2、SC属性不存在：&quot; + pro.getProperty(&quot;SC&quot;)) ; System.out.println(&quot;3、SC属性不存在，同时设置显示的默认值：&quot; + pro.getProperty(&quot;SC&quot;,&quot;没有发现&quot;)) ; } } //输出一下内容 1、BJ属性存在：BeiJing 2、SC属性不存在：null 3、SC属性不存在，同时设置显示的默认值：没有发现 Properties的第二个例子将属性保存在普通文件之中 public void store(OutputStream out,String comments) throws IOException 将属性内容通过输出流输出，同时声明属性的注释 import java.util.Properties; import java.io.File; import java.io.FileOutputStream; import java.io.FileNotFoundException; import java.io.IOException; public class PropertiesDemo02{ public static void main(String args[]){ Properties pro = new Properties() ; // 创建Properties对象 pro.setProperty(&quot;BJ&quot;,&quot;BeiJing&quot;) ; // 设置属性 pro.setProperty(&quot;TJ&quot;,&quot;TianJin&quot;) ; pro.setProperty(&quot;NJ&quot;,&quot;NanJing&quot;) ; File file = new File(&quot;.&quot;+File.separator +&quot;src&quot;+File.separator +&quot;main&quot;+File.separator +&quot;resources&quot; + File.separator + &quot;area.properteis&quot;) ; // 指定要操作的文件 try{ pro.store(new FileOutputStream(file),&quot;song xm add comment&quot;) ; // 保存属性到普通文件 }catch(FileNotFoundException e){ e.printStackTrace() ; }catch(IOException e){ e.printStackTrace() ; } } } //在resources下回发现多了一个属性文件 内容如下： #song xm add comment #Tue Oct 01 20:47:09 CST 2014 BJ=BeiJing NJ=NanJing TJ=TianJin Properties的第三个例子 从普通文件之中读取属性内容 public void load(InputStream inStream) throws IOException 输入流中取出全部的属性内容 import java.util.Properties; import java.io.File; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.IOException; public class PropertiesDemo03{ public static void main(String args[]){ Properties pro = new Properties() ; // 创建Properties对象 File file = new File(&quot;.&quot;+File.separator +&quot;src&quot;+File.separator +&quot;main&quot;+File.separator +&quot;resources&quot; + File.separator + &quot;area.properteis&quot;) ; // 指定要操作的文件 try{ pro.load(new FileInputStream(file)) ; // 读取属性文件 }catch(FileNotFoundException e){ e.printStackTrace() ; }catch(IOException e){ e.printStackTrace() ; } System.out.println(&quot;1、BJ属性存在：&quot; + pro.getProperty(&quot;BJ&quot;)) ; System.out.println(&quot;2、SH属性存在：&quot; + pro.getProperty(&quot;SH&quot;)) ; } } //输出内容： 1、BJ属性存在：BeiJing 2、SH属性存在：null Properties的第四个例子 属性保存在XML文件之中 public void storeToXML(OutputStream os,String comment) throws IOException 以XML文件格式输出属性，默认编码 public void storeToXML(OutputStream os,String comment,String encoding) throws IOException以XML文件格式输出属性，用户指定默认编码 import java.io.File; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; import java.util.Properties; public class PropertiesDemo04{ public static void main(String args[]){ Properties pro = new Properties() ; // 创建Properties对象 pro.setProperty(&quot;BJ&quot;,&quot;BeiJing&quot;) ; // 设置属性 pro.setProperty(&quot;TJ&quot;,&quot;TianJin&quot;) ; pro.setProperty(&quot;NJ&quot;,&quot;NanJing&quot;) ; File file = new File(&quot;.&quot;+File.separator +&quot;src&quot;+File.separator +&quot;main&quot;+File.separator +&quot;resources&quot; + File.separator + &quot;area.xml&quot;) ; // 指定要操作的文件 try{ pro.storeToXML(new FileOutputStream(file),&quot;Area Info&quot;) ; // 保存属性到普通文件 }catch(FileNotFoundException e){ e.printStackTrace() ; }catch(IOException e){ e.printStackTrace() ; } } } //会发下在资源文件下多了一个xml文件内容如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt; &lt;!DOCTYPE properties SYSTEM &quot;http://java.sun.com/dtd/properties.dtd&quot;&gt; &lt;properties&gt; &lt;comment&gt;Area Info&lt;/comment&gt; &lt;entry key=&quot;BJ&quot;&gt;BeiJing&lt;/entry&gt; &lt;entry key=&quot;NJ&quot;&gt;NanJing&lt;/entry&gt; &lt;entry key=&quot;TJ&quot;&gt;TianJin&lt;/entry&gt; &lt;/properties&gt; Properties的第五个例子 从XML文件之中读取属性 public void loadFromXML(InputStream in) throws IOException,InvalidPropertiesFormatException从XML文件格式中读取内容 import java.util.Properties; import java.io.File; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.IOException; public class PropertiesDemo05{ public static void main(String args[]){ Properties pro = new Properties() ; // 创建Properties对象 File file = new File(&quot;.&quot;+File.separator +&quot;src&quot;+File.separator +&quot;main&quot;+File.separator +&quot;resources&quot; + File.separator + &quot;area.xml&quot;) ; // 指定要操作的文件 try{ pro.loadFromXML(new FileInputStream(file)) ; // 读取属性文件 }catch(FileNotFoundException e){ e.printStackTrace() ; }catch(IOException e){ e.printStackTrace() ; } System.out.println(&quot;1、BJ属性存在：&quot; + pro.getProperty(&quot;BJ&quot;)) ; System.out.println(&quot;2、NC属性存在：&quot; + pro.getProperty(&quot;NC&quot;)) ; } } //输出内容如下： 1、BJ属性存在：BeiJing 2、NC属性存在：null","link":"/2013/09/02/javase/JAVASE-Properties/"},{"title":"JAVASE--数据流stream","text":"介绍 在JDK1.8开始发现整个类集里面所提供的接口都出现了大量的default或者是 static方法，以Collection的父接口Iterable接口里面定义的方法来观察：default void forEach​(Consumer&lt;? super T&gt; action),加了一个消费型的函数式接口（能在方发上接受参数，但是不会返回结果）。 示例： List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;a&quot;); list.add(&quot;b&quot;); list.forEach(System.out::println); /** 输出 * a * b */ stream 在Collection接口 专门添加了处理数据流的类 java.util.stream.Stream 定义的方法：default Stream stream​() stream–count()Returns the count of elements in this stream. 定义： long count​() List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;a&quot;); list.add(&quot;b&quot;); list.add(&quot;b&quot;); Stream&lt;String&gt; stream = list.stream(); System.out.println(stream.count()); //输出结果 3 stream–distinct​()去掉重复数据Returns a stream consisting of the distinct elements (according to Object.equals(Object)) of this stream。定义：Stream distinct​() List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;a&quot;); list.add(&quot;b&quot;); list.add(&quot;b&quot;); Stream&lt;String&gt; stream = list.stream(); System.out.println(stream.distinct().count()); //输出结果 2 stream–collect()收集器（最后使用收集）Performs a mutable reduction operation on the elements of this stream using a Collector.&lt;R,A&gt; R collect​(Collector&lt;? super T,A,R&gt; collector) java.util.stream.Collectors 的 static Collector&lt;T,?,List&gt; toList​()示例： public class Test { public static void main(String[] args) { List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;a&quot;); list.add(&quot;b&quot;); list.add(&quot;b&quot;); Stream&lt;String&gt; stream = list.stream(); //去掉所有重复数据后形成新的集合数据，里面是不包含重复内容的集合 List&lt;String&gt; newList = stream.distinct().collect(Collectors.toList()); System.out.println(newList); System.out.println(list); } } /** 输出结果 * [a, b] * [a, b, b] */ stream–filter()数据筛选处理Stream filter​(Predicate&lt;? super T&gt; predicate)示例： public class Test { public static void main(String[] args) { List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;java&quot;); list.add(&quot;Android&quot;); list.add(&quot;jsp&quot;); list.add(&quot;h5&quot;); Stream&lt;String&gt; stream = list.stream(); List&lt;String&gt; newList = stream.distinct().filter((x) -&gt; { return x.contains(&quot;a&quot;) || x.contains(&quot;A&quot;); } ).collect(Collectors.toList()); System.out.println(newList); } } /**输出结果 * * [java, Android] * */ stream–map()对数据进行过滤前后的额外处理，比如转大小写 Stream map​(Function&lt;? super T,? extends R&gt; mapper)Function函数式特点，接收数据处理并返回示例： public class Test { public static void main(String[] args) { List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;java&quot;); list.add(&quot;Android&quot;); list.add(&quot;jsp&quot;); list.add(&quot;h5&quot;); Stream&lt;String&gt; stream = list.stream(); List&lt;String&gt; newList = stream.distinct().filter((x) -&gt; { return x.contains(&quot;a&quot;) || x.contains(&quot;A&quot;); } ).map((x)-&gt;x.toUpperCase()).collect(Collectors.toList()); //对于lamda表达式只有一行语句，可以不写return返回 System.out.println(newList); } } /**输出结果 * [JAVA, ANDROID] */ 在Stream接口里面提供有集合数据分页的操作： 设置跳过的数据行数：public Stream skip(long n); 设置取出的数据个数: public Stream limit(long maxSize). 在Stream接口里面还可以进行数据的全匹配或者部分匹配： 全匹配： public boolean allMatch(Predicate&lt;? super T&gt; predicate); 匹配任意一个: public boolean anyMatch(Predicate&lt;? super T&gt; predicate) 或操作 default Predicate or​(Predicate&lt;? super T&gt; other) 与操作 default Predicate and​(Predicate&lt;? super T&gt; other) 或操作示例： public class Test { public static void main(String[] args) { List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;java&quot;); list.add(&quot;Android&quot;); list.add(&quot;jsp&quot;); list.add(&quot;h5&quot;); Stream&lt;String&gt; stream = list.stream(); Predicate&lt;String&gt; p1 = (x)-&gt;x.contains(&quot;jsp&quot;); Predicate&lt;String&gt; p2 = (x)-&gt;x.contains(&quot;h5&quot;); if(stream.anyMatch(p1.or(p2))){ System.out.println(&quot;包含数据h5 或者 jsp&quot;); }else{ System.out.println(&quot;数据不存在&quot;); } } } 或者 public class Test { public static void main(String[] args) { List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;java&quot;); list.add(&quot;Android&quot;); // list.add(&quot;jsp&quot;); // list.add(&quot;h5&quot;); list.add(&quot;h5jsp&quot;); list.add(&quot;jsph5&quot;); Stream&lt;String&gt; stream = list.stream(); Predicate&lt;String&gt; p1 = (x)-&gt;x.contains(&quot;jsp&quot;); Predicate&lt;String&gt; p2 = (x)-&gt;x.contains(&quot;h5&quot;); if(stream.anyMatch(p1.or(p2))){ //有两条记录都符合，Predicate之间没有先后顺序 System.out.println(&quot;包含数据h5 或者 jsp&quot;); }else{ System.out.println(&quot;数据不存在&quot;); } } } /** * 以上两个输出结果一样： * 包含数据h5 或者 jsp */ 与操作示例 public class Test { public static void main(String[] args) { List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;java&quot;); list.add(&quot;Android&quot;); list.add(&quot;jsp&quot;); list.add(&quot;h5&quot;); list.add(&quot;h5jsp&quot;); list.add(&quot;jsph5&quot;); Stream&lt;String&gt; stream = list.stream(); Predicate&lt;String&gt; p1 = (x)-&gt;x.contains(&quot;jsp&quot;); Predicate&lt;String&gt; p2 = (x)-&gt;x.contains(&quot;h5&quot;); if(stream.anyMatch(p1.and(p2))){ //有两条记录都符合，Predicate之间没有先后顺序 System.out.println(&quot;包含数据h5 或者 jsp&quot;); }else{ System.out.println(&quot;数据不存在&quot;); } } } /** * 输出结果： * 包含数据h5 或者 jsp */ Stream的数据分析方法–reduce数据分析方法：public Optional reduce​(BinaryOperator accumulator)就是做数据统计使用的。","link":"/2016/12/18/javase/JAVASE-stream%E6%95%B0%E6%8D%AE%E6%B5%81/"},{"title":"JAVASE-国际化应用","text":"国际化应用 研究国际化应用介绍 国际化应用就是根据当前的语言环境读取指定的语言资源文件。国际化的操作就是指一个程序可以同时适应多门语言，即：如果现在程序者是中国人，则会以中文为显示文字，如果现在程序的使用者是英国人，则会以英语为显示的文字，也就是说可以通过国际化操作，让一个程序适应各个国家的语言要求。 国际化程序的实现思路 国际化应用范例资源文件创建 在工程目录的src下建立一个 *.properties资源文件，暂定为Message.properties资源文件资源文件存放内容均为 key-value形式，若有中文信息，必须将其变为UNICODE编码,此工具为JDK自行提供 native2ascii命令 国际化实现的支持类 如果要想实现Java程序的国际化操作必须通过以下的三个类完成：java.util.Locale：用于表示一个国家语言类。java.util.ResourceBundle：用于访问资源文件。java.text.MessageFormat：格式化资源文件的占位字符串 Locale 要想实现国际化首先就要认识Locale类，因为此类是实现国际化的一个重要类。国家都有对应的ISO编码中国的编码为：zh-CN英语-美国的编码为：en-US法语的编码为：fr-FR ResourceBundle ResourceBundle类的主要是读取属性文件，读取属性文件的的时候可以直接指定属性文件的名称（指定名称时不需要文件的后缀），也可以根据Locale所指定的区域码来选取指定的资源文件资源文件命名的时候最好采用单词首字母大写的方式完成。 国际化程序示例 在资源文件中进行一些动态文本的配置， 设置占位符，这些符号中的内容暂时不固定，而是在程序执行的时候由程序进行设置，而要想实现这样的功能，则必须使用MessageForm类。此类是在java.text包中定义的。在Format类中还存在数字格式化的Format ( NumberFormat)、日期格式化的Format (DateFormat)等格式化工具占位符使用**{数字}**的形式表示，如果现在表示第一个内容 “{0}”第二个内容“{1}”依次类推。 第一步：建立资源文件 Message_zh_CN.properties info =\\u4f60\\u597d\\uff0c{0}\\uff01 Message_en_US.properties info = Hello,{0}! 第二步：代码示例，处理动态文本import java.util.ResourceBundle ; import java.util.Locale ; import java.text.* ; public class LocalDemo{ public static void main(String args[]){ Locale zhLoc = new Locale(&quot;zh&quot;,&quot;CN&quot;) ; // 表示中国地区 Locale enLoc = new Locale(&quot;en&quot;,&quot;US&quot;) ; // 表示美国地区 // 找到中文的属性文件，需要指定中文的Locale对象 ResourceBundle zhrb = ResourceBundle.getBundle(&quot;Message&quot;,zhLoc) ; // 找到英文的属性文件，需要指定英文的Locale对象 ResourceBundle enrb = ResourceBundle.getBundle(&quot;Message&quot;,enLoc) ; // 依次读取各个属性文件的内容，通过键值读取，此时的键值名称统一为info String str1 = zhrb.getString(&quot;info&quot;) ; String str2 = enrb.getString(&quot;info&quot;) ; System.out.println(&quot;中文：&quot; + MessageFormat.format(str1,&quot;风清扬&quot;)) ; System.out.println(&quot;英语：&quot; + MessageFormat.format(str2,&quot;QingYang Feng&quot;)) ; } }; //编译运行输出以下结果： // 中文：你好，风清扬！ // 英语：Hello,QingYang Feng! 扩展点-使用类代替properties资源文件 之前是使用属性文件保存所有的资源信息的，当然，在Java中也可以使用类来保存所有的资源信息，但是在开发中此种做法并不多见，主要还是以属性文件的应用为主。 与之前的资源文件一样，如果使用类保存信息，则也必须按照key-value的形式出现，而且类的命名必须与属性文件一致。而且此类必须继承ListResourceBundle类，继承之后要覆写此类中的getContent()方法。 示例： package cn.ecit.message; import java.util.ListResourceBundle; public class Message_zh_CN extends ListResourceBundle{ private final Object data[][] = { {&quot;info&quot;,&quot;你好，{0}&quot;} } ; public Object[][] getContents() { // 覆写方法 return data; } } import java.text.MessageFormat; import java.util.Locale; import java.util.ResourceBundle; public class LocalDemo{ public static void main(String[] args) { Locale zhLoc = new Locale(&quot;zh&quot;, &quot;CN&quot;); // 表示中国地区 // 找到中文的属性文件 ResourceBundle zhrb = ResourceBundle.getBundle(&quot;cn.ecit.message.Message&quot;,zhLoc) ; // 依次读取各个属性文件的内容，通过键值读取，此时的键值名称为“info” String str1 = zhrb.getString(&quot;info&quot;) ; System.out.println(&quot;中文：&quot; + MessageFormat.format(str1,&quot;风清扬&quot;)) ; } } 资源文件查找顺序 在多种资源文件一起出来，如Message.properties、Message_zh_CN.properties、Message_zh_CN.class,只会使用一个，按照优先级使用！ Message_zh_CN.class Message_zh_CN.properties Message.properties","link":"/2014/10/02/javase/JAVASE-%E5%9B%BD%E9%99%85%E5%8C%96%E5%BA%94%E7%94%A8-2014-10-02/"},{"title":"JAVA概述--JAVA语言基础语法","text":"Java语言 Java语言是美国公司Sun公司，在1995年推出的高级编程语言，所谓编程语言，是计算机语言，人们可以使用编程语言对计算机下达命令，让计算机完成人们需要的功能。 JDK是什么?JRE是什么?JDK和JRE的区别Java Runtime Environment (JRE) 包含： Java虚拟机、库函数、运行Java应用程序和Applet所必须文件 Java 2 SDK (Development Kit)包含： JRE的超集，包含编译器和调试器等用于程序开发的文件 Java运行环境的三项主要功能： n 加载代码：由class loader 完成； n 校验代码：由bytecode verifier 完成； n 执行代码：由 runtime interpreter完成。 sdk（也就是jdk）是jre的超集，是在jre的基础上增加了编译器及其他一些开发工具。 jre就是java运行时环境，包括了jvm和其它一些java核心api,任何一台电脑，只有安装了jre才可以运行java程序. 总结： 1. 如果只是要运行JAVA程序，之需要JRE就可以。 JRE通常非常小，也包含了JVM. 2. 如果要开发JAVA程序，就需要安装JDK。 JVM是什么?(JAVA VIRTUAL MACHINE) JVM是一种规范，可以使用软件来实现，也可以使用硬件来实现，就是一个虚拟的用于执行bytecodes字节码的计算机。他也定义了指令集、寄存器集、结构栈、垃圾收集堆、内存区域。JVM负责将java字节码解释运行，边解释边运行，这样，速度就会受到一定的影响。JAVA提供了另一种解释运行的方法JIT（just in time），可以一次解释完，再运行特定平台上的机器码，高级的JIT可以只能分析热点代码，并将这些代码转成本地机器码，并将结果缓存起来，下次直接从内存中调用，这样就大大提高了执行JAVA代码的效率。这样就实现了跨平台、可移植的功能。 JVM是指在一台计算机上由软件或硬件模拟的计算机；它类似一个小巧而高效的CPU。 byte-code代码是与平台无关的是虚拟机的机器指令。 java字节代码运行的两种方式: 1)方式interpreter(解释) 2)Just-in-time(即时编译):有代码生成器将字节代码转换成本机的机器代码,然后可以以较高速度执行。 JAVA的跨平台实现的核心是不同平台使用不同的虚拟机不同的操作系统有不同的虚拟机。Java 虚拟机机制屏蔽了底层运行平台的差别，实现了“一次编译，随处运行”。Java通过不同的系统、不同版本、不同位数的java虚拟机(jvm),来屏蔽不同的系统指令集差异而对外体统统一的接口(java API),对于我们普通的java开发者而言，只需要按照接口开发即可。如果我系统需要部署到不同的环境时，只需在系统上面按照对应版本的虚拟机即可。 JAVA的三种注释 Java注释一共分为三种形式： // 注释：单行注释； /* ... */：多行注释； /** ... */：文档注释 public class TestDemo { public static void main(String[] args) { // 此处为注释，编译代码时不编译 System.out.println(&quot;Hello.&quot;); } } public class TestDemo { public static void main(String[] args) { /* * 此处为多行注释，编译代码时不编译 * hello */ System.out.println(&quot;Hello.&quot;); } } /** * 此处为文档注释 * @author songxm */ public class TestDemo { public static void main(String[] args) { System.out.println(&quot;Hello &quot;); } } JAVA中标识符 标识符可以定义类、属性、方法等结构信息名称。Java中每一个标识符都有自己的严格定义要求。要求如下：标识符由字母、数字、_、$所组成，其中不能以数字开头，不能是Java中的关键字（有些语言也称其为保留字）对于以上的要求，读者需要注意以下问题：在编写的时候尽量不要去使用数字，例如：i1、i2；命名尽量有意义，不要使用“a”、“b”这样的标识符。例如：Student、Math这些都属于有意义的内容；Java中标识符是区分大小写的，例如：biz、Biz、BIZ表示的三个不同的标识符；对于“$”符号有特殊意义，不要去使用（将在内部类中为读者讲解）； 数据类型划分 Java数据类型分为两大部分：基本数据类型：数值 byte,short,int,long,float,double;字符 char; 布尔 boolean引用数据类型： 数组，类，接口 数据类型转换 一个整数对应四种类型数据 byte(1)、short(2)、int(4)、long(8), 整数默认就是 int类型。一个小数（专业术语浮点数）对应两种类型数据 float(4)、double(8)，小数默认是double类型 当数据类型不一样时，将会发生数据类型转换。 自动类型转换(隐式)： 特点：代码不需要进行特殊处理，自动完成。 规则：数据范围从小到大(注意与字节数不相关的)。 e.g long num1 = 100 //自动类型转换 e.g double num2 = 2.5F //自动类型转换 e.g float num3 = 30L; //自动类型转换 ,注意虽然float字节数小于long占用的字节数，但float存储是 底数 + 指数，导致数值范围 float &gt; long 强制类型转换(显式) ： 特点：代码需要进行特殊的格式处理，不能自动完成。 格式：范围小的类型 范围小的变量名 = （范围小的类型）原本范围大的数据; e.g int num = (int)100L; //编译就可以通过，正常运行 注意事项： 强制类型转换一般不推荐使用，因为有可能发生精度损失，数据溢出 byte/short/char 这三种类型都可以发生数学运算 byte/short/char 这三种类型在运算时候，都会被首先提升成为int类型，然后再计算 boolean类型不能发生数据类型转换 float的宽限分段： 1位是符号位、8位是指数位、23位是尾数位，IEEE 754规定 0表示0,255表示无穷大,还有1-254可用，最后就有-126~127 e.g char c = 'A'; int res = c + 1; // res最后是 66，大写字母A被当做 65进行处理 e.g byte num1 = 40; byte num2 = 50; int result = num1 + num2; // 正常显示 90 编译器的常量优化 对于byte/short/char三种类型来说，如果右侧赋值的数值没有超过范围，那么javac编译器将会自动隐含地为我们补上一个（byte）(short)(char). byte num = /*(byte)*/ 30; //这里不会自动类型转换，编译器javac优化作用 byte num1 = 128; //右侧超过了左侧的范围，编译不通过 数字和字符对照关系表（编码表） ASCII码表： 美国信息交换标准代码 简称。 Unicode码表：万国码，也是数字和符号的对照关系，开头0~127部分和ASCII完全一样，但是从128开始包含更多字符。 在 ASCII 编码中，一个英文字母字符存储需要1个字节。在 GB2312 编码或 GBK 编码中，一个汉字字符存储需要2个字节。在 UTF-8编码中，一个英文字母存储需要1个字节，一个汉字储存需要3到4个字节。 进制转换 java内置的进制转换//十进制转成十六进制： Integer.toHexString(int i) //十进制转成八进制 Integer.toOctalString(int i) //十进制转成二进制 Integer.toBinaryString(int i) //十六进制转成十进制 Integer.valueOf(&quot;FFFF&quot;,16).toString() //八进制转成十进制 Integer.valueOf(&quot;876&quot;,8).toString() 二进制转十进制 //Integer.valueOf(&quot;0101&quot;,2).toString() // java.lang.Integer类 // parseInt(String s, int radix) parseInt(&quot;0&quot;, 10) returns 0 parseInt(&quot;473&quot;, 10) returns 473 parseInt(&quot;-0&quot;, 10) returns 0 parseInt(&quot;-FF&quot;, 16) returns -255 parseInt(&quot;1100110&quot;, 2) returns 102 parseInt(&quot;2147483647&quot;, 10) returns 2147483647 parseInt(&quot;-2147483648&quot;, 10) returns -2147483648 parseInt(&quot;2147483648&quot;, 10) throws a NumberFormatException String s; s = String.format(&quot;%d&quot;, factor); System.out.println(s); s = String.format(&quot;%x&quot;, factor); System.out.println(s); s = String.format(&quot;%o&quot;, factor); 运算符-进行特定操作的符号 ps: Java的运算是以补码形式运算的，一旦运算当中有不同类型的数据，那么结果将会是数据类型范围大的那种 算数运算符 四则运算（加+ 减- 乘* 除/） 取模% (取余数) 递增++，递减– ps:+号在java中有三种作用,代表正号,做加法运算,字符串的连接ps:在单独使用的时候，++与–没有任何区别；在混合使用，如和其他操作混合，像与赋值混合，或者打印操作混合，有重大区别：A. 如果是【前++】，那么变量【立刻马上 + 1】，然后拿着结果进行使用。【先加后用】B. 如果是【后++】，那么首先使用变量本来的数值，【然后再让变量+1】。【先用后加】【前–】与【后–】与之类似。 赋值运算符 基本赋值运算符 = (把=右边的数据赋值给左边) 扩展的赋值运算符(+=,-=,*=,/=,%=) ps. 复合赋值运算符其中隐含了一个强制类型转换。 byte num = 30; num += 5; // 正常输出35，里面隐含强制类型转换 num = byte + int -&gt; num = int + int -&gt; num = (byte)int 比较运算符 ==等于，!= 不等于, &gt; 大于, &gt;= 大于等于, &lt; 小于， &lt;= 小于等于 ps. 无论你的操作是简单还是复杂，结果是boolean类型 逻辑运算符 &amp; 逻辑与，有false则false。 | 逻辑或，有true则 true 。 ^ 逻辑异或，相同为false,不同为true。 位异或运算符的特点：^的特点：一个数据对另一个数据位异或两次，该数本身不变。 System.out.println(5^10^10); //结果5 System.out.println(5^10^5); //结果10 System.out.println(5^10^2); //结果13 //效率最快,两个数交换 a=a^b; b=a^b; a=a^b; ! 逻辑非: 非false则true,非true则false。 &amp;&amp; 逻辑与 最终与 &amp; 结果一样。&amp;&amp;具有短路效果。左边是false，右边不执行。&amp;&amp;是无论左边是false还是true,右边都会执行 || 逻辑或 || 与 | 结果是一样的|| 具有短路效果。左边是true,右边不执行。| 是无论左边是false还是true,右边都会执行 位运算符 &amp; 按位与(有0则0,其它为1) | 按位或(有1则1，其它为0) ^ 按位异或(相同则0，不同则1) ~ 按位取反(按位补运算符翻转操作数的每一位) &lt;&lt;按位左移(左移，右边补齐0，最高位不变) ps. 左移，向左移动几位就是乘以2的几次幂 System.out.println(12 &lt;&lt; 1); 结果：24 System.out.println(12 &lt;&lt; 2); 结果：48 &gt;&gt;按位右移 (右移，左边补齐0，最高位不变) ps. 右移，向右移动几位就是除以2的几次幂 System.out.println(12 &gt;&gt; 1); 结果：6 System.out.println(12 &gt;&gt; 2); 结果：3 &gt;&gt;&gt; 无符号右移,无论最高位是0还是1，左边补齐0 三元运算符 数据类型 变量名称 = (关系表达式) ? 表达式A : 表达式B; ps. 首先判断条件是否成立：如果成立为true，那么将表达式A的值赋值给左侧的变量；如果不成立为false，那么将表达式B的值赋值给左侧的变量；ps. 必须同时保证表达式A 和 表达式B都符合左侧数据类型的要求。 表达式 用运算符连接起来的式子叫做表达式。例如： 20 + 5. 又例如 a + b 方法 完成特定功能的代码块。 提高代码的复用性修饰符 返回值类型 方法名(参数类型 参数名1,参数类型 参数名2...) { 方法体语句; return 返回值; } 流程控制顺序结构 从上往下，依次执行。 选择结构 选择结构 if条件语句（3种表达方式） 第一种:if 语句if(布尔表达) { //如果布尔表达式为true将执行的语句（语句体） } 第二种:if…else语句if (布尔表达式) { //如果布尔表达式的值为true } else { //如果布尔表达式的值为false } ```htmlif…else与三元运算符比较: 三元运算符实现的，if…else一定可以实现. if…else实现的,三元运算未必能实现,比如if…else里有多条语句，并且不是赋值语句时，三元运算就不能实现，因为三元运算只能赋值。``` 第三种:if…else if…else 语句if(布尔表达式 1){ //如果布尔表达式 1的值为true执行代码 }else if(布尔表达式 2){ //如果布尔表达式 2的值为true执行代码 }else if(布尔表达式 3){ //如果布尔表达式 3的值为true执行代码 }else { //如果以上布尔表达式都不为true执行代码 } ps: 最后一个else可以省略,但是建议不要省略,可以对范围外的错误值提示switch 选择语句 switch 语句中的变量类型可以是： byte、short、int、 char,enum。从 Java SE 7 开始，switch 支持字符串类型了，同时 case 标签必须为字符串常量或字面量。 switch 语句可以拥有多个 case 语句。每个 case 后面跟一个要比较的值和冒号。 case 语句中的值的数据类型必须与变量的数据类型相同，而且只能是常量或者字面常量。 当变量的值与 case 语句的值相等时，那么 case 语句之后的语句开始执行，直到 break 语句出现才会跳出 switch 语句。 当遇到 break 语句时，switch 语句终止。程序跳转到 switch 语句后面的语句执行。case 语句不必须要包含 break 语句。如果没有 break 语句出现，程序会继续执行下一条 case 语句，直到出现 break 语句。 switch 语句可以包含一个 default 分支，该分支必须是 switch 语句的最后一个分支。default 在没有 case 语句的值和变量值相等的时候执行。default 分支不需要 break 语句。switch(expression){ case value : //语句 break; //可选 case value : //语句 break; //可选 //你可以有任意数量的case语句 default : //可选 //语句 } 循环结构 循环结构 while 循环初始化语句A while(判断条件语句B) { 循环体语句C; 控制条件语句D; } do…while 循环初始化语句 do { 循环体语句; 控制条件语句（步进表达式）; } while(判断条件语句); ps:while与do…while的区别（do…while永远都会执行{}代码块） for 循环for(初始化表达式;条件表达式;循环后的操作表达式) { 循环体; } 扩展break关键字用法 可以用在switch语句中，一旦执行，整个switch语句立刻结束。 还可以用在循环语句中，一旦执行，整个循环语句立刻结束，打断循环continue 关键字用法 一旦执行。立刻跳过当前次循环剩余内容，马上开始下一次循环。死循环 while语句的无限循环while (true) for语句的无限循环for (; ; )return关键字 return的作用返回其实它的作用不是结束循环的，而是结束方法的。也就是return后面的代码都不执行了面试题:return和break以及continue的区别?return是结束方法break是跳出循环continue是终止本次循环继续下次循环break和continue只能用在循环结构语句中return,不仅可以用在循环结构中，也可以用在循环结构外 数组 数组是一组相关数据的集合，一个数组实际上就是一连串的变量，数组按照使用可以分为一维数组、二维数组、多维数组。数组优点： 不使用数组定义100个整型变量：int i1;int i2;…int i100 使用数组定义: int i[100] 一维数组 一维数组可以存放上千万个数据，并且这些数据的类型是完全相同的。要使用Java的数组，必须经过两个步骤：（1）声明数组，（2）分配内存给数组。语法如下：声明形式一：声明一维数组: 数据类型 数组名[] = null;分配内存： 数组名 = new 数据类型[长度];声明形式二：声明一维数组: 数据类型[] 数组名 = null;数组动态初始化示例： public class Test{ public static void main(String[] args){ int[] score = null; score = new int[3]; for (int i=0;i&lt;3;i++) { score[i] = 60 + i; } } } 数组的静态初始化直接在声明时就给数组赋初值。利用大括号完成。格式如下： 数据类型 数组名[] = {初值0，初值1，...，初值n} 或者 数据类型 数组名[] = new 数据类型[]{初值0，初值1，...，初值n} 静态初始化示例 public class Test{ public static void main(String[] args){ int[] score = {85,78,90};//或者 int score[] = new int[]{85,78,90}; for (int i : score) { System.out.println(&quot;静态初始化值:&quot; + i); } } } 一维数组与内存关系 二维数组 如果把一维数组当成几何中的线性图形，那么二维数组就相当于是一个表格。二维数组声明的方式和一维数组类似，内存的分配也一样是用new这个关键字。动态初始化： 数据类型 数组名[][]; 数组名 = new 数据类型[行的个数][列的个数]; 静态初始化 数据类型 数组名[][] = {{第0行初值},{第一行初值},...,{第n行初值}} 或者 数据类型 数组名[][] = new 数据类型[][]{{第0行初值},{第一行初值},...,{第n行初值}} 多维数组 要想提高数组的维度，只要在声明数组的时候将索引与中括号再加一组即可，所以三维数组声明为 int score[][][] N维数组以此类推。","link":"/2013/09/01/javase/JAVASE-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95-01/"},{"title":"Java的类加载机制与反射机制","text":"类加载 当程序主动使用某个类时，如果该类还未被加载到内存中，则系统会通过加载、连接、初始化三个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成这三个步骤，所以有时也把这三个步骤统称为类加载或类初始化。类加载指的是将类的class 文件读入内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。 类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。 ➢从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式。 从JAR包加载class文件，这种方式也是很常见的，前面介绍JDBC编程时用到的数据库驱动类就放在JAR文件中，JVM可以从JAR文件中直接加载该class文件。 通过网络加载class文件。 把一个Java源文件动态编译，并执行加载。 类加载器通常无须等到“首次使用”该类时才加载该类，Java 虚拟机规范允许系统预先加载某些类。 类加载器 类加载器负责加载所有的类，系统为所有被载入内存中的类生成一个java.lang.Class实例。一旦一个类被载入JVM中，同一个类就不会被再次载入了。现在的问题是，怎么样才算“同一个类”? 正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。 在Java中，一个类用其全限定类名(包括包名和类名)作为标识;但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。 例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person、 pg、kl)。 这意味着两个类加载器加载的同名类: (Person、 pg、 kl) 和(Person、 pg、 kl2) 是不同的、它们所加载的类也是完全不同、互不兼容的。 当JVM启动时，会形成由三个类加载器组成的初始类加载器层次结构。 Bootstrap ClassL oader:根类加载器。 Extension ClassLoader: 扩展类加载器。 System ClassLoader:系统类加载器。Bootstrap ClassLoader被称为引导(也称为原始或根)类加载器，它负责加载Java的核心类。在Sun的JVM中，当执行java.exe命令时，使用-Xbootclasspath选项或使用-D选项指定sun.boot.class.path 系统属性值可以指定加载附加的类。根类加载器非常特殊，它并不是java.lang.ClassLoader的子类，而是由JVM自身实现的。下面程序可以获得根类加载器所加载的核心类库。Extension Classloader被称为扩展类加载器，它负责加载JRE的扩展目录(%JAVA_ HOME%/jre/ib/ext或者由java.ext.dirs系统属性指定的目录)中JAR包的类。通过这种方式，就可以为Java扩展核心类以外的新功能，只要把自己开发的类打包成JAR文件，然后放入JAVA_ HOME/jre/lib/ext路径即可(对于本书的安装环境来说，扩展路径为:D:/Java/jdk1 .8.0_ 05/jre/lib/ext)。System Classloader被称为系统( 也称为应用)类加载器，它负责在JVM启动时加载来自java命令的-classpath选项、java.class.path 系统属性，或CLASSPATH环境变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以类加载器作为父加载器。package com.ecit; import java.net.*; public class BootstrapTest { public static void main(String[] args) { // 获取根类加载器所加载的全部URL数组 URL[] urls = sun.misc.Launcher. getBootstrapClassPath().getURLs(); // 遍历、输出根类加载器加载的全部URL for (int i = 0; i &lt; urls.length; i++) { System.out.println(urls[i].toExternalForm()); } } } // 输出结果: // file:/Library/Java/JavaVirtualMachines/jdk1.8.0_152.jdk/Contents/Home/jre/lib/resources.jar // file:/Library/Java/JavaVirtualMachines/jdk1.8.0_152.jdk/Contents/Home/jre/lib/rt.jar // file:/Library/Java/JavaVirtualMachines/jdk1.8.0_152.jdk/Contents/Home/jre/lib/sunrsasign.jar // file:/Library/Java/JavaVirtualMachines/jdk1.8.0_152.jdk/Contents/Home/jre/lib/jsse.jar // file:/Library/Java/JavaVirtualMachines/jdk1.8.0_152.jdk/Contents/Home/jre/lib/jce.jar // file:/Library/Java/JavaVirtualMachines/jdk1.8.0_152.jdk/Contents/Home/jre/lib/charsets.jar // file:/Library/Java/JavaVirtualMachines/jdk1.8.0_152.jdk/Contents/Home/jre/lib/jfr.jar // file:/Library/Java/JavaVirtualMachines/jdk1.8.0_152.jdk/Contents/Home/jre/classes JVM四种类加载器层次结构package com.ecit; import java.util.*; import java.net.*; import java.io.*; public class ClassLoaderPropTest { public static void main(String[] args) throws IOException { // 获取系统类加载器 ClassLoader systemLoader = ClassLoader.getSystemClassLoader(); System.out.println(&quot;系统类加载器：&quot; + systemLoader); /* 获取系统类加载器的加载路径――通常由CLASSPATH环境变量指定 如果操作系统没有指定CLASSPATH环境变量，默认以当前路径作为 系统类加载器的加载路径 */ Enumeration&lt;URL&gt; em1 = systemLoader.getResources(&quot;&quot;); while(em1.hasMoreElements()) { System.out.println(em1.nextElement()); } // 获取系统类加载器的父类加载器：得到扩展类加载器 ClassLoader extensionLader = systemLoader.getParent(); System.out.println(&quot;扩展类加载器：&quot; + extensionLader); System.out.println(&quot;扩展类加载器的加载路径：&quot; + System.getProperty(&quot;java.ext.dirs&quot;)); System.out.println(&quot;扩展类加载器的parent: &quot; + extensionLader.getParent()); } } // 输出结果: // 系统类加载器：sun.misc.Launcher$AppClassLoader@2626b418 // file:/Users/sxm/Desktop/JunitDemo/target/classes/ // 扩展类加载器：sun.misc.Launcher$ExtClassLoader@4617c264 // 扩展类加载器的加载路径：/Users/sxm/Library/Java/Extensions:/Library/Java/JavaVirtualMachines/jdk1.8.0_152.jdk/Contents/Home/jre/lib/ext:/Library/Java/Extensions:/Network/Library/Java/Extensions:/System/Library/Java/Extensions:/usr/lib/java // 扩展类加载器的parent: null 从上面运行结果可以看出，系统类加载器的加载路径是程序运行的当前路径, 但此处看到扩展类加载器的父加载器是null, 并不是根类加载器。这是因为根类加载器并没有继承ClassLoader抽象类,所以扩展类加载器的getParent()方法返回null.但实际上，扩展类加载器的父类加载器是根类加载器，只是根类加载器并不是Java实现的。从运行结果可以看出，系统类加载器是AppClassLoader的实例，扩展类加载器是ExtClassLoader的实例。实际上，这两个类都是URLClassLoader类的实例。 创建并使用自定义的类加载器package com.ecit.annotation; import java.io.*; import java.lang.reflect.*; public class CompileClassLoader extends ClassLoader { // 读取一个文件的内容 private byte[] getBytes(String filename) throws IOException { File file = new File(filename); long len = file.length(); byte[] raw = new byte[(int)len]; try( FileInputStream fin = new FileInputStream(file)) { // 一次读取class文件的全部二进制数据 int r = fin.read(raw); if(r != len) throw new IOException(&quot;无法读取全部文件：&quot; + r + &quot; != &quot; + len); return raw; } } // 定义编译指定Java文件的方法 private boolean compile(String javaFile) throws IOException { System.out.println(&quot;CompileClassLoader:正在编译 &quot; + javaFile + &quot;...&quot;); // 调用系统的javac命令 Process p = Runtime.getRuntime().exec(&quot;javac &quot; + javaFile); try { // 其他线程都等待这个线程完成 p.waitFor(); } catch(InterruptedException ie) { System.out.println(ie); } // 获取javac线程的退出值 int ret = p.exitValue(); // 返回编译是否成功 return ret == 0; } // 重写ClassLoader的findClass方法 protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException { Class clazz = null; // 将包路径中的点（.）替换成斜线（/）。 String fileStub = name.replace(&quot;.&quot; , &quot;/&quot;); String javaFilename = fileStub + &quot;.java&quot;; String classFilename = fileStub + &quot;.class&quot;; File javaFile = new File(javaFilename); File classFile = new File(classFilename); // 当指定Java源文件存在，且class文件不存在、或者Java源文件 // 的修改时间比class文件修改时间更晚，重新编译 if(javaFile.exists() &amp;&amp; (!classFile.exists() || javaFile.lastModified() &gt; classFile.lastModified())) { try { // 如果编译失败，或者该Class文件不存在 if(!compile(javaFilename) || !classFile.exists()) { throw new ClassNotFoundException( &quot;ClassNotFoundExcetpion:&quot; + javaFilename); } } catch (IOException ex) { ex.printStackTrace(); } } // 如果class文件存在，系统负责将该文件转换成Class对象 if (classFile.exists()) { try { // 将class文件的二进制数据读入数组 byte[] raw = getBytes(classFilename); // 调用ClassLoader的defineClass方法将二进制数据转换成Class对象 clazz = defineClass(name,raw,0,raw.length); } catch(IOException ie) { ie.printStackTrace(); } } // 如果clazz为null，表明加载失败，则抛出异常 if(clazz == null) { throw new ClassNotFoundException(name); } return clazz; } // 定义一个主方法 public static void main(String[] args) throws Exception { // 如果运行该程序时没有参数，即没有目标类 if (args.length &lt; 1) { System.out.println(&quot;缺少目标类，请按如下格式运行Java源文件：&quot;); System.out.println(&quot;java CompileClassLoader ClassName&quot;); } // 第一个参数是需要运行的类 String progClass = args[0]; // 剩下的参数将作为运行目标类时的参数， // 将这些参数复制到一个新数组中 String[] progArgs = new String[args.length-1]; System.arraycopy(args , 1 , progArgs , 0 , progArgs.length); CompileClassLoader ccl = new CompileClassLoader(); // 加载需要运行的类 Class&lt;?&gt; clazz = ccl.loadClass(progClass); // 获取需要运行的类的主方法 Method main = clazz.getMethod(&quot;main&quot; , (new String[0]).getClass()); Object[] argsArray = {progArgs}; main.invoke(null,argsArray); } } 写一个简单的Java类测试 public class HelloWorld { public static void main(String[] args) { System.out.println(&quot;Hello World!&quot;); for (String str:args) { System.out.println(&quot;Hello World类接收到的参数信息----&gt;&quot; + str); } } } //编译运行: java 包名.CompileClassLoader 包名.HelloWorld 爱我中华 满汉全席 //输出结果: // CompileClassLoader:正在编译 包名/HelloWorld.java... // Hello World! // Hello World类接收到的参数信息----&gt;爱我中华 // Hello World类接收到的参数信息----&gt;满汉全席 本示例程序提供的类加载器功能比较简单，仅仅提供了在运行之前先编译Java源文件的功能。实际上，使用自定义的类加载器，可以实现如下常见功能。 执行代码前自动验证数字签名 根据用户提供的密码解密代码，从而可以实现代码混淆器来避免反编译.class文件。* 根据用户需求来动态地加载类。 根据应用需求把其他数据以字节码的形式加载到应用中。 URLClassLoader Java为ClassLoader提供了–个URLClassLoader实现类，该类也是系统类加载器和扩展类加载器的父类(此处的父类，就是指类与类之间的继承关系)。URLClassLoader功能比较强大，它既可以从本地文件系统获取二进制文件来加载类，也可以从远程主机获取二进制文件来加载类。在应用程序中可以直接使用URLClassLoader加载类，URLClassLoader 类提供了如下两个构造器。 ➢URLClassLoader(URL[] urls): 使用默认的父类加载器创建一个 ClassLoader 对象，该对象将从urls所指定的系列路径来查询并加载类。 ➢URLClassLoader(URL[] urls, ClassLoader parent):使用指定的父类加载器创建一个ClassLoader对象，其他功能与前一个构造器相同。一旦得到了URLClassLoader 对象之后，就可以调用该对象的loadClassO方法来加载指定类。下面程序示范了如何直接从文件系统中加载MySQL驱动，并使用该驱动来获取数据库连接。通过这种方式来获取数据库连接，可以无须将MySQL驱动添加到CLASSPATH环境变量中。```javapackage com.ecit.annotation; import java.sql.;import java.util.;import java.net.*;public class URLClassLoaderTest{ private static Connection conn; //定义一个获取数据库连接方法 public static Connection getConn(String url , String user , String pass) throws Exception { if (conn == null) { // 创建一个URL数组 URL[] urls = {new URL( “file:/Users/sxm/Desktop/mysql-connector-java-3.1.10-bin.jar”)}; // 以默认的ClassLoader作为父ClassLoader，创建URLClassLoader URLClassLoader myClassLoader = new URLClassLoader(urls); // 加载MySQL的JDBC驱动，并创建默认实例 Driver driver = (Driver)myClassLoader. loadClass(“com.mysql.jdbc.Driver”).newInstance(); // 创建一个设置JDBC连接属性的Properties对象 Properties props = new Properties(); // 至少需要为该对象传入user和password两个属性 props.setProperty(“user” , user); props.setProperty(“password” , pass); // 调用Driver对象的connect方法来取得数据库连接 conn = driver.connect(url , props); } return conn; } public static void main(String[] args)throws Exception { System.out.println(getConn(“jdbc:mysql://localhost:3306/mysql” , “root” , “32147”)); }}// 输出结果：// com.mysql.jdbc.JDBC4Connection@6659c656 ## 类的连接 - 当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。类连接又可分为如下三个阶段。 - (1)验证:验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一-致。 - (2)准备:类准备阶段则负责为类的类变量分配内存，并设置默认初始值。 - (3)解析:将类的二进制数据中的符号引用替换成直接引用。 ## 类的初始化 - 在类的初始化阶段，**虚拟机负责对类进行初始化**，主要就是对类变量进行初始化。在Java类中对类变量指定初始值有两种方式:**①声明类变量时指定初始值;②使用静态初始化块为类变量指定初始值。** ## 认识Class类(反射的基石) ### **通过对象反向取得类信息** 在正常情况下，需要先有一个类的完整路径引入之后才可以按照固定的格式产生实例化对象，但是在Java中也允许通过一个实例化对象找到一个类的完整信息，那么这就是Class类的的功能。 #### 代码示例 ```java package com.songxm.stuq.reflect; class Student { String name; String idno; } public class ClassDemo { public static void main(String[] args) { Student student = new Student(); System.out.println(student.getClass().getName()); } } Object类的支持 Object类的getClass()方法:在Object类中定义了以下的方法，此方法将被所有子类继承：public final Class getClass(); Java反射源头:以上的方法返回值的类型是一个“Class”类，实际上此类是Java反射的源头，实际上所谓反射从程序的运行结果来看也很好理解，即：可以通过对象反射求出类的名称。 实例化Class的三种方法 通过Class.forName(“类名”) 类.class 对象.getClass() 九个预定义Class对象 基本的 Java 类型（boolean、byte、char、short、int、long、float 和 double）和关键字 void通过class属性也表示为 Class 对象； 包装类与基本数据类型的字节码是不一样的 Class类中boolean isPrimitive() :判定指定的 Class 对象是否表示一个基本类型。 Class类中 boolean isArray() ：判定此 Class 对象是否表示一个数组类型。Integer.TYPE == int.class ; Integer.class == int.class; 数组类型的Class实例对象： Class&lt;String[]&gt; clz = String[].class; 反射机制的深入介绍 一般而言，开发者社群说到动态语言，大致认同的一个定义是：“程序运行时，允许改变程序结构或变量类型，这种语言称为动态语言”。从这个观点看，Perl，Python，Ruby是动态语言，C++，Java，C#不是动态语言反射就是把Java类中的各种成分映射成相应的java类,表示java类的Class类显然要提供一系列的方法，来获得其中的变量，方法，构造方法，修饰符，包等信息，这些信息就是用相应类的实例对象来表示，它们是Field、Method、Contructor、Package等等 取得类的结构 在实际开发中，以上的程序就是反射应用最多的地方，当然，反射机制所提供的功能远不止如次，还可以通过反射得到一个类的完整结构，那么这就要使用到java.lang.reflect包中的以下几个类:Constructor：表示类中的构造方法Field：表示类中的属性Method：表示类中的方法 这三个类都是AccessibleObject类的子类: Constructor类Constructor类代表某个类中的一个构造方法 得到某个类所有的构造方法： 例子：Constructor [] constructors= Class.forName(“java.lang.String”).getConstructors(); 得到某一个构造方法： 例子：Constructor constructor = Class.forName(“java.lang.String”).getConstructor(StringBuffer.class); //获得方法时要用到类型 创建实例对象： 通常方式：String str = new String(new StringBuffer(“abc”)); 反射方式： String str = (String)constructor.newInstance(new StringBuffer(“abc”)); //调用获得的方法时要用到上面相同类型的实例对象 Class.newInstance()方法： 例子：String obj = (String)Class.forName(“java.lang.String”).newInstance(); 该方法内部先得到默认的构造方法，然后用该构造方法创建实例对象。 该方法内部的具体代码是怎样写的呢？用到了缓存机制来保存默认构造方法的实例对象。 Field类Field类代表某个类中的一个成员变量，在反射操作中虽然可以使用Method调用类中的setter及getter方法设置和取得属性，但是这样操作毕竟很麻烦，所以在反射机制中也可以直接通过Field类操作类中的属性，通过Field类提供的set()和get()方法就可以完成设置和取得属性内容的操作，但是在操作前首先需要注意的是，在类中的所有属性已经都设置成私有的访问权限，所以在使用set()或get()方法的时候首先要先使用Field类中的setAccessible(true)方法将需要操作的属性设置成可以被外部访问。示例代码,ReflectPoint类的定义： public class ReflectPoint { private int x; public int y; public ReflectPoint(int x, int y) { super(); this.x = x; this.y = y; } } ReflectPoint point = new ReflectPoint(1,7); Field y = Class.forName(&quot;cn.ecit.ReflectPoint&quot;).getField(&quot;y&quot;); System.out.println(y.get(point)); //Field x = Class.forName(&quot;cn.ecit.ReflectPoint&quot;).getField(&quot;x&quot;); //获取时会报错，因为私有权限 Field x = Class.forName(&quot;cn.ecit.ReflectPoint&quot;).getDeclaredField(&quot;x&quot;); x.setAccessible(true); System.out.println(x.get(point)); Method类Method类代表某个类中的一个成员方法，通过Class类的getMethod(String name,Class..parameterTypes)方法取得一个Method的对象，并设置此方法操作时所需要的参数类型，之后才可以使用invoke进行调用，并向方法中传递要设置的参数 得到类中的某一个方法： 例子： Method charAt = Class.forName(“java.lang.String”).getMethod(“charAt”, int.class); 调用方法： 通常方式：System.out.println(str.charAt(1)); 反射方式： System.out.println(charAt.invoke(str, 1)); 如果传递给Method对象的invoke()方法的第一个参数为null，这有着什么样的意义呢？说明该Method对象对应的是一个静态方法！ jdk1.4和jdk1.5的invoke方法的区别： Jdk1.5：public Object invoke(Object obj,Object… args) Jdk1.4：public Object invoke(Object obj,Object[] args)，即按jdk1.4的语法，需要将一个数组作为参数传递给invoke方法时，数组中的每个元素分别对应被调用方法中的一个参数，所以，调用charAt方法的代码也可以用Jdk1.4改写为 charAt.invoke(“str”, new Object[]{1})形式。 Java8新增的方法参数反射Java 8在java.lang.reflect 包下新增了一个Executable抽象基类，该对象代表可执行的类成员，该类派生了Constructor、Method 两个子类。Executable基类提供了大量方法来获取修饰该方法或构造器的注解信息;还提供了isVarArgs(方法用于判断该方法或构造器是否包含数量可变的形参，以及通过getModifiers(方 法来获取该方法或构造器的修饰符。除此之外，Executable 提供了如下两个方法来获取该方法或参数的形参个数及形参名。 ➢int getParameterCount()):获取该构造器或方法的形参个数。 ➢Parameter[] getParameters():获取该构造器或方法的所有形参。上面第二个方法返回了一个Parameter[]数组，Parameter 也是Java 8新增的API,每个Parameter 对象代表方法或构造器的一个参数。Parameter 也提供了大量方法来获取声明该参数的泛型信息，还提供了如下常用方法来获取参数信息。 ➢getModifiers(): 获取修饰该形参的修饰符。 ➢String getName():获取形参名。 ➢Type getParameterizedType):获取带泛型的形参类型。 ➢Class&lt;?&gt; getType():获取形参类型。 ➢boolean isNamePresent()):该方法返回该类的class 文件中是否包含了方法的形参名信息。 ➢boolean isVarArgs():该方法用于判断该参数是否为个数可变的形参。需要指出的是，使用javac命令编译Java源文件时，默认生成的class 文件并不包含方法的形参名信息，因此调用isNamePresent()方法将会返回false，调用getName(方法也不能得到该参数的形参名。如果希望javac命令编译Java源文件时可以保留形参信息，则需要为该命令指定-parameters选项。import java.lang.reflect.Method; import java.lang.reflect.Parameter; import java.util.List; class Test { public void replace(String str, List&lt;String&gt; list) { System.out.println(); } } public class MethodParameterTest { public static void main(String[] args) throws Exception { //获取String的类 Class&lt;Test&gt; clazz = Test.class; //获取string类的带两个参数的replace ()方法 Method replace = clazz.getMethod(&quot;replace&quot;, String.class, List.class); //获取指定方法的参数个数 System.out.println(&quot;replace方法参数个数:&quot; + replace.getParameterCount()); //获取replace的所有参数信息 Parameter[] parameters = replace.getParameters(); int index = 1; //遍历所有参数 for (Parameter p : parameters) { if (p.isNamePresent()) System.out.println(&quot;---第&quot; + index++ + &quot;个参数信息 &quot;); System.out.println(&quot;参数名:&quot; + p.getName()); System.out.println(&quot;形参类型: &quot; + p.getType()); System.out.println(&quot;泛型类型: &quot; + p.getParameterizedType()); } } } // 输出结果: // replace方法参数个数:2 // 参数名:arg0 // 形参类型: class java.lang.String // 泛型类型: class java.lang.String // 参数名:arg1 // 形参类型: interface java.util.List // 泛型类型: java.util.List&lt;java.lang.String&gt; 通过反射操作数组 反射机制不光只能用在类上，可以应用在任意的引用数据类型的数据上，当然，这本身就包含了数组，即：可以使用反射操作数组。可以通过Class类的以下方法取得一个数组的Class对象：public Class&lt;?&gt; getComponentType() 在反射操作包java.lang.reflect中使用Array类表示一个数组，可以通过此类进行取得数组长度，取得数组内容的操作 具有相同维数和元素类型的数组属于同一个类型，即具有相同的Class实例对象。 代表数组的Class实例对象的getSuperClass()方法返回的父类为Object类对应的Class。 基本类型的一维数组可以被当作Object类型使用，不能当作Object[]类型使用；非基本类型的一维数组，既可以当做Object类型使用，又可以当做Object[]类型使用。代码示例package com.songxm.stuq.reflect; import java.lang.reflect.Array; public class ClassArrayDemo { public static void main(String[] args) throws Exception { int temp[] = {1,2,3} ; // 声明一个整型数组 Class&lt;?&gt; c = temp.getClass().getComponentType() ; // 取得数组的Class对象 System.out.println(&quot;类型：&quot; + c.getName()); // 得到数组类型名称 System.out.println(&quot;长度：&quot; + Array.getLength(temp));// 得到数组长度 System.out.println(&quot;第一个内容：&quot; + Array.get(temp,0)) ;// 得到第一个内容 Array.set(temp, 0, 6) ; // 修改第一个内容 System.out.println(&quot;第一个内容：&quot; + Array.get(temp,0)) ;// 得到第一个内容 } } //输出为： 类型：int 长度：3 第一个内容：1 第一个内容：6 动态代理（企业常用） 通过一个代理类完成全部的代理功能，那么此时就必须使用动态代理完成。 在Java中要想实现动态代理机制，则需要java.lang.reflect.InvocationHandler接口和java.lang.reflect.Proxy类的支持。 *此外动态代理模式还用在调试*,远程方法调用(RMI)。 在Java的javalang.eflect包下提供了一个Proxy类和- -个InvocationHandler接口，通过使用这个类和接口可以生成JDK动态代理类或动态代理对象。InvocationHandler接口 public interface InvocationHandler{ public Object invoke(Object proxy,Method method,Object[] args) throws Throwable } 参数说明： Object proxy：被代理的对象 Method method：要调用的方法 Object args[]：方法调用时所需要的参数 Proxy类 Proxy类是专门完成代理的操作类，可以通过此类为一个或多个接口动态地生成实现类，此类提供了如下的操作方法:```javapublic static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException 参数说明:ClassLoader loader：类加载器Class&lt;?&gt;[] interfaces：得到全部的接口InvocationHandler h：得到InvocationHandler接口的子类实例``` 动态代理实现 定义MyInvocationHandler的类import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; public class MyInvocationHandler implements InvocationHandler { private Object obj; // 真实主题 public Object bind(Object obj) { // 绑定真实操作主题 this.obj = obj; return Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(), this); // 取得代理对象 } public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { // 动态调用方法 System.out.println(&quot;动态代理 准备开始代理&quot; + proxy.getClass().getName()); Object temp = method.invoke(this.obj, args);// 调用方法，传入真实主题和参数 System.out.println(&quot;动态代理 代理结束&quot; + temp); return temp; // 返回方法的返回信息 } } 动态代理实现 定义接口public interface Subject{ // 定义Subject接口 public String say(String name,int age) ;// 定义抽象方法say } 动态代理实现 定义真实主题实现类public class RealSubject implements Subject{// 真实实现类 public String say(String name, int age) {// 覆写say()方法 return &quot;姓名：&quot; + name + &quot;，年龄：&quot; + age;// 返回信息 } } 动态代理实现 测试动态代理public class DynaProxyDemo { public static void main(String[] args) { MyInvocationHandler handler = new MyInvocationHandler(); // 实例化代理操作类 Subject sub = (Subject) handler.bind(new RealSubject()); // 绑定对象 String info = sub.say(&quot;song xm&quot;, 23); // 通过动态代理调用方法 System.out.println(info); // 信息输出 } } //输出信息： // 动态代理 准备开始代理com.sun.proxy.$Proxy0 // 动态代理 代理结束姓名：song xm，年龄：23 // 姓名：song xm，年龄：23 工厂设计模式JAVA反射机制对工厂设计模式的改进 工厂设计模式在实际的开发中使用的非常多，从之前读者已经学习过了简单的工厂模式，通过简单的工厂设计模式可以达到类的解耦合目的，但是之前的工厂设计模式依然存在问题，那就是在增加一个子类的时候都需要修改工厂类，这样肯定会非常的麻烦，学习完反射机制之后，实际上，此时就可以通过反射机制来改善工厂类，让其在增加子类的时候可以不用做任何的修改，就可以达到功能的扩充 使用反射加泛型完成高可用工厂设计模式（企业常用） package com.songxm.stuq.reflect; interface IFruit { public void eat(); } class Apple implements IFruit { @Override public void eat() { System.out.println(&quot;[Apple] eat!&quot;); } } class Orange implements IFruit { @Override public void eat() { System.out.println(&quot;[Orange] eat!&quot;); } } interface IMessage { public void print(); } class WeiXinMsg implements IMessage{ @Override public void print() { System.out.println(&quot;[WeiXin] print info!&quot;); } } class QQMsg implements IMessage{ @Override public void print() { System.out.println(&quot;[QQMsg] print info!&quot;); } } class Factory {//泛型是的工厂返回接口高可用 public static &lt;T&gt; T getInstance(String className) { // 取得接口实例 T IObject = null; // 定义接口对象 try { IObject = (T) Class.forName(className).newInstance(); // 实例化对象 } catch (Exception e) { e.printStackTrace(); } return IObject; } } public class FelectFactoryPlus { public static void main(String[] args) { IFruit fruit = Factory.getInstance(&quot;com.songxm.stuq.reflect.Apple&quot;); fruit.eat(); fruit = Factory.getInstance(&quot;com.songxm.stuq.reflect.Orange&quot;); fruit.eat(); IMessage message = Factory.getInstance(&quot;com.songxm.stuq.reflect.WeiXinMsg&quot;); message.print(); message = Factory.getInstance(&quot;com.songxm.stuq.reflect.QQMsg&quot;); message.print(); } } // //输出信息： // [Apple] eat! // [Orange] eat! // [WeiXin] print info! // [QQMsg] print info! 结合属性文件的工厂模式 更加完美 以上的操作代码虽然可以通过反射取得接口的实例，但是在操作的时候需要传入完整的包.类名称，而且用户也无法知道一个接口有多少个可以使用的子类，所以此时可以通过属性文件的形式配置所要的子类信息。 //对上面的终极优化 class Init { public static Properties getPro() throws IOException { Properties pro = new Properties(); InputStream inputStream = Init.class.getClassLoader().getResourceAsStream(&quot;factory.properties&quot;); if (inputStream!=null) { pro.load(inputStream); } return pro; } } public class FelectFactoryPlus { public static void main(String[] args) throws IOException { Properties pro = Init.getPro(); IFruit fruit = Factory.getInstance(pro.getProperty(&quot;apple&quot;)); fruit.eat(); fruit = Factory.getInstance(pro.getProperty(&quot;orange&quot;)); fruit.eat(); IMessage message = Factory.getInstance(pro.getProperty(&quot;WeiXinMsg&quot;)); message.print(); message = Factory.getInstance(pro.getProperty(&quot;QQMsg&quot;)); message.print(); } // 在src/main/resource下新建factory.properties apple=com.songxm.stuq.reflect.Apple orange=com.songxm.stuq.reflect.Orange WeiXinMsg=com.songxm.stuq.reflect.WeiXinMsg QQMsg=com.songxm.stuq.reflect.QQMsg","link":"/2013/09/16/javase/JAVASE-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6-16/"},{"title":"JAVA常用类库-String类，正则表达式,StringBuffer类(线程安全的)","text":"StringString的两种实例化方式 直接赋值式 new调用构造方法的方式完成ps:两种的内容虽然一样，但是他们的栈内存和堆内存完全不一样String str1 = &quot;hello&quot;; //直接赋值式 String str2 = new String(&quot;hello&quot;); //new调用构造方法的方式 ==和equals() String有两种比较方式：一种是使用“==”完成，比较的是地址值另一种是使用“equals”方法完成，比较的是具体的内容，开发中比较常用 两种实例化方式区别一个字符串就是String的匿名对象ps:从以上例子看出使用直接赋值的方式只需要一个实例化对象即可，而使用new String()方式则意味着要开辟两个内存对象。开发中最好使用直接赋值方式，可有效节省内存。 字符串内容不可变 public class Test{ public static void main(String args[]){ String name = &quot;ecit&quot;; //声明字符串 for (int i=0;i&lt;100 ; i++) { name += i; //字符串的引用不断改变 } } } //这样的操作，要断开连接引用100次才可以完成，这样的操作性能很低。应该避免使用。 //如果非要这样的操作可以使用StringBuffer类 完成。 正则表达式 正则表达式可以方便的对数据进行匹配，可以执行更加复杂的字符串验证，拆分，替换功能常用正则规则 正则Matcher验证操作import java.util.regex.Pattern; import java.util.regex.Matcher; public class Test{ public static void main(String args[]){ String dateStr = &quot;1991q-11-09&quot;; //声明字符串 Pattern pattern = Pattern.compile(&quot;\\\\d{4}-\\\\d{2}-\\\\d{2}&quot;); Matcher matcher = pattern.matcher(dateStr); if (matcher.matches()) { System.out.println(&quot;日期格式合法&quot;); }else{ System.out.println(&quot;日期格式不合法&quot;); } } } 正则的Pattern拆分操作import java.util.regex.Pattern; import java.util.regex.Matcher; public class Test{ public static void main(String args[]){ String str = &quot;1991q-11-09gehhrht222355aaaaooo77kk&quot;; //声明字符串 Pattern pattern = Pattern.compile(&quot;\\\\d+&quot;); String[] s = pattern.split(str); for (String a : s) { System.out.print(a + &quot;\\t&quot;); } } } // 输出结果 // q- - gehhrht aaaaooo kk 正则Matcher替换操作import java.util.regex.Pattern; import java.util.regex.Matcher; public class Test{ public static void main(String args[]){ String str = &quot;1991q-11-09gehhrht222355aaaaooo77kk&quot;; //声明字符串 Pattern pattern = Pattern.compile(&quot;\\\\d+&quot;); Matcher matcher = pattern.matcher(str); String newStr = matcher.replaceAll(&quot;_&quot;); System.out.println(newStr); } } // 输出结果: // _q-_-_gehhrht_aaaaooo_kk String类对正则的支持 从以上操作不难发现，很多代码除了要求字符串不同，使用的正则规则不同，基本上没有特别的了。所以在JDK1.4之后，Java对正则进行了扩充，在String类中开始直接支持正则的操作。 import java.util.regex.Pattern; import java.util.regex.Matcher; public class Test{ public static void main(String args[]){ String str = &quot;1991q-11-09gehhrht222355aaaaooo77kk&quot;; //声明字符串 String newStr = str.replaceAll(&quot;\\\\d+&quot;,&quot;_&quot;); System.out.println(&quot;正则替换操作:&quot; + newStr); boolean flag = &quot;1991-11-09&quot;.matches(&quot;\\\\d{4}-\\\\d{2}-\\\\d{2}&quot;); System.out.println(&quot;正则验证操作:&quot; + flag); String[] strs = str.split(&quot;\\\\d+&quot;); System.out.print(&quot;正则拆分操作:&quot;); for (String s : strs) { System.out.print(s + &quot;\\t&quot;); } } } // 输出结果： // 正则替换操作:_q-_-_gehhrht_aaaaooo_kk // 正则验证操作:true // 正则拆分操作: q- - gehhrht aaaaooo kk StringBuffer StringBuffer是使用缓冲区的，本身也是操作字符串的，但是与String类不同，String类的内容一旦声明之后不可改变，改变的是其内存地址的指向，而StrinBuffer中内容是可以改变的。 字符串连接操作append()替换 String的 “+” 连接功能public class Test{ public static void main(String args[]){ StringBuffer name = new StringBuffer(&quot;ecit&quot;); //声明字符串 for (int i=0;i&lt;100 ; i++) { name.append(i) ; //字符串的内容不断改变,改善了上述String需要断开连接引用100次的问题 } System.out.println(name); } } reverse()字符串的反转操作public class Test{ public static void main(String args[]){ StringBuffer name = new StringBuffer(&quot;ecit&quot;); //声明字符串 System.out.println(name.reverse()); } } 替换指定范围内的数据public class Test{ public static void main(String args[]){ StringBuffer name = new StringBuffer(&quot;ecit sxm.&quot;); //声明字符串 System.out.println(name.replace(0,5,&quot;china&quot;)); } } // 输出结果: // chinasxm. 指定位置插入数据public class Test{ public static void main(String args[]){ StringBuffer name = new StringBuffer(&quot;sxm.&quot;); //声明字符串 System.out.println(name.insert(0,&quot;china &quot;)); } } // 输出结果: // china sxm. 指定位置字符串截取public class Test{ public static void main(String args[]){ StringBuffer name = new StringBuffer(&quot;china sxm.&quot;); //声明字符串 System.out.println(name.substring(6,9)); } } // 输出结果: // sxm 指定字符串删除public class Test{ public static void main(String args[]){ StringBuffer name = new StringBuffer(&quot;china sxm.&quot;); //声明字符串 System.out.println(name.delete(6,9)); } } // 输出结果: // china . 查找指定字符串public class Test{ public static void main(String args[]){ StringBuffer name = new StringBuffer(&quot;china sxm.&quot;); //声明字符串 if(name.indexOf(&quot;song&quot;)!=-1){ System.out.println(&quot;找到了song字符串&quot;); }else if (name.indexOf(&quot;s&quot;)!=-1) { System.out.println(&quot;找到了s字符串&quot;); }else{ System.out.println(&quot;以上字符串都没找到&quot;); } } } // 输出结果: // 找到了s字符串 StringBuffer 和 StringBuilder 的区别 区别一:线程安全性 StringBuffer：线程安全，StringBuilder：线程不安全。因为 StringBuffer 的所有公开方法都是 synchronized 修饰的，而 StringBuilder 并没有 synchronized 修饰。 区别二:缓冲区 StringBuffer 每次获取 toString 都会直接使用缓存区的 toStringCache 值来构造一个字符串。StringBuilder 则每次都需要复制一次字符数组，再构造一个字符串。所以， StringBuffer 对缓存区优化，不过 StringBuffer 的这个toString 方法仍然是同步的。 区别三:性能 StringBuilder 的性能要远大于 StringBuffer。 ps：StringBuffer 适用于用在多线程操作同一个 StringBuffer 的场景，如果是单线程场合 StringBuilder 更适合。","link":"/2013/09/03/javase/JAVASE-%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%BA%93-03/"},{"title":"JAVA常用类库-Runtime类，Process类，System类,Arrays类，Timer类定时器使用，Comparable接口和Comparator接口使用","text":"Runtime类(单例设计模式) Runtime运行时，是一个封装了JVM进程的类，每一个Java程序实际上都是启动了一个JVM进程，那么每一个JVM进程都是对应这一个Runtime实例。此实例是由JVM为其实例化的。 Runtime类常用方法 得到JVM信息public class Test{ public static void main(String args[]){ Runtime runtime = Runtime.getRuntime(); System.out.println(&quot;JVM最大内存值: &quot; + runtime.maxMemory()); System.out.println(&quot;JVM空闲内存值: &quot; + runtime.freeMemory()); String str = &quot;Hello China,have a nice day!&quot;; for(int i=0;i&lt;1000;i++){ str+=i; //产生1000次垃圾对象，JVM空闲内存量会变化 } System.out.println(&quot;操作1000次String之后，JVM空闲内存值: \\t &quot; + runtime.freeMemory()); System.gc(); //通知系统进行资源回收 System.runFinalization(); // 强制垃圾回收机制调用可恢复对象的finalize()方法 System.out.println(&quot;垃圾回收后JVM空闲内存值: \\t &quot; + runtime.freeMemory()); } } // 输出结果： // JVM最大内存值: 3817865216 // JVM空闲内存值: 254741016 // 操作1000次String之后，JVM空闲内存值: 242661432 // 垃圾回收后JVM空闲内存值: 255750976 Runtime类与Process类import java.io.InputStreamReader; import java.io.BufferedReader; public class Test{ public static void main(String args[]) throws Exception{ Runtime runtime = Runtime.getRuntime(); Process process = runtime.exec(&quot;cmatrix&quot;); //黑客帝国画面 long start = System.currentTimeMillis(); long end = 0; long stopTime = 10_000; //暂定10s退出进程 try( BufferedReader br =new BufferedReader(new InputStreamReader(process.getInputStream())); ){ String line=null; while((line=br.readLine())!=null){ end = System.currentTimeMillis(); //判断指定的进程是否在运行 System.out.println(line); if((end-start)&gt;=stopTime){ System.out.println(&quot;计划运行&quot; + stopTime + &quot;ms,实际已经运行: &quot; + (end-start) + &quot;ms，进程即将退出&quot;); break; } } }catch(Exception e){ e.printStackTrace(); System.err.println(&quot;程序出现异常&quot; ); }finally{ int exitVal = process.waitFor(); System.out.println(&quot;process exit value is &quot; + exitVal); if(process!=null){ process.destroy(); } } } } System类 System类是一些与系统相关的属性和方法的集合，而且在System类所有属性都是静态的，要想引用这些属性和方法，直接使用System类调用即可。 currentTimeMillis——返回毫秒数public class SystemDemo{ public static void main(String args[]){ long startTime = System.currentTimeMillis() ; // 取得开始计算之前的时间 int sum = 0 ; // 声明变量 for(int i=0;i&lt;30000000;i++){ // 执行累加操作 sum += i ; } long endTime = System.currentTimeMillis() ; // 取得计算之后的时间 // 结束时间减去开始时间 System.out.println(&quot;计算所花费的时间：&quot; + (endTime-startTime) +&quot;毫秒&quot;) ; } } getProperty——获取指定的系统属性public class Test{ public static void main(String args[]){ String dirPath = System.getProperty(&quot;user.dir&quot;); System.out.println(dirPath); } } getProperties获取全部系统属性public class Test{ public static void main(String args[]){ System.getProperties().list(System.out) ; // 列出系统的全部属性 } } arraycopy——数组拷贝import java.util.Arrays; public class ArraysDemo{ public static void main(String args[]){ int[] srcArr = {0,1,2,3,4,5}; int[] desArr = new int[srcArr.length]; System.arraycopy(srcArr,0,desArr,0,3); //拷贝前三个元素 System.out.println(&quot;原数组:&quot; + Arrays.toString(srcArr)); System.out.println(&quot;拷贝后:&quot; + Arrays.toString(desArr)); } } //输出结果: //原数组:[0, 1, 2, 3, 4, 5] //拷贝后:[0, 1, 2, 0, 0, 0] gc——运行垃圾回收器 调用 gc 方法暗示着 Java 虚拟机做了一些努力来回收未用对象或失去了所有引用的对象，以便能够快速地重用这些对象当前占用的内存。当控制权从方法调用中返回时，虚拟机已经尽最大努力从所有丢弃的对象中回收了空间。System类的gc()方法不是一个新的操作，而是间接调用了Runtime类中的gc()方法。 class Person{ private String name ; private int age ; public Person(String name,int age){ this.name = name ; this.age = age; System.out.println(&quot;对象初始化中 --&gt; &quot; + this) ; } public String toString(){ // 覆写toString()方法 return &quot;姓名：&quot; + this.name + &quot;，年龄：&quot; + this.age ; } public void finalize() throws Throwable{ // 对象释放空间时默认调用此方法 System.out.println(&quot;对象被释放 --&gt; &quot; + this) ; } } public class SystemDemo{ public static void main(String args[]){ Person per = new Person(&quot;张三&quot;,30) ; per = null ; // 断开引用 System.gc(); System.runFinalization(); //强制回收 } } // 输出结果： // 对象初始化中 --&gt; 姓名：张三，年龄：30 // 对象被释放 --&gt; 姓名：张三，年龄：30 对象从创建到回收状态转换 2011年7月发布的Java7提供了 G1 垃圾回收器来代替原有的并行标记/清除垃圾回收器(简称CMS)。2014年3月发布的Java8 删除了HotSpot JVM中的永生代内存(PermGen,永生代内存主要用于存储一些需要常驻内存，通常不会被回收的信息),而是改为使用本地内存来存储类的元数据信息，并将之称为：元空间(Metaspace)，这意味着以后不会再遇到java.lang.OutOfMemoryError:PermGen错误 final、finally、finalize的区别final表示终结器，用于定义不能被继承的父类，不能被覆写的方法，常量；finally是异常处理出口；**finalize()**是Object类定义的一个方法，用于执行对象回收前的收尾操作。 exit——退出虚拟机 exit(int)方法终止当前正在运行的 Java 虚拟机，参数解释为状态码。根据惯例，非 0 的状态码表示异常终止。 而且，该方法永远不会正常返回。 这是唯一一个能够退出程序并不执行finally的情况。 public class SystemDemo{ public static void main(String args[]){ try { System.out.println(&quot;this is try&quot;); System.exit(0); } catch (Exception e) { e.printStackTrace(); } finally { System.out.println(&quot;this is finally&quot;); } } } 这段程序最后只会输出 this is try 这一句话，而不会输出 this is finally 。退出虚拟机会直接杀死整个程序，已经不是从代码的层面来终止程序了，所以finally不会执行。 Arrays类 import java.util.* ; public class ArraysDemo{ public static void main(String arg[]){ int temp[] = {3,4,5,7,9,1,2,6,8} ; // 声明一个整型数组 Arrays.sort(temp) ; // 进行排序的操作 System.out.print(&quot;排序后的数组************：&quot; + temp + &quot;\\t&quot;) ; System.out.println(Arrays.toString(temp)) ; // 以字符串输出数组 // 如果要想使用二分法查询的话，则必须是排序之后的数组 int point = Arrays.binarySearch(temp,3) ; // 检索位置 System.out.println(&quot;元素‘3’的位置在：&quot; + point) ; Arrays.fill(temp,3) ;// 填充数组 System.out.print(&quot;数组填充：&quot;) ; System.out.println(Arrays.toString(temp)) ; } } // 输出结果： // 排序后的数组:[1, 2, 3, 4, 5, 6, 7, 8, 9] // 元素‘3’的位置在：2 // 数组填充：[3, 3, 3, 3, 3, 3, 3, 3, 3] Arrays增强 asList方法,使用该方法可以返回一个固定大小的List (1.7出现) List&lt;String&gt; list = Arrays.asList(&quot;hello&quot;,&quot;world!&quot;); List&lt;Integer&gt; numList = Arrays.asList(100,200,300); copyOf及copyOfRange方法 String[] names2 = { &quot;Eric&quot;, &quot;John&quot;, &quot;Alan&quot;, &quot;Liz&quot; }; //[Eric, John, Alan] String[] copy = Arrays.copyOf(names2, 3); //[Alan, Liz] String[] rangeCopy = Arrays.copyOfRange(names2, 2,names2.length); sort方法 String[] names = { &quot;Liz&quot;, &quot;John&quot;, &quot;Eric&quot;, &quot;Alan&quot; }; //只排序前两个 //[John, Liz, Eric, Alan] Arrays.sort(names, 0, 2); //全部排序 //[Alan, Eric, John, Liz] Arrays.sort(names); equals方法 判断一维数组内容值是否相等 String[] names1 = { &quot;Eric&quot;, &quot;John&quot;, &quot;Alan&quot;, &quot;Liz&quot; }; String[] names2 = { &quot;Eric&quot;, &quot;John&quot;, &quot;Alan&quot;, &quot;Liz&quot; }; System.out.println(Arrays.equals(names1, names2)); deepEquals方法 二维数组判断 int[][] stuGrades1 = { { 80, 81, 82 }, { 84, 85, 86 }, { 87, 88, 89 } }; int[][] stuGrades2 = { { 80, 81, 82 }, { 84, 85, 86 }, { 87, 88, 89 } }; System.out.println(Arrays.deepEquals(stuGrades1, stuGrades2)); Java8增强了Arrays类的功能，为Arrays类增加了一些工具方法，这些工具方法可以充分利用多CPU并行的能力来提高设置、排序的性能。下面是Java8为Arrays类增加的工具类方法。 Comparable接口和Comparator接口Comparable接口 可以直接使用java.util.Arrays类进行数组的排序操作，但对象所在的类必须实现Comparable接口，用于指定排序接口，//Comparable接口定义如下： public interface Comparable&lt;T&gt;{ public int compareTo(T o) ; } //此方法返回一个int类型的数据，但是此int的值只能是以下三种： // 1：表示大于 // -1：表示小于 // 0：表示相等 示例：package com.ecit; public class ComparableDemo01 { public static void main(String[] args) { Student stu[] = { new Student(&quot;张三&quot;, 20, 90.0f), new Student(&quot;李四&quot;, 22, 90.0f), new Student(&quot;王五&quot;, 20, 99.0f), new Student(&quot;赵六&quot;, 20, 70.0f), new Student(&quot;孙七&quot;, 22, 100.0f) }; java.util.Arrays.sort(stu); // 进行排序操作 for (int i = 0; i &lt; stu.length; i++) { // 输出数组中的内容 System.out.println(stu[i]); } } } class Student implements Comparable&lt;Student&gt; { // 指定类型为Student private String name; private int age; private float score; public Student(String name, int age, float score) { this.name = name; this.age = age; this.score = score; } @Override public String toString() { return name + &quot;\\t\\t&quot; + age + &quot;\\t\\t&quot; + score; } @Override public int compareTo(Student stu) { // 覆写compareTo()方法，实现排序规则的应用 if (this.score &gt; stu.score) { return -1; } else if (this.score &lt; stu.score) { return 1; } else { if (this.age &gt; stu.age) { return 1; } else if (this.age &lt; stu.age) { return -1; } else { return 0; } } } }; /** 输出结果： 孙七 22 100.0 王五 20 99.0 张三 20 90.0 李四 22 90.0 赵六 20 70.0 **/ 分析比较器的排序原理 实际上之前所讲解的排序过程，也就是经常听到数据结构中的二叉树的排序方法，通过二叉树进行排序，之后利用中序遍历的方式把内容依次读取出来。 二叉树排序的基本原理就是，将第一个内容作为根节点保存，之后如果后面的值比根节点的值小，则放在根节点的左子树，如果后面的值比根节点的值大，则放在根节点的右子树。二叉树排序示例：package com.ecit; class BinaryTree{ class Node{ // 声明一个节点类 private Comparable data ; // 保存具体的内容 private Node left ; // 保存左子树 private Node right ; // 保存右子树 public Node(Comparable data){ this.data = data ; } public void addNode(Node newNode){ // 确定是放在左子树还是右子树 if(newNode.data.compareTo(this.data)&lt;0){ // 内容小，放在左子树 if(this.left==null){ this.left = newNode ; // 直接将新的节点设置成左子树 }else{ this.left.addNode(newNode) ; // 继续向下判断 } } if(newNode.data.compareTo(this.data)&gt;=0){ // 放在右子树 if(this.right==null){ this.right = newNode ; // 没有右子树则将此节点设置成右子树 }else{ this.right.addNode(newNode) ; // 继续向下判断 } } } public void printNode(){ // 输出的时候采用中序遍历 if(this.left!=null){ this.left.printNode() ; // 输出左子树 } System.out.print(this.data + &quot;\\t&quot;) ; if(this.right!=null){ this.right.printNode() ; } } }; private Node root ; // 根元素 public void add(Comparable data){ // 加入元素 Node newNode = new Node(data) ; // 定义新的节点 if(root==null){ // 没有根节点 root = newNode ; // 第一个元素作为根节点 }else{ root.addNode(newNode) ; // 确定是放在左子树还是放在右子树 } } public void print(){ this.root.printNode() ; // 通过根节点输出 } }; public class ComparableDemo03{ public static void main(String args[]){ BinaryTree bt = new BinaryTree() ; bt.add(8) ; bt.add(3) ; bt.add(10) ; bt.add(9) ; bt.add(1) ; bt.add(5) ; System.out.println(&quot;排序之后的结果：&quot;) ; bt.print() ; } } /** 输出结果： 排序之后的结果： 1 3 5 8 9 10 **/ 另一种比较器：Comparator 如果一个类已经开发完成，但是在此类建立的初期并没有实现Comparable接口，此时肯定是无法进行对象排序操作的，所以为了解决这样的问题，java又定义了另一个比较器的操作接口 —— Comparator。此接口定义在java.util包中，接口定义如下：public interface Comparator&lt;T&gt;{ public int compare(T o1,T o2) ; boolean equals(Object obj) ; } package com.ecit; import java.util.* ; class Student{ // 指定类型为Student private String name ; private int age ; public Student(String name,int age){ this.name = name ; this.age = age ; } public boolean equals(Object obj){ // 覆写equals方法 if(this==obj){ return true ; } if(!(obj instanceof Student)){ return false ; } Student stu = (Student) obj ; if(stu.name.equals(this.name)&amp;&amp;stu.age==this.age){ return true ; }else{ return false ; } } public void setName(String name){ this.name = name ; } public void setAge(int age){ this.age = age ; } public String getName(){ return this.name ; } public int getAge(){ return this.age ; } public String toString(){ return name + &quot;\\t\\t&quot; + this.age ; } }; class StudentComparator implements Comparator&lt;Student&gt;{ // 实现比较器 // 因为Object类中本身已经有了equals()方法 public int compare(Student s1,Student s2){ if(s1.equals(s2)){ return 0 ; }else if(s1.getAge()&lt;s2.getAge()){ // 按年龄比较 return 1 ; }else{ return -1 ; } } }; public class ComparatorDemo{ public static void main(String args[]){ Student stu[] = {new Student(&quot;张三&quot;,20), new Student(&quot;李四&quot;,22),new Student(&quot;王五&quot;,20), new Student(&quot;赵六&quot;,20),new Student(&quot;孙七&quot;,22)} ; java.util.Arrays.sort(stu,new StudentComparator()) ; // 进行排序操作 for(int i=0;i&lt;stu.length;i++){ // 循环输出数组中的内容 System.out.println(stu[i]) ; } } }; 总结 在使用中尽可能还是使用Comnparable 在需要排序的类上实现好此接口，而Comparator需要单独建立-个排序的类，这样如果有很多的话，则排序的规则类也就会非常的多，操作起来比较麻烦。掌握一点:只要是对象排序，则在java中永远是以Comparable接口为准的。 Timer类 Timer类是一种线程设施，可以用来实现在某一个时间或某一段时间后，安排某一个任务执行一次，或定期重复执行。该功能要与TimerTask配合使用。TimerTask类用来实现由Timer安排的一次或重复执行的某一个任务。 每一个Timer对象对应的是一个线程，因此计时器所执行的任务应该迅速完成，否则可能会延迟后续任务的执行，而这些后续的任务就有可能堆在一起，等到该任务完成后才能快速连续执行。 schedule()与scheduleAtFixedRate()方法的区别 两者的区别在与重复执行任务时，对于时间间隔出现延迟的情况处理： schedule()方法的执行时间间隔永远是固定的，如果之前出现了延迟的情况，之后也会继续按照设定好的的间隔时间来执行 scheduleAtFixedRate()方法可以根据出现的延迟时间自动调整下一次间隔的执行时间 TimerTask类 要想执行具体的任务，则必须使用TimerTask类。TimerTask类是一个抽象类，如果要使用该类，需要自己建立一个类来继承此类，并实现其中的抽象方法。 示例定时器package com.ecit; import java.text.SimpleDateFormat; import java.util.Date; import java.util.Timer; import java.util.TimerTask; public class TestTimer { public static void main(String[] args){ Timer t = new Timer(); // 建立Timer类对象 MyTask mytask = new MyTask(); // 定义任务 t.schedule(mytask, 1000, 2000); // 设置任务的执行，1秒后开始，每2秒重复 } } class MyTask extends TimerTask { // 任务调度类要继承TimerTask @Override public void run() { SimpleDateFormat sdf = null; sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SSS&quot;); System.out.println(&quot;当前系统时间为：&quot; + sdf.format(new Date())); } } /** 输出结果： 当前系统时间为：2013-09-04 19:17:26:573 当前系统时间为：2013-09-04 19:17:28:542 当前系统时间为：2013-09-04 19:17:30:545 ... **/","link":"/2013/09/04/javase/JAVASE-%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%BA%93-04/"},{"title":"多线程","text":"多线程的基本概念线程指的是进程中的一个执行场景,也就是执行流程，那么进程和线程有什么区别？ 每个进程是一个应用程序，都有独立的内存空间 同一个进程中的线程共享其进程中的内存和资源(共享的内存是堆内存和方法区内存，栈内存不共享，每个线程有自己的栈) 什么是进程一个进程对应一个应用程序，例如:在Windows操作系统启动Word就表示启动一个进程，在JAVA的开发环境下启动JVM，就表示启动一个进程。现代的计算机都是支持多进程的，在同一个操作系统中，可以同时启动多个进程。多进程有什么作用单进程计算机只能做一件事。玩电脑，一边玩游戏(游戏进程)，一边听音乐(音乐进程)对于单核计算机来讲，在同一个时间点上，游戏进程和音乐进程是同时在运行吗？不是，因为计算机的CPU只能在某个时间点上做一件事。由于计算机将在”游戏进程”和“音乐进程”之间频繁的切换执行，切换速度极高，人类感觉游戏和音乐同时在进行。 多进程的作用不是提高执行速度，而是提高CPU的使用率。进程和进程之间的内存是独立的。 什么是线程线程是一个进程中执行场景，一个进程可以启动多个线程。多线程不是为了提高执行速度，而是为了提高应用程序的使用率 并发性(concurrency) 和 并行性(parallel) 并发性(concurrency) 和 并行性(parallel)是两个概念，并行指在同一时刻，有多条指令在多个处理器上同时执行；并发指在同一时刻只能有一条指令执行，但多个进程指令被快速轮换执行,使得在宏观上具有多个进程同时执行的效果。 Java程序的运行原理Java命令会启动JAVA虚拟机，启动JVM，等于启动了一个应用程序，表示启动了一个进程。该进程会自动启动一个“主线程”，然后主线程去调用某个类的main方法。所以main方法运行在主线程中，在此之前的所有程序都是单线程的。 Java多线程实现的三种方式继承java.lang.Threadpublic class ThreadTest { public static void main(String[] args) { // 创建线程 Processor t = new Processor(); // 启动，这段代码执行瞬间结束，告诉jvm再分配一个新的栈给 t线程。 // run()方法不需要程序员手动调用，系统线程启动之后自动调用run方法 t.start(); // 这段代码在主线程中运行 for (int i = 0; i &lt; 3; i++) { System.out.println(&quot;main---&gt;&quot; + i); } //有了多线程之后，main方法结束，只是主线程栈中没有方法栈帧了。 //但是其他线程或者其他栈中还有栈帧。 // main 方法结束，程序可能还在运行 } } // 定义一个线程 class Processor extends Thread { // 重写run方法 @Override public void run() { System.out.println(&quot;新启动线程的执行场景....&quot;); } } 实现 java.lang.Runnable(推荐方式)public class ThreadTest { public static void main(String[] args) { // 创建线程 Thread t = new Thread(new Processor()); // 启动，这段代码执行瞬间结束，告诉jvm再分配一个新的栈给 t线程。 // run()方法不需要程序员手动调用，系统线程启动之后自动调用run方法 t.start(); // 这段代码在主线程中运行 for (int i = 0; i &lt; 3; i++) { System.out.println(&quot;main---&gt;&quot; + i); } // 有了多线程之后，main方法结束，只是主线程栈中没有方法栈帧了。 // 但是其他线程或者其他栈中还有栈帧。 // main 方法结束，程序可能还在运行 } } // 定义一个线程 class Processor implements Runnable { // 重写run方法 @Override public void run() { System.out.println(&quot;新启动线程的执行场景....&quot;); } } 使用Callable和 Future创建线程 从JDK5开始，Java提供了Callable接口，看上去像Runnable增强版，Callable接口提供了一个call()方法可以作为线程执行体，但call()方法比run()方法功能更强大。call()方法可以有返回值。JDK5提供了Future接口来代表Callable接口里call()方法的返回值，并为Future接口提供了一个FutureTask实现类，它也实现了Runnable接口。 import java.util.concurrent.Callable; import java.util.concurrent.ExecutionException; import java.util.concurrent.FutureTask; public class CallableTask { public static void main(String[] args) throws ExecutionException, InterruptedException { FutureTask &lt;Integer&gt; futureTask = new FutureTask &lt;&gt;((Callable &lt;Integer&gt;) () -&gt; { int i = 0; for (; i &lt; 100; i++) { // System.out.println(Thread.currentThread().getName() + i); } // 作为Callable的返回值i return i; }); for (int i = 0; i &lt; 5; i++) { System.out.println(i); if (i==2) { //利用Callable和FutureTask作为目标对象启动线程 new Thread(futureTask,&quot;有返回值的线程&quot;).start(); } } // 接收FutureTask的返回值 System.out.println(&quot;子线程的返回值:&quot; + futureTask.get()); } } // 输出结果: // 0 // 1 // 2 // 3 // 4 // 子线程的返回值:100 线程的生命周期 新建: 采用new语句创建完成 就绪: 执行start后 运行: 占用CPU时间,run方法执行 阻塞: 执行了wait语句，执行了sleep语句和等待某个对象锁，等待输入的场合 终止: 退出run方法。线程的调度与控制通常我们的计算机只有一个CPU，CPU在某一个时刻只能执行一条指令，线程只有得到CPU时间片，也就是使用权，才可以执行指令。在单CPU的机器上线程不是并行运行的，只有在多个CPU上线程才可以并行运行。Java虚拟机要负责线程的调度，取得CPU的使用权目前有两种调度模型:分时调度模型和抢占式调度模型，Java使用抢占式调度模型 分时调度模型:所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间片 抢占式调度模型:优先让优先级高的线程使用CPU，如果线程的优先级相同，那么回随机选择一个 线程优先级调度程序改默认优先级5，把特急的设置成高优先级10，目前就三种优先级，如果改的话，只能改成最低，最高。线程优先级主要分三种: MAX_PRIORITY，NORM_PRIORITY，MIN_PRIORITY按道理高优先级的线程会先执行，但是还是不一定，有时低优先级也开始运行。 public final static int MIN_PRIORITY = 1; //最低优先级 public final static int NORM_PRIORITY = 5;//干活线程建立默认优先级 public final static int MAX_PRIORITY = 10;//hhhh所以对于设置优先级，只是本地记号，一切由操作系统决定 线程调度与控制–Thread.sleep方法详解(用的多) Thread.sleep(毫秒) sleep方法是一个静态方法 该方法的作用:阻塞当前线程，腾出CPU，让给其它线程。 sleep设置休眠的时间，单位毫秒，当一个线程遇到 sleep的时候，就会睡眠，进入到阻塞状态，放弃CPU腾出cpu时间片，给其他线程用，所以在开发中通常我们会这样做，使其他的线程能够取得CPU时间片，当睡眠时间到达了，线程会进入可运行状态，得到CPU时间片继续执行，如果线程在睡眠状态被中断了，将会抛出 Iterruptedexception 如果一个线程休眠时间很长，想要打断它的休眠，可以调用 interrupt()方法，以下方法靠的是异常处理机制 public class ThreadTest { public static void main(String[] args) { // 创建线程 Thread t = new Thread(new Processor()); // 启动，这段代码执行瞬间结束，告诉jvm再分配一个新的栈给 t线程。 // run()方法不需要程序员手动调用，系统线程启动之后自动调用run方法 t.start(); t.interrupt(); // 打断t线程的休眠，t线程采用异常捕获机制，进入就绪状态 // 这段代码在主线程中运行 for (int i = 0; i &lt; 3; i++) { System.out.println(&quot;main---&gt;&quot; + i); } // 有了多线程之后，main方法结束，只是主线程栈中没有方法栈帧了。 // 但是其他线程或者其他栈中还有栈帧。 // main 方法结束，程序可能还在运行 } } // 定义一个线程 class Processor implements Runnable { // 重写run方法 @Override public void run() { try { Thread.sleep(100000000000000l); } catch (InterruptedException e) { System.out.println(&quot;t线程打断休眠状态，由阻塞状态到就绪状态&quot;); } System.out.println(&quot;新启动线程的执行场景....&quot;); } } 如何正确的终止一个线程通常定义一个标记，来判断标记的状态，停止线程的执行 // 启动5s 就终止线程 public class ThreadTest { public static void main(String[] args) throws InterruptedException { Processor p = new Processor(); // 创建线程 Thread t = new Thread(p); // 启动，这段代码执行瞬间结束，告诉jvm再分配一个新的栈给 t线程。 t.start(); Thread.sleep(5000);// 启动5s 就终止线程 p.flag = false; //改变标记 } } // 定义一个线程 class Processor implements Runnable { boolean flag = true; // 重写run方法 @Override public void run() { for (int i = 0; i &lt; 10; i++) { if(flag) { try { Thread.sleep(1000l); } catch (InterruptedException e) { } System.out.println(Thread.currentThread().getName()+&quot; &quot;+i); }else { return; } } } } 输出: Thread-0 0 Thread-0 1 Thread-0 2 Thread-0 3 Thread-0 4 线程调度与控制–Thread.yield方法详解 只让位给同优先级的线程 让位的时间不固定 静态的 static 它与 sleep()方法类似,只是不能由用户指定暂停多长时间,并且 yield()方法只能让同优先级的线程有执行的机会 public class ThreadTest { public static void main(String[] args) throws InterruptedException { Processor p = new Processor(); // 创建线程 Thread t = new Thread(p); // 启动，这段代码执行瞬间结束，告诉jvm再分配一个新的栈给 t线程。 t.start(); t.setName(&quot;t&quot;); for(int i=1;i&lt;=10;i++) { System.out.println(Thread.currentThread().getName() +&quot; &quot;+i); } } } // 定义一个线程 class Processor implements Runnable { @Override public void run() { for (int i = 0; i &lt; 10; i++) { System.out.println(Thread.currentThread().getName() +&quot; &quot;+ i); if(i%2==0) { Thread.yield(); } } } } 输出: main 1 main 2 main 3 main 4 main 5 main 6 main 7 main 8 t 0 // 0 让位给同级线程 main 9 t 1 t 2 // 2 让位给同级线程 main 10 t 3 t 4 t 5 t 6 t 7 t 8 t 9 线程调度与控制–join方法详解 成员方法 当前线程可以调用另一个线程的join方法,调用后当前线程会被阻塞不再执行,直到被调用的线程执行完毕,当前线程才会执行 public class ThreadTest { public static void main(String[] args) throws InterruptedException { Processor p = new Processor(); // 创建线程 Thread t = new Thread(p); // 启动，这段代码执行瞬间结束，告诉jvm再分配一个新的栈给 t线程。 t.start(); t.setName(&quot;t&quot;); t.join(); //当前线程主线程 调用了另一个线程t的 join方法，主线程阻塞不再执行，直到t线程执行完毕 for(int i=1;i&lt;=10;i++) { System.out.println(Thread.currentThread().getName() +&quot; &quot;+i); } } } // 定义一个线程 class Processor implements Runnable { @Override public void run() { for (int i = 0; i &lt; 10; i++) { System.out.println(Thread.currentThread().getName() +&quot; &quot;+ i); } } } 输出: t 0 t 1 t 2 t 3 t 4 t 5 t 6 t 7 t 8 t 9 main 1 main 2 main 3 main 4 main 5 main 6 main 7 main 8 main 9 main 10 线程的同步(加锁) 异步编程模型:t1线程执行t1的，t2线程执行t2的，两个线程之间谁也不等谁同步编程模型:t1线程和t2线程执行，当t1线程必须等t2线程执行结束之后，t1线程才能执行，这是同步编程模型什么时候要同步呢？为什么要引入线程同步呢？为了数据的安全。尽管应用程序的使用率降低，但是为了保证数据是安全的，必须加入线程同步机制线程同步机制使程序变成了（等同）单线程 什么条件下要使用线程同步 必须是多线程环境 多线程环境共享同一个数据 共享的数据涉及到修改操作 示例爸爸和孩子对同一个银行卡取款 在没有用线程同步的情况，提现出现错误数据，示例 public class ThreadTest { public static void main(String[] args) throws InterruptedException { Account mun = new Account(80001,5000); //编号80001的客户账号里有5000存款 Thread parent = new Thread(new ATM(mun), &quot;爸爸来取钱&quot;); Thread child = new Thread(new ATM(mun), &quot;孩子也来取钱&quot;); parent.start(); child.start(); } } class ATM implements Runnable{ Account account; public ATM(Account account) { this.account = account; } @Override public void run() { account.withdraw(1000); //提现1000 System.out.println(Thread.currentThread().getName() + &quot;取完钱账户还剩 :&quot; + account.getBalance()); } } // 定义账户 class Account { int userId; double balance; public Account(int userId, double balance) { super(); this.userId = userId; this.balance = balance; } public int getUserId() { return userId; } public void setUserId(int userId) { this.userId = userId; } public double getBalance() { return balance; } public void setBalance(double balance) { this.balance = balance; } public void withdraw(double money) { double after = balance - money; try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } this.setBalance(after); } } 输出结果: 爸爸来取钱取完钱账户还剩 :4000.0 孩子也来取钱取完钱账户还剩 :4000.0 使用synchronized同步对象锁，使数据修改安全 public class ThreadTest { public static void main(String[] args) throws InterruptedException { Account mun = new Account(80001,5000); //编号80001的客户账号里有5000存款 Thread parent = new Thread(new ATM(mun), &quot;爸爸来取钱&quot;); Thread child = new Thread(new ATM(mun), &quot;孩子也来取钱&quot;); parent.start(); child.start(); } } class ATM implements Runnable{ Account account; public ATM(Account account) { this.account = account; } @Override public void run() { account.withdraw(1000); //提现1000 System.out.println(Thread.currentThread().getName() + &quot;取完钱账户还剩 :&quot; + account.getBalance()); } } // 定义账户 class Account { int userId; double balance; public Account(int userId, double balance) { super(); this.userId = userId; this.balance = balance; } public int getUserId() { return userId; } public void setUserId(int userId) { this.userId = userId; } public double getBalance() { return balance; } public void setBalance(double balance) { this.balance = balance; } public void withdraw(double money) { synchronized (this) { double after = balance - money; try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } this.setBalance(after); } } } // 结果输出: // 爸爸来取钱取完钱账户还剩 :4000.0 // 孩子也来取钱取完钱账户还剩 :3000.0 两个线程分别持有不同对象，对象锁就是不一样的，不存在两个线程竞争对象锁 public class ThreadTest16 { public static void main(String[] args) throws Exception{ MyClass mc1 = new MyClass(); MyClass mc2 = new MyClass(); Processor p1 = new Processor(mc1); //两个线程分别持有不同对象，对象锁就是不一样的，不存在两个线程竞争对象锁 Processor p2 = new Processor(mc2); Thread t1 = new Thread(p1); t1.setName(&quot;t1&quot;); Thread t2 = new Thread(p2); t2.setName(&quot;t2&quot;); //启动线程 t1.start(); //延迟(保证t1线程先启动，并执行run) Thread.sleep(1000); t2.start(); } } class Processor implements Runnable { MyClass mc; Processor(MyClass mc){ this.mc = mc; } public void run(){ if(Thread.currentThread().getName().equals(&quot;t1&quot;)){ mc.m1(); } if(Thread.currentThread().getName().equals(&quot;t2&quot;)){ mc.m2(); } } } class MyClass { public synchronized void m1(){ //休眠 try{ Thread.sleep(10000); }catch(Exception e){} System.out.println(&quot;m1....&quot;); } //m2方法不会等m1方法结束，t1,t2不共享同一个mc public synchronized void m2(){ System.out.println(&quot;m2....&quot;); } } 类锁(synchronized修饰的方法出现static),类只有一个，所以锁是类级别的，只有一个.存在锁竞争 /* 类锁,类只有一个，所以锁是类级别的，只有一个. */ public class ThreadTest17 { public static void main(String[] args) throws Exception{ Thread t1 = new Thread(new Processor()); Thread t2 = new Thread(new Processor()); t1.setName(&quot;t1&quot;); t2.setName(&quot;t2&quot;); t1.start(); //延迟，保证t1先执行 Thread.sleep(1000); t2.start(); } } class Processor implements Runnable { public void run(){ if(&quot;t1&quot;.equals(Thread.currentThread().getName())){ MyClass.m1(); } if(&quot;t2&quot;.equals(Thread.currentThread().getName())){ MyClass.m2(); } } } class MyClass { //synchronized添加到静态方法上，线程执行此方法的时候会找类锁。 public synchronized static void m1(){ try{Thread.sleep(10000);}catch(Exception e){} System.out.println(&quot;m1....&quot;); } //不会等m1结束，因为该方法没有被synchronized修饰 /* public static void m2(){ System.out.println(&quot;m2...&quot;); } */ //m2方法等m1结束之后才能执行，该方法有synchronized //线程执行该代码需要“类锁”，而类锁只有一个。 public synchronized static void m2(){ System.out.println(&quot;m2...&quot;); } } 误区示例: /* 类锁,类只有一个，所以锁是类级别的，只有一个. */ public class ThreadTest18 { public static void main(String[] args) throws Exception{ MyClass mc1 = new MyClass(); MyClass mc2 = new MyClass(); Thread t1 = new Thread(new Processor(mc1)); Thread t2 = new Thread(new Processor(mc2)); t1.setName(&quot;t1&quot;); t2.setName(&quot;t2&quot;); t1.start(); //延迟，保证t1先执行 Thread.sleep(1000); t2.start(); } } class Processor implements Runnable { MyClass mc; Processor(MyClass mc){ this.mc = mc; } public void run(){ if(&quot;t1&quot;.equals(Thread.currentThread().getName())){ mc.m1(); //用的还是类锁。和对象锁无关. } if(&quot;t2&quot;.equals(Thread.currentThread().getName())){ mc.m2(); } } } class MyClass { //synchronized添加到静态方法上，线程执行此方法的时候会找类锁。 public synchronized static void m1(){ try{Thread.sleep(10000);}catch(Exception e){} System.out.println(&quot;m1....&quot;); } //m2方法等m1结束之后才能执行，该方法有synchronized //线程执行该代码需要“类锁”，而类锁只有一个。 public synchronized static void m2(){ System.out.println(&quot;m2...&quot;); } } 同步锁（Lock） 从Java5开始，Java提供了一种功能更强大的线程同步机制–通过显示定义同步锁对象来实现同步，在这种机制下，同步锁由Lock对象充当。Lock提供了比 synchronized方法和 synchronized代码块更广泛的锁定操作，Lock允许实现更灵活结构，可以具有差别很大的属性，并且支持多个相关的 Condition对象。Lock、 ReadWriteLock是Java5提供的两个根接口，并为Lock提供了 ReentrantLock（可重入锁）实现类，为ReadWriteLock提供了ReentrantReadWriteLock实现类。Java8新增了新型的 StampedLock类，在大多数场景中它可以替代传统的 ReentrantReadWriteLock，ReentrantReadWriteLock为读写操作提供了三种锁模式: Writing、 ReadingOptimistic、 Reading在实现线程安全的控制中，比较常用的是 ReentrantLock（可重入锁）。使用该Lock对象可以显式地加锁、释放锁，通常使用 ReentrantLock的代码格式如下: public class Test { //定义锁对象 private final ReentrantLock lock = new ReentrantLock(); //... //定义需要保证线程安全的方法 public void business(){ //加锁 lock.lock(); try{ //需要保证线程安全的代码 //... } //使用finally块来保证释放锁 finally{ lock.unlock(); } } } 改写父子取款的例子: import java.util.concurrent.locks.ReentrantLock; public class ThreadTest { public static void main(String[] args) throws InterruptedException { Account mun = new Account(80001,5000); //编号80001的客户账号里有5000存款 Thread parent = new Thread(new ATM(mun), &quot;爸爸来取钱&quot;); Thread child = new Thread(new ATM(mun), &quot;孩子也来取钱&quot;); parent.start(); child.start(); } } class ATM implements Runnable{ Account account; public ATM(Account account) { this.account = account; } @Override public void run() { account.withdraw(1000); //提现1000 System.out.println(Thread.currentThread().getName() + &quot;取完钱账户还剩 :&quot; + account.getBalance()); } } // 定义账户 class Account { //定义锁对象 private final ReentrantLock lock = new ReentrantLock(); int userId; double balance; public Account(int userId, double balance) { super(); this.userId = userId; this.balance = balance; } public int getUserId() { return userId; } public void setUserId(int userId) { this.userId = userId; } public double getBalance() { return balance; } public void setBalance(double balance) { this.balance = balance; } public void withdraw(double money) { lock.lock(); try { double after = balance - money; try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } this.setBalance(after); }finally{ lock.unlock(); } } } // 输出结果: // 爸爸来取钱取完钱账户还剩 :4000.0 // 孩子也来取钱取完钱账户还剩 :3000.0 线程通信 假设现在系统中有两个线程，这两个线程分别代表存款者和取钱者—现在假设系统有一种特殊的要求，系统要求存款者和取钱者不断地重复存款、取钱的动作，而且要求每当存款者将钱存入指定账户后，取钱者就立即取出该笔钱。不允许存款者连续两次存钱，也不允许取钱者连续两次取钱。为了实现这种功能，可以借助于Object类提供的 wait、 notify和 notify Al0三个方法，这三个方法并不属于 Thread类，而是属于Object类。但这三个方法必须由同步监视器对象来调用，这可分成以下两种情况。对于使用synchronized修饰的同步方法，因为该类的默认实例（this）就是同步监视器，所以可以在同步方法中直接调用这三个方法。对于使用synchronized修饰的同步代码块，同步监视器是 synchronized后括号里的对象，所以必须使用该对象调用这三个方法。关于这三个方法的解释如下。wait:导致当前线程等待，直到其他线程调用该同步监视器的 notify()方法或 notifyAll()方法来唤醒该线程。该 wait方法有三种形式———无时间参数的wait（一直等待，直到其他线程通知）、带毫秒参数的 wait和带毫秒、毫微秒参数的 wait()（这两种方法都是等待指定时间后自动苏醒）。调用 wait()方法的当前线程会释放对该同步监视器的锁定。notify():唤醒在此同步监视器上等待的单个线程。如果所有线程都在此同步监视器上等待，则会选择唤醒其中一个线程。选择是任意性的。只有当前线程放弃对该同步监视器的锁定后（使用 wait方法），才可以执行被唤醒的线程。notifyAll():唤醒在此同步监视器上等待的所有线程。只有当前线程放弃对该同步监视器的锁定后，才可以执行被唤醒的线程。程序中可以通过一个旗标来标识账户中是否已有存款，当旗标为 false时，表明账户中没有存款，存款者线程可以向下执行，当存款者把钱存入账户后，将旗标设为true，并调用 notify()或 notifyAll()方法来唤醒其他线程；当存款者线程进入线程体后，如果旗标为true就调用 wait()方法让该线程等待。当旗标为true时，表明账户中已经存入了存款，则取钱者线程可以向下执行，当取钱者把钱从账户中取出后，将旗标设为false，并调用 notify()或 notifyAll()方法来唤醒其他线程；当取钱者线程进入线程体后，如果旗标为false就调用 wait方法让该线程等待。本程序为 Account类提供 draw和 deposit（两个方法，分别对应该账户的取钱、存款等操作，因为这两个方法可能需要并发修改 Account类的 balance成员变量的值，所以这两个方法都使synchronized修饰成同步方法。除此之外，这两个方法还使用了 wait、 notifyAll来控制线程的协作。 public class Account { // 封装账户编号、账户余额两个Field private String accountNo; private double balance; //标识账户中是否已有存款的旗标 private boolean flag = false; public Account(){} // 构造器 public Account(String accountNo , double balance) { this.accountNo = accountNo; this.balance = balance; } // accountNo的setter和getter方法 public void setAccountNo(String accountNo) { this.accountNo = accountNo; } public String getAccountNo() { return this.accountNo; } // 因此账户余额不允许随便修改，所以只为balance提供getter方法， public double getBalance() { return this.balance; } public synchronized void draw(double drawAmount) { try { // 如果flag为假，表明账户中还没有人存钱进去，取钱方法阻塞 if (!flag) { wait(); } else { // 执行取钱 System.out.println(Thread.currentThread().getName() + &quot; 取钱:&quot; + drawAmount); balance -= drawAmount; System.out.println(&quot;账户余额为：&quot; + balance); // 将标识账户是否已有存款的旗标设为false。 flag = false; // 唤醒其他线程 notifyAll(); } } catch (InterruptedException ex) { ex.printStackTrace(); } } public synchronized void deposit(double depositAmount) { try { // 如果flag为真，表明账户中已有人存钱进去，则存钱方法阻塞 if (flag) //① { wait(); } else { // 执行存款 System.out.println(Thread.currentThread().getName() + &quot; 存款:&quot; + depositAmount); balance += depositAmount; System.out.println(&quot;账户余额为：&quot; + balance); // 将表示账户是否已有存款的旗标设为true flag = true; // 唤醒其他线程 notifyAll(); } } catch (InterruptedException ex) { ex.printStackTrace(); } } // 下面两个方法根据accountNo来重写hashCode()和equals()方法 public int hashCode() { return accountNo.hashCode(); } public boolean equals(Object obj) { if(this == obj) return true; if (obj !=null &amp;&amp; obj.getClass() == Account.class) { Account target = (Account)obj; return target.getAccountNo().equals(accountNo); } return false; } } public class DrawThread extends Thread { // 模拟用户账户 private Account account; // 当前取钱线程所希望取的钱数 private double drawAmount; public DrawThread(String name , Account account , double drawAmount) { super(name); this.account = account; this.drawAmount = drawAmount; } // 重复100次执行取钱操作 public void run() { for (int i = 0 ; i &lt; 100 ; i++ ) { account.draw(drawAmount); } } } public class DepositThread extends Thread { // 模拟用户账户 private Account account; // 当前取钱线程所希望存款的钱数 private double depositAmount; public DepositThread(String name , Account account , double depositAmount) { super(name); this.account = account; this.depositAmount = depositAmount; } // 重复100次执行存款操作 public void run() { for (int i = 0 ; i &lt; 100 ; i++ ) { account.deposit(depositAmount); } } } public class DrawTest { public static void main(String[] args) { // 创建一个账户 Account acct = new Account(&quot;1234567&quot; , 0); new DrawThread(&quot;取钱者&quot; , acct , 800).start(); new DepositThread(&quot;存款者甲&quot; , acct , 800).start(); new DepositThread(&quot;存款者乙&quot; , acct , 800).start(); new DepositThread(&quot;存款者丙&quot; , acct , 800).start(); } } 两个线程交替输出–使用synchronized_wait_notifyAll实现交替输出 printOdd线程执行该方法,拿走num对象的对象锁,并且输出printOdd–&gt;1,唤醒printEven线程,虽然printEven线程被唤醒,printEven线程并不会马上执行,因为printEven线程无法获取到num对象锁。当 printOdd方法执行this.wait(),printOdd线程无期限的等待, printOdd方法结束,释放对象锁,printEven线程获取到对象锁，开始printEven()方法 public class ThreadTest { public static void main(String[] args) throws InterruptedException { Num mun = new Num(); Thread printOdd = new Thread(new PrintOddThread(mun),&quot;printOdd&quot;); Thread printEven = new Thread(new PrintEvenThread(mun),&quot;printEven&quot;); printOdd.start(); Thread.sleep(1000); printEven.start(); } } // 定义线程共享的数据 class Num { int count=1; public synchronized void printOdd() throws InterruptedException { // 加上对象Num锁 System.out.println(Thread.currentThread().getName() + &quot;---&gt;&quot; + (count++)); this.notifyAll(); // 唤醒打印偶数的线程 this.wait(); // 奇数线程等待 } public synchronized void printEven() throws InterruptedException { // //加上对象Num锁 System.out.println(Thread.currentThread().getName() + &quot;---&gt;&quot; + (count++)); this.notifyAll(); // 唤醒打印奇数的线程 this.wait(); // 偶数线程等待 } } // 定义打印奇数线程 class PrintOddThread implements Runnable { Num num; public PrintOddThread(Num num) { this.num = num; } public void run() { while (true) { try { num.printOdd(); } catch (InterruptedException e) { e.printStackTrace(); } } } } // 定义打印偶数线程 class PrintEvenThread implements Runnable { Num num; public PrintEvenThread(Num num) { this.num = num; } public void run() { while (true) { try { num.printEven(); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } } 使用Condition控制线程通信 如果程序不使用 synchronized关键字来保证同步，而是直接使用Lock对象来保证同步，则系统中不存在隐式的同步监视器，也就不能使用wait()、 notify()、 notifyAll()方法进行线程通信了。当使用Lock对象来保证同步时，java提供了 C一个类来保持协调，使用 Condition可以让那些已经得到Lock对象却无法继续执行的线程释放Lock对象， Condition对象也可以唤醒其他处于等待的线程。Condition将同步监视器方法（wait()、 notify()和 notifyAll()）分解成截然不同的对象，以便通过将这些对象与Lock对象组合使用，为每个对象提供多个等待集（wait-set）。在这种情况下，Lock替代了同步方法或同步代码块， Condition替代了同步监视器的功能。Condition实例被绑定在一个Lock对象上.要获得特定Lock实例的 Condition实例，调用Lock对象的 newCondition方法即可。 Condition提供了如下三个方法。 import java.util.concurrent.*; import java.util.concurrent.locks.*; public class Account { // 显式定义Lock对象 private final Lock lock = new ReentrantLock(); // 获得指定Lock对象对应的Condition private final Condition cond = lock.newCondition(); // 封装账户编号、账户余额两个Field private String accountNo; private double balance; //标识账户中是否已有存款的旗标 private boolean flag = false; public Account(){} // 构造器 public Account(String accountNo , double balance) { this.accountNo = accountNo; this.balance = balance; } // accountNo的setter和getter方法 public void setAccountNo(String accountNo) { this.accountNo = accountNo; } public String getAccountNo() { return this.accountNo; } // 因此账户余额不允许随便修改，所以只为balance提供getter方法， public double getBalance() { return this.balance; } public void draw(double drawAmount) { // 加锁 lock.lock(); try { // 如果flag为假，表明账户中还没有人存钱进去，取钱方法阻塞 if (!flag) { cond.wait(); } else { // 执行取钱 System.out.println(Thread.currentThread().getName() + &quot; 取钱:&quot; + drawAmount); balance -= drawAmount; System.out.println(&quot;账户余额为：&quot; + balance); // 将标识账户是否已有存款的旗标设为false。 flag = false; // 唤醒其他线程 cond.signalAll(); } } catch (InterruptedException ex) { ex.printStackTrace(); } // 使用finally块来释放锁 finally { lock.unlock(); } } public void deposit(double depositAmount) { lock.lock(); try { // 如果flag为真，表明账户中已有人存钱进去，则存钱方法阻塞 if (flag) //① { cond.wait(); } else { // 执行存款 System.out.println(Thread.currentThread().getName() + &quot; 存款:&quot; + depositAmount); balance += depositAmount; System.out.println(&quot;账户余额为：&quot; + balance); // 将表示账户是否已有存款的旗标设为true flag = true; // 唤醒其他线程 cond.signalAll(); } } catch (InterruptedException ex) { ex.printStackTrace(); } // 使用finally块来释放锁 finally { lock.unlock(); } } } 使用阻塞队列(BlockingQueue)控制线程通信 java5提供了一个BlockingQueue接口，虽然BlockingQueue也是Queue的子接口，但它们主要用途并不是作为容器，而是作为线程同步的工具。BlockingQueue具有一个特征：当生产者线程试图向BlockingQueue中放入元素时，如果该队列已满，则该线程被阻塞；当消费者线程试图从BlockingQueue中取出元素时，如果该队列已空，则该线程被阻塞。程序的两个线程通过交替向BlockingQueue中放入元素，取出元素，即可很好的控制线程的通信。BlockingQueue提供如下两个支持阻塞的方法。 import java.util.concurrent.*; public class BlockingQueueTest { public static void main(String[] args) throws Exception { // 定义一个长度为2的阻塞队列 BlockingQueue&lt;String&gt; bq = new ArrayBlockingQueue&lt;&gt;(2); bq.put(&quot;Java&quot;);//与bq.add(&quot;Java&quot;、bq.offer(&quot;Java&quot;)相同 bq.put(&quot;Java&quot;);//与bq.add(&quot;Java&quot;、bq.offer(&quot;Java&quot;)相同 bq.put(&quot;Java&quot;);//① 阻塞线程。 } } 示例使用； import java.util.concurrent.*; class Producer extends Thread { private BlockingQueue&lt;String&gt; bq; public Producer(BlockingQueue&lt;String&gt; bq) { this.bq = bq; } public void run() { String[] strArr = new String[] { &quot;Java&quot;, &quot;Struts&quot;, &quot;Spring&quot; }; for (int i = 0 ; i &lt; 999999999 ; i++ ) { System.out.println(getName() + &quot;生产者准备生产集合元素！&quot;); try { Thread.sleep(200); // 尝试放入元素，如果队列已满，线程被阻塞 bq.put(strArr[i % 3]); } catch (Exception ex){ex.printStackTrace();} System.out.println(getName() + &quot;生产完成：&quot; + bq); } } } class Consumer extends Thread { private BlockingQueue&lt;String&gt; bq; public Consumer(BlockingQueue&lt;String&gt; bq) { this.bq = bq; } public void run() { while(true) { System.out.println(getName() + &quot;消费者准备消费集合元素！&quot;); try { Thread.sleep(200); // 尝试取出元素，如果队列已空，线程被阻塞 bq.take(); } catch (Exception ex){ex.printStackTrace();} System.out.println(getName() + &quot;消费完成：&quot; + bq); } } } public class BlockingQueueTest2 { public static void main(String[] args) { // 创建一个容量为1的BlockingQueue BlockingQueue&lt;String&gt; bq = new ArrayBlockingQueue&lt;&gt;(1); // 启动3条生产者线程 new Producer(bq).start(); new Producer(bq).start(); new Producer(bq).start(); // 启动一条消费者线程 new Consumer(bq).start(); } } // 输出结果: // Thread-0生产者准备生产集合元素！ // Thread-2生产者准备生产集合元素！ // Thread-1生产者准备生产集合元素！ // Thread-3消费者准备消费集合元素！ // Thread-0生产完成：[Java] // Thread-0生产者准备生产集合元素！ // Thread-3消费完成：[] // Thread-3消费者准备消费集合元素！ // Thread-2生产完成：[Java] // Thread-2生产者准备生产集合元素！ // Thread-3消费完成：[] // Thread-3消费者准备消费集合元素！ // Thread-2生产完成：[Struts] // Thread-2生产者准备生产集合元素！ // Thread-3消费完成：[] // Thread-3消费者准备消费集合元素！ // Thread-0生产完成：[Struts] // Thread-0生产者准备生产集合元素！ // Thread-3消费完成：[] // Thread-3消费者准备消费集合元素！ // Thread-1生产完成：[Java] // Thread-1生产者准备生产集合元素！ // Thread-3消费完成：[] // Thread-3消费者准备消费集合元素！ // Thread-2生产完成：[Spring] // Thread-2生产者准备生产集合元素！ // Thread-3消费完成：[] // ... 死锁public class DeadLock { public static void main(String[] args){ Object o1 = new Object(); Object o2 = new Object(); Thread t1 = new Thread(new T1(o1,o2)); Thread t2 = new Thread(new T2(o1,o2)); t1.start(); t2.start(); } } class T1 implements Runnable { Object o1; Object o2; T1(Object o1,Object o2){ this.o1 = o1; this.o2 = o2; } public void run(){ synchronized(o1){ // t1线程等 o2对象锁，o2对象锁被t2线程拿了，t2在等o1对象锁，o1对象锁被t1线程拿了,导致死锁 try{Thread.sleep(1000);}catch(Exception e){} synchronized(o2){ } } } } class T2 implements Runnable { Object o1; Object o2; T2(Object o1,Object o2){ this.o1 = o1; this.o2 = o2; } public void run(){ synchronized(o2){ try{Thread.sleep(1000);}catch(Exception e){} synchronized(o1){ } } } } 守护线程 其他所有的用户线程结束，则守护线程退出！ 守护线程一般都是无限执行的. 从线程分类上可以分为:用户线程（以上讲的都是用户线程），另一个是守护线程，守护线程是这样的，所有的用户线程结束生命周期，守护线程才会结束生命周期，只要有一个用户线程存在，那么守护线程就不会结束，例如java中著名的垃圾回收器就是一个守护线程只有应用程序中所有的线程结束，它才会结束 public class ThreadTest { public static void main(String[] args) throws InterruptedException { Processor p = new Processor(); Thread t = new Thread(p); t.setName(&quot;t&quot;); t.setDaemon(true); //将t线程设置为守护线程,即便t线程里面是死循环，也会等主线程main这个用户线程执行完 结束 t.start(); for (int i = 1; i &lt;= 10; i++) { System.out.println(Thread.currentThread().getName() + &quot; &quot; + i); } } } // 定义一个线程 class Processor implements Runnable { @Override public void run() { int i = 0; while (true) { System.out.println(Thread.currentThread().getName() + &quot; &quot; + i++); } } } 定时器 Timerpublic class ThreadTest { public static void main(String[] args) throws InterruptedException { Timer timer = new Timer(&quot;定时打开终端&quot;, true);//timer设置为守护线程，每隔 5s 打开当前目录 timer.schedule(new TermTimerTask(), new Date(), 5000); while(true) { } } } class TermTimerTask extends TimerTask { @Override public void run() { try { Runtime.getRuntime().exec(new String[] {&quot;/bin/sh&quot;,&quot;-c&quot;,&quot;open ~&quot;}); //Unix系统下 } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } 线程池 系统启动一个新线程的成本是比较高的，因为它涉及与操作系统交互。使用线程池可以很好地提高性能，尤其是当程序中需要创建大量生存期很短暂的线程时，更应该考虑使用线程池。除此之外，使用线程池可以有效地控制系统并发线程的数量，当系统中包含大量并发线程时，会导致系统性能剧烈下降，甚至导致JVM崩溃，而线程池的最大线程数参数可以控制系统中并发线程数不超过此数。 Java8改进的线程池 从Java5开始，Java内建支持线程池，新增了一个Executors工厂类来产生线程池，该工厂包含如下几个静态工厂方法来创建线程池。**newCachedThreadPool():**创建一个具有缓存功能的线程池，系统根据需要创建线程。**newFixedThreadPool(int nThreads):**创建一个可重用的，具有固定线程数的线程池。**newSingleThreadExecutor():**创建一个只有单线程的线程池，它相当于调用newFixedThreadPool(int nThreads)方法，参数传入1.**newScheduledThreadPool(int corePoolSize):**创建具有指定线程数的线程池，它可以在指定延迟后执行线程任务。corePoolSize指池中所保存的线程数。**newSingleThreadScheduledExecutor():**创建单个线程的线程池，指定延迟后执行线程任务。**ExecutorService newWorkStealingPool(int parallelism):**创建持有足够的线程的线程池来支持给定的并行级别，该方法还会使用多个队列来减少竞争。如果当前机器有4个CPU，则传入参数可以为4. ExecutorService ExecutorService代表尽快执行线程的线程池(只要线程池中有空闲线程，就立即执行线程任务)，程序只要将一个Runnnable对象或Callable对象提交给该线程池，就会尽快执行该任务。ExecutorService提供了如下三个方法。 Future&lt;?&gt; submit(Runnable task):其中Future对象代表Runnable任务的返回值，但run()方法没有返回值，所以Future对象将在run()执行后返回null。但可以调用Future的isDone()、isCancelled()方法获得Runnable对象的执行状态。 &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result):其中result显示指定线程执行结束后的返回值，所以Future对象将在run()方法执行结束后返回result。 &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task):其中Future代表Callable对象里call()方法的返回值。 ScheduledExecutorService ScheduledExecutorService代表可在指定延迟后或周期性地执行线程任务的线程池，它提供了如下4个方法。 &lt;V&gt; ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable, long delay, TimeUnit unit) ScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit) ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit):依次在initialDelay+period、initialDelay+2*period...处重复执行，以此类推。 ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit) import java.util.concurrent.*; class MyThread implements Runnable { public void run() { for (int i = 0; i &lt; 100 ; i++ ) { System.out.println(Thread.currentThread().getName() + &quot;的i值为:&quot; + i); } } } public class ThreadPoolTest { public static void main(String[] args) throws Exception { // 创建一个具有固定线程数（6）的线程池 ExecutorService pool = Executors.newFixedThreadPool(6); // 向线程池中提交两个线程 pool.submit(new MyThread()); pool.submit(new MyThread()); // 关闭线程池,表示不再接受新任务，但会将以前所有已提交任务执行完成。 pool.shutdown(); } } java8增强的ForkJoinPool Java7提供了ForkJoinPool来支持一个任务拆分成多个”小任务”并行计算，再把多个”小任务“的结果合并成总的计算结果。ForkJoinPool是ExecutorService的实现类，因此是一种特殊的线程池。ForkJoinPool提供了如下两个常用的构造器。 ForkJoinPool():以Runtime.getRuntime().availableProcessors()返回值作为parallelism参数来创建ForkJoinPool ForkJoinPool(int parallelism):创建一个包含parallelism个并行线程的ForkJoinPool。 RecursiveAction无返回任务示例将打印0~300，拆分多个任务完成 package com.example.demo; import java.util.concurrent.ForkJoinPool; import java.util.concurrent.RecursiveAction; import java.util.concurrent.TimeUnit; // 继承RecursiveAction来实现&quot;可分解&quot;的任务 class PrintTask extends RecursiveAction { // 每个“小任务”只最多只打印50个数 private static final int THRESHOLD = 50; private int start; private int end; // 打印从start到end的任务 public PrintTask(int start, int end) { this.start = start; this.end = end; } @Override protected void compute() { // 当end与start之间的差小于THRESHOLD时，开始打印 if(end - start &lt; THRESHOLD) { for (int i = start ; i &lt; end ; i++ ) { System.out.println(Thread.currentThread().getName() + &quot;的i值：&quot; + i); } } else { // 如果当end与start之间的差大于THRESHOLD时，即要打印的数超过50个 // 将大任务分解成两个小任务。 int middle = (start + end) /2; PrintTask left = new PrintTask(start, middle); PrintTask right = new PrintTask(middle, end); // 并行执行两个“小任务” left.fork(); right.fork(); } } } public class ForkJoinPoolTest { public static void main(String[] args) throws Exception { ForkJoinPool pool = new ForkJoinPool(); // 提交可分解的PrintTask任务 pool.submit(new PrintTask(0 , 300)); pool.awaitTermination(2, TimeUnit.SECONDS); // 关闭线程池 pool.shutdown(); } } RecursiveTask有返回值示例并行拆分计算长度100的数组的总和 package com.example.demo; import java.util.concurrent.*; import java.util.*; // 继承RecursiveTask来实现&quot;可分解&quot;的任务 class CalTask extends RecursiveTask&lt;Integer&gt; { // 每个“小任务”只最多只累加20个数 private static final int THRESHOLD = 20; private int arr[]; private int start; private int end; // 累加从start到end的数组元素 public CalTask(int[] arr , int start, int end) { this.arr = arr; this.start = start; this.end = end; } @Override protected Integer compute() { int sum = 0; // 当end与start之间的差小于THRESHOLD时，开始进行实际累加 if(end - start &lt; THRESHOLD) { for (int i = start ; i &lt; end ; i++ ) { sum += arr[i]; } return sum; } else { // 如果当end与start之间的差大于THRESHOLD时，即要打印的数超过20个 // 将大任务分解成两个小任务。 int middle = (start + end) /2; CalTask left = new CalTask(arr , start, middle); CalTask right = new CalTask(arr , middle, end); // 并行执行两个“小任务” left.fork(); right.fork(); // 把两个“小任务”累加的结果合并起来 return left.join() + right.join(); } } } public class Sum { public static void main(String[] args) throws Exception { int[] arr = new int[100]; Random rand = new Random(); int total = 0; // 初始化100个数字元素 for (int i = 0 , len = arr.length; i &lt; len ; i++ ) { int tmp = rand.nextInt(20); // 对数组元素赋值，并将数组元素的值添加到total总和中。 total += (arr[i] = tmp); } System.out.println(total); ForkJoinPool pool = new ForkJoinPool(); // 提交可分解的CalTask任务 Future&lt;Integer&gt; future = pool.submit(new CalTask(arr , 0 , arr.length)); System.out.println(future.get()); // 关闭线程池 pool.shutdown(); } } 线程相关类ThreadLocal类 通过使用ThreadLocal类可以简化多线程编程时的并发访问，使用这个工具类可以很简捷地隔离多线程程序的竞争资源。ThreadLocal，是 Thread Local Variable（线程局部变量）的意思，也许将它命名为 ThreadLocalVar更加合适。线程局部变量（ThreadLocal）的功用其实非常简单，就是为每一个使用该变量的线程都提供一个变量值的副本，使每一个线程都可以独立地改变自己的副本，而不会和其他线程的副本冲突。从线程的角度看，就好像每一个线程都完全拥有该变量一样。ThreadLocal类的用法非常简单，它只提供了如下三个 public方法。**get:**返回此线程局部变量中当前线程副本中的值。**void remove:**删除此线程局部变量中当前线程的值。**void set（ value）:**设置此线程局部变量中当前线程副本中的值。下面程序将向读者证明 ThreadLocal的作用。 package com.example.demo; class Account { /* 定义一个ThreadLocal类型的变量，该变量将是一个线程局部变量 每个线程都会保留该变量的一个副本 */ private ThreadLocal&lt;String&gt; name = new ThreadLocal&lt;&gt;(); // 定义一个初始化name属性的构造器 public Account(String str) { this.name.set(str); // 下面代码用于访问当前线程的name副本的值 System.out.println(&quot;---&quot; + this.name.get()); } // name的setter和getter方法 public String getName() { return name.get(); } public void setName(String str) { this.name.set(str); } } class MyTest extends Thread { // 定义一个Account属性 private Account account; public MyTest(Account account, String name) { super(name); this.account = account; } public void run() { // 循环10次 for (int i = 0 ; i &lt; 10 ; i++) { // 当i == 6时输出将账户名替换成当前线程名 if (i == 6) { account.setName(getName()); } // 输出同一个账户的账户名和循环变量 System.out.println(account.getName() + &quot; 账户的i值：&quot; + i); } } } public class ThreadLocalTest { public static void main(String[] args) { // 启动两条线程，两条线程共享同一个Account Account at = new Account(&quot;初始名&quot;); /* 虽然两条线程共享同一个账户，即只有一个账户名 但由于账户名是ThreadLocal类型的，所以每条线程 都完全拥有各自的账户名副本，所以从i == 6之后，将看到两条 线程访问同一个账户时看到不同的账户名。 */ new MyTest(at , &quot;线程甲&quot;).start(); new MyTest(at , &quot;线程乙&quot;).start (); } } // 输出结果: // ---初始名 // null 账户的i值：0 // null 账户的i值：1 // null 账户的i值：2 // null 账户的i值：3 // null 账户的i值：4 // null 账户的i值：5 // 线程甲 账户的i值：6 // 线程甲 账户的i值：7 // 线程甲 账户的i值：8 // 线程甲 账户的i值：9 // null 账户的i值：0 // null 账户的i值：1 // null 账户的i值：2 // null 账户的i值：3 // null 账户的i值：4 // null 账户的i值：5 // 线程乙 账户的i值：6 // 线程乙 账户的i值：7 // 线程乙 账户的i值：8 // 线程乙 账户的i值：9","link":"/2013/09/10/javase/JAVASE-%E5%A4%9A%E7%BA%BF%E7%A8%8B-10/"},{"title":"JAVA常用类库-日期操作类Date、Calendar,JDK8新日期时间操作","text":"Java原本提供了Date 和Calendar用于处理日期、时间的类，包括创建日期、时间对象，获取系统当前日期、时间等操作。但Date不仅无法实现国际化，而且它对不同属性也使用了前后矛盾的偏移量，比如月份与小时都是从0开始的，月份中的天数则是从1开始的，年又是从1900 开始的，而java.util.Calendar则显得过于复杂，从下面介绍中会看到传统Java对日期、时间处理的不足。Java 8吸取了Joda-Time库(一个被广泛使用的日期、时间库)的经验，提供了-套全新的日期时间库。 Calendar类 因为Date 类在设计.上存在一些缺陷，所以Java 提供了Calendar 类来更好地处理日期和时间。Calendar是-一个抽象类， 它用于表示日历。 Calendar类可以将取得的时间精确到毫秒。但是，这个类本身是一个抽象类，从之前学习到的知识可以知道，如果要想使用一个抽象类，则必须依靠对象的多态性，通过子类进行父类的实例化操作，Calendar的子类是GregorianCalendar类,代表了通常说的公历。 Calendar类是–个抽象类，所以不能使用构造器来创建Calendar对象。但它提供了几个静态.getInstance(方法来获取Calendar对象，这些方法根据TimeZone， Locale类来获取特定的Calendar， 如果不指定TimeZone、Locale， 则使用默认的TimeZone、Locale 来创建Calendar。 package com.ecit; import java.util.Calendar; import java.util.GregorianCalendar; public class CalendarDemo { private Calendar calendar = null ; // 声明一个Calendar对象，取得时间 public CalendarDemo(){ // 构造方法中直接实例化对象 this.calendar = new GregorianCalendar() ; } public String getDate(){ // 得到的是一个日期：格式为：yyyy-MM-dd HH:mm:ss.SSS // 考虑到程序要频繁修改字符串，所以使用StringBuffer提升性能 StringBuffer buf = new StringBuffer() ; buf.append(calendar.get(Calendar.YEAR)).append(&quot;-&quot;) ; // 增加年 buf.append(this.addZero(calendar.get(Calendar.MONTH)+1,2)).append(&quot;-&quot;) ; // 增加月 buf.append(this.addZero(calendar.get(Calendar.DAY_OF_MONTH),2)).append(&quot; &quot;) ; // 取得日 buf.append(this.addZero(calendar.get(Calendar.HOUR_OF_DAY),2)).append(&quot;:&quot;) ; // 取得时 buf.append(this.addZero(calendar.get(Calendar.MINUTE),2)).append(&quot;:&quot;) ; buf.append(this.addZero(calendar.get(Calendar.SECOND),2)).append(&quot;.&quot;) ; buf.append(this.addZero(calendar.get(Calendar.MILLISECOND),3)) ; return buf.toString() ; } public String getDateComplete(){ // 得到的是一个日期：格式为：yyyy年MM月dd日 HH时mm分ss秒SSS毫秒 // 考虑到程序要频繁修改字符串，所以使用StringBuffer提升性能 StringBuffer buf = new StringBuffer() ; buf.append(calendar.get(Calendar.YEAR)).append(&quot;年&quot;) ; // 增加年 buf.append(this.addZero(calendar.get(Calendar.MONTH)+1,2)).append(&quot;月&quot;) ; // 增加月 buf.append(this.addZero(calendar.get(Calendar.DAY_OF_MONTH),2)).append(&quot;日&quot;) ; // 取得日 buf.append(this.addZero(calendar.get(Calendar.HOUR_OF_DAY),2)).append(&quot;时&quot;) ; // 取得时 buf.append(this.addZero(calendar.get(Calendar.MINUTE),2)).append(&quot;分&quot;) ; // 取得分 buf.append(this.addZero(calendar.get(Calendar.SECOND),2)).append(&quot;秒&quot;) ; // 取得秒 buf.append(this.addZero(calendar.get(Calendar.MILLISECOND),3)).append(&quot;毫秒&quot;) ; // 取得毫秒 return buf.toString() ; } public String getTimeStamp(){ // 得到的是一个时间戳 // 考虑到程序要频繁修改字符串，所以使用StringBuffer提升性能 StringBuffer buf = new StringBuffer() ; buf.append(calendar.get(Calendar.YEAR)) ; // 增加年 buf.append(this.addZero(calendar.get(Calendar.MONTH)+1,2)) ; // 增加月 buf.append(this.addZero(calendar.get(Calendar.DAY_OF_MONTH),2)) ; // 取得日 buf.append(this.addZero(calendar.get(Calendar.HOUR_OF_DAY),2)) ; // 取得时 buf.append(this.addZero(calendar.get(Calendar.MINUTE),2)) ; // 取得分 buf.append(this.addZero(calendar.get(Calendar.SECOND),2)); // 取得秒 buf.append(this.addZero(calendar.get(Calendar.MILLISECOND),3)) ; // 取得毫秒 return buf.toString() ; } // 考虑到日期中存在前导0，所以在此处加上补零的方法 private String addZero(int num,int len){ StringBuffer s = new StringBuffer() ; s.append(num) ; while(s.length()&lt;len){ // 如果长度不足，则继续补0 s.insert(0,&quot;0&quot;) ; // 在第一个位置处补0 } return s.toString() ; } public static void main(String[] args) { CalendarDemo dt = new CalendarDemo(); System.out.println(&quot;系统日期：&quot;+dt.getDate()) ; System.out.println(&quot;中文日期：&quot;+dt.getDateComplete()) ; System.out.println(&quot;时间戳：&quot;+dt.getTimeStamp()) ; } } // 系统日期：2013-09-05 16:55:01.763 // 中文日期：2013年09月05日16时55分01秒763毫秒 // 时间戳：20130905165501763 Calendar类 add与 roll区别 **add(int field, int amount)**的功能非常强大，add 主要用于改变Calendar的特定字段的值。如果需要增加某字段的值，则让amount为正数;如果需要减少某字段的值，则让amount为负数即可。 1.当被修改的字段超出它允许的范围时，会发生进位，即上一级字段也会增大。例如: Calendar call = Calendar.getInstance() ; call.set(2003,7,23,0,0,0) ;// 2003-8-23 call.add (MONTH, 6) ; // 2003-8-23 =&gt; 2004-2-23 2.如果下一级字段也需要改变，那么该字段会修正到变化最小的值。例如: Calendar cal2 = Calendar.getInstance() ; cal2.set (2003,7,31,0,0,0); // 2003-8-31 // 因为进位后月份改为2月，2月没有31日，自动变成 29日 cal2.add (MONTH, 6) ; // 2003-8-31 =&gt; 2004-2-29 roll()的规则与add()的处理规则不同: 1.当被修改的字段超出它允许的范围时，上一级字段不会增大。 Calendar cal3 = Calendar.getInstance() ; cal3.set (2003,7,23,0,0,0) ;// 2003-8-23 // MONTH字段“进位”，但YEAR字段并不增加 cal3.roll(MONTH,6) ;// 2003-8-23 =&gt; 2003-2-23 2.下一级字段的处理规则与add()相似: Calendar cal4 = Calendar.getInstance() ; cal4.set(2003,7,31,0,0,0);// 2003-8-31 // MONTH字段“进位”后变成2，2月没有31日 // YEAR字段不会改变，2003年2月只有28天 cal4.roll(MONTH, 6); // 2003-8-31=&gt; 2003-2-28 JDK8 新增的日期、时间包Java 8 开始专 门新增了 一个 java.time 包， 该包下包含了 如下常用的类 : Clock: 该类用于获取指定时区的当前 日期、时间 。 该类可取代 System 类的 currentTimeMillis()方法，而且提供了更多方法来获取当前日期、时间 。 该类提供了大量静态方法来获取 Clock 对象 。 Duration: 该类代表持续时间 。 该类可 以非常方便地获取一段时间 。 Instant: 代表一个具体的时刻，可以精确到纳秒 。 该类提供了静态 的 now()方法来获取当前时刻，也提供了 静态的 now(Clock clock)方法来获取 clock 对应的时刻 。 除此之外， 它还提供了 一系列minusXxx()方法在当前时刻基础上减去一段时间 ， 也提供了 plusXxx()方法在当前时刻基础上加上一段时 间 。 LocalDate: 该类代表不带时区的日期 ，例如 2007-12-03 。 该类提供了静态的 now()方法来获取当前日期，也提供了静态的 now(Clock clock)方法来获取 clock 对应的日期 。 除此之外 ， 它还提供了 rninusXxxO方法在当前年份基础上减去几年、几月、几周或几日等，也提供了 plusXxx()方法在当前年份基础上加上几年、几月、几周或几日等 。 LocalTime: 该类代表不带时 区的 时间，例如 10:15 : 30 。 该类提供了静态的 now()方法来获取当前时间，也提供了静态的 now(Clock clock)方法来获取 clock 对应的时间 。 除此之外，它还提供了 rninusXxx()方法在当前年份基础上减去几小时、几分、几秒等，也提供了plusXxx()方法在当前年份基础上加上几小时、几分、 几秒等。 LocalDateTime: 该类代表不带时区的日期 、时间， 例如 2007-12-03Tl 0: 15 :3 0 。 该类提供了静态的 now()方法来获取当前日期、 时间，也提供 了静态的 now(Clock clock)方法来获取 clock 对应的日期、时间 。 除此之外，它还提供了 minusXxx()方法在当前年份基础上减去几年 、几月 、几日、几小时、几分、 几秒等， 也提供 了 plusXxxO方法在当前年份基础上加上几年、几月 、几日、几小时、几分 、 几秒等 。 MonthDay: 该类仅代表月日 ，例如一04-12 。 该类提供了静态 的 nowO方法来获取当前月日 ，也提供了静态的 now(Clock clock)方法来获取 clock 对应的月日 。 Year: 该类仅代表年，例如 2014 。 该类提供了静态的 now()方法来获取当前年份 ，也提供了静态的 now(Clock clock)方法来获取 clock 对应的年份 。 除此之外，它还提供了 rninusYears()方法在当前年份基础上减去几年 ，也提供了 plusYears()方法在当前年份基础上加上几年 。 YearMonth: 该类仅代表年月 ，例如 2014-04 。 该类提供了静态的 nowO方法来获取当前年月，也提供了静态的 now(Clock clock)方 法来获取 clock 对 应的年月 。 除此之外 ，它还提供了rninusXxx()方法在当前年月基础上减去几年 、几月 ，也提供了 plusXxx()方法在当前年月基础上加上几年、几月 。 ZonedDateTime: 该类代表一个时区化的日期 、时间 。 Zoneld: 该类代表一个时区 。 DayOtweek: 这是一个枚举类，定义了周日到周六的枚举值 。 Month: 这也是一个枚举类，定义了 一月到十二月的枚举值 。 package com.ecit; import java.time.*; public class CalendarDemo { public static void main(String[] args) { // -----下面是关于Clock的用法----- // 获取当前Clock Clock clock = Clock.systemUTC(); // 通过Clock获取当前时刻 System.out.println(&quot;当前时刻为：&quot; + clock.instant()); // 获取clock对应的毫秒数，与System.currentTimeMillis()输出相同 System.out.println(clock.millis()); System.out.println(System.currentTimeMillis()); // -----下面是关于Duration的用法----- Duration d = Duration.ofSeconds(6000); System.out.println(&quot;6000秒相当于&quot; + d.toMinutes() + &quot;分&quot;); System.out.println(&quot;6000秒相当于&quot; + d.toHours() + &quot;小时&quot;); System.out.println(&quot;6000秒相当于&quot; + d.toDays() + &quot;天&quot;); // 在clock基础上增加6000秒，返回新的Clock Clock clock2 = Clock.offset(clock, d); // 可看到clock2与clock1相差1小时40分 System.out.println(&quot;当前时刻加6000秒为：&quot; +clock2.instant()); // -----下面是关于Instant的用法----- // 获取当前时间 Instant instant = Instant.now(); System.out.println(instant); // instant添加6000秒（即100分钟），返回新的Instant Instant instant2 = instant.plusSeconds(6000); System.out.println(instant2); // 根据字符串中解析Instant对象 Instant instant3 = Instant.parse(&quot;2014-02-23T10:12:35.342Z&quot;); System.out.println(instant3); // 在instant3的基础上添加5小时4分钟 Instant instant4 = instant3.plus(Duration .ofHours(5).plusMinutes(4)); System.out.println(instant4); // 获取instant4的5天以前的时刻 Instant instant5 = instant4.minus(Duration.ofDays(5)); System.out.println(instant5); // -----下面是关于LocalDate的用法----- LocalDate localDate = LocalDate.now(); System.out.println(localDate); // 获得2014年的第146天 localDate = LocalDate.ofYearDay(2014, 146); System.out.println(localDate); // 2014-05-26 // 设置为2014年5月21日 localDate = LocalDate.of(2014, Month.MAY, 21); System.out.println(localDate); // 2014-05-21 // -----下面是关于LocalTime的用法----- // 获取当前时间 LocalTime localTime = LocalTime.now(); // 设置为22点33分 localTime = LocalTime.of(22, 33); System.out.println(localTime); // 22:33 // 返回一天中的第5503秒 localTime = LocalTime.ofSecondOfDay(5503); System.out.println(localTime); // 01:31:43 // -----下面是关于localDateTime的用法----- // 获取当前日期、时间 LocalDateTime localDateTime = LocalDateTime.now(); // 当前日期、时间加上25小时３分钟 LocalDateTime future = localDateTime.plusHours(25).plusMinutes(3); System.out.println(&quot;当前日期、时间的25小时3分之后：&quot; + future); // 下面是关于Year、YearMonth、MonthDay的用法示例----- Year year = Year.now(); // 获取当前的年份 System.out.println(&quot;当前年份：&quot; + year); // 输出当前年份 year = year.plusYears(5); // 当前年份再加5年 System.out.println(&quot;当前年份再过5年：&quot; + year); // 根据指定月份获取YearMonth YearMonth ym = year.atMonth(10); System.out.println(&quot;year年10月：&quot; + ym); // 输出XXXX-10，XXXX代表当前年份 // 当前年月再加5年，减3个月 ym = ym.plusYears(5).minusMonths(3); System.out.println(&quot;year年10月再加5年、减3个月：&quot; + ym); MonthDay md = MonthDay.now(); System.out.println(&quot;当前月日：&quot; + md); // 输出--XX-XX，代表几月几日 // 设置为5月23日 MonthDay md2 = md.with(Month.MAY).withDayOfMonth(23); System.out.println(&quot;5月23日为：&quot; + md2); // 输出--05-23 } }","link":"/2013/09/05/javase/JAVASE-%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%BA%93-05/"},{"title":"JAVA常用类库-时间格式器，数字格式器，Math类，Random类,BigInteger类，BigDecimal类","text":"DateFormat类 在java.util.Date类中实际上取得的时间是一个非常正确的时间。但是因为其显示的格式不理想，所以无法符合国人的喜好，那么实际上此时就可以为此类进行格式化操作，变为符合于中国人的日期格式。另外要提醒读者的是DateFormat类与MessageFormat类都属于Format类的子类，专门用于格式化数据使用。DateFormat的parse()方法可以把一个字符串解析成Date对象，但它要求被解析的字符串必须符合日期字符串的要求，否则可能抛出ParseException异常。 import java.text.DateFormat; import java.util.Date; import java.util.Locale; public class DateFormatDemo { public static void main(String[] args) { DateFormat df1 = null ; // 声明一个DateFormat DateFormat df2 = null ; // 声明一个DateFormat df1 = DateFormat.getDateInstance() ; // 得到日期的DateFormat对象 df2 = DateFormat.getDateTimeInstance() ; // 得到日期时间的DateFormat对象 System.out.println(&quot;DATE：&quot; + df1.format(new Date())) ; // 按照日期格式化 System.out.println(&quot;DATETIME：&quot; + df2.format(new Date())) ; // 按照日期时间格式化 df1 = DateFormat.getDateInstance(DateFormat.YEAR_FIELD, Locale.CHINA); df2 = DateFormat.getDateTimeInstance(DateFormat.YEAR_FIELD, DateFormat.ERA_FIELD, Locale.CHINA); System.out.println(&quot;DATE：&quot; + df1.format(new Date())); System.out.println(&quot;DATETIME：&quot; + df2.format(new Date())); df1 = DateFormat.getDateInstance(DateFormat.YEAR_FIELD, Locale.US); df2 = DateFormat.getDateTimeInstance(DateFormat.YEAR_FIELD, DateFormat.ERA_FIELD, Locale.US); System.out.println(&quot;DATE：&quot; + df1.format(new Date())); System.out.println(&quot;DATETIME：&quot; + df2.format(new Date())); String str1 = &quot;2014-12-12&quot;; String str2 = &quot;2014年12月10日&quot;; //下面输出Fri Dec 12 00:00:00 CST 2014 System.out.println(DateFormat.getDateInstance().parse(str1)) ; //下面输出Wed Dec 10 00:00:00 CST 2014 System.out.println (DateFormat.getDateInstance(LONG).parse (str2)) ; //下面抛出ParseException 异常 System.out.println (DateFormat.getDateInstance().parse(str2)) ; } } SimpleDateFormat DateFormat的parse(方法可以把字符串解析成Date对象，但实际上DateFormat的parse()方法不够灵活一它 要求被解析的字符串必须满足特定的格式!为了更好地格式化日期、解析日期字符串，Java提供了SimpleDateFormat 类。SimpleDateFormat是DateFormat的子类，正如它的名字所暗示的，它是“简单”的日期格式器。很多读者对“简单”的日期格式器不屑一顾，实际上SimpleDateFormat比DateFormat更简单，功能更强大。 public class DateDemo{ public static void main(String args[]){ String strDate = &quot;2008-10-19 10:11:30.345&quot; ; // 准备第一个模板，从字符串中提取出日期数字 String pat1 = &quot;yyyy-MM-dd HH:mm:ss.SSS&quot; ; // 准备第二个模板，将提取后的日期数字变为指定的格式 String pat2 = &quot;yyyy年MM月dd日 HH时mm分ss秒SSS毫秒&quot; ; SimpleDateFormat sdf1 = new SimpleDateFormat(pat1) ; // 实例化模板对象 SimpleDateFormat sdf2 = new SimpleDateFormat(pat2) ; // 实例化模板对象 Date d = null ; try{ d = sdf1.parse(strDate) ; // 将给定的字符串中的日期提取出来 }catch(Exception e){ // 如果提供的字符串格式有错误，则进行异常处理 e.printStackTrace() ; // 打印异常信息 } System.out.println(sdf2.format(d)) ; // 将日期变为新的格式 } } Java8新增的日期、时间格式器 Java 8新增的日期、时间API里不仅包括了Instant、 LocalDate、 LocalDateTime、 LocalTime 等代表日期、时间的类，而且在java.time.format 包下提供了-一个Date TimeFormatter格式器类，该类相当于前面介绍的DateFormat和SimpleDateFormat的合体，功能非常强大。与DateFormat、SimpleDateFormat类似，Date TimeFormatter不仅可以将日期、时间对象格式化成字符串，也可以将特定格式的字符串解析成日期、时间对象。为了使用DateTimeFormatter 进行格式化或解析，必须先获取DateTimeFormatter 对象，获取DateTimeFormatter对象有如下三种常见的方式。 直接使用静态常量创建DateTimeFormatter 格式器。DateTimeFormatter 类中包含了大量形如ISO_LOCAL_DATE、ISO_LOCAL_TIME、ISO_LOCAL_DATE_TIME等静态常量，这些静态常量本身就是DateTimeFormatter实例。 使用代表不同风格的枚举值来创建DateTimeFormatter格式器。在FormatStyle枚举类中定义了FULL、LONG、MEDIUM、SHORT四个枚举值，它们代表日期、时间的不同风格。 调用DateTimeFormatter的format(TemporalAccessor temporal)方法执行格式化，其中LocalDate、LocalDateTime、LocalTime 等类都是TemporalAccessor接口的实现类。 调用LocalDate、 LocalDateTime、 LocalTime 等日期、时间对象的format(DateTimeFormatter formatter)方法执行格式化。 import java.text.ParseException; import java.time.LocalDateTime; import java.time.format.DateTimeFormatter; import java.time.format.FormatStyle; public class NewDateFormatDemo { public static void main(String[] args) throws ParseException { DateTimeFormatter[] formatters = new DateTimeFormatter[]{ //直接使用常量创建DateTimeFormatter格式器 DateTimeFormatter.ISO_LOCAL_DATE, DateTimeFormatter.ISO_LOCAL_TIME, DateTimeFormatter.ISO_LOCAL_DATE_TIME, //使用本地化的不同风格来创建DateTimeFormatter格式器 DateTimeFormatter.ofLocalizedDateTime(FormatStyle.LONG, FormatStyle.LONG), DateTimeFormatter.ofLocalizedTime(FormatStyle.LONG), //根据模式字符串来创建DateT imeFormatter格式器 DateTimeFormatter.ofPattern(&quot;Gyyyy-MM-dd HH:mm:ss&quot;) }; LocalDateTime date = LocalDateTime.now(); //依次使用不同的格式器对LocalDateTime进行格式化 for (int i = 0; i &lt; formatters.length; i++) { System.out.println(formatters[i].format(date)); } } } NumberFormat类 NumberFormat也是一个抽象基类,所以无法通过它的构造器来创建NumberFormat对象，它提供了如下几个类方法来得到NumberFormat对象。NumberFormat nf = null ; // 声明一个NumberFormat对象 nf = NumberFormat.getInstance() ; // 得到默认的数字格式化显示 System.out.println(&quot;格式化之后的数字：&quot; + nf.format(10000000)) ; System.out.println(&quot;格式化之后的数字：&quot; + nf.format(1000.345)) ; // 格式化之后的数字：10,000,000 // 格式化之后的数字：1,000.345 DecimalFormat DecimalFormat也是Format的一个子类，主要的作用是用来格式化数字使用，当然，在格式化数字的时候要比直接使用NumberFormat更加方便，因为可以直接指定按用户自定义的方式进行格式化操作，与之前讲解的SimpleDateFormat类似，如果要想进行自定义格式化操作，则必须指定格式化操作的模板。import java.text.DecimalFormat; import java.text.ParseException; public class FormatDemo { public static void main(String[] args) throws ParseException { FormatDemo demo = new FormatDemo() ; demo.format1(&quot;###,###.###&quot;, 111222.34567); demo.format1(&quot;000,000.000&quot;, 11222.34567); demo.format1(&quot;###,###.###￥&quot;, 111222.34567); demo.format1(&quot;000,000.000￥&quot;, 11222.34567); demo.format1(&quot;##.###%&quot;, 0.345678); // 使用百分数形式 demo.format1(&quot;00.###%&quot;, 0.0345678); // 使用百分数形式 demo.format1(&quot;###.###\\u2030&quot;, 0.345678); // 使用千分数形式 demo.format1(&quot;###.###\\u00A4&quot;, 0.345678); // 使用千分数形式 } public void format1(String pattern,double value){ DecimalFormat df = null ; // 声明一个DecimalFormat对象 df = new DecimalFormat(pattern) ; // 实例化对象 String str = df.format(value) ; // 格式化数字 System.out.println(&quot;使用&quot; + pattern + &quot;格式化数字: &quot;+value+&quot;：&quot; + str); } } /** 输出结果： 使用###,###.###格式化数字: 111222.34567：111,222.346 使用000,000.000格式化数字: 11222.34567：011,222.346 使用###,###.###￥格式化数字: 111222.34567：111,222.346￥ 使用000,000.000￥格式化数字: 11222.34567：011,222.346￥ 使用##.###%格式化数字: 0.345678：34.568% 使用00.###%格式化数字: 0.0345678：03.457% 使用###.###‰格式化数字: 0.345678：345.678‰ 使用###.###¤格式化数字: 0.345678：0.346￥ **/ Math类 Math类是数学操作类，提供了一系列的数学操作方法，包括求绝对值、三角函数等，在Math类中提供的一切方法都是静态方法，所以直接由类名称调用即可。System.out.println(&quot;求平方根：&quot; + Math.sqrt(9.0)); System.out.println(&quot;求两数的最大值：&quot; + Math.max(10,30)); System.out.println(&quot;求两数的最小值：&quot; + Math.min(10,30)); System.out.println(&quot;2的3次方：&quot; + Math.pow(2,3)); System.out.println(&quot;四舍五入：&quot; + Math.round(33.6)); Java7的ThreadLocalRandom与Random Random是随机数产生类，可以指定一个随机数的范围，之后可以任意产生在此范围中的数字。 Random类专门用于生成一个伪随机数，它有两个构造器:–个构造器使用默认的种子(以当前时间作为种子)，另一个构造器需要程序员显式传入一一个long型整数的种子。 ThreadLocalRandom类是Java 7新增的一个类， 它是Random的增强版。在并发访问的环境下，使用ThreadLocalRandom来代替Random可以减少多线程资源竞争,最终保证系统具有更好的线程安全性。 ThreadLocalRandom类的用法与Random类的用法基本相似，它提供了- -个静态的current()方法来获取ThreadLocalRandom对象，获取该对象之后即可调用各种nextXxx()方法来获取伪随机数了。ThreadLocalRandom与Random都比Math的random()方法提供了更多的方式来生成各种伪随机数,可以生成浮点类型的伪随机数，也可以生成整数类型的伪随机数，还可以指定生成随机数的范围。关于Random类的用法如下程序所示。ThreadLocalRandom rand = ThreadLocalRandom.current () ;//生成一个4~20之间的伪随机整数 int vall = rand. nextInt (4,20) ; //生成一个2.0~10.0之间的伪随机浮点数 double val2 = rand. nextDouble(2.0,10.0) ; BigInteger类 如果在操作的时候一个整型数据已经超过了整数的最大类型长度long的话，则此数据就无法装入，所以，此时要使用BigInteger类进行操作。BigInteger bi1 = new BigInteger(&quot;123456789&quot;) ; // 定义BigInteger对象 BigInteger bi2 = new BigInteger(&quot;987654321&quot;) ; // 定义BigInteger对象 System.out.println(&quot;加法操作：&quot; + bi2.add(bi1)); // 加法操作 System.out.println(&quot;减法操作：&quot; + bi2.subtract(bi1)); // 减法操作 System.out.println(&quot;乘法操作：&quot; + bi2.multiply(bi1)); // 乘法操作 System.out.println(&quot;除法操作：&quot; + bi2.divide(bi1)); // 除法操作 System.out.println(&quot;最大数：&quot; + bi2.max(bi1)); // 求出最大数 System.out.println(&quot;最小数：&quot; + bi2.min(bi1)); // 求出最小数 BigInteger result[] = bi2.divideAndRemainder(bi1) ; // 除法操作 System.out.println(&quot;商是：&quot; + result[0] + &quot;；余数是：&quot; + result[1]); BigDecimal类 对于不需要任何准确计算精度的程序可以直接使用float或double完成，但是如果需要精确计算的结果，则必须使用BigDecimal类package com.ecit; import java.math.* ; class MyMath{ public static double add(double d1,double d2){ // 进行加法计算 BigDecimal b1 = new BigDecimal(d1) ; BigDecimal b2 = new BigDecimal(d2) ; return b1.add(b2).doubleValue() ; } public static double sub(double d1,double d2){ // 进行减法计算 BigDecimal b1 = new BigDecimal(d1) ; BigDecimal b2 = new BigDecimal(d2) ; return b1.subtract(b2).doubleValue() ; } public static double mul(double d1,double d2){ // 进行乘法计算 BigDecimal b1 = new BigDecimal(d1) ; BigDecimal b2 = new BigDecimal(d2) ; return b1.multiply(b2).doubleValue() ; } public static double div(double d1,double d2,int len){ // 进行乘法计算 BigDecimal b1 = new BigDecimal(d1) ; BigDecimal b2 = new BigDecimal(d2) ; return b1.divide(b2,len,BigDecimal.ROUND_HALF_UP).doubleValue() ; } public static double round(double d,int len){ // 进行四舍五入 BigDecimal b1 = new BigDecimal(d) ; BigDecimal b2 = new BigDecimal(1) ; return b1.divide(b2,len,BigDecimal.ROUND_HALF_UP).doubleValue() ; } } public class BigDecimalDemo01{ public static void main(String args[]){ System.out.println(&quot;加法运算：&quot; + MyMath.round(MyMath.add(10.345,3.333),1)) ; System.out.println(&quot;减法运算：&quot; + MyMath.round(MyMath.sub(10.345,3.333),3)) ; System.out.println(&quot;乘法运算：&quot; + MyMath.round(MyMath.mul(10.345,3.333),2)) ; System.out.println(&quot;除法运算：&quot; + MyMath.div(10.345,3.333,5)) ; } }","link":"/2013/09/06/javase/JAVASE-%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%BA%93-06/"},{"title":"JAVA异常机制","text":"异常 异常是导致程序中断运行的一种指令流，如果不对异常进行正确的处理，则可能导致程序的中断执行，造成不必要的损失，所以在程序的设计中必须要考虑各种异常的发生，并正确的做好相应的处理，这样才能保证程序正常的执行 异常处理格式 ps:在异常处理中，捕获更粗的异常要放在捕获更细的异常之后。使用try…catch和try…catch…finally可以处理异常，finally将作为异常的统一出口，不管是否有异常都会执行此语句。 异常类的继承结构 在整个Java的异常结构中，实际上有以下两个最常用的类:Exception、Error,这两个类全部是Throwable子类**Exception:**一般表示的是程序中出现的问题，可以直接使用try…catch处理。**Error:**一般指的是JVM错误，程序中无法处理 throws与throw关键字throws关键字 在定义一个方法的时候可以使用throws关键字声明，使用throws声明的方法表示此方法不处理异常，而交给方法的调用处进行处理。 throws使用格式 public 返回类型 方法名称(参数列表...) throws 异常类{} throw关键字 throw关键字的作用是在程序中抛出一个异常。抛出的时候抛出的是一个异常类的实例化对象。 throw与throws的应用 在一般的开发中try…catch…finally、throw、throws联合使用的情况是最多的，例如：要设计一个相除的方法，但是在进行操作之前必须打印”计算开始的“信息、结束之后打印”异常结束”的信息，如果有异常的话，则应该把异常交给被调用处处理，面对这样的要求，就必须使用以上的全部操作。 class Math{ public int div(int i,int j) throws Exception{ // 定义除法操作，如果有异常，则交给被调用处处理 System.out.println(&quot;***** 计算开始 *****&quot;) ; int temp = 0 ; // 定义局部变量 try{ temp = i / j ; // 计算，但是此处有可能出现异常 }catch(Exception e){ throw e ; }finally{ // 不管是否有异常，都要执行统一出口 System.out.println(&quot;***** 计算结束 *****&quot;) ; } return temp ; } } public class ThrowDemo02{ public static void main(String args[]){ Math m = new Math() ; try{ System.out.println(&quot;除法操作：&quot; + m.div(10,0)) ; }catch(Exception e){ System.out.println(&quot;异常产生：&quot; + e) ; } } } Exception与RuntimeException的区别 Exception在程序中是必须使用try…catch进行处理RuntimeException可以不使用try…catch进行处理，但是如果有异常产生，则异常将由JVM进行处理 断言 断言在实际开发使用并不是很常见，简单了解即可 public class TestDemo { public static void main(String args[]) { int num = 10; // 假设中间可能经过了20行代码来操作num的内容，期望中的内容应该是20 assert num == 20 : &quot;num的内容不是20&quot;;// 进行断言操作 System.out.println(&quot;num = &quot; + num); } } assert关键字是在JDK 1.4的时候引入的，其主要的功能是进行断言。断言指的是程序执行到某行之后，其结果一定是预期的结果。这是因为Java默认情况下是不开启断言的。断言本身不会影响程序的执行，如果要想启用断言，则应该增加一些选项： java -ea TestDemo 而增加“-ea”参数之后，本程序就会出现如下的错误信息","link":"/2013/09/09/javase/JAVASE-%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6-09/"},{"title":"JAVA引用传递分析","text":"##引用传递分析 引用传递例子一class Demo { int temp = 30; // 此处为了方便，属性暂时不封装 } public class RefDemo01 { public static void main(String args[]) { Demo d1 = new Demo(); // 实例化Demo对象，实例化之后里面的temp=30 d1.temp = 50; // 修改temp属性的内容 System.out.println(&quot;fun()方法调用之前：&quot; + d1.temp); fun(d1); System.out.println(&quot;fun()方法调用之后：&quot; + d1.temp); } public static void fun(Demo d2) { // 此处的方法由主方法直接调用 d2.temp = 1000; // 修改temp值 } } //输出结果: //fun()方法调用之前：50 //fun()方法调用之后：1000 图示内存分析： 引用传递例子二public class RefDemo02{ public static void main(String args[]){ String str1 = &quot;hello&quot; ; // 实例化字符串对象 System.out.println(&quot;fun()方法调用之前：&quot; + str1) ; fun(str1) ; // 调用fun()方法 System.out.println(&quot;fun()方法调用之后：&quot; + str1) ; } public static void fun(String str2){ // 此处的方法由主方法直接调用 str2 = &quot;world&quot; ; // 修改字符串内容,实际是将world放在了字符创常量池中,然后str2,指向了 world } } //输出结果: //fun()方法调用之前：hello //fun()方法调用之后：hello 图示内存分析： 引用传递例子三class Demo{ String temp = &quot;hello&quot; ; // 此处为了方便，属性暂时不封装 } public class RefDemo03{ public static void main(String args[]){ Demo d1 = new Demo() ; // 实例化Demo对象，实例化之后里面的temp=30 d1.temp = &quot;world&quot; ; // 修改temp属性的内容 System.out.println(&quot;fun()方法调用之前：&quot; + d1.temp) ; fun(d1) ; System.out.println(&quot;fun()方法调用之后：&quot; + d1.temp) ; } public static void fun(Demo d2){ // 此处的方法由主方法直接调用 d2.temp = &quot;china&quot;; // 修改temp值 } } //输出结果: //fun()方法调用之前：world //fun()方法调用之后：china 图示内存分析：更严格的内存分析如下：","link":"/2013/09/06/javase/JAVASE-%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E5%88%86%E6%9E%90-06/"},{"title":"JAVA抽象类和接口，枚举","text":"抽象类 有时候我们需要编写一些预制的代码，但是这些代码中的某一部分我们没有办法给一个具体的实现。打一个比方，我们设计一个抽象的流的代码，给这个流读取、写入、序列化、转换为字符串、转接到另一个流等操作。显然，其它方法我们可以写出来，但是读取写入我们没法写。不同的流，io是不同的，对不对？此时我们怎么做？只能用抽象类了。 抽象类概念 包含一个抽象方法的类就称为抽象类。 抽象方法 只声明而未实现的方法称为抽象方法，抽象方法必须使用abstract关键字声明 抽象类使用规则 包含一个抽象方法的类必须是抽象类； 抽象类和抽象方法都要使用abstract关键字声明； 抽象方法只需声明而不需要实现； 抽象类必须被子类继承，子类（如果不是抽象类）必须覆写抽象类中的全部抽象方法。 抽象类不能被实例化，无法使用new关键字来调用抽象类的构造器创建抽象类的实例。 抽象类定义格式abstract class 抽象类名称{ 属性； 访问权限 返回值类型 方法名称(参数){ //普通方法 [return 返回值]; } 访问权限 abstract 返回值类型 方法名称(参数){ //抽象方法 [return 返回值]; } } 示例代码:abstract class Person{ private String name ; // 定义name属性 private int age ; // 定义age属性 public Person(String name,int age){ this.name = name ; this.age = age ; } public void setName(String name){ this.name = name ; } public void setAge(int age){ this.age = age ; } public String getName(){ return this.name ; } public int getAge(){ return this.age ; } public abstract String getInfo() ; // 抽象方法 } class Student extends Person{ private String school ; public Student(String name,int age,String school){ super(name,age) ; // 指定要调用抽象类中有两个参数的构造方法 this.school = school ; } public void setSchool(String school){ this.school = school ; } public String getSchool(){ return this.school ; } public String getInfo(){ return &quot;姓名：&quot; + super.getName() + &quot;；年龄：&quot; + super.getAge() + &quot;；学校：&quot; + this.getSchool() ; } } public class AbstractDemo04{ public static void main(String args[]){ Student stu = new Student(&quot;张三&quot;,30,&quot;清华大学&quot;) ; System.out.println(stu.getInfo()) ; } } ps:抽象类不能使用final关键字声明，final定义的类是不能有子类的，抽象类是必须有子类的。 接口 抽象类是从多个类中抽象出来的模板，如果将这种抽象进行得更彻底，则可以提炼出一种更加特殊的”抽象类“–接口(interface)，接口里不能包含普通方法，接口里所有方法都是抽象方法。可以理解为接口是一种特殊的类，里面全部是由全局常量和公共的抽象方法组成。Java8对接口进行了改进，允许在接口中定义默认方法和类方法，默认方法可以提供方法实现。 接口定义(java8标准)[修饰符] interface 接口名 extends 父接口1，父接口2...{ 零到多个常量定义... 零到多个抽象方法定义... 零到多个内部类，接口，枚举定义... 零到多个默认方法或类方法定义... } 示例代码： public interface Output{ //接口里定义的成员变量只能是常量，始终是public static final修饰的，没写的话系统自动默认添加 int MAX_CACHE_LINE = 50; //接口里定义的普通方法只能是public的抽象方法 void out(); void getData(String msg) //在接口中定义默认方法，需要使用default修饰，默认方法也总是使用public修饰，public可以选择性省略 default void print(String... msgs){ for (String msg : msgs) { System.out.println(msg); } } //在接口中定义类方法，需要使用static修饰，类方法也总是使用public修饰，public可以选择性省略 static String staticTest(){ return &quot;接口里的类方法&quot;; } } 注意事项 修饰符可以是public或者省略，如果省略了public访问控制符，则默认采用包权限访问控制符。 接口里定义的方法只能是抽象方法，类方法或默认方法，因此如果不是定义默认方法，系统将自动为普通方法增加abstract修饰符； 接口里定义的内部类，内部接口，内部枚举默认采用public static 两个修饰符，不管定义时是否指定这两个修饰符，系统都会自动使用public static对它们进行修饰。实现接口与抽象类一样，接口要使用也必须通过子类，子类通过implements关键字实现接口。class 子类 implements 接口A，接口B，...{ } 一个子类可以同时继承抽象类和实现接口class 子类 extends 抽象类 implements 接口A，接口B，...{} 匿名内部类 内部类指的是在一个类的内部定义了另外的类结构，利用内部类可以方便的实现私有属性的互相访问，但是内部类是需要明确的使用class进行定义的。而匿名内部类的是没有名字的内部类，但是其必须在抽象类或接口基础上才可以定义。 枚举 在JDK 1.5之后，引入了一个新的关键字类型 —— enum，可以直接定义枚举类型，格式如下： [public] enum 枚举类型名称{ 枚举对象1,枚举对象2,…,枚举对象n ; } public enum Color { // 定义枚举类型 RED, GREEN, BLUE; // 定义枚举的三个类型 } 从前面已经清楚的知道，使用enum关键字可以定义一个枚举，实际上此关键字表示的是java.lang.Enum类型，即：使用enum声明的枚举类型，就相当于定义一个类，而此类则默认继承java.lang.Enum类。java.lang.Enum类的定义如下: public abstract class Enum&lt;E extends Enum&lt;E&gt;&gt; extends Object implements Comparable&lt;E&gt;, java.io.Serializable 在枚举类建立完成之后，实际上都会为其调用枚举类中的构造方法，为其赋值，在Enum类的构造方法中的第一个参数name就是定义的枚举的名称，第二个参数ordinal则会从0开始依次进行编号。之后可以使用Enum类中提供的name()和ordinal()方法取得名字和编号。public enum Color { // 定义枚举类型 RED, GREEN, BLUE; // 定义枚举的三个类型 public static void main(String[] args) { for(Color c:Color.values()){ // 枚举.values()表示得到全部枚举的内容 System.out.println(c.ordinal() + &quot; --&gt; &quot; + c.name()) ; } } } /** 输出结果： 0 --&gt; RED 1 --&gt; GREEN 2 --&gt; BLUE **/ 通过构造方法为属性赋值 enum Color { RED(&quot;红色&quot;), GREEN(&quot;绿色&quot;), BLUE(&quot;兰色&quot;); // 定义枚举的三个类型 private Color(String name){ // 定义构造方法 this.setName(name) ; // 设置名字 } private String name ; // 定义name属性 public String getName() { // 取得name属性 return name; } public void setName(String name) { // 设置name属性 this.name = name; } } public class ConstructorEnum { public static void main(String[] args) { for(Color c:Color.values()){ // 枚举.values()表示得到全部枚举的内容 System.out.println(c.ordinal() + &quot; --&gt; &quot; + c.name() + &quot;(&quot; + c.getName() + &quot;)&quot;) ;// 输出 } }} 枚举类也可以实现一个接口，但是因为接口中会存在抽象方法，所以枚举类中的每个对象都必须分别实现此抽象方法interface Print { // 定义Print接口 public String getColor(); // 定义抽象方法 } enum Color implements Print { // 枚举类实现接口 RED { // 枚举对象实现抽象方法 public String getColor() { return &quot;红色&quot;; } },GREEN { // 枚举对象实现抽象方法 public String getColor() { return &quot;绿色&quot;; } },BLUE { // 枚举对象实现抽象方法 public String getColor() { return &quot;蓝色&quot;; } }; } public class InterfaceEnumDemo { public static void main(String[] args) { for(Color c:Color.values()){ // foreach输出 System.out.print(c.getColor() + &quot;、&quot;) ; // 输出 } }} enum Color { // 枚举类实现接口 RED { // 枚举对象实现抽象方法 public String getColor() { return &quot;红色&quot;; } },GREEN { // 枚举对象实现抽象方法 public String getColor() { return &quot;绿色&quot;; } },BLUE { // 枚举对象实现抽象方法 public String getColor() { return &quot;蓝色&quot;; } }; public abstract String getColor(); // 定义抽象方法 } public class AbstractMethodEnum { public static void main(String[] args) { for(Color c:Color.values()){ // foreach输出 System.out.print(c.getColor() + &quot;、&quot;) ; // 输出 } } } 类集对枚举的支持 在JDK 1.5的java.util 程序包中提供两个新的集合操作类：EnumMap 和 EnumSet，这两个类与枚举类型的结合应用可使以前非常繁琐的程序变得简单方便。EnumSet类提供了java.util.Set接口的一个特殊实现，而EnumMap类提供了java.util.Map接口的一个特殊实现，该类中的键（key）是一个枚举类型 EnumMapEnumMap是Map接口的子类，所以本身还是以Map的形式进行操作，即：key  value。如果要想使用EnumMap，则首先要创建EnumMap的对象，在创建此对象的时候必须指定要操作的枚举类型，所以构造方法如下所示： public EnumMap(Class&lt;K&gt; keyType) package com.ecit; import java.util.EnumMap; import java.util.Map; enum Color { RED, GREEN, BLUE; // 定义枚举的三个类型 } public class EnumMapDemo { public static void main(String[] args) { Map&lt;Color, String&gt; desc = null; // 定义一个Map对象 desc = new EnumMap&lt;Color, String&gt;(Color.class);// 实例化EnumMap desc.put(Color.RED, &quot;红色&quot;); // 加入一个内容 desc.put(Color.GREEN, &quot;绿色&quot;); // 加入一个内容 desc.put(Color.BLUE, &quot;蓝色&quot;); // 加入一个内容 System.out.println(&quot;===== 输出全部的内容 =====&quot;); for (Color c : Color.values()) { // 取得全部的枚举 System.out.println(c.name() + &quot; --&gt; &quot; + desc.get(c)); } System.out.println(&quot;===== 输出全部的键值 =====&quot;); for (Color c : desc.keySet()) { // 取得全部的key System.out.print(c.name() + &quot;、&quot;); } System.out.println(); // 换行 System.out.println(&quot;===== 输出全部的内容 =====&quot;); for (String s : desc.values()) { // 取得全部的value System.out.print(s + &quot;、&quot;); } } } EnumSet EnumSet是Set接口的子类，所以里面的内容是无法重复的，在使用EnumSet的时候是不能直接使用关键字new为其进行实例化的，所以在此类中提供了很多的静态方法。 验证EnumSet —— 将全部的集合设置到EnumSet集合之中 import java.util.EnumSet; enum Color { RED, GREEN, BLUE; // 定义枚举的三个类型 } public class EnumSetDemo01 { public static void main(String[] args) { EnumSet&lt;Color&gt; es = null ; // 声明一个EnumSet对象 System.out.println(&quot;===== EnumSet.allOf(Color.class) =====&quot;); es = EnumSet.allOf(Color.class) ; // 将枚举的全部类型设置到EnumSet对象之中 print(es) ; } public static void print(EnumSet&lt;Color&gt; temp){ // 专门的输出操作 for(Color c:temp){ // 循环输出EnumSet中的内容 System.out.print(c + &quot;、&quot;); } System.out.println() ; } } 验证EnumSet——只设置一个枚举的类型到集合之中import java.util.EnumSet; enum Color { RED, GREEN, BLUE; // 定义枚举的三个类型 } public class EnumSetDemo02 { public static void main(String[] args) { EnumSet&lt;Color&gt; es = null ; // 声明一个EnumSet对象 System.out.println(&quot;===== EnumSet.of(Color.BLUE) =====&quot;); es = EnumSet.of(Color.BLUE) ; // 设置一个枚举的内容 print(es) ; } public static void print(EnumSet&lt;Color&gt; temp){ // 专门的输出操作 for(Color c:temp){ // 循环输出EnumSet中的内容 System.out.print(c + &quot;、&quot;); } System.out.println() ; } } 验证EnumSet —— 创建只能放入指定枚举类型的集合import java.util.EnumSet; enum Color { RED, GREEN, BLUE; // 定义枚举的三个类型 } public class EnumSetDemo03 { public static void main(String[] args) { EnumSet&lt;Color&gt; es = null ; // 声明一个EnumSet对象 System.out.println(&quot;===== EnumSet.noneOf(Color.class) =====&quot;); es = EnumSet.noneOf(Color.class) ; // 创建一个可以加入Color类型的对象 es.add(Color.RED) ; // 增加内容 es.add(Color.GREEN) ; // 增加内容 print(es) ; } public static void print(EnumSet&lt;Color&gt; temp){ // 专门的输出操作 for(Color c:temp){ // 循环输出EnumSet中的内容 System.out.print(c + &quot;、&quot;); } System.out.println() ; } } 验证EnumSet —— 创建不包含指定元素的集合import java.util.EnumSet; enum Color { RED, GREEN, BLUE; // 定义枚举的三个类型 } public class EnumSetDemo04 { public static void main(String[] args) { EnumSet&lt;Color&gt; esOld = null ; // 声明一个EnumSet对象 EnumSet&lt;Color&gt; esNew = null ; // 声明一个EnumSet对象 esOld = EnumSet.noneOf(Color.class) ; // 创建一个可以加入Color类型的对象 esOld.add(Color.RED) ; // 增加内容 esOld.add(Color.GREEN) ; // 增加内容 System.out.println(&quot;===== EnumSet.complementOf(es) =====&quot;); esNew = EnumSet.complementOf(esOld) ; // 创建一个不包含指定元素的集合 print(esNew) ; } public static void print(EnumSet&lt;Color&gt; temp){ // 专门的输出操作 for(Color c:temp){ // 循环输出EnumSet中的内容 System.out.print(c + &quot;、&quot;); } System.out.println() ; } } 验证EnumSet —— 拷贝已有的内容import java.util.EnumSet; enum Color { RED, GREEN, BLUE; // 定义枚举的三个类型 } public class EnumSetDemo05 { public static void main(String[] args) { EnumSet&lt;Color&gt; esOld = null ; // 声明一个EnumSet对象 EnumSet&lt;Color&gt; esNew = null ; // 声明一个EnumSet对象 esOld = EnumSet.noneOf(Color.class) ; // 创建一个可以加入Color类型的对象 esOld.add(Color.RED) ; // 增加内容 esOld.add(Color.GREEN) ; // 增加内容 System.out.println(&quot;===== EnumSet.copyOf(es) =====&quot;); esNew = EnumSet.copyOf(esOld) ; // 从已有的集合中拷贝出内容 print(esNew) ; } public static void print(EnumSet&lt;Color&gt; temp){ // 专门的输出操作 for(Color c:temp){ // 循环输出EnumSet中的内容 System.out.print(c + &quot;、&quot;); } System.out.println() ; } }","link":"/2013/09/08/javase/JAVASE-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3-08/"},{"title":"JAVA中的泛型","text":"泛型 泛型可以解决数据类型的安全性问题，它主要原理是在声明的时候通过一个标识表示类中某个属性的类型或者是某个方法的返回值及参数类型。 泛型定义格式[访问权限] class 类名称&lt;泛型类型1,泛型类型2,...,泛型类型n&gt;{ [访问权限] 泛型类型标识 变量名称； [访问权限] 泛型类型标识 方法名称(){}； [访问权限] 返回值类型声明 方法名称(泛型类型标识 变量名称){} } 泛型对象定义类名称&lt;具体类&gt; 对象名称 = new 类名称&lt;具体类&gt;(); class 类&lt;泛型类型&gt;{ 修饰符 泛型类型 属性; public 泛型类型 getter(){} public void setter(泛型类型 变量){} } 现在要求设计一个表示坐标点的类，坐标由X和Y组成，坐标表示方法有以下三种：整数表示：x=10,y=20小数表示：x=10.5,y=20.6字符串表示：x=”东经180度”,y=”北纬21度”采用泛型设计此类： class Point&lt;T&gt;{ private T x ; // 表示X坐标 private T y ; // 表示Y坐标 public void setX(T x){ this.x = x ; } public void setY(T y){ this.y = y ; } public T getX(){ return this.x ; } public T getY(){ return this.y ; } } public class GenericsPoint{ public static void main(String args[]){ Point&lt;Integer&gt; p = new Point&lt;Integer&gt;() ; p.setX(10) ; // 利用自动装箱操作：int --&gt; Integer p.setY(21) ; // 利用自动装箱操作：int --&gt; Integer int x = p.getX() ; // 自动拆箱 int y = p.getY() ; // 自动拆箱 System.out.println(&quot;整数表示，X坐标为：&quot; + x) ; System.out.println(&quot;整数表示，Y坐标为：&quot; + y) ; } } 多个泛型 如果一个类中有多个属性需要使用不同的泛型声明，则可以在声明类的时候指定多个泛型类型。```javaclass Notepad&lt;K,V&gt;{ // 此处指定了两个泛型类型 private K key ; // 此变量的类型由外部决定 private V value ; // 此变量的类型由外部决定 public K getKey(){ return this.key ; } public V getValue(){ return this.value ; } public void setKey(K key){ this.key = key ; } public void setValue(V value){ this.value = value ; }}public class GenericsDemo09{ public static void main(String args[]){ Notepad&lt;String,Integer&gt; t = null ; // 定义两个泛型类型的对象 t = new Notepad&lt;String,Integer&gt;() ; // 里面的key为String，value为Integer t.setKey(“ecit”) ; // 设置第一个内容 t.setValue(30) ; // 设置第二个内容 System.out.print(“姓名；” + t.getKey()) ; // 取得信息 System.out.print(“，年龄；” + t.getValue()) ; // 取得信息 } } ### Java7泛型的“菱形”语法 - 在Java7以前,如果使用带泛型的接口、类定义变量,那么调用构造器创建对象时构造器的后面也必须带泛型,这显得有些多余了。例如如下两条语句: ```java List&lt;String&gt; strList = new ArrayList&lt;String&gt;() Map&lt;String Integer&gt; scores = new HashMap&lt;String Integer&gt;() 从Java7开始,Java允许在构造器后不需要带完整的泛型信息,只要给出一对尖括号(&lt;&gt;)即可,Java可以推断尖括号里应该是什么泛型信息。即上面两条语句可以改写为如下形式:List&lt;String&gt; strList new ArrayList&lt;&gt;() Map&lt;String Integer&gt; scores new HashMap&lt;&gt;() 从泛型派生子类 当创建了带泛型声明的接口、父类之后,可以为该接口创建实现类,或从该父类派生子类,需要指出的是,当使用这些接口、父类时不能再包含类型形参。例如,下面代码就是错误的。public class DogBox extends Box&lt;E&gt; { } 如果想从 Box类派生一个子类,则可以改为如下代码:public class DogBox extends Box&lt;Dog&gt; { } 泛型的安全警告如果子类继承父类时，不指定具体泛型也可以，但是在编译时会提示使用了未经检查或不安全的操作——这就是泛型检查的警告，注: 有关详细信息, 请使用 -Xlint:unchecked 重新编译。public class DogBox extends Box{ //编译会有泛型安全警告，但是可以正常编译通过，默认把 E 当成Object对象处理 } 泛型方法 场景引出 假设需要实现这样一个方法—该方法负责将一个 Object数组的所有元素添加到一个 Collection集合中。考虑采用如下代码来实现该方法。 static void fromArrayToCollection(Object[] a, Collection&lt;Object&gt; c) { for (Object o : a) c.add(o); } 上面定义的方法没有任何问题,关键在于方法中的c形参,它的数据类型是 Collection&lt;Object&gt;。 正如前面所介绍的, Collection&lt;Sing&gt;不是 Collection&lt; Object&gt;的子类型—所以这个方法的功能非常有限,它只能将 Object数组的元素复制到元素为 Object 的Collection集合中,即 下面代码将引起编译错误。 String[] arrStrs = {&quot;a&quot;,&quot;b&quot;,&quot;c&quot;}; Collection&lt;String&gt; collection = new ArrayList&lt;&gt;(); fromArrayToCollection(arrStrs,collection); //这一行引起编译错误 可见上面方法的参数类型不可以使用 Collection&lt; String&gt;,那使用通配符 Collection&lt;?&gt;是否可行呢? 显然也不行,因为Java不允许把对象放进一个未知类型的集合中。为了解决这个问题,可以使用Java5提供的泛型方法( Generic Method)。所谓泛型方法,就是在声明方法时定义一个或多个类型形参。 泛型方法的用法格式如下: 修饰符 &lt;T,S&gt; 返回值类型 方法名(形参列表) { //方法体, } 采用支持泛型的方法 修改 fromArrayToCollection函数 static &lt;T&gt; void fromArrayToCollection(T [] a, Collection&lt;T&gt; c) { for (T o : a) { c.add(o); } } public class Test { public static void main(String[] args) { String[] arrStrs = {&quot;a&quot;,&quot;b&quot;,&quot;c&quot;}; Collection&lt;String&gt; collection = new ArrayList&lt;&gt;(); fromArrayToCollection(arrStrs,collection); System.out.println(collection.toString()); Integer[] intArray = {10,23,45}; Collection&lt;Integer&gt; collectionInt = new ArrayList&lt;&gt;(); fromArrayToCollection(intArray,collectionInt); System.out.println(collectionInt.toString()); } static &lt;T&gt; void fromArrayToCollection(T [] a, Collection&lt;T&gt; c) { //支持泛型的方法 for (T o : a) { c.add(o); } } } 泛型的通配符 有时候希望传入的类型有一个指定的范围，从而可以进行一些特定的操作，这时候就是通配符边界登场的时候了。泛型有三种通配符形式：&lt;?&gt; 无限制通配符 &lt;? extends E&gt; extends关键字声明了类型的上界，表示参数化的类型可能是所指定的类型，或者是此类型的子类 &lt;? super E&gt; super关键字声明了类型的下界，表示参数化的类型可能是指定的类型，或者是此类型的父类 泛型的常见字母 T Type表示类型 K V 分别代表键值中key value E 代表Element ? 代表不确定的类型不能使用在静态属性，静态方法上泛型使用时不能指定基本类型 泛型通配符使用示例: public class Test { public static void main(String[] args) { String[] arrStrs = {&quot;a&quot;,&quot;b&quot;,&quot;c&quot;}; Collection&lt;String&gt; collection = new ArrayList&lt;&gt;(); fromArrayToCollection(arrStrs,collection); System.out.println(collection.toString()); Object[] intArray = {10,23,45}; Collection&lt;Object&gt; collectionInt = new ArrayList&lt;&gt;(); fromArrayToCollection(intArray,collectionInt); System.out.println(collectionInt.toString()); copy(collection,collectionInt); System.out.println(collectionInt.toString()); } static &lt;T&gt; void fromArrayToCollection(T [] a, Collection&lt;T&gt; c) { for (T o : a) { c.add(o); } } static &lt;T&gt; void copy(Collection&lt;? extends T&gt; src,Collection&lt;T&gt; desc){ for (T ele : src){ desc.add(ele); } } } 泛型构造器 正如泛型方法允许在方法签名中声明类型形参一样,Java也允许在构造器签名中声明类型形参,这样就产生了所谓的泛型构造器。一旦定义了泛型构造器,接下来在调用构造器时,就不仅可以让Java根据数据参数的类型来“推断”类型形参的类型,而且程序员也可以显式地为构造器中的类型形参指定实际的类型。如下程序所示。public class Foo { public &lt;T&gt; Foo(T t){ System.out.println(&quot;泛型构造器&quot;); } public static void main(String[] args) { new Foo(&quot;Hello&quot;); new Foo(100); new Foo(100.0d); new&lt;String&gt;Foo(&quot;World&quot;); } } Java8改进的泛型类型推断Java8改进了泛型方法的类型推断能力,类型推断主要有如下两方面。 可通过调用方法的上下文来推断类型参数的目标类型 可在方法调用链中,将推断得到的类型参数传递到最后一个方法。如下程序示范了Java8对泛型方法的类型推断。```javaclass MyUtil { public static MyUtil nil() { return null; } public static MyUtil cons(Z head, MyUtil tail) { return null; } E head() { return null; } }public class InferenceTest { public static void main(String[] args) { //可以通过方法赋值的目标参数来推断类型参数为 string MyUtil&lt;String&gt; Is = MyUtil.nil(); //无须使用下面语句在调用nil()方法时指定类型参数的类型 MyUtil&lt;String&gt; mu = MyUtil.&lt;String&gt;nil(); // 可调用cons()方法所需的参数类型来推断类型参数为 Integer MyUtil.cons(42, MyUtil.nil()); //无须使用下面语句在调用n11()方法时指定类型参数的类型 MyUtil.cons(42, MyUtil.&lt;Integer&gt;nil()); } }```","link":"/2013/09/11/javase/JAVASE-%E6%B3%9B%E5%9E%8B-11/"},{"title":"JAVA深浅克隆","text":"","link":"/2013/09/05/javase/JAVASE-%E6%B7%B1%E6%B5%85%E5%85%8B%E9%9A%86-05/"},{"title":"JAVA继承机制和多态性","text":"类的继承 继承是面向对象的三大特征之一，也是实现软件复用的重要手段。Java的继承具有单继承的特点，每个子类只有一个直接父类。 类的继承格式class 父类{} //定义父类 class 子类 extends 父类{} //使用extends关键字实现继承 示例: class Person{ // 定义Person类 private String name ; // 定义name属性 private int age ; // 定义age属性 public void setName(String name){ this.name = name; } public void setAge(int age){ this.age = age ; } public String getName(){ return this.name ; } public int getAge(){ return this.age ; } } class Student extends Person{ // 定义Student类 // 此处不添加任何的代码 } public class ExtDemo02{ public static void main(String arsg[]){ Student stu = new Student() ;// 实例化子类对象 stu.setName(&quot;张三&quot;) ; // 此方法在Student类中没有明确定义 stu.setAge(30) ; System.out.println(&quot;姓名：&quot; + stu.getName() + &quot;，年龄：&quot; + stu.getAge() ) ; } } 子类扩展自己的功能 class Person{ // 定义Person类 private String name ; // 定义name属性 private int age ; // 定义age属性 public void setName(String name){ this.name = name; } public void setAge(int age){ this.age = age ; } public String getName(){ return this.name ; } public int getAge(){ return this.age ; } } class Student extends Person{ // 定义Student类 private String school ; // 定义school属性 public void setSchool(String school){ this.school = school ; } public String getSchool(){ return this.school ; } } public class ExtDemo03{ public static void main(String arsg[]){ Student stu = new Student() ;// 实例化子类对象 stu.setName(&quot;张三&quot;) ; // 此方法在Student类中没有明确定义 stu.setAge(30) ; stu.setSchool(&quot;清华大学&quot;) ; System.out.println(&quot;姓名：&quot; + stu.getName() + &quot;，年龄：&quot; + stu.getAge() + &quot;，学校：&quot; + stu.getSchool() ) ; } } 类的继承限制限制一：一个子类只能继承一个父类，存在单继承局限。限制二：在一个子类继承时，实际上会继承父类中的所有操作(属性、方法)，但是需要注意的是，对于所有的非私有(no private)操作属于显示继承(可以直接利用对象操作)，而所有的私有操作属于隐式继承(间接完成)。错误示例： class Person{ // 定义Person类 private String name ; // 定义name属性 private int age ; // 定义age属性 public void setName(String name){ this.name = name; } public void setAge(int age){ this.age = age ; } public String getName(){ return this.name ; } public int getAge(){ return this.age ; } } class Student extends Person{ // 定义Student类 public void fun(){ System.out.println(&quot;父类中的name属性：&quot; + name) ; // 错误，无法访问 System.out.println(&quot;父类中的age属性：&quot; + age) ; // 错误，无法访问 } } 正确示例 class Person{ // 定义Person类 private String name ; // 定义name属性 private int age ; // 定义age属性 public void setName(String name){ this.name = name; } public void setAge(int age){ this.age = age ; } public String getName(){ return this.name ; } public int getAge(){ return this.age ; } } class Student extends Person{ // 定义Student类 public void fun(){ System.out.println(&quot;父类中的name属性：&quot; + getName()) ; // 正确，间接访问 System.out.println(&quot;父类中的age属性：&quot; + getAge()) ; // 正确，间接访问 } } 限制三：在继承关系中，如果要实例化子类对象，会默认先调用父类构造，为父类中的属性初始化，之后再调用子类构造，为子类中的属性初始化，即默认情况下，子类会找到父类中的无参构造方法。 class Person{ private String name; private int age; public Person(){ System.out.println(&quot;父类Person中的构造。&quot;) ; } public void setName(String name){ this.name = name; } public void setAge(int age){ this.age = age ; } public String getName(){ return this.name ; } public int getAge(){ return this.age ; } } class Student extends Person{ // 定义Student类 private String school ; // 定义school属性 public Student(){ //super() ; // 默认隐藏 System.out.println(&quot;子类Student中的构造。&quot;) ; } public void setSchool(String school){ this.school = school ; } public String getSchool(){ return this.school ; } } public class Test{ public static void main(String arsg[]){ Student stu = new Student() ;// 实例化子类对象 stu.setName(&quot;张三&quot;) ; // 此方法在Student类中没有明确定义 stu.setAge(30) ; stu.setSchool(&quot;清华大学&quot;) ; System.out.println(&quot;姓名：&quot; + stu.getName() + &quot;，年龄：&quot; + stu.getAge() + &quot;，学校：&quot; + stu.getSchool() ) ; } } // 输出结果: // 父类Person中的构造。 // 子类Student中的构造。 // 姓名：张三，年龄：30，学校：清华大学 方法的覆写 在覆写的过程之中，还必须考虑到权限问题，即：被子类所覆写的方法不能够拥有比父类更严格的访问控制权限。对于访问控制权限实际上已经给读者讲解过过三种了，这三种权限由宽到严的顺序是：public &gt; default（默认，什么都不写） &gt; private，也就是说private的访问权限是最严格的（只能够被一个类中所访问）。即：如果父类的方法使用的是public声明，那么子类覆写此方法的时候只能是public，如果父类的方法是default（默认）的话，那么子类覆写方法的时候只能使用default或public错误的覆写例子： class Person{ // 定义父类 public void print(){ // 默认的访问权限 System.out.println(&quot;Person --&gt; void print()。&quot;) ; } } class Student extends Person{ // 定义继承关系 void print(){ // 错误的，降低了访问权限 System.out.println(&quot;Student --&gt; void print()。&quot;) ; } } 正确的覆写例子： class Person{ // 定义父类 void print(){ // 默认的访问权限 System.out.println(&quot;Person --&gt; void print()。&quot;) ; } } class Student extends Person{ // 定义继承关系 public void print(){ System.out.println(&quot;Student --&gt; void print()。&quot;) ; } } public class OverrideDemo01{ public static void main(String args[]){ Student s = new Student() ; s.print() ; } } 子类覆写父类的方法后，想要强制改为调用父类方法，就只能使用super关键字完成。super关键字可以从子类访问父类中的内容。super.方法().示例： class Person{ // 定义父类 void print(){ // 默认的访问权限 System.out.println(&quot;Person --&gt; void print()。&quot;) ; } } class Student extends Person{ // 定义继承关系 public void print(){ super.print() ; // 访问父类中被子类覆写过的方法 System.out.println(&quot;Student --&gt; void print()。&quot;) ; } } public class OverrideDemo03{ public static void main(String args[]){ Student s = new Student() ; s.print() ; } } ps:如果现在将父类的一个方法定义成private访问权限，在子类中将此方法声明为default访问权限，这个就不是方法覆写了，而是相当在子类中又重新定义了一个新的方法出来。 重载与覆写的区别 this与super的区别 对于this和super本身都可以调用构造方法，而且调用的时候都必须放在构造方法的首行，所以这两个关键字肯定不能同时出现。 多态 Java引用变量有两个类型：一个是编译时类型，一个是运行时类型。编译时类型由声明该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定。如果编译时类型和运行时类型不一致，就可能出现所谓的多态。 多态体现两方面方法的多态性:重载与覆写重载：同一个方法名称，根据不同的参数类型及个数可以完成不同的功能；覆写：同一个方法，根据操作的子类不同，所完成的功能也不同。 class A{ // 定义类A public void fun1(){ // 定义fun1()方法 System.out.println(&quot;A --&gt; public void fun1(){}&quot;) ; } public void fun2(){ this.fun1() ; // 调用fun1()方法 } } class B extends A{ public void fun1(){ // 此方法被子类覆写了 System.out.println(&quot;B --&gt; public void fun1(){}&quot;) ; } public void fun3(){ System.out.println(&quot;B --&gt; public void fun3(){}&quot;) ; } } public class PolDemo01{ public static void main(String asrgs[]){ B b = new B() ; // 实例化子类对象 A a = b ; // 向上转型关系 a.fun1() ; // 此方法被子类覆写过 b.fun3() ; } } //输出结果: //B --&gt; public void fun1(){} //B --&gt; public void fun3(){} 对象的多态性：父子类对象的转换。向上转型：子类对象变为父类对象，父类 父类对象 = 子类实例，自动转型；向下转型：父类对象变为子类对象，子类 子类对象 = （子类）父类实例，强制转型； class A{ // 定义类A public void fun1(){ // 定义fun1()方法 System.out.println(&quot;A --&gt; public void fun1(){}&quot;) ; } public void fun2(){ this.fun1() ; // 调用fun1()方法 } } class B extends A{ public void fun1(){ // 此方法被子类覆写了 System.out.println(&quot;B --&gt; public void fun1(){}&quot;) ; } public void fun3(){ System.out.println(&quot;B --&gt; public void fun3(){}&quot;) ; } } public class PolDemo02{ public static void main(String asrgs[]){ A a = new B() ; // 向上转型关系 B b = (B)a ; // 发生了向下转型关系 b.fun1() ; b.fun2() ; b.fun3() ; } } //输出结果： //B --&gt; public void fun1(){} //B --&gt; public void fun1(){} //B --&gt; public void fun3(){} instanceof关键字 Java中使用instanceof关键字判断一个对象到底是哪个类的实例 对象 instanceof 类-》返回boolean类型 class A{ // 定义类A public void fun1(){ // 定义fun1()方法 System.out.println(&quot;A --&gt; public void fun1(){}&quot;) ; } public void fun2(){ this.fun1() ; // 调用fun1()方法 } } class B extends A{ public void fun1(){ // 此方法被子类覆写了 System.out.println(&quot;B --&gt; public void fun1(){}&quot;) ; } public void fun3(){ System.out.println(&quot;B --&gt; public void fun3(){}&quot;) ; } } public class InstanceofDemo01{ public static void main(String asrgs[]){ A a1 = new B() ; // 通过向上转型实例化对象 System.out.println(&quot;A a1 = new B()：&quot; + (a1 instanceof A)) ; System.out.println(&quot;A a1 = new B()：&quot; + (a1 instanceof B)) ; A a2 = new A() ; // 通过向上转型实例化对象 System.out.println(&quot;A a2 = new B()：&quot; + (a2 instanceof A)) ; System.out.println(&quot;A a2 = new B()：&quot; + (a2 instanceof B)) ; } } //输出结果: //A a1 = new B()：true //A a1 = new B()：true //A a2 = new B()：true //A a2 = new B()：false ps:在对象向下转型之前最好使用instanceof关键字进行验证 class A{ // 定义类A public void fun1(){ // 定义fun1()方法 System.out.println(&quot;A --&gt; public void fun1(){}&quot;) ; } public void fun2(){ this.fun1() ; // 调用fun1()方法 } } class B extends A{ public void fun1(){ // 此方法被子类覆写了 System.out.println(&quot;B --&gt; public void fun1(){}&quot;) ; } public void fun3(){ System.out.println(&quot;B --&gt; public void fun3(){}&quot;) ; } } class C extends A{ public void fun1(){ // 此方法被子类覆写了 System.out.println(&quot;C --&gt; public void fun1(){}&quot;) ; } public void fun5(){ System.out.println(&quot;C --&gt; public void fun5(){}&quot;) ; } } public class InstanceofDemo02{ public static void main(String asrgs[]){ fun(new B()) ; fun(new C()) ; } public static void fun(A a){ a.fun1() ; if(a instanceof B){ B b = (B) a ; b.fun3() ; } if(a instanceof C){ C c = (C) a ; c.fun5() ; } } }","link":"/2013/09/07/javase/JAVASE-%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81-07/"},{"title":"JAVA网路编程","text":"IP地址与InetAddressIP地址: ( Internet Protocol)简介 在互联网上的每台计算机都有一个唯一表示自己的标记，这个标记就是IP地址，在windows操 作系统中，用户可以通过图所示的图形方便的设置每台电脑的IP 身份证:表示一个唯一的标记，代表终身。。 对于网络上，每一台计算机也有自己的名字，那么这个名字就称为IP地址。 IP地址表示 IP地址使用32位长度二进制数据表示，一般在实际中看到的大部分IP地址都是以十进制的数据形式表示的，如“192.168.1.3”. IP地址格式 IP地址 = 网络地址 十 主机地址 网络号:用于识别主机所在的网络: 主机号:用于识别该网络中的主机。 IP地址中存在掩码的功能主要是区分网络号和主机号 IP地址分类 IP地址分为五类，A类保留给政府机构，B类分配给中等规模的公司，C类分配给任何需要的人，D类用于组播，E类用于实验，各类可容纳的地址数目不同。 |No. | 地址分类 | 地址范围||:——:|:——-:|:———-:|:———:||1 | A类地址 | 1.0.0.1126.255.255.254||2 | B类地址 | 128.0.0.1191.255.255.254||3 | C类地址 | 192.0.0.1223.255.255.254||4 | D类地址 | 224.0.0.1239.255.255.254||5 | E类地址 | 240.0.0.1~255.255.255.254| InetAddress InetAddress类 主要表示IP地址，这个类有两个子类: Inet4Address 、Inet6Address，一个用于表示IPV4，另一个表示IPV6协议。 之前的IP地址，实际上是使用四个十进制数字表示，相当于32位，把这样的P地址称为IPV4 但是随着网络上的主机越来越多，之后发现IPV4地址不够使了，所以又进行改进，产生了IPV6。 InetAddress类的常用方法 No. 方法 类型 描述 1 public static InetAddress getByName(String host) throws UnknowmHostException 普通 通过主机名称得到ImnetAddress对象 2 public static InetAddress getLocalHost() throws UnknownHostException 普通 通过本机得 到InetAddress对象 3 public String getHostName() 普通 得到P地址 4 public boolean isReachable(int timeout) throws IOException 普通 判断地址是否可达，同时指定超时时间 import java.net.InetAddress ; public class TestIP{ public static void main(String args[]) throws Exception {// 所有异常抛出 InetAddress locAdd = null ; InetAddress remAdd = null ; locAdd = InetAddress.getLocalHost() ;// 得到本机 remAdd = InetAddress.getByName(&quot;www.baidu.com&quot;) ; System.out.println(&quot;本机的IP地址：&quot; + locAdd.getHostAddress()) ; System.out.println(&quot;百度IP地址：&quot; + remAdd.getHostAddress()) ; System.out.println(&quot;本机是否可达：&quot; + locAdd.isReachable(5000)) ; } } // 输出结果: // 本机的IP地址：192.168.0.101 // 百度IP地址：180.101.49.12 // 本机是否可达：true URI与URI ConnectionURL URL (Uniform Resource Locator)统一资源定位符，可以直接使用此类找到互联网上的资源(如:一个简单的网页)public URL (String protocol, String host, int port, String file) throws MalformedURLException public final InputStream openStream() throws IOException import java.net.URL ; import java.io.InputStream ; import java.util.Scanner ; public class TestIP{ public static void main(String args[]) throws Exception { // 所有异常抛出 URL url = new URL(&quot;http&quot;,&quot;www.baidu.com&quot;,80,&quot;/&quot;) ; InputStream input = url.openStream() ; // 打开输入流 Scanner scan = new Scanner(input) ; // 实例化Scanner类 scan.useDelimiter(&quot;\\n&quot;) ; // 设置读取分隔符 while(scan.hasNext()){ System.out.println(scan.next()) ; } } } URLConnection URLConnection 是封装访问远程网络资源一般方法的类， 通过它可以建立与远程服务器的连接，检查远程资源的一些属性。 No 方法 类型 描述 1 public int getContentLength( 普通 取得内容的长度 2 public String getContentType() 普通 取得内容的类型 3 public InputStream getInputStream() throws IOException 普通 取得连接的输入流 import java.net.URL ; import java.net.URLConnection ; import java.io.InputStream ; import java.util.Scanner ; public class TestIP{ public static void main(String args[]) throws Exception { // 所有异常抛出 URL url = new URL(&quot;http://www.baidu.com&quot;) ; URLConnection urlCon = url.openConnection() ; // 建立连接 System.out.println(&quot;内容大小：&quot; + urlCon.getContentLength()) ; System.out.println(&quot;内容类型：&quot; + urlCon.getContentType()) ; } } URLEncoder与URLDecoder 在使用URL访问的时候，经常会看到在地址之后会有很多其他的附带信息，例如:在百度网上搜索”笑傲江湖”的时候在地址栏之后就会附带有很多其他的信息。https://www.baidu.com/s?wd=%E7%AC%91%E5%82%B2%E6%B1%9F%E6%B9%96&amp;rsv_spt=1&amp;rsv_iqid=0xdd114ecf0014184c&amp;issp=1&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=2&amp;ie=utf-8&amp;tn=baiduhome_pg&amp;rsv_enter=1&amp;rsv_dl=tb&amp;rsv_sug3=19&amp;rsv_sug1=13&amp;rsv_sug7=101&amp;rsv_sug2=0&amp;rsv_btype=i&amp;inputT=5405&amp;rsv_sug4=5683 URLEncoder类与URLDecoder类的常用方法 No 方法 类型 描述 1 public static String encode(String s,String enc) throws UnsupportedEncodingException 普通 使用指定的编码机制将字符串转换为application/x-www-fom-urlencoded格式。 No 方法 类型 描述 1 public static String decode(String s,String enc) throws UnsupportedEncodingException 普通 使用指定的编码机制对application/x-www-fom-turlencoded字符串解码. import java.net.URLDecoder ; import java.net.URLEncoder ; public class CodeDemo{ public static void main(String args[]) throws Exception{ String keyWord = &quot;笑傲江湖&quot; ; String encod = URLEncoder.encode(keyWord,&quot;UTF-8&quot;) ; // 进行编码的操作 System.out.println(&quot;编码之后的内容：&quot; + encod) ; String decod = URLDecoder.decode(encod,&quot;UTF-8&quot;) ; // 进行解码操作 System.out.println(&quot;解码之后的内容：&quot; + decod) ; } } TCP程序设计 在Java中 使用Socket (即套接字)完成TCP程序的开发，使用此类可以方便的建立可靠的、双向的、持续的、点对点的通讯连接。 在Socket的 程序开发中，服务器端使用ServerSocket等待客户端的连接，对于Java的网络程序来讲，每一个 客户端都使用一个Socket对象表示。 ServerSocket ServerSocket 类主要用在服务器端程序的开发上，用于接收客户端的连接请求。 No 方法 类型 描述 1 public ServerSocket( int port) throws IOException 构造 创建ServerSocket实例， 并指定监听端口 2 public Socket accept() throws IOException 普通 等待客户端连接，此方法连接之前一直阻塞 3 public InetAddress getInetAddress() 普通 返回服务器的P地址 4 public booleau isClosed() 普通 返回ServerSocket的关闭状态 5 public void close() thurows IOException 普通 关闭ServerSocket Socket 在服务器端每次运行时都要使用aceept()方法等待客户端连接，此方法执行之后服务器端将进入阻塞状态，直到客户端连接之后程序才可以向下继续执行，此方法的返回值类型是Socket，每一个Socket都表示一个客户端对象。 No 方法 类型 描述 1 public Socket(String host,int port) throws UnknowmHostException,IOException 构造 构造Socket对象，同时指定要连接服务器的主机名称及连接端口。 2 public ImnputStream getInputStream() throwws IOException 普通 返回此套接字的输入流 3 public OutputStream getOutputStream() throws IOException 普通 返回此套接字的输出流 4 public void close() throws IOException 普通 关闭此Socket 5 public boolean isClosed() 普通 判断此套接字是否被关闭 UDP简介 在TCP的所有操作都必须建立可靠的连接，这样一来肯定会浪费大量的系统性能，为了减少这种开销，在网络中又提供了另外一种传输协议–UDP，不可靠的连接，这种协议在各个聊天工具中被广泛的应用。 在UDP开发中使用DatagramPacket包装一条 要发送的信息，之后使用DatagramSocket用于完成信息的发送操作 DatagramPacket No 方法 类型 描述 1 public DatagramPacket(byte[ buf,int length) 构造 实例化DatagramPacket对象时，指定接收数据长度 2 public DatagramPacket(byte[] buf,int length,InetAddress address,int port) 构造 实例化DatagramPacket对象时指定发送的数据、数据的长度、目标地址及端口 3 public byte[] getData() 普通 返回接收的数据 4 public int getLength() 普通 返回要发送或接收数据的长度 是包含真实的是要发送的信息， 称为数据报。所有的数据报使用DatagramSocket进行发送的操作。 DatagramSocket No 方法 类型 描述 1 public DatagramSocke t(int port) throws SocketException 构造 创建DatagramPacket对象，并指定监听的端口 2 public void send(DatagramPacket p) throws IOException 普通 发送数据报 3 public void receive(DatagramPacket p) throws IOException 普通 接收数据报 import java.net.DatagramPacket ; import java.net.DatagramSocket ; import java.net.InetAddress ; public class UDPServer{ public static void main(String args[]) throws Exception{ // 所有异常抛出 DatagramSocket ds = null ; // 定义发送数据报的对象 DatagramPacket dp = null ; // 声明DatagramPacket对象 ds = new DatagramSocket(3000) ; // 服务端在3000端口上等待服务器发送信息\\ String str = &quot;hello World!!!&quot; ; dp = new DatagramPacket(str.getBytes(),str.length(),InetAddress.getByName(&quot;localhost&quot;),9000) ; // 所有的信息使用buf保存 System.out.println(&quot;发送信息。&quot;) ; ds.send(dp); // 发送信息出去 ds.close() ; } } import java.net.DatagramPacket ; import java.net.DatagramSocket ; public class UDPClient{ public static void main(String args[]) throws Exception{ // 所有异常抛出 DatagramSocket ds = null ; // 定义接收数据报的对象 byte[] buf = new byte[1024] ; // 开辟空间，以接收数据 DatagramPacket dp = null ; // 声明DatagramPacket对象 ds = new DatagramSocket(9000) ; // 客户端在9000端口上等待服务器发送信息 dp = new DatagramPacket(buf,1024) ; // 所有的信息使用buf保存 ds.receive(dp) ; // 接收数据 String str = new String(dp.getData(),0,dp.getLength()) + &quot;from &quot; + dp.getAddress().getHostAddress() + &quot;：&quot; + dp.getPort() ; System.out.println(str) ; // 输出内容 } }","link":"/2013/09/14/javase/JAVASE-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-14/"},{"title":"JAVASE-集合","text":"集合 数学概念：集合就是具有相同属性事物的全体 计算机概念：","link":"/2013/09/08/javase/JAVASE-%E9%9B%86%E5%90%88/"},{"title":"JAVA面向对象","text":"面向过程与面向对象 程序的发展经历了两个主要阶段：面向过程，面向对象 面向对象的四个特征封装(Encapsulation) 对外部不可见 隐藏对象的属性和实现细节，仅对外公开访问方法，控制在程序中属性的读和写的访问级别 封装目的 增强安全性和简化编程，使用者不必了解具体的实现细节，而只要通过对外公开的访问方法，来使用类的成员。 封装的基本要求 把所有的属性私有化。 对每个属性提供 getter 和 setter 方法。 如果有一个带参的构造函数的话，那一定要写一个不带参的构造函数。 建议重写 toString 方法，但这不是必须的。 继承(Inheritance) 扩展类的功能多态(Polymorphism) 方法的重载 对象的多态性抽象 类与对象关系 类是对某一类事物的描述，是抽象的，概念上的定义；对象是实际存在的该类事物的每个个体，因而也称实例(instance) 类的定义 类是Java中的基本组成元素，而所有的java程序一定要被类所管理，那么定义类的简单格式如下： [public] class 类名称 {} 发现在类前面可以有选择性的来决定是否需要编写public，所以对于类的定义现在就有了两种形式：public class定义：类名称必须和文件名称保持一致，否则程序将无法编译，在一个.java之中只能有一个public class；class定义：类名称可以和文件名称不一致，但是生成的是class定义的名称，在一个.java程序之中可以同时存在多个class的定义*，编译之后会分为不同的*.class文件；示例： public class Person{ private String name; private int age; public void tell(){ System.out.println(&quot;name:&quot; + name); } } Person类图 对象的创建及使用类名 对象名称 = null; //声明对象 对象名称 = new 类名(); //实例化对象 或者 类名 对象名称 = new 类名(); 对象创建的内存图匿名对象 类的三种方式创建实例对象 创建类的实例。为某个类创建实例的方式包括:使用new操作符来创建实例，通过反射来创建实例，通过反序列化的方式来创建实例。 this关键字的作用 表示类中的属性class Person{ // 定义Person类 private String name ; // 姓名 private int age ; // 年龄 public Person(String name,int age){ // 通过构造方法赋值 name = name ; //注意这里必须改为 this.name = name; //否则对象名字赋值不成功 age = age ; //注意这里必须改为 this.age = age; //否则对象的年龄赋值不成功 } public String getInfo(){ // 取得信息的方法 return &quot;姓名：&quot; + name + &quot;，年龄：&quot; + age ; } } public class ThisDemo01{ public static void main(String args[]){ Person per1 = new Person(&quot;张三&quot;,33) ; // 调用构造实例化对象 System.out.println(per1.getInfo()) ; // 取得信息 } } //结果输出： //姓名：null，年龄：0 可以使用this调用本类的构造方法this调用构造方法时必须放在构造器首行，不能调用本身的构造器并且要避免递归调用。如果类中声明了n个构造器，则最多可以有n-1个构造器可以通过this调用其他构造器。 this表示当前对象 static关键字的作用static声明对象全局共享属性class Person{ // 定义Person类 String name ; // 定义name属性，暂时不封装 int age ; // 定义age属性，暂时不封装 static String country = &quot;A城&quot; ; // 定义城市属性，有默认值，static public Person(String name,int age){ this.name = name ; this.age = age; } public void info(){ // 得到信息 System.out.println(&quot;姓名：&quot; + this.name + &quot;，年龄：&quot; + this.age + &quot;，城市：&quot; + country) ; } } public class StaticDemo03{ public static void main(String args[]){ Person p1 = new Person(&quot;张三&quot;,30) ; // 实例化对象 Person p2 = new Person(&quot;李四&quot;,31) ; // 实例化对象 Person p3 = new Person(&quot;王五&quot;,32) ; // 实例化对象 System.out.println(&quot;--------------- 修改之前 -------------&quot;) ; p1.info() ; p2.info() ; p3.info() ; Person.country = &quot;B城&quot; ; System.out.println(&quot;--------------- 修改之后 -------------&quot;) ; p1.info() ; p2.info() ; p3.info() ; } } 内存示意图： 扩展：Java中内存区一共有四个：栈内存：可以保存对象名称(保存访问堆内存的地址)堆内存：保存每个对象的具体属性全局数据区：保存static类型的属性全局代码区：保存所有方法的定义 static定义方法 static定义的方法可以在没有实例化对象产生的情况下由类名直接进行调用。 class Person{ // 定义Person类 private String name ; // 定义name属性，暂时不封装 private int age ; // 定义age属性，暂时不封装 private static String country = &quot;A城&quot; ; // 定义城市属性，有默认值，static public static void setCountry(String c){ // 此方法可以直接由类名称调用 country = c ; } public static String getCountry(){ return country ; } public Person(String name,int age){ this.name = name ; this.age = age; } public void info(){ // 得到信息 System.out.println(&quot;姓名：&quot; + this.name + &quot;，年龄：&quot; + this.age + &quot;，城市：&quot; + country) ; } } public class StaticDemo04{ public static void main(String args[]){ Person p1 = new Person(&quot;张三&quot;,30) ; // 实例化对象 Person p2 = new Person(&quot;李四&quot;,31) ; // 实例化对象 Person p3 = new Person(&quot;王五&quot;,32) ; // 实例化对象 System.out.println(&quot;--------------- 修改之前 -------------&quot;) ; p1.info() ; p2.info() ; p3.info() ; Person.setCountry(&quot;B城&quot;) ; // 调用静态方法修改static属性的内容 System.out.println(&quot;--------------- 修改之后 -------------&quot;) ; p1.info() ; p2.info() ; p3.info() ; } } ps:static定义的方法不能调用非static的方法或属性 class Person{ // 定义Person类 private static String country = &quot;A城&quot; ; // 定义静态属性 private String name = &quot;Hello&quot; ; public static void sFun(String c){ System.out.println(&quot;name = &quot; + name) ; // 错误，不能调用非static属性 fun() ; // 错误，不能调用非static方法 } public void fun(){ System.out.println(&quot;World&quot;) ; } }; static相关应用 统计一个类产生了多少实例class Demo{ // 定义Person类 private static int count = 0 ; // 所有对象共享此属性 public Demo(){ count++ ; // 只要有对象产生就应该自增 System.out.println(&quot;产生了&quot; + count + &quot;个对象！&quot;) ; } } public class StaticDemo06{ public static void main(String args[]){ new Demo() ; // 增加新对象 new Demo() ; // 增加新对象 new Demo() ; // 增加新对象 } } 代码块 在程序编写之中可以直接使用“{}”定义一段语句，那么根据此部分定义的位置以及声明的关键字的不同，代码块一共可以分为四种：普通代码块、构造块、静态块、同步代码块（多线程时讲解） 普通代码块 普通代码块是定义在方法中的代码块 public class CodeDemo01{ public static void main(String args[]){ { // 普通代码块 int x = 30 ; // 就属于一个局部变量 System.out.println(&quot;普通代码块 --&gt; x = &quot; + x) ; } int x = 100 ; // 与局部变量名称相同 System.out.println(&quot;代码块之外 --&gt; x = &quot; + x) ; } }; // 输出结果： // 普通代码块 --&gt; x = 30 // 代码块之外 --&gt; x = 100 ps:普通代码块中变量x，不会与全局的x变量互相影响，使用普通代码块可以将一个方法中的代码进行部分分割，但是从实际开发来讲，这种代码块使用的机会较少。 构造块 普通代码块是定义在方法中的，而构造块是定义在类中的代码块。 class Demo{ { // 直接在类中编写代码块，称为构造块 System.out.println(&quot;1、构造块。&quot;) ; } public Demo(){ // 定义构造方法 System.out.println(&quot;2、构造方法。&quot;) ; } }; public class CodeDemo02{ public static void main(String args[]){ new Demo() ; // 实例化对象 new Demo() ; // 实例化对象 new Demo() ; // 实例化对象 } }; // 输出结果： // 1、构造块。 // 2、构造方法。 // 1、构造块。 // 2、构造方法。 // 1、构造块。 // 2、构造方法 ps:可以发现，构造块优先于构造方法执行，而且每当有一个新的实例化对象产生时，就会重复执行构造块的程序。 静态块 静态块也是定义在类中，如果一个构造块上使用了static关键字进行定义的话，那么就表示静态块，但是静态块要考虑两种情况。情况一：在非主类中定义的构造块；情况二：在主类中定义的构造块。 class Demo{ { // 直接在类中编写代码块，称为构造块 System.out.println(&quot;1、构造块。&quot;) ; } static{ // 使用static，称为静态代码块 System.out.println(&quot;0、静态代码块&quot;) ; } public Demo(){ // 定义构造方法 System.out.println(&quot;2、构造方法。&quot;) ; } }; public class CodeDemo03{ static{ // 在主方法所在的类中定义静态块 System.out.println(&quot;在主类中定义的静态代码块&quot;) ; } public static void main(String args[]){ System.out.println(&quot;在主类的主方法main&quot;); new Demo() ; // 实例化对象 new Demo() ; // 实例化对象 new Demo() ; // 实例化对象 } }; // 输出结果： // 在主类中定义的静态代码块 // 在主类的主方法main // 0、静态代码块 // 1、构造块。 // 2、构造方法。 // 1、构造块。 // 2、构造方法。 // 1、构造块。 // 2、构造方法 ps:可以发现主类中定义的静态块的执行要优先于主方法执行。静态块用于初始化类，为类的属性初始化。每个静态代码块只会执行一次。由于JVM在加载类时会执行静态代码块，所以静态代码块先于主方法执行。如果类中包含多个静态代码块，那么将按照”先定义的代码先执行，后定义的代码后执行”。执行顺序：（优先级从高到低。）静态代码块-mian方法-构造代码块-构造方法。其中静态代码块只执行一次。构造代码块在每次创建对象是都会执行。注意：1 静态代码块不能存在于任何方法体内。2 静态代码块不能直接访问实例变量和实例方法，需要通过类的实例对象来访问。 jdk1.7之前静态块与主方法 在JDK1.7前，实际上Java一直存在于一个bug。按照标准来讲，所有的程序应该由主方法开始执行，静态块会优先于主方法执行，所以在JDK1.7前是可以使用静态块来代替主方法的。示例： public class Test{ static{ System.out.println(&quot;Hello World.&quot;); System.exit(1); } } 内部类 内部类是一种类的结构扩充，让一个类的内部除了属性与方法之外还可以存在有其它类的结构，并且内部类也可以定义在方法或代码块中 class Outer { // 外部类 private String msg = &quot;Hello World !&quot; ; class Inner { // 定义了一个内部类 private String info = &quot;世界，你好！&quot; ; // 内部类的私有属性 public void print() { System.out.println(msg) ;// 直接访问外部类的私有属性 } } public void fun() { Inner in = new Inner() ; // 内部类对象 System.out.println(in.info) ;// 直接利用了内部类对象访问了内部类中定义的私有属性 } } public class TestDemo { public static void main(String args[]) { Outer out = new Outer() ; // 实例化外部类对象 out.fun() ; // 调用外部类方法 } } //程序输出 //世界，你好！ 实例化内部类对象 内部类实例化语法：外部类.内部类 对象 = new 外部类().new 内部类()；由于内部类需要使用外部类中的属性，而所有的属性只有在对象实例化之后才会分配空间，所以在实例化内部类对象时首先要实例化外部类对象，但是需要提醒读者的是，以上的格式只是一个基础，指的是在一个类内部只定义一个内部类的情况，而如果说一个内部类中又定义了内部类，则类结构需要继续向下延伸，变为“外部类.内部类1.内部类2 对象 = new 外部类().new 内部类1().new 内部类2()；”示例： class Outer { // 外部类 private String msg = &quot;Hello World !&quot; ; class Inner { // 定义了一个内部类 public void print() { System.out.println(Outer.this.msg) ; } } } public class TestDemo { public static void main(String args[]) { Outer.Inner in = new Outer().new Inner() ; // 实例化内部类对象 in.print() ; } } 定义私有内部类 由于存在有private声明，所以Inner类只能够在Outer类的内部使用，这个时候将无法在外部实例化Inner类对象，而这个内部类只能够为Outer一个类服务。示例： class Outer { // 外部类 private String msg = &quot;Hello World !&quot; ; private class Inner { // 定义私有内部类 public void print() { System.out.println(Outer.this.msg) ; } } } 使用static定义内部类 使用static定义的属性或者是方法是不受到类实例化对象控制的，所以如果使用了static定义内部类。它一定不可能受到外部类的实例化对象控制。如果一个内部类使用了static定义的话，那么这个内部类就变为了一个“外部类”，并且只能够访问外部类中定义的static操作。相当于定义一个外部类。 class Outer { // 外部类 private static String msg = &quot;Hello World !&quot;; // static属性 static class Inner { // static定义的内部类等同于外部类 public void print() { System.out.println(Outer.msg); // 直接访问static属性 } } } //此时的代码利用了static定义了内部类，这个内部类就相当于变为了外部类，并且只能够访问Outer类中的static属性或方法。但是此时如果要想取得内部类的实例化对象，使用的语法如下： //外部类.内部类 对象 = new 外部类.内部类() ; class Outer { // 外部类 private static String msg = &quot;Hello World !&quot;; // static属性 static class Inner { // static定义的内部类等同于外部类 public void print() { System.out.println(Outer.msg);// 直接访问static属性 } } } public class TestDemo { public static void main(String args[]) { Outer.Inner in = new Outer.Inner() ;// 实例化“外部类”对象 in.print() ; // 调用方法 } } 在方法中定义内部类 内部类理论上可以在类的任意位置上进行定义，这就包括代码块之中，或者是普通方法之中，而在以后的开发过程之中，在普通方法里面定义内部类的情况是最多的。 class Outer { // 外部类 private String msg = &quot;Hello World !&quot; ; public void fun() { // 外部类普通方法 class Inner { // 方法中定义的内部类 public void print() { System.out.println(Outer.this.msg) ; } } new Inner().print() ; // 内部类实例化对象调用print()输出 } } public class TestDemo { public static void main(String args[]) { new Outer().fun() ; } } //程序执行: Hello World ! 范例：访问方法中定义的参数或者是变量 class Outer { // 外部类 private String msg = &quot;Hello World !&quot; ; public void fun(int num) { // 外部类普通方法 double score = 99.9 ; // 方法变量 class Inner { // 方法中定义的内部类 public void print() { System.out.println(&quot;属性：&quot; + Outer.this.msg) ; System.out.println(&quot;方法参数：&quot; + num) ; System.out.println(&quot;方法变量：&quot; + score) ; } } new Inner().print() ;// 内部类实例化对象调用print()输出 } } public class TestDemo { public static void main(String args[]) { new Outer().fun(100) ; } } //程序执行结果： 属性：Hello World ! 方法参数：100 方法变量：99.9 final关键字修饰变量： 被final修饰的变量不可改变。即初始化一次后，就不能再次被赋值！即，变为常量！ 修饰方法： 被final修饰的方法不可以被子类重写！ 修饰类： 被final修饰的类不能被继承! 访问控制权限 Java中存在四种访问权限private访问权限default（默认）访问权限protected访问权限public访问权限","link":"/2013/09/02/javase/JAVASE-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-02/"},{"title":"JAVA引用的强软弱虚","text":"引用分类- 强引用 Strongreference:引用指向对象，gc（ Garbage collection）运行时不回收 - 软引用: Softreference ac运行时可能回收（im内存不够） - 弱引用 Weakreference ac运行时立即回收 - 虚引用 Phantomreference类似于无引用，主要跟踪对象被回收的状态不能单独使用，必须与引用队列 Referencequeue）联合使用 目的避免对象长期驻留在内存中解决垃圾回收机制回收时机问题 Weakhashmap√键为弱引用，回收键后自动删除key－ value对象Identityhashmap√键只以地址去重，而不是比较 thashcode与 equals√注意:键是常量池中的字符串Enummap√键必须为枚举的值√构造器: public Enummlap（指定枚举 class对象）","link":"/2014/07/04/javase/JAVA%E5%BC%95%E7%94%A8%E7%9A%84%E5%BC%BA%E8%BD%AF%E5%BC%B1%E8%99%9A/"},{"title":"数据库连接池dbcp,c3p0，","text":"数据库连接池 数据库连接是一种关键的有限的昂贵的资源，数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术能明显提高对数据库操作的性能。连接池的优点 节省创建连接与释放连接性能消耗，连接池中连接起到复用的作用，提高程序性能 连接池原理 连接池基本的思想是在系统初始化的时候，将数据库连接作为对象存储在内存中，当用户需要访问数据库时，并非建立一个新的连接，而是从连接池中取出一个已建立的空闲连接对象。使用完毕后，用户也并非将连接关闭，而是将连接放回连接池中，以供下一个请求访问使用。而连接的建立、断开都由连接池自身来管理。同时，还可以通过设置连接池的参数来控制连接池中的初始连接数、连接的上下限数以及每个连接的最大使用次数、最大空闲时间等等。也可以通过其自身的管理机制来监视数据库连接的数量、使用情况等。 连接池参数（所有池参数都有默认值）： 初始大小：10个 最小空闲连接数：3个 增量：一次创建的最小单位（5个） 最大空闲连接数：12个 最大连接数：20个 最大的等待时间：1000毫秒 Apache的DBCP连接池 DBCP 是 Apache 软件基金组织下的开源连接池实现，使用DBCP数据源，应用程序应在系统中增加如下两个 jar 文件： Commons-dbcp.jar：连接池的实现 Commons-pool.jar：连接池实现的依赖库 依赖jar包&lt;dependency&gt; &lt;groupId&gt;commons-dbcp&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt; DBCP连接池实例化// 1.创建连接池对象 BasicDataSource ds = new BasicDataSource(); // 2.设置相关属性 ds.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); ds.setUrl(&quot;jdbc:mysql://127.0.0.1:3306/testDB&quot;); ds.setUsername(&quot;root&quot;); ds.setPassword(&quot;root&quot;); DBCP采用配置文件实例化dbcpconfig.properties配置文件 DRIVERCLASS=com.mysql.jdbc.Driver URL=jdbc:mysql://127.0.0.1:3306/testDB USER=root PWD=root #DRIVERCLASS=oracle.jdbc.driver.OracleDriver #URL=jdbc:oracle:thin:@localhost:1521:xe #USER=system #PWD=123 static{ InputStream in = JdbcUtil.class.getClassLoader(). getResourceAsStream(&quot;dbcpconfig.properties&quot;); Properties prop = new Properties(); prop.load(in); BasicDataSourceFactory factory = new BasicDataSourceFactory(); dataSource = factory.createDataSource(prop); } c3p0连接池 C3P0是一个开源的JDBC连接池，它实现了数据源和JNDI绑定，支持JDBC3规范和JDBC2的标准扩展。目前使用它的开源项目有Hibernate，Spring等。 c3p0与dbcp区别 dbcp没有自动回收空闲连接的功能 c3p0有自动回收空闲连接功能 依赖jar包&lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;/dependency&gt; c3p0连接池实例化ComboPooledDataSource ds = new ComboPooledDataSource(); // 2.手动配置参数 ds.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;); ds.setJdbcUrl(&quot;jdbc:mysql://127.0.0.1:3306/testDB&quot;); ds.setUser(&quot;root&quot;); ds.setPassword(&quot;root&quot;); ds. setMaxPoolSize (40) ; ds. setMinPoolSize(10) ; ds. setInitialPoolSize(30) ; Connection conn = ds.getConnection() ; c3p0连接池使用配置文件只要在项目的classpath下创建c3p0.properties or c3p0-config.xml名称的配置文件。ComboPooledDataSource ds = new ComboPooledDataSource()；c3p0会自动查找配置文件&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;c3p0-config&gt; &lt;default-config&gt; &lt;!-- 默认配置 --&gt; &lt;property name=&quot;driverClass&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot;&gt;jdbc:mysql://127.0.0.1:3306/testDB1&lt;/property&gt; &lt;property name=&quot;user&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;password&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;acquireIncrement&quot;&gt;10&lt;/property&gt; &lt;property name=&quot;initialPoolSize&quot;&gt;10&lt;/property&gt; &lt;property name=&quot;maxPoolSize&quot;&gt;100&lt;/property&gt; &lt;property name=&quot;maxIdleTime&quot;&gt;60&lt;/property&gt; &lt;property name=&quot;minPoolSize&quot;&gt;5&lt;/property&gt; &lt;/default-config&gt; &lt;named-config name=&quot;itcast&quot;&gt; &lt;!-- 默认配置 --&gt; &lt;property name=&quot;driverClass&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot;&gt;jdbc:mysql://127.0.0.1:3306/testDB2&lt;/property&gt; &lt;property name=&quot;user&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;password&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;acquireIncrement&quot;&gt;10&lt;/property&gt; &lt;property name=&quot;initialPoolSize&quot;&gt;10&lt;/property&gt; &lt;property name=&quot;maxPoolSize&quot;&gt;100&lt;/property&gt; &lt;property name=&quot;maxIdleTime&quot;&gt;60&lt;/property&gt; &lt;property name=&quot;minPoolSize&quot;&gt;5&lt;/property&gt; &lt;/named-config&gt; &lt;/c3p0-config&gt; tomcat内置连接池介绍 在web开发中，可以将连接池交给服务器管理，如果需要时，就可以直接从服务器中获取连接对象。在tomcat中提供了一个context.xml文件,我们可以将连接池配置在这个文件中，详细信息大家可以查看tomcat帮助文档 context.xml文件可以放置在三个位置: 1.tomcat/conf下 这个配置是被服务器下所有应用所使用的. 2.tomcat/Catalina/xxx目录下，这个配置被某一个虚拟主机使用 3.在web工程的META-INF目录下创建一个context.xml文件，它是被当前工程所使用配置tomcat内置连接池特别提醒：此种配置下，驱动jar文件需放置在tomcat的lib下&lt;Context&gt; &lt;Resource name=&quot;jdbc/testDBSource&quot; auth=&quot;Container&quot; type=&quot;javax.sql.DataSource&quot; username=&quot;root&quot; password=&quot;root&quot; driverClassName=&quot;com.mysql.jdbc.Driver&quot; url=&quot;jdbc:mysql://127.0.0.1:3306/testDB&quot; maxActive=&quot;8&quot; maxIdle=&quot;4&quot;/&gt; &lt;/Context&gt; JNDI介绍(sun公司模仿windows的服务注册列表) JNDI(Java Naming and Directory Interface)，Java命名和目录接口，它对应于J2SE中的javax.naming包，这套API的主要作用在于：它可以把Java对象放在一个容器中（支持JNDI容器 Tomcat），并为容器中的java对象取一个名称，以后程序想获得Java对象，只需通过名称检索即可。 其核心API为Context，它代表JNDI容器，其lookup方法为检索容器中对应名称的对象。 从服务器中获取连接对象:Context context = new InitialContext(); // 初始化上下文对象 Context envCtx = (Context) context.lookup(&quot;java:comp/env&quot;); // 固定路径 DataSource ds = (DataSource) envCtx.lookup(&quot;jdbc/testDBSource&quot;);// 通过绑定名称，查找指定java对象 Spring的内置连接池-DriverManagerDataSource","link":"/2013/09/14/javase/JDBC-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/"},{"title":"JVM优化第二篇","text":"适当调整Tomcat的运行JVM参数可以提升整体性能 JVM内存模型 JVM参数介绍修改文件：bin/catalina.sh JAVA_OPTS=&quot;-Dfile.encoding=UTF-8 -server -Xms1024m -Xmx1024m -XX:NewSize=512m -XX:MaxNewSize=512m -XX:PermSize=256m -XX:MaxPermSize=256m -XX:NewRatio=2 -XX:MaxTenuringThreshold=50 -XX:+DisableExplicitGC&quot; 参数说明： 1、 file.encoding 默认文件编码 2、 -Xmx1024m 设置JVM最大可用内存为1024MB 3、 -Xms1024m 设置JVM最小内存为1024m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。 4、 -XX:NewSize 设置年轻代大小 5、 XX:MaxNewSize 设置最大的年轻代大小 6、 -XX:PermSize 设置永久代大小 7、 -XX:MaxPermSize 设置最大永久代大小 8、 -XX:NewRatio=4:设置年轻代（包括Eden和两个Survivor区）与终身代的比值（除去永久代）。设置为4，则年轻代与终身代所占比值为1：4，年轻代占整个堆栈的1/5 9、 -XX:MaxTenuringThreshold=0：设置垃圾最大年龄，默认为：15。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。 10、 -XX:+DisableExplicitGC这个将会忽略手动调用GC的代码使得 System.gc()的调用就会变成一个空调用，完全不会触发任何GC 在tomcat中设置jvm参数linux环境下修改bin/catalina.sh文件参数（第一行）,注意需要引号，Windows环境不需要引号 JAVA_OPTS=&quot;-Dfile.encoding=UTF-8 -server -Xms1024m -Xmx2048m -XX:NewSize=512m -XX:MaxNewSize=1024m -XX:PermSize=256m -XX:MaxPermSize=256m -XX:MaxTenuringThreshold=10 -XX:NewRatio=2 -XX:+DisableExplicitGC&quot; windows环境下修改bin/catalina.bat文件设置参数（第一行）,不需要引号 set JAVA_OPTS=-Dfile.encoding=UTF-8 -server -Xms1024m -Xmx2048m -XX:NewSize=512m -XX:MaxNewSize=1024m -XX:PermSize=256m -XX:MaxPermSize=256m -XX:MaxTenuringThreshold=10 -XX:NewRatio=2 -XX:+DisableExplicitGC","link":"/2016/12/15/javase/JVM%E4%BC%98%E5%8C%96%E7%AC%AC%E4%BA%8C%E7%AF%87/"},{"title":"JVM初次认识","text":"JVM全貌图线程私有程序计数器 类似threadlocal，保证线程在CPU时间片切换，还能从上次执行的地方开始执行 栈区介绍(一个线程一个栈空间) JVM方法栈，java文件定义的方法 本地方法栈, native-jni,c,c++执行后的结果 程序计数器，计算代码执行地址堆空间(线程无关，所有线程共享的空间) 对象空间,存放程序实际new出来的对象,动态分配，垃圾回收主要作用的空间 持久层方法区,存放类信息，常量，静态变量，编译后的字节码*.class文件,固定不变，JVM启动就分配，JVM退出则销毁ps: *.class文件已经将原来 *.java里定义的类，方法，编译成串行执行指令，以二进制形式存在 JVM异常OutOfMemoryError 一般指的堆空间溢出，主要是对象生成太多，而没有释放和销毁。StackOverFlowError 栈空间溢出，主要是方法调用层级太多，超过虚拟机所允许的最大层级。例如，递归没有终止条件，函数递归可能出现栈空间溢出。栈空间是以线程为单位编排的JVM性能调优 虚拟机内存管理垃圾回收机制(Garbage Collection)JAVA的内存管理实际上指的就是对象的管理，其中包括对象空间的分配和释放。 对象空间的分配使用new关键字创建对象即可 对象空间的释放将对象赋值null，即该对象没有引用指向时。垃圾回收器将负责回收所有”不可达”对象的内存空间。 要点 程序员无权调用垃圾回收器。 **程序员可以通过System.gc()。通知GC运行，但是JAVA规范并不能保证立刻运行。** **finalize方法**，是JAVA提供给程序员用来释放对象或资源的方法，**但是尽量少用**。","link":"/2014/03/03/javase/JVM%E5%88%9D%E6%AC%A1%E8%AE%A4%E8%AF%86/"},{"title":"JAVA7 新特性","text":"二进制整数JDK7开始，可以使用二进制来表示整数(byte,short,int和long)，使用二进制的字面量的好处是代码更容易别理解。语法非常简单。只要在二进制数值前面加0b或者0B.示例: public class TestBinary { public static void main(String[] args) { byte b = (byte)0b11001; //25 short s = (short)0b110010; //50 int i = 0b1100100; //100 long l = 0b10000000; //128 } } 下划线分隔符在实际开发和学习中，如果遇到特别长的数字，读懂它令人头疼！JDK7为我们提供了下划线分隔符，可以按照自己的习惯进行分割，如:int b = 1_2312_3131;我们很容易就知道这是1亿2312万3131啦！ 非常符合国人的习惯！ public class TestBinaryNum { public static void main(String[] args){ int a = 0b0000_0000_0000_0000_0000_0000_0000_0011; int b = 1_2312_3131; System.out.println(a); System.out.println(b); } } 增强的switch:JDK1.7增强了switch 语句的功能,允许switch语句的控制表达式是java.lang.String类型的变量或表达式 public class TestSwitch { public static void main(String[] args) { String season = &quot;春天&quot;; switch (season) { case &quot;春天&quot;: System.out.println(&quot;春暖花开&quot;); break; case &quot;夏天&quot;: System.out.println(&quot;夏日炎炎&quot;); break; case &quot;秋天&quot;: System.out.println(&quot;秋高气爽&quot;); break; case &quot;冬天&quot;: System.out.println(&quot;冬雪皑皑&quot;); break; default: break; } } } 泛型的菱形语法在JDK1.7之前使用带泛型的接口，类定义了变量，那么调用构造器创建对象时后面也必须带泛型，这显得有些多余了，例如： List&lt;String&gt; strList = new ArrayList&lt;String&gt;(); 在JAVA 7 以前是必须的不能省略，从JAVA 7 开始，构造器后面不需要带完整的泛型信息，即： List&lt;String&gt; strList = new ArrayList&lt;&gt;(); 自动关闭资源的try当程序使用finally块关闭资源时，程序显得异常臃肿 示例： public class TestFileIO { public static void main(String[] args) { FileInputStream fis = null; try { fis = new FileInputStream(&quot;a.txt&quot;); }catch(FileNotFoundException e) { e.printStackTrace(); }finally { if(fis != null) { try { fis.close(); }catch (IOException e) { e.printStackTrace(); } } } } } 在java 7，上面的finally关闭资源代码不得不写，但JAVA 7的出现改变了这种局面。java 7 增强了try语句的功能，它允许在try 关键字后紧跟一对圆括号,圆括号可以声明，初始化一个或多个资源，此处的资源指的那些必须在程序结束时显示关闭的资源(比如数据库连接、网络连接等),try语句在该语句结束时自动关闭这些资源 需要指出的是，为了保证try语句可以正常关闭资源，这些资源实现类必须实现AutoCloseable或Closeable接口，实现这两个接口就必须close()方法 Closeable是AutoCloseable的子接口，可以被自动关闭的资源类要么实现AutoCloseable接口，要么实现Closeable接口。Closeable接口里的close方法声明抛出了 IOException,因此它的实现类在实现close()方法时只能声明抛出IOException 或其子类；AutoCloseable接口里的close()方法声明抛出了Exception，因此它的实现在实现close()方法时可以声明抛出任何异常 自动关闭资源的try语句相当于包含了隐士的finally块(这个finally块用于关闭资源)，因此这个try语句可以既没有catch块，也没有finally块。 如果程序需要，自动关闭资源的try语句后也可以带多个catch块和一个finally块。//可以用来关闭Scanner 等IO流 try(Scanner console=new Scanner(System.in)){ int x= console.nextInt(); } // 也可用来关闭JDBC中用到的资源 public class InsertSample2 { public static void main(String[] args) { XSB student = new XSB(&quot;191602&quot;, &quot;李四&quot;, 0, &quot;1998-7-9&quot;, &quot;计算机&quot;, 0, null); String sql = &quot;INSERT INTO xsb(xh, xm, xb, csrq, zy, zxf, bz) &quot; + &quot;VALUES(?, ?, ?, ?, ?, ?, ?)&quot;; try (Connection con = DriverManager.getConnection(url, user, password); PreparedStatement pstmt = con.prepareStatement(sql)) { pstmt.setString(1, student.getXh()); pstmt.setString(2, student.getXm()); pstmt.setInt(3, student.getXb()); pstmt.setString(4, student.getCsrq()); pstmt.setString(5, student.getZy()); pstmt.setInt(6, student.getZxf()); pstmt.setString(7, student.getBz()); int rowCount = pstmt.executeUpdate(); System.out.println(&quot;插入&quot; + rowCount + &quot;行&quot;); } catch (SQLException e) { e.printStackTrace(); } } } 多异常捕捉 JAVA 7以前，每个catch只能捕捉一种类型的异常，但从JAVA 7开始，一个catch块可以捕捉多种类型的异常。 使用一个catch块捕捉多种类型的异常时有如下两个需要注意的地方： 捕捉多个类型的异常时，多个异常类型之间用竖线(|) 隔开 捕捉多个类型的异常时，异常变量有隐士的final修饰，因此程序不能对异常变量重新赋值示例：public class TestMutilException { public static void main(String[] args) { try { int a = Integer.parseInt(args[0]); int b = Integer.parseInt(args[1]); int c = a/b; System.out.println(&quot;输入的两个数相除的结果是：&quot; + c); } catch (NumberFormatException | IndexOutOfBoundsException | ArithmeticException e) { System.err.println(&quot;程序发生了数组越界，数字格式异常，算术异常之一&quot;); //捕捉多异常，异常变量默认有final修饰， //所以下面代码有错 // ie = new ArithmeticException(&quot;test&quot;) }catch(Exception e){ System.err.println(&quot;未知异常&quot;); // 捕捉一个类型的异常时，异常变量没有final修饰 // 所以下面代码完全正确 e = new RuntimeException(&quot;test&quot;); } } }","link":"/2014/07/01/javase/java7%E6%96%B0%E7%89%B9%E6%80%A7/"},{"title":"JAVA8 新特性","text":"新特性概览 1. Lambda 表达式 2. 函数式接口 3. 方法引用与构造器引用 4. Stream API 5. 接口中的默认方法与静态方法 6. 新时间日期API 7. 其他新特性 速度更快;代码更少(增加了新的语法 Lambda 表达式) 强大的Stream API;便于并行;最大化减少空指针异常 Optional Lambda 表达式 Lambda 是一个匿名函数，我们可以把 Lambda 表达式理解为是一段可以传递的代码(将代码 像数据一样进行传递)。可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使 Java的语言表达能力得到了提升。 Lambda 表达式语法Lambda 表达式在Java 语言中引入了一个新的语法元 素和操作符。这个操作符为 “-&gt;” ， 该操作符被称 为 Lambda 操作符或剪头操作符。它将 Lambda 分为 两个部分: **左侧:**指定了 Lambda 表达式需要的所有参数 **右侧:**指定了 Lambda 体，即 Lambda 表达式要执行 的功能。 (params) -&gt; expression //函数名呢?没有!!! (params) -&gt; statement //函数名呢?没有!!! (params) -&gt; { statements } //函数名呢?没有!!! 包含三个部分 一个括号内用逗号分隔的形式参数，参数是函数式接口里面方法的参数 一个箭头符号:-&gt; 方法体，可以是表达式和代码块，方法体函数式接口里面方法的实现，如果是代码块，则必须用{}来包裹起来，且需要一个return 返回值，但有个例外，若 函数式接口里面方法返回值是void，则无需{} 示例: public static void runThreadUseLambda() { //Runnable是一个函数接口，只包含了有个无参数的，返回void的run方法; //所以lambda表达式左边没有参数，右边也没有return，只是单纯的打印一句话 new Thread(() -&gt;System.out.println(&quot;lambda实现的线程&quot;)).start(); } 函数式接口只包含一个抽象方法的接口，称为函数式接口。 你可以通过 Lambda 表达式来创建该接口的对象。(若 Lambda表达式抛出一个受检异常，那么该异常需要在目标接口的抽象方法上进行声明)。 我们可以在任意函数式接口上使用 @FunctionalInterface 注解，这样做可以检查它是否是一个函数式接口，同时 javadoc 也会包 含一条声明，说明这个接口是一个函数式接口。@FunctionalInterface interface MyFunc&lt;T&gt; { T get(T t); } class Test { public static String getStrUpcase(MyFunc&lt;String&gt; t,String str) { return t.get(str); } public static void main(String[] args) { System.out.println(getStrUpcase((t)-&gt;t.toUpperCase(), &quot;abc&quot;)); System.out.println(getStrUpcase((t)-&gt;t.substring(1, 3), &quot;abccde&quot;)); } } 输出: ABC bc Java 内置四大核心函数式接口其它函数式接口方法引用方法引用是什么? 是lambda表达式的一个简化写法. 方法引用语法:左边是容器(可以是类名，实例名)，中间是” :: “，右边是相应的方法名。如下所示:一般方法的引用格式是如果是静态方法，则是ClassName::methodName。如 Object ::equals如果是实例方法，则是Instance::methodName。如Object obj=new Object();obj::equals;构造函数.则是ClassName::new方法引用构造器引用数组引用Stream APIJava8中有两大最为重要的改变。第一个是 Lambda 表达式;另外一 个则是 Stream API(java.util.stream.*)。Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对 集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。 使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数 据库查询。也可以使用 Stream API 来并行执行操作。简而言之， Stream API 提供了一种高效且易于使用的处理数据的方式。注意:1.Stream 自己不会存储元素。2.Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。3.Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行 Stream操作的三个步骤 创建 StreamJava8 中的 Collection 接口被扩展，提供了两个获取流的方法: default Stream stream() : 返回一个顺序流 default Stream parallelStream() : 返回一个并行流 由数组创建流Java8 中的 Arrays 的静态方法 stream() 可 以获取数组流: static Stream stream(T[] array): 返回一个流重载形式，能够处理对应基本类型的数组: public static IntStream stream(int[] array) public static LongStream stream(long[] array) public static DoubleStream stream(double[] array) 由值创建流可以使用静态方法 Stream.of(), 通过显示值 创建一个流。它可以接收任意数量的参数。 public static Stream of(T… values) : 返回一个流 由函数创建流:创建无限流可以使用静态方法 Stream.iterate() 和 Stream.generate(), 创建无限流。 迭代public static Stream iterate(final T seed, final UnaryOperator f) 生成public static Stream generate(Supplier s) : Stream的中间操作多个中间操作可以连接起来形成一个流水线，除非流水 线上触发终止操作，否则中间操作不会执行任何的处理! 而在终止操作时一次性全部处理，称为“惰性求值”。 筛选与切片 映射 排序 Stream的终止操作 并行流与串行流并行流就是把一个内容分成多个数据块，并用不同的线程分 别处理每个数据块的流。Java 8 中将并行进行了优化，我们可以很容易的对数据进行并 行操作。Stream API 可以声明性地通过 parallel() 与 sequential() 在并行流与顺序流之间进行切换。 新时间日期 API 使用 LocalDate、LocalTime、LocalDateTime LocalDate、LocalTime、LocalDateTime 类的实 例是不可变的对象，分别表示使用 ISO-8601日 历系统的日期、时间、日期和时间。它们提供 了简单的日期或时间，并不包含当前的时间信 息。也不包含与时区相关的信息。 Instant 时间戳用于“时间戳”的运算。它是以Unix元年(传统 的设定为UTC时区1970年1月1日午夜时分)开始 所经历的描述进行运算 Duration 和 PeriodDuration:用于计算两个“时间”间隔Period:用于计算两个“日期”间隔","link":"/2016/11/01/javase/java8%E6%96%B0%E7%89%B9%E6%80%A7-2016-11-01/"},{"title":"JAVA8 新特性实战","text":"新","link":"/2016/11/02/javase/java8%E6%96%B0%E7%89%B9%E6%80%A7%E5%AE%9E%E6%88%98-2016-11-02/"},{"title":"java单向队列与双向队列,stack类","text":"单向队列与双向队列模拟银行排队办理存款业务 public class QueueDemo { public static void main(String[] args) { Queue&lt;Request&gt; queue = new ArrayDeque&lt;Request&gt;(); for (int i = 0; i &lt; 10; i++) { final int num = i; queue.offer(new Request() { //入队 public void deposit() { System.out.println(&quot;第&quot;+num+&quot;个人，办理存款业务，存款额度:&quot;+(Math.random()+1000)); } }); } dealWith(queue); } public static void dealWith(Queue&lt;Request&gt; queue) { Request request = null; while( (request = queue.poll())!=null) { //出队 request.deposit(); } } } interface Request { void deposit();// 存款 } //输出： //第0个人，办理存款业务，存款额度:1000.7644793325873 //第1个人，办理存款业务，存款额度:1000.0352004153044 //第2个人，办理存款业务，存款额度:1000.4463195586463 //第3个人，办理存款业务，存款额度:1000.8480898925962 //第4个人，办理存款业务，存款额度:1000.0048498826396 //第5个人，办理存款业务，存款额度:1000.8563283038636 //第6个人，办理存款业务，存款额度:1000.4270846461806 //第7个人，办理存款业务，存款额度:1000.4050626707306 //第8个人，办理存款业务，存款额度:1000.4158023189915 //第9个人，办理存款业务，存款额度:1000.4508035778159 自定义栈/** * 使用队列实现自定义堆栈 * 1、弹 * 2、压 * 3、获取头 * @param &lt;E&gt; */ public class MyStack&lt;E&gt; { //容器 private Deque&lt;E&gt; container =new ArrayDeque&lt;E&gt;(); //容量 private int cap; public MyStack(int cap) { super(); this.cap = cap; } //压栈 public boolean push(E e){ if(container.size()+1&gt;cap){ return false; } return container.offerLast(e); //压栈 } //弹栈 public E pop(){ return container.pollLast(); //出栈 } //获取 public E peek(){ return container.peekLast(); //获取头 } public int size(){ return this.container.size(); } public static void main(String[] args) { MyStack&lt;String&gt; backHistory =new MyStack&lt;String&gt;(3); backHistory.push(&quot;www.baidu.com&quot;); backHistory.push(&quot;www.google.com&quot;); backHistory.push(&quot;www.sina.com&quot;); backHistory.push(&quot;www.sxm.cn&quot;); System.out.println(&quot;大小：&quot;+backHistory.size()); System.out.println(&quot;获取头 &quot;+ backHistory.peek()) ; //遍历 String item=null; while(null!=(item=backHistory.pop())){ //出栈 System.out.println(item); } } } /** 输出效果： 大小：3 获取头 www.sina.com www.sina.com www.google.com www.baidu.com **/ stack类 栈是采用先进后出的数据存储方式，每一个栈都包含一个栈顶，每次出栈是将栈顶的数据取出 在Java中使用Stack类进行栈的操作，Stack类是Vector的子类，Stack类的定义如下：public class Stack&lt;E&gt; extends Vector&lt;E&gt; package com.ecit; import java.util.Stack; public class StackDemo { public static void main(String args[]) { Stack&lt;String&gt; s = new Stack&lt;String&gt;(); // 实例化Stack对象 s.push(&quot;A&quot;); // 入栈 s.push(&quot;B&quot;); // 入栈 s.push(&quot;C&quot;); // 入栈 System.out.print(s.pop() + &quot;、&quot;) ; // 出栈 System.out.print(s.pop() + &quot;、&quot;) ; // 出栈 System.out.println(s.pop() + &quot;、&quot;) ; // 出栈 System.out.print(s.pop() + &quot;、&quot;) ; // 错误，出栈，出现异常，栈为空 } } /** *输出结果： C、B、A、 Exception in thread &quot;main&quot; java.util.EmptyStackException ... **/","link":"/2015/07/01/javase/java%E5%8D%95%E5%90%91%E9%98%9F%E5%88%97%E4%B8%8E%E5%8F%8C%E5%90%91%E9%98%9F%E5%88%97/"},{"title":"谷歌公司guava和Apache公司的collections","text":"三方容器jar（谷歌guava 瓜娃） &lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;version&gt;14.0.1&lt;/version&gt; &lt;/dependency&gt; 三方容器jar（Apache的commons-collections） &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-collections4&lt;/artifactId&gt; &lt;version&gt;4.1&lt;/version&gt; &lt;/dependency&gt; 集合JDK中的只读属性，类似视图快照 Map&lt;String,String&gt; map =new HashMap&lt;String,String&gt;(); map.put(&quot;test&quot;, &quot;test&quot;); map.put(&quot;2222&quot;, &quot;2222&quot;); //只读控制 //对原有map包装，相当于原有map的视图，快照，不够安全 Map&lt;String,String&gt; map2 =Collections.unmodifiableMap(map); //map2.put(&quot;a&quot;, &quot;a&quot;); //不能操作 map.put(&quot;111&quot;, &quot;1111&quot;); //改变原有元素，视图也一起改变 System.out.println(map2.size()); //一个元素的容器测试 List&lt;String&gt; list =Collections.singletonList(new String(&quot;aaa&quot;)); //list.add(&quot;test&quot;); //只能包含一个元素的容器,一执行就报错 //相比只读设置map，guava安全可靠，相对简单 Map&lt;String,String&gt; guvaMap = ImmutableMap.of(&quot;test&quot;,&quot;test&quot;,&quot;2222&quot;,&quot;2222&quot;,&quot;111&quot;,&quot;1111&quot;); //guvaMap.put(&quot;3333&quot;, &quot;333&quot;); System.out.println(guvaMap.size()); 输出： 3 3 guava函数式编程 容器转换 回文 过滤import java.text.SimpleDateFormat; import java.util.Collection; import java.util.List; import java.util.Set; import org.junit.Test; import com.google.common.base.Function; import com.google.common.base.Functions; import com.google.common.base.Predicate; import com.google.common.collect.Collections2; import com.google.common.collect.Lists; import com.google.common.collect.Sets; /** * 函数式编程 :解耦 * 1、Predicate * 2、Function * 工具:Collections2.filter() 过滤器 * Collections2.transfer() 转换 * Functions.compose()组合式函数编程 */ public class TestGuava { @Test public void functionComposeTest() { //组合式函数编程 //确保容器中的字符串长度不超过5，超过进行截取，后全部大写 List&lt;String&gt; list =Lists.newArrayList(&quot;sxmsxt&quot;,&quot;good&quot;,&quot;happiness&quot;); //确保容器中的字符串长度不超过5，超过进行截取 Function&lt;String,String&gt; f1 =new Function&lt;String,String&gt;(){ public String apply(String input) { return input.length()&gt;5?input.substring(0,5):input; } }; //转成大写 Function&lt;String,String&gt; f2 =new Function&lt;String,String&gt;(){ public String apply(String input) { return input.toUpperCase(); } }; //String =f2(f1(String)) Function&lt;String,String&gt; f =Functions.compose(f1, f2); Collection&lt;String&gt; resultCol =Collections2.transform(list, f); for(String temp:resultCol){ System.out.println(temp); } } /** * 过滤器 */ @Test public void test1(){ //创建List 静态初始化 List&lt;String&gt; list =Lists.newArrayList(&quot;moom&quot;,&quot;son&quot;,&quot;dad&quot;,&quot;sxmsxm&quot;,&quot;refer&quot;); //找出回文 palindrome backwords mirror words //匿名内部类对象: 匿名内部类，同时创建类对象 Collection&lt;String&gt; palindromeList =Collections2.filter(list, new Predicate&lt;String&gt;(){ public boolean apply(String input) { //业务逻辑 return new StringBuilder(input).reverse().toString().equals(input); } }); for(String temp:palindromeList){ System.out.println(temp); } } /** * 转换 */ @Test public void test2(){ //类型转换 Set&lt;Long&gt; timeSet =Sets.newHashSet(); timeSet.add(10000000L); timeSet.add(99999999999999999L); timeSet.add(2000000000L); Collection&lt;String&gt; timeStrCol =Collections2.transform(timeSet, new Function&lt;Long,String&gt;(){ public String apply(Long input) { return new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).format(input); }}); for(String temp:timeStrCol){ System.out.println(temp); } } } guava约束 非空、长度验证/** * 加入约束条件:非空、长度验证 * Constraint * Preconditions * Constraints */ public class TestGuava { @Test public void yueshu() { Set&lt;String&gt; sets =Sets.newHashSet(); //创建约束 Constraint&lt;String&gt; constraint =new Constraint&lt;String&gt;(){ public String checkElement(String element) { //非空验证 Preconditions.checkNotNull(element); //长度验证 5-20为字符串 Preconditions.checkArgument(element.length()&gt;=5 &amp;&amp; element.length()&lt;=20); return element; } }; Set&lt;String&gt; cs =Constraints.constrainedSet(sets, constraint); //cs.add(null); //java.lang.NullPointerException // cs.add(&quot;good&quot;); //java.lang.IllegalArgumentException cs.add(&quot;sxmsxm&quot;); for(String str:cs){ System.out.println(str); } } } guava对集合的 交集 并集 差集处理更好import java.util.Set; import org.junit.Test; import com.google.common.collect.Sets; import com.google.common.collect.Sets.SetView; /** * 集合的操作:交集、差集、并集 * Sets.intersection() * Sets.difference() * Sets.union(); */ public class TestGuava { @Test public void yueshu() { Set&lt;Integer&gt; sets =Sets.newHashSet(1,2,3,4,5,6); Set&lt;Integer&gt; sets2 =Sets.newHashSet(3,4,5,6,7,8,9); //交集 System.out.println(&quot;交集为:&quot;); SetView&lt;Integer&gt; intersection =Sets.intersection(sets, sets2); for(Integer temp:intersection){ System.out.println(temp); } //差集 System.out.println(&quot;差集为:&quot;); SetView&lt;Integer&gt; diff =Sets.difference(sets, sets2); for(Integer temp:diff){ System.out.println(temp); } //并集 System.out.println(&quot;并集为:&quot;); SetView&lt;Integer&gt; union =Sets.union(sets, sets2); for(Integer temp:union){ System.out.println(temp); } } } guava Multiset统计单词更简单import com.google.common.collect.HashMultiset; import com.google.common.collect.Multiset; /** * 统计单词出现的次数 * 1、HashMap 分拣存储+面向对象思维 --&gt;判断 * 2、Multiset :无序+可重复 .count() 增强了可读性 +操作简单 */ public class TestGuava { @Test public void conunt_word() { String str =&quot;this is a cat and that is a mice where is the food&quot;; //分割字符串 String[] strArray =str.split(&quot; &quot;); //存储到Multiset中 Multiset&lt;String&gt; set =HashMultiset.create(); for(String strTemp:strArray){ set.add(strTemp); } //获取所有的单词 Set Set&lt;String&gt; letters =set.elementSet(); for(String temp:letters){ System.out.println(temp+&quot;--&gt;&quot;+set.count(temp)); } } } guava分析查看 课程和教授关系import java.util.Collection; import java.util.HashMap; import java.util.Iterator; import java.util.Map; import java.util.Set; import org.junit.Test; import com.google.common.collect.ArrayListMultimap; import com.google.common.collect.Multimap; /** * 分析查看 教师 教授的每门课程 * Multimap :key-value key可以重复 */ public class TestGuava { @Test public void conunt_word() { Map&lt;String, String&gt; cours = new HashMap&lt;String, String&gt;(); // 加入测试数据 cours.put(&quot;改革开放&quot;, &quot;邓爷爷&quot;); cours.put(&quot;三个代表&quot;, &quot;江主席&quot;); cours.put(&quot;科学发展观&quot;, &quot;胡主席&quot;); cours.put(&quot;和谐社会&quot;, &quot;胡主席&quot;); cours.put(&quot;八荣八耻&quot;, &quot;胡主席&quot;); cours.put(&quot;....&quot;, &quot;习主席&quot;); // Multimap Multimap&lt;String, String&gt; teachers = ArrayListMultimap.create(); // 迭代器 Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it = cours.entrySet().iterator(); while (it.hasNext()) { Map.Entry&lt;String, String&gt; entry = it.next(); String key = entry.getKey(); // 课程 String value = entry.getValue(); // 教师 // 教师 --&gt;课程 teachers.put(value, key); } // 查看Multimap Set&lt;String&gt; keyset = teachers.keySet(); for (String key : keyset) { Collection&lt;String&gt; col = teachers.get(key); System.out.println(key + &quot;--&gt;&quot; + col); } } } guava 双向map–BiMap 更灵活的由value找 key/** * HashMap 键唯一，值可以重复 * BiMap:双向Map(Bidirectional Map ) 键与值都不能重复(unique -valued map) */ public class TestGuava { @Test public void test() { BiMap&lt;String,String&gt; bimap=HashBiMap.create(); bimap.put(&quot;sxm&quot;, &quot;sxmt@sina.com&quot;); bimap.put(&quot;google&quot;,&quot;good@gmail.com&quot;); //通过邮箱找用户 String user =bimap.inverse().get(&quot;good@gmail.com&quot;); System.out.println(user); System.out.println(bimap.inverse()==bimap); System.out.println(bimap.inverse().inverse()==bimap); } } guava 对Table模型的方便操作import java.util.Map; import java.util.Set; import org.junit.Test; import com.google.common.collect.HashBasedTable; import com.google.common.collect.Table; import com.google.common.collect.Table.Cell; import com.google.common.collect.Tables; /** * 双键的Map --&gt;Table --&gt;rowKey+columnKey+value * 1、方法 * 所有的行数据:cellSet() * 所有的学生: rowKeySet() * 所有的课程:columnKeySet() * 所有的成绩: values() * 学生对应的课程: rowMap() +get(学生) * row(学生) * 课程对应的学生: columnMap +get(课程) * column(课程) */ public class TestGuava { @Test public void test() { Table&lt;String,String,Integer&gt; tables=HashBasedTable.create(); //测试数据 tables.put(&quot;a&quot;, &quot;javase&quot;, 80); tables.put(&quot;b&quot;, &quot;javase&quot;, 90); tables.put(&quot;a&quot;, &quot;oracle&quot;, 100); tables.put(&quot;c&quot;, &quot;oracle&quot;, 95); //所有的行数据 Set&lt;Cell&lt;String,String,Integer&gt;&gt; cells =tables.cellSet(); for(Cell&lt;String,String,Integer&gt; temp:cells){ System.out.println(temp.getRowKey()+&quot;--&gt;&quot;+temp.getColumnKey()+&quot;--&gt;&quot;+temp.getValue()); } System.out.println(&quot;==========学生查看成绩==============&quot;); System.out.print(&quot;学生\\t&quot;); //所有的课程 Set&lt;String&gt; cours =tables.columnKeySet(); for(String t:cours){ System.out.print(t+&quot;\\t&quot;); } System.out.println(); //所有的学生 Set&lt;String&gt; stus =tables.rowKeySet(); for(String stu:stus){ System.out.print(stu+&quot;\\t&quot;); Map&lt;String,Integer&gt; scores =tables.row(stu); for(String c:cours){ System.out.print(scores.get(c)+&quot;\\t&quot;); } System.out.println(); } System.out.println(&quot;==========课程查看成绩==============&quot;); System.out.print(&quot;课程\\t&quot;); //所有的学生 Set&lt;String&gt; stuSet =tables.rowKeySet(); for(String t:stuSet){ System.out.print(t+&quot;\\t&quot;); } System.out.println(); //所有的课程 Set&lt;String&gt; courSet =tables.columnKeySet(); for(String c:courSet){ System.out.print(c+&quot;\\t&quot;); Map&lt;String,Integer&gt; scores =tables.column(c); for(String s:stuSet){ System.out.print(scores.get(s)+&quot;\\t&quot;); } System.out.println(); } System.out.println(&quot;===========转换===========&quot;); Table&lt;String,String,Integer&gt; tables2 =Tables.transpose(tables); //所有的行数据 Set&lt;Cell&lt;String,String,Integer&gt;&gt; cells2 =tables2.cellSet(); for(Cell&lt;String,String,Integer&gt; temp:cells2){ System.out.println(temp.getRowKey()+&quot;--&gt;&quot;+temp.getColumnKey()+&quot;--&gt;&quot;+temp.getValue()); } } } Apache–collections函数式编程断言import java.util.ArrayList; import java.util.List; import org.apache.commons.collections4.Predicate; import org.apache.commons.collections4.PredicateUtils; import org.apache.commons.collections4.functors.EqualPredicate; import org.apache.commons.collections4.functors.NotNullPredicate; import org.apache.commons.collections4.functors.UniquePredicate; import org.apache.commons.collections4.list.PredicatedList; import org.junit.Test; /** 函数式编程 之 Predicate 断言 封装条件或判别式 if..else替代 1、 new EqualPredicate&lt;类型&gt;(值) EqualPredicate.equalPredicate(值); 2、NotNullPredicate.INSTANCE 3、UniquePredicate.uniquePredicate() 4、自定义 new Predicate() +evaluate PredicateUtils.allPredicate andPredicate anyPredicate PredicatedXxx.predicatedXxx(容器,判断) * */ public class Demo01 { /** * 组合断言 */ @Test public void test() { System.out.println(&quot;======自定义判断======&quot;); //自定义的判别式 Predicate&lt;String&gt; selfPre =new Predicate&lt;String&gt;(){ public boolean evaluate(String object) { return object.length()&gt;=5 &amp;&amp; object.length()&lt;=20; }}; Predicate notNull=NotNullPredicate.notNullPredicate(); Predicate all =PredicateUtils.allPredicate(notNull,selfPre); List&lt;String&gt; list =PredicatedList.predicatedList(new ArrayList&lt;String&gt;(),all); list.add(&quot;sxmsxm&quot;); list.add(null); list.add(&quot;bj&quot;); } /** * 判断唯一 */ @Test public void unique(){ System.out.println(&quot;====唯一性判断====&quot;); Predicate&lt;Long&gt; uniquePre =UniquePredicate.uniquePredicate(); List&lt;Long&gt; list =PredicatedList.predicatedList(new ArrayList&lt;Long&gt;(), uniquePre); list.add(100L); list.add(200L); list.add(100L); //出现重复值，抛出异常 } /** * 判断非空 */ @Test public void notNull(){ System.out.println(&quot;====非空判断====&quot;); //Predicate notNull=NotNullPredicate.INSTANCE; Predicate notNull=NotNullPredicate.notNullPredicate(); //String str =&quot;bjs&quot;; String str =null; System.out.println(notNull.evaluate(str)); //如果非空为true ,否则为false //添加容器值的判断 List&lt;Long&gt; list =PredicatedList.predicatedList(new ArrayList&lt;Long&gt;(), notNull); list.add(1000L); list.add(null); //验证失败，出现异常 } /** * 比较相等判断 */ @Test public void equal(){ System.out.println(&quot;======相等判断======&quot;); //Predicate&lt;String&gt; pre =new EqualPredicate&lt;String&gt;(&quot;bjsxt&quot;); Predicate&lt;String&gt; pre =EqualPredicate.equalPredicate(&quot;sxmsxm&quot;); boolean flag =pre.evaluate(&quot;sx&quot;); System.out.println(flag); } } Apache公司容器转换器import java.text.SimpleDateFormat; import java.util.ArrayList; import java.util.Collection; import java.util.Iterator; import java.util.List; import org.apache.commons.collections4.CollectionUtils; import org.apache.commons.collections4.Predicate; import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.functors.SwitchTransformer; import org.junit.Test; /** 解耦，业务处理与判断进行分类 函数式编程 Transformer 类型转化 1、new Transformer() +transform 2、SwitchTransformer CollectionUtils.collect(容器,转换器) */ public class Demo02 { @Test public void testCompose() { System.out.println(&quot;===自定义类型转换==&quot;); //判别式 Predicate&lt;Employee&gt; isLow=new Predicate&lt;Employee&gt;(){ public boolean evaluate(Employee emp) { return emp.getSalary()&lt;10000; } }; Predicate&lt;Employee&gt; isHigh=new Predicate&lt;Employee&gt;(){ public boolean evaluate(Employee emp) { return emp.getSalary()&gt;=10000; } }; Predicate[] pres ={isLow,isHigh}; //转换 Transformer&lt;Employee,Level&gt; lowTrans =new Transformer&lt;Employee,Level&gt;(){ public Level transform(Employee input) { return new Level(input.getName(),&quot;卖身中&quot;); }}; Transformer&lt;Employee,Level&gt; highTrans =new Transformer&lt;Employee,Level&gt;(){ public Level transform(Employee input) { return new Level(input.getName(),&quot;养身中&quot;); }}; Transformer[] trans ={lowTrans,highTrans}; //二者进行了关联 Transformer switchTrans =new SwitchTransformer(pres, trans, null); //容器 List&lt;Employee&gt; list =new ArrayList&lt;Employee&gt;(); list.add(new Employee(&quot;老马&quot;,1000000)); list.add(new Employee(&quot;老裴&quot;,999)); Collection&lt;Level&gt; levelList = CollectionUtils.collect(list,switchTrans); //遍历容器 Iterator&lt;Level&gt; levelIt =levelList.iterator(); while(levelIt.hasNext()){ System.out.println(levelIt.next()); } } /** * 内置类型的转换 */ @Test public void inner(){ System.out.println(&quot;===内置类型转换 长整形时间日期，转成指定格式的字符串==&quot;); //类型转换器 Transformer&lt;Long,String&gt; trans =new Transformer&lt;Long,String&gt;(){ public String transform(Long input) { return new SimpleDateFormat(&quot;yyyy年MM月dd日&quot;).format(input); }}; //容器 List&lt;Long&gt; list =new ArrayList&lt;Long&gt;(); list.add(999999999999L); list.add(300000000L); //工具类 程序猿出钱---开发商---农民工出力 Collection&lt;String&gt; result=CollectionUtils.collect(list, trans); //遍历查看结果 for(String time:result){ System.out.println(time); } } } /** * 员工类 */ public class Employee { private String name; private double salary; //alt +/ public Employee() { } //alt+shift+s o public Employee(String name, double salary) { super(); this.name = name; this.salary = salary; } //alt+shift+s +r tab 回车 shift+tab 回车 public String getName() { return name; } public void setName(String name) { this.name = name; } public double getSalary() { return salary; } public void setSalary(double salary) { this.salary = salary; } @Override public String toString() { return &quot;(码农:&quot;+this.name+&quot;,敲砖钱:&quot;+this.salary+&quot;)&quot;; } } /** * 等级类 */ public class Level { private String name; private String level; public Level() { } public Level(String name, String level) { super(); this.name = name; this.level = level; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getLevel() { return level; } public void setLevel(String level) { this.level = level; } @Override public String toString() { return &quot;(码农:&quot;+this.name+&quot;,水平:&quot;+this.level+&quot;)&quot;; } } 输出： ===自定义类型转换== (码农:老马,水平:养身中) (码农:老裴,水平:卖身中) ===内置类型转换 长整形时间日期，转成指定格式的字符串== 2001年09月09日 1970年01月04日","link":"/2015/10/20/javase/%E8%B0%B7%E6%AD%8C%E5%85%AC%E5%8F%B8%E5%92%8Capache%E5%85%AC%E5%8F%B8%E7%9A%84%E5%AE%B9%E5%99%A8jar/"},{"title":"正则表达式","text":"简介 语法标准 自定义 量词 正则字符边界 正则补充 正则分支_捕获_非捕获","link":"/2014/09/01/javase/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"title":"多线程并发深入第二篇","text":"JUC 介绍在 Java 5.0 提供了 java.util.concurrent (简称JUC )包，在此包中增加了在并发编程中很常用 的实用工具类，用于定义类似于线程的自定义子系统，包括线程池、异步IO 和轻量级任务框架。 提供可调的、灵活的线程池。还提供了设计用于 多线程上下文中的 Collection 实现等。 volatile 关键字 内存可见性内存可见性(Memory Visibility) **内存可见性(Memory Visibility)**是指当某个线程正在使用对象状态 而另一个线程在同时修改该状态，需要确保当一个线程修改了对象 状态后，其他线程能够看到发生的状态变化 可见性错误是指当读操作与写操作在不同的线程中执行时，我们无 法确保执行读操作的线程能适时地看到其他线程写入的值，有时甚 至是根本不可能的事情 我们可以通过同步来保证对象被安全地发布。除此之外我们也可以 使用一种更加轻量级的 volatile 变量 volatile提供了一种稍弱的同步机制，即 volatile 变 量，用来确保将变量的更新操作通知到其他线程。 可以将 volatile 看做一个轻量级的锁，但是又与 锁有些不同: 对于多线程，不是一种互斥关系 不能保证变量状态的“原子性操作”```javapublic class TestVolatile { public static void main(String[] args) { State state = new State(); Thread t = new Thread(state); t.start(); while(true) { if(state.isState()) { System.out.println(“——————–main———–” + state.isState()); } } }}class State implements Runnable{ private boolean state; public boolean isState() { return state; } @Override public void run() { try { Thread.sleep(100); } catch (InterruptedException e) { } this.state = true; System.out.println(Thread.currentThread().getName()+”–&gt;”+ this.state); } }输出：Thread-0–&gt;true 分析内存不可见 ![](/images/javase/mem_no_volatile.png) 使用volatile解决 ```java public class TestVolatile { public static void main(String[] args) { State state = new State(); Thread t = new Thread(state); t.start(); while(true) { if(state.isState()) { System.out.println(&quot;--------------------main-----------&quot; + state.isState()); break; } } } } class State implements Runnable{ volatile private boolean state; public boolean isState() { return state; } @Override public void run() { try { Thread.sleep(100); } catch (InterruptedException e) { } this.state = true; System.out.println(Thread.currentThread().getName()+&quot;--&gt;&quot;+ this.state); } } 输出: --------------------main-----------true Thread-0--&gt;true ``` 分析 ```text 在共享数据前加上 volatile修饰，使得main线程对 t线程修改后的状态可见了，这时才读到正确数据状态 ``` ## 原子变量与CAS算法 ### CAS算法 ```text CAS (Compare-And-Swap) 是一种硬件对并发的支持，针对多处理器 操作而设计的处理器中的一种特殊指令，用于管理对共享数据的并发访问。 1 CAS 是一种无锁的非阻塞算法的实现。 2 CAS 包含了 3 个操作数:  需要读写的内存值 V 3 进行比较的值 A 4 拟写入的新值 B 5 当且仅当 V 的值等于 A 时，CAS 通过原子方式用新值 B 来更新 V 的 值，否则不会执行任何操作。 ``` 模拟CAS算法 ```java /* * 模拟 CAS 算法 */ public class TestCompareAndSwap { public static void main(String[] args) { final CompareAndSwap cas = new CompareAndSwap(); for (int i = 0; i &lt; 10; i++) { new Thread(new Runnable() { @Override public void run() { int expectedValue = cas.get(); boolean b = cas.compareAndSet(expectedValue, (int)(Math.random() * 101)); System.out.println(b); } }).start(); } } } class CompareAndSwap{ private int value; //获取内存值 public synchronized int get(){ return value; } //比较 public synchronized int compareAndSwap(int expectedValue, int newValue){ int oldValue = value; if(oldValue == expectedValue){ this.value = newValue; } return oldValue; } //设置 public synchronized boolean compareAndSet(int expectedValue, int newValue){ return expectedValue == compareAndSwap(expectedValue, newValue); } } ``` ### 原子变量 类的小工具包，支持在单个变量上解除锁的线程安全编程。事实上，此包中的类可 将 volatile 值、字段和数组元素的概念扩展到那些也提供原子条件更新操作的类。 - 类 AtomicBoolean、AtomicInteger、AtomicLong 和 AtomicReference 的实例各自提供对 相应类型单个变量的访问和更新。每个类也为该类型提供适当的实用工具方法。 - AtomicIntegerArray、AtomicLongArray和AtomicReferenceArray类进一步扩展了原子操 作，对这些类型的数组提供了支持。这些类在为其数组元素提供 volatile 访问语义方 面也引人注目，这对于普通数组来说是不受支持的。 - 核心方法:boolean compareAndSet(expectedValue, updateValue) - java.util.concurrent.atomic包下提供了一些原子操作的常用类: - AtomicBoolean、AtomicInteger、AtomicLong、AtomicReference 、 AtomicIntegerArray、AtomicLongArray - AtomicMarkableReference - AtomicReferenceArray - AtomicStampedReference volatile无法保证共享数据原子性，出现不同线程打印出重复的数字，示例 ```java import java.util.concurrent.atomic.AtomicInteger; /* * 一、i++ 的原子性问题：i++ 的操作实际上分为三个步骤“读-改-写” * int i = 10; * i = i++; //10 * * int temp = i; * i = i + 1; * i = temp; * * 二、原子变量：在 java.util.concurrent.atomic 包下提供了一些原子变量。 * 1. volatile 保证内存可见性 * 2. CAS（Compare-And-Swap） 算法保证数据变量的原子性 * CAS 算法是硬件对于并发操作的支持 * CAS 包含了三个操作数： * ①内存值 V * ②预估值 A * ③更新值 B * 当且仅当 V == A 时， V = B; 否则，不会执行任何操作。 */ public class TestAtomicDemo { public static void main(String[] args) { AtomicDemo ad = new AtomicDemo(); for (int i = 0; i &lt; 10; i++) { new Thread(ad).start(); } } } class AtomicDemo implements Runnable{ private volatile int serialNumber = 0; //private AtomicInteger serialNumber = new AtomicInteger(0); @Override public void run() { try { Thread.sleep(200); } catch (InterruptedException e) {} System.out.println(getSerialNumber()); } public int getSerialNumber(){ //return serialNumber.getAndIncrement(); return serialNumber++; } } 输出: 2 0 0 5 4 7 8 6 3 1 ``` 共享数据，用原子类型变量定义，解决示例 ```java import java.util.concurrent.atomic.AtomicInteger; /* * 一、i++ 的原子性问题：i++ 的操作实际上分为三个步骤“读-改-写” * int i = 10; * i = i++; //10 * * int temp = i; * i = i + 1; * i = temp; * * 二、原子变量：在 java.util.concurrent.atomic 包下提供了一些原子变量。 * 1. volatile 保证内存可见性 * 2. CAS（Compare-And-Swap） 算法保证数据变量的原子性 * CAS 算法是硬件对于并发操作的支持 * CAS 包含了三个操作数： * ①内存值 V * ②预估值 A * ③更新值 B * 当且仅当 V == A 时， V = B; 否则，不会执行任何操作。 */ public class TestAtomicDemo { public static void main(String[] args) { AtomicDemo ad = new AtomicDemo(); for (int i = 0; i &lt; 10; i++) { new Thread(ad).start(); } } } class AtomicDemo implements Runnable{ private AtomicInteger serialNumber = new AtomicInteger(0); @Override public void run() { try { Thread.sleep(200); } catch (InterruptedException e) {} System.out.println(getSerialNumber()); } public int getSerialNumber(){ return serialNumber.getAndIncrement(); } } 输出: 1 2 3 0 9 4 7 5 8 6 ``` ## ConcurrentHashMap 锁分段机制 Java 5.0 在 java.util.concurrent 包中提供了多种并发容器类来改进同步容器 的性能。 - ConcurrentHashMap 同步容器类是Java 5 增加的一个线程安全的哈希表。对 与多线程的操作，介于 HashMap 与 Hashtable 之间。内部采用“锁分段” 机制替代 Hashtable 的独占锁。进而提高性能。 - 此包还提供了设计用于多线程上下文中的 Collection 实现: ConcurrentHashMap、ConcurrentSkipListMap、ConcurrentSkipListSet、 CopyOnWriteArrayList 和 CopyOnWriteArraySet。当期望许多线程访问一个给 定 collection 时，ConcurrentHashMap 通常优于同步的 HashMap， ConcurrentSkipListMap 通常优于同步的 TreeMap。当期望的读数和遍历远远 大于列表的更新数时，CopyOnWriteArrayList 优于同步的 ArrayList。 ```text hashtable虽然线程安全，相当于多个线程变成了串行执行，而ConcurrentHashMap采用锁分段技术，默认分了16段，可以并行执行，但是JDK1.8之后废弃了锁分段，改为了CAS无锁算法 ``` ```java import java.util.Iterator; import java.util.concurrent.CopyOnWriteArrayList; /* * CopyOnWriteArrayList/CopyOnWriteArraySet : “写入并复制” * 注意：添加操作多时，效率低，因为每次添加时都会进行复制，开销非常的大。并发迭代操作多时可以选择。 */ public class TestCopyOnWriteArrayList { public static void main(String[] args) throws InterruptedException { HelloThread ht = new HelloThread(); for (int i = 0; i &lt; 3; i++) { new Thread(ht).start(); } Thread.sleep(1000); } } class HelloThread implements Runnable{ // private static List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;String&gt;()); private static CopyOnWriteArrayList&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;(); static{ list.add(&quot;AA&quot;); list.add(&quot;BB&quot;); list.add(&quot;CC&quot;); } @Override public void run() { Iterator&lt;String&gt; it = list.iterator(); while(it.hasNext()){ System.out.println(Thread.currentThread()+&quot;---&gt;&quot;+it.next()); list.add(&quot;DD&quot;); } } } 输出: Thread[Thread-1,5,main]---&gt;AA Thread[Thread-2,5,main]---&gt;AA Thread[Thread-0,5,main]---&gt;AA Thread[Thread-2,5,main]---&gt;BB Thread[Thread-1,5,main]---&gt;BB Thread[Thread-2,5,main]---&gt;CC Thread[Thread-0,5,main]---&gt;BB Thread[Thread-1,5,main]---&gt;CC Thread[Thread-0,5,main]---&gt;CC ``` ## CountDownLatch闭锁 Java 5.0 在 java.util.concurrent 包中提供了多种并发容器类来改进同步容器 的性能。 - CountDownLatch 一个同步辅助类，在完成一组正在其他线程中执行的操作 之前，它允许一个或多个线程一直等待。 - **闭锁可以延迟线程的进度直到其到达终止状态，闭锁可以用来确保某些活 动直到其他活动都完成才继续执行:** - 确保某个计算在其需要的所有资源都被初始化之后才继续执行; - 确保某个服务在其依赖的所有其他服务都已经启动之后才启动;  等待直到某个操作所有参与者都准备就绪再继续执行 ```java import java.util.concurrent.CountDownLatch; /* * CountDownLatch ：闭锁，在完成某些运算是，只有其他所有线程的运算全部完成，当前运算才继续执行 */ public class TestCountDownLatch { public static void main(String[] args) { final CountDownLatch latch = new CountDownLatch(50); LatchDemo ld = new LatchDemo(latch); long start = System.currentTimeMillis(); for (int i = 0; i &lt; 50; i++) { new Thread(ld).start(); } try { latch.await(); } catch (InterruptedException e) { } long end = System.currentTimeMillis(); System.out.println(&quot;耗费时间为：&quot; + (end - start)); } } class LatchDemo implements Runnable { private CountDownLatch latch; public LatchDemo(CountDownLatch latch) { this.latch = latch; } @Override public void run() { try { for (int i = 0; i &lt; 50000; i++) { if (i % 2 == 0) { System.out.println(i); } } } finally { latch.countDown(); //执行完一定要 } } } ``` ## 实现Callable 接口 Java 5.0 在 java.util.concurrent 提供了一个新的创建执行 线程的方式:Callable 接口 - Callable 接口类似于 Runnable，两者都是为那些其实例可 能被另一个线程执行的类设计的。**但是 Runnable 不会返 回结果，并且无法抛出经过检查的异常。** - **Callable 需要依赖FutureTask** ，FutureTask 也可以用作闭 锁。 ```java import java.util.concurrent.Callable; import java.util.concurrent.ExecutionException; import java.util.concurrent.FutureTask; /* * 一、创建执行线程的方式三：实现 Callable 接口。 相较于实现 Runnable 接口的方式，方法可以有返回值，并且可以抛出异常。 * * 二、执行 Callable 方式，需要 FutureTask 实现类的支持，用于接收运算结果。 FutureTask 是 Future 接口的实现类 */ public class TestCallable { public static void main(String[] args) { ThreadDemo td = new ThreadDemo(); //1.执行 Callable 方式，需要 FutureTask 实现类的支持，用于接收运算结果。 FutureTask&lt;Integer&gt; result = new FutureTask&lt;&gt;(td); new Thread(result).start(); //2.接收线程运算后的结果 try { Integer sum = result.get(); //FutureTask 可用于 闭锁 System.out.println(sum); System.out.println(&quot;------------------------------------&quot;); } catch (InterruptedException | ExecutionException e) { e.printStackTrace(); } } } class ThreadDemo implements Callable&lt;Integer&gt;{ @Override public Integer call() throws Exception { int sum = 0; for (int i = 0; i &lt;= 100; i++) { sum += i; } return sum; } } 输出结果: 5050 ------------------------------------ ``` ## 显示锁 Lock ```text 在 Java 5.0 之前，协调共享对象的访问时可以使用的机制只有 synchronized 和 volatile 。Java 5.0 后增加了一些 新的机制，但并不是一种替代内置锁的方法，而是当内置锁不适用时，作为一种可选择的高级功能。 ReentrantLock 实现了 Lock 接口，并提供了与 synchronized 相同的互斥性和内存可见性。但相较于 synchronized 提供了更高的处理锁的灵活性。 ``` ```java import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; /* * 一、用于解决多线程安全问题的方式： * synchronized:隐式锁 * 1. 同步代码块 * 2. 同步方法 * jdk 1.5 后： * 3. 同步锁 Lock * 注意：是一个显示锁，需要通过 lock() 方法上锁，必须通过 unlock() 方法进行释放锁 */ public class TestLock { public static void main(String[] args) { Ticket ticket = new Ticket(); new Thread(ticket, &quot;1号窗口&quot;).start(); new Thread(ticket, &quot;2号窗口&quot;).start(); new Thread(ticket, &quot;3号窗口&quot;).start(); new Thread(ticket, &quot;4号窗口&quot;).start(); new Thread(ticket, &quot;5号窗口&quot;).start(); } } class Ticket implements Runnable { private int tick = 5;// 共享数据5张票 private Lock lock = new ReentrantLock(); @Override public void run() { while (true) { lock.lock(); //上锁 try { if (tick &gt; 0) { try { Thread.sleep(200); } catch (InterruptedException e) { } System.out.println(Thread.currentThread().getName() + &quot; 完成售票，余票为：&quot; + --tick); } } finally { lock.unlock(); // 释放锁 try { Thread.sleep(200); } catch (InterruptedException e) { e.printStackTrace(); } } } } } 输出结果: 1号窗口 完成售票，余票为：4 2号窗口 完成售票，余票为：3 3号窗口 完成售票，余票为：2 4号窗口 完成售票，余票为：1 5号窗口 完成售票，余票为：0 ``` ## Condition 控制线程通信 Condition 接口描述了可能会与锁有关联的条件变量。这些变量在用法上与使用 Object.wait 访问的隐式监视器类似，但提供了更强大的 功能。需要特别指出的是，单个 Lock 可能与多个 Condition 对象关 联。为了避免兼容性问题，Condition 方法的名称与对应的 Object 版本中的不同。 - 在 Condition 对象中，与 wait、notify 和 notifyAll 方法对应的分别是 await、signal 和 signalAll。 - Condition 实例实质上被绑定到一个锁上。要为特定 Lock 实例获得 Condition 实例，请使用其 newCondition() 方法。 注意 Object.wait虚假唤醒中 通过while(true)解决 JDK-api有说明，示例**生产者和消费者案例** ### synchronized-Object.wait-notifyAll方式实现的 生产者和消费者案例 ```java /* * 生产者和消费者案例 */ public class TestProductorAndConsumer { public static void main(String[] args) { Clerk clerk = new Clerk(); Productor pro = new Productor(clerk); Consumer cus = new Consumer(clerk); new Thread(pro, &quot;生产者 A&quot;).start(); new Thread(cus, &quot;消费者 B&quot;).start(); new Thread(pro, &quot;生产者 C&quot;).start(); new Thread(cus, &quot;消费者 D&quot;).start(); } } //店员 class Clerk{ private int product = 0; //进货 public synchronized void get(){//循环次数：0 while(product &gt;= 1){//为了避免虚假唤醒问题，应该总是使用在循环中 System.out.println(&quot;产品已满！&quot;); try { this.wait(); } catch (InterruptedException e) { } } System.out.println(Thread.currentThread().getName() + &quot; : &quot; + ++product); this.notifyAll(); } //卖货 public synchronized void sale(){//product = 0; 循环次数：0 while(product &lt;= 0){ System.out.println(&quot;缺货！&quot;); try { this.wait(); } catch (InterruptedException e) { } } System.out.println(Thread.currentThread().getName() + &quot; : &quot; + --product); this.notifyAll(); } } //生产者 class Productor implements Runnable{ private Clerk clerk; public Productor(Clerk clerk) { this.clerk = clerk; } @Override public void run() { for (int i = 0; i &lt; 5; i++) { //一共生产5次，进5次货 try { Thread.sleep(200); } catch (InterruptedException e) { } clerk.get(); } } } //消费者 class Consumer implements Runnable{ private Clerk clerk; public Consumer(Clerk clerk) { this.clerk = clerk; } @Override public void run() { for (int i = 0; i &lt; 5; i++) { //一共卖5次 clerk.sale(); } } } 输出: 缺货！ 缺货！ 生产者 C : 1 消费者 D : 0 缺货！ 缺货！ 生产者 A : 1 消费者 B : 0 缺货！ 缺货！ 生产者 A : 1 消费者 D : 0 缺货！ 缺货！ 生产者 C : 1 消费者 B : 0 缺货！ 缺货！ 生产者 A : 1 消费者 D : 0 缺货！ 缺货！ 生产者 C : 1 消费者 B : 0 缺货！ 缺货！ 生产者 A : 1 消费者 D : 0 缺货！ 缺货！ 生产者 C : 1 消费者 B : 0 缺货！ 缺货！ 生产者 A : 1 消费者 D : 0 缺货！ 生产者 C : 1 消费者 B : 0 ``` ### Lock-condition 方式实现的 生产者和消费者案例 ```java import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; /* * 生产者消费者案例： */ public class TestProductorAndConsumerForLock { public static void main(String[] args) { Clerk clerk = new Clerk(); Productor pro = new Productor(clerk); Consumer con = new Consumer(clerk); new Thread(pro, &quot;生产者 A&quot;).start(); new Thread(con, &quot;消费者 B&quot;).start(); new Thread(pro, &quot;生产者 C&quot;).start(); new Thread(con, &quot;消费者 D&quot;).start(); } } class Clerk { private int product = 0; private Lock lock = new ReentrantLock(); private Condition condition = lock.newCondition(); // 进货 public void get() { lock.lock(); try { while (product &gt;= 1) { // 为了避免虚假唤醒，应该总是使用在循环中。 System.out.println(&quot;产品已满！&quot;); try { condition.await(); } catch (InterruptedException e) { } } System.out.println(Thread.currentThread().getName() + &quot; : &quot; + ++product); condition.signalAll(); } finally { lock.unlock(); } } // 卖货 public void sale() { lock.lock(); try { while (product &lt;= 0) { System.out.println(&quot;缺货！&quot;); try { condition.await(); } catch (InterruptedException e) { } } System.out.println(Thread.currentThread().getName() + &quot; : &quot; + --product); condition.signalAll(); } finally { lock.unlock(); } } } // 生产者 class Productor implements Runnable { private Clerk clerk; public Productor(Clerk clerk) { this.clerk = clerk; } @Override public void run() { for (int i = 0; i &lt; 5; i++) { try { Thread.sleep(200); } catch (InterruptedException e) { e.printStackTrace(); } clerk.get(); } } } // 消费者 class Consumer implements Runnable { private Clerk clerk; public Consumer(Clerk clerk) { this.clerk = clerk; } @Override public void run() { for (int i = 0; i &lt; 5; i++) { clerk.sale(); } } } 输出: 缺货！ 缺货！ 生产者 C : 1 产品已满！ 消费者 B : 0 缺货！ 缺货！ 生产者 A : 1 消费者 B : 0 缺货！ 缺货！ 生产者 C : 1 消费者 B : 0 缺货！ 缺货！ 生产者 A : 1 消费者 B : 0 缺货！ 缺货！ 生产者 C : 1 产品已满！ 消费者 B : 0 缺货！ 生产者 A : 1 消费者 D : 0 缺货！ 生产者 C : 1 产品已满！ 消费者 D : 0 缺货！ 生产者 A : 1 消费者 D : 0 缺货！ 生产者 C : 1 产品已满！ 消费者 D : 0 缺货！ 生产者 A : 1 消费者 D : 0 ``` ### ABCABCABC三个线程交替执行 lock - 多个condition实现 ```java package com.atguigu.juc; import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; /* * 编写一个程序，开启 3 个线程，这三个线程的 ID 分别为 A、B、C，每个线程将自己的 ID 在屏幕上打印 10 遍，要求输出的结果必须按顺序显示。 * 如：ABCABCABC…… 依次递归 */ public class TestABCAlternate { public static void main(String[] args) { final AlternateDemo ad = new AlternateDemo(); new Thread(new Runnable() { @Override public void run() { for (int i = 1; i &lt;= 10; i++) { ad.loopA(i); } } }, &quot;A&quot;).start(); new Thread(new Runnable() { @Override public void run() { for (int i = 1; i &lt;= 10; i++) { ad.loopB(i); } } }, &quot;B&quot;).start(); new Thread(new Runnable() { @Override public void run() { for (int i = 1; i &lt;= 10; i++) { ad.loopC(i); System.out.println(&quot;-----------------------------------&quot;); } } }, &quot;C&quot;).start(); } } class AlternateDemo{ private int number = 1; //当前正在执行线程的标记 private Lock lock = new ReentrantLock(); private Condition condition1 = lock.newCondition(); private Condition condition2 = lock.newCondition(); private Condition condition3 = lock.newCondition(); /** * @param totalLoop : 循环第几轮 */ public void loopA(int totalLoop){ lock.lock(); try { //1. 判断 if(number != 1){ condition1.await(); } //2. 打印 System.out.println(Thread.currentThread().getName() + &quot;\\t&quot; + &quot;\\t&quot; + totalLoop); //3. 唤醒 number = 2; condition2.signal(); } catch (Exception e) { e.printStackTrace(); } finally { lock.unlock(); } } public void loopB(int totalLoop){ lock.lock(); try { //1. 判断 if(number != 2){ condition2.await(); } //2. 打印 System.out.println(Thread.currentThread().getName() + &quot;\\t&quot; + &quot;\\t&quot; + totalLoop); //3. 唤醒 number = 3; condition3.signal(); } catch (Exception e) { e.printStackTrace(); } finally { lock.unlock(); } } public void loopC(int totalLoop){ lock.lock(); try { //1. 判断 if(number != 3){ condition3.await(); } //2. 打印 System.out.println(Thread.currentThread().getName() + &quot;\\t&quot; + &quot;\\t&quot; + totalLoop); //3. 唤醒 number = 1; condition1.signal(); } catch (Exception e) { e.printStackTrace(); } finally { lock.unlock(); } } } ``` ## 读-写锁 ReadWriteLock ```text ReadWriteLock 维护了一对相关的锁，一个用于只读操作， 另一个用于写入操作。只要没有 writer，读取锁可以由 多个 reader 线程同时保持。写入锁是独占的。 ReadWriteLock 读取操作通常不会改变共享资源，但执行 写入操作时，必须独占方式来获取锁。对于读取操作占 多数的数据结构。 ReadWriteLock 能提供比独占锁更高 的并发性。而对于只读的数据结构，其中包含的不变性 可以完全不需要考虑加锁操作。 ``` 示例 ```java import java.util.concurrent.locks.ReadWriteLock; import java.util.concurrent.locks.ReentrantReadWriteLock; /* * 1. ReadWriteLock : 读写锁 * * 写写/读写 需要“互斥” * 读读 不需要互斥 * */ public class TestReadWriteLock { public static void main(String[] args) { final ReadWriteLockDemo rw = new ReadWriteLockDemo(); new Thread(new Runnable() { @Override public void run() { rw.set((int) (Math.random() * 101)); } }, &quot;Write1:&quot;).start(); new Thread(new Runnable() { @Override public void run() { rw.set((int) (Math.random() * 101)); } }, &quot;Write2:&quot;).start(); for (int i = 0; i &lt; 5; i++) { new Thread(new Runnable() { @Override public void run() { rw.get(); } }).start(); } } } class ReadWriteLockDemo { private int number = 0; private ReadWriteLock lock = new ReentrantReadWriteLock(); // 读 public void get() { lock.readLock().lock(); // 上锁 try { System.out.println(Thread.currentThread().getName() + &quot; : &quot; + number); } finally { lock.readLock().unlock(); // 释放锁 } } // 写 public void set(int number) { lock.writeLock().lock(); try { System.out.println(Thread.currentThread().getName() + &quot;--&gt;&quot; + number); this.number = number; } finally { lock.writeLock().unlock(); } } } 输出: Write1:--&gt;5 Write2:--&gt;41 Thread-0 : 41 Thread-1 : 41 Thread-2 : 41 Thread-3 : 41 Thread-4 : 41 ``` ## 线程八锁（对象锁与类锁） 一个对象里面如果有多个synchronized方法，某一个时刻内，只要一个线程去调用 其中的一个synchronized方法了，其它的线程都只能等待，换句话说，某一个时刻 内，只能有唯一一个线程去访问这些synchronized方法 • 锁的是当前对象this，被锁定后，其它的线程都不能进入到当前对象的其它的 synchronized方法 • 加个普通方法后发现和同步锁无关 • 换成两个对象后，不是同一把锁了，情况立刻变化。 • 都换成静态同步方法后，情况又变化 • 所有的非静态同步方法用的都是同一把锁——实例对象本身，也就是说如果一个实 例对象的非静态同步方法获取锁后，该实例对象的其他非静态同步方法必须等待获 取锁的方法释放锁后才能获取锁，可是别的实例对象的非静态同步方法因为跟该实 例对象的非静态同步方法用的是不同的锁，所以毋须等待该实例对象已获取锁的非 静态同步方法释放锁就可以获取他们自己的锁。 • 所有的静态同步方法用的也是同一把锁——类对象本身，这两把锁是两个不同的对 象，所以静态同步方法与非静态同步方法之间是不会有竞态条件的。但是一旦一个 静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取 锁，而不管是同一个实例对象的静态同步方法之间，还是不同的实例对象的静态同 步方法之间，只要它们同一个类的实例对象! ## 线程池 - 第四种获取线程的方法:线程池，一个 ExecutorService，它使用可能的几个池线程之一执行每个提交的任务，通常使用 Executors 工厂方法配置。 - 线程池可以解决两个不同问题:由于减少了每个任务调用的开销，它们通常可以在执行大量异步任务时提供增强的性能，并且还可以提供绑定和管理资源(包括执行 任务集时使用的线程)的方法。每个 ThreadPoolExecutor 还维护着一些基本的统计数 据，如完成的任务数。 - 为了便于跨大量上下文使用，此类提供了很多可调整的参数和扩展钩子 (hook)。但是，强烈建议程序员使用较为方便的 Executors 工厂方法 : - **Executors.newCachedThreadPool()(无界线程池，可以进行自动线程回收)** - **Executors.newFixedThreadPool(int)(固定大小线程池)** - **Executors.newSingleThreadExecutor()(单个后台线程)** 它们均为大多数使用场景预定义了设置。 **线程池使用，callable方式提交任务，获取线程返回结果** ```java import java.util.ArrayList; import java.util.List; import java.util.concurrent.Callable; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.Future; /* * 一、线程池：提供了一个线程队列，队列中保存着所有等待状态的线程。避免了创建与销毁额外开销，提高了响应的速度。 * * 二、线程池的体系结构： * java.util.concurrent.Executor : 负责线程的使用与调度的根接口 * |--**ExecutorService 子接口: 线程池的主要接口 * |--ThreadPoolExecutor 线程池的实现类 * |--ScheduledExecutorService 子接口：负责线程的调度 * |--ScheduledThreadPoolExecutor ：继承 ThreadPoolExecutor， 实现 ScheduledExecutorService * * 三、工具类 : Executors * ExecutorService newFixedThreadPool() : 创建固定大小的线程池 * ExecutorService newCachedThreadPool() : 缓存线程池，线程池的数量不固定，可以根据需求自动的更改数量。 * ExecutorService newSingleThreadExecutor() : 创建单个线程池。线程池中只有一个线程 * * ScheduledExecutorService newScheduledThreadPool() : 创建固定大小的线程，可以延迟或定时的执行任务。 */ public class TestThreadPool { public static void main(String[] args) throws Exception { //1. 创建线程池 ExecutorService pool = Executors.newFixedThreadPool(5); //固定5个线程 List&lt;Future&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();//返回结果保存 for (int i = 0; i &lt; 10; i++) { Future&lt;Integer&gt; future = pool.submit(new Callable&lt;Integer&gt;(){//压入10个任务 @Override public Integer call() throws Exception { int sum = 0; for (int i = 0; i &lt;= 100; i++) { sum += i; } System.out.println(Thread.currentThread().getName() + &quot;--&gt;&quot; + sum); return sum; } }); list.add(future); } pool.shutdown(); } } 输出: pool-1-thread-1--&gt;5050 pool-1-thread-4--&gt;5050 pool-1-thread-3--&gt;5050 pool-1-thread-2--&gt;5050 pool-1-thread-5--&gt;5050 pool-1-thread-1--&gt;5050 pool-1-thread-4--&gt;5050 pool-1-thread-5--&gt;5050 pool-1-thread-3--&gt;5050 pool-1-thread-2--&gt;5050 ``` **线程池使用，runnable方式提交任务，无返回结果** ```java import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; /* * 一、线程池：提供了一个线程队列，队列中保存着所有等待状态的线程。避免了创建与销毁额外开销，提高了响应的速度。 * * 二、线程池的体系结构： * java.util.concurrent.Executor : 负责线程的使用与调度的根接口 * |--**ExecutorService 子接口: 线程池的主要接口 * |--ThreadPoolExecutor 线程池的实现类 * |--ScheduledExecutorService 子接口：负责线程的调度 * |--ScheduledThreadPoolExecutor ：继承 ThreadPoolExecutor， 实现 ScheduledExecutorService * * 三、工具类 : Executors * ExecutorService newFixedThreadPool() : 创建固定大小的线程池 * ExecutorService newCachedThreadPool() : 缓存线程池，线程池的数量不固定，可以根据需求自动的更改数量。 * ExecutorService newSingleThreadExecutor() : 创建单个线程池。线程池中只有一个线程 * * ScheduledExecutorService newScheduledThreadPool() : 创建固定大小的线程，可以延迟或定时的执行任务。 */ public class TestThreadPool { public static void main(String[] args) throws Exception { //1. 创建线程池 ExecutorService pool = Executors.newFixedThreadPool(5); //2. 为线程池中的线程分配任务 for (int i = 0; i &lt; 10; i++) { //提交10个任务 pool.submit(new Runnable() { public void run() { int sum = 0; for (int i = 0; i &lt;= 100; i++) { sum += i; } System.out.println(Thread.currentThread().getName() + &quot;--&gt;&quot; + sum); } }); } //3. 关闭线程池 pool.shutdown(); } } 输出: pool-1-thread-2--&gt;5050 pool-1-thread-5--&gt;5050 pool-1-thread-4--&gt;5050 pool-1-thread-3--&gt;5050 pool-1-thread-3--&gt;5050 pool-1-thread-3--&gt;5050 pool-1-thread-1--&gt;5050 pool-1-thread-5--&gt;5050 pool-1-thread-4--&gt;5050 pool-1-thread-2--&gt;5050 ``` ## 线程调度- ScheduledExecutorService **一个 ExecutorService，可安排在给定的延迟后运行或定 期执行的命令。** ```java import java.util.Random; import java.util.concurrent.Callable; import java.util.concurrent.Executors; import java.util.concurrent.Future; import java.util.concurrent.ScheduledExecutorService; import java.util.concurrent.TimeUnit; /* * 一、线程池：提供了一个线程队列，队列中保存着所有等待状态的线程。避免了创建与销毁额外开销，提高了响应的速度。 * * 二、线程池的体系结构： * java.util.concurrent.Executor : 负责线程的使用与调度的根接口 * |--**ExecutorService 子接口: 线程池的主要接口 * |--ThreadPoolExecutor 线程池的实现类 * |--ScheduledExecutorService 子接口：负责线程的调度 * |--ScheduledThreadPoolExecutor ：继承 ThreadPoolExecutor， 实现 ScheduledExecutorService * * 三、工具类 : Executors * ExecutorService newFixedThreadPool() : 创建固定大小的线程池 * ExecutorService newCachedThreadPool() : 缓存线程池，线程池的数量不固定，可以根据需求自动的更改数量。 * ExecutorService newSingleThreadExecutor() : 创建单个线程池。线程池中只有一个线程 * * ScheduledExecutorService newScheduledThreadPool() : 创建固定大小的线程，可以延迟或定时的执行任务。 */ public class TestScheduledThreadPool { public static void main(String[] args) throws Exception { ScheduledExecutorService pool = Executors.newScheduledThreadPool(3);//3个线程 for (int i = 0; i &lt; 5; i++) { //压入5个任务 Future&lt;Integer&gt; result = pool.schedule(new Callable&lt;Integer&gt;(){ @Override public Integer call() throws Exception { int num = new Random().nextInt(100);//生成随机数 System.out.println(Thread.currentThread().getName() + &quot; : &quot; + num); return num; } }, 1, TimeUnit.SECONDS);//每隔1s 执行一次 System.out.println(result.get()); } pool.shutdown(); } } 输出: pool-1-thread-1 : 73 73 pool-1-thread-1 : 78 78 pool-1-thread-2 : 7 7 pool-1-thread-1 : 89 89 pool-1-thread-3 : 55 55 ``` ## ForkJoinPool 分支/合并框架 工作窃取 jdk1.7有了 **原理** ![](/images/javase/forkjoin原理.png) ```text 1.采用 “工作窃取”模式(work-stealing): 当执行新的任务时它可以将其拆分分成更小的任务执行，并将小任务加 到线程队列中，然后再从一个随机线程的队列中偷一个并把它放在自己的队列中。 2. 相对于一般的线程池实现，fork/join框架的优势体现在对其中包含的任务 的处理方式上.在一般的线程池中，如果一个线程正在执行的任务由于某些 原因无法继续运行，那么该线程会处于等待状态。而在fork/join框架实现中， 如果某个子问题由于等待另外一个子问题的完成而无法继续运行。那么处理 该子问题的线程会主动寻找其他尚未运行的子问题来执行.这种方式减少了 线程的等待时间，提高了性能。 ``` jdk1.8Stream并行流 比该框架更简洁 ```java package com.atguigu.juc; import java.time.Instant; import java.util.concurrent.ForkJoinPool; import java.util.concurrent.ForkJoinTask; import java.util.concurrent.RecursiveTask; import java.util.stream.LongStream; import javax.xml.datatype.Duration; import org.junit.Test; public class TestForkJoinPool { public static void main(String[] args) { Instant start = Instant.now(); ForkJoinPool pool = new ForkJoinPool(); ForkJoinTask&lt;Long&gt; task = new ForkJoinSumCalculate(0L, 50000000000L); Long sum = pool.invoke(task); System.out.println(sum); Instant end = Instant.now(); System.out.println(&quot;耗费时间为：&quot; + Duration.between(start, end).toMillis());//166-1996-10590 } @Test public void test1(){ Instant start = Instant.now(); long sum = 0L; for (long i = 0L; i &lt;= 50000000000L; i++) { sum += i; } System.out.println(sum); Instant end = Instant.now(); System.out.println(&quot;耗费时间为：&quot; + Duration.between(start, end).toMillis());//35-3142-15704 } //java8 新特性 @Test public void test2(){ Instant start = Instant.now(); Long sum = LongStream.rangeClosed(0L, 50000000000L) .parallel() //转并行流 .reduce(0L, Long::sum); //计算 System.out.println(sum); Instant end = Instant.now(); System.out.println(&quot;耗费时间为：&quot; + Duration.between(start, end).toMillis());//1536-8118 } } class ForkJoinSumCalculate extends RecursiveTask&lt;Long&gt;{ /** * */ private static final long serialVersionUID = -259195479995561737L; private long start; private long end; private static final long THURSHOLD = 10000L; //临界值 public ForkJoinSumCalculate(long start, long end) { this.start = start; this.end = end; } @Override protected Long compute() { long length = end - start; if(length &lt;= THURSHOLD){ long sum = 0L; for (long i = start; i &lt;= end; i++) { sum += i; } return sum; }else{ long middle = (start + end) / 2; ForkJoinSumCalculate left = new ForkJoinSumCalculate(start, middle); left.fork(); //进行拆分，同时压入线程队列 ForkJoinSumCalculate right = new ForkJoinSumCalculate(middle+1, end); right.fork(); // return left.join() + right.join(); } } } ```","link":"/2016/10/20/javase/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E6%B7%B1%E5%85%A5%E7%AC%AC%E4%BA%8C%E7%AF%87/"},{"title":"软件功能设计第一篇","text":"软件功能设计 所谓软件的功能设计，指的是：针对软件中某一个具体的功能，所进行的设计。包括这个功能的实现方式，实现的基本结构，类的组成，职责的划分等。是软件设计中最重要的基本功。 功能设计在整个软件设计中的层次 软件设计的层次很多，不同的软件设计过程有不同的划分方式，大致可分为:架构设计，api/spi设计，数据库设计，功能设计，类设计，方法设计 功能设计与设计模式的关系 功能设计通常会综合应用多种设计模式，是各种设计思想的具体体现的载体。由于功能千变万化，因而要有较高的设计技巧和功力，才能设计出正确的、易用的、灵活的、扩展性高的、高性能实现。 设计模式是业界公认的，优秀的设计经验和设计理念，理解、掌握、融会贯通、并能熟练变形应用设计模式，对于功能设计是有极大的帮助的。 功能设计和详细设计的关系 功能设计只是详细设计中的一个部分，详细设计还包括很多其他的设计，比如：流程设计、对API/SPI的完善和细化，对数据库设计的完善和细化、对多个功能交互的控制、事务的规划、权限/安全的规划、例外的控制。。。很多很多 功能设计的实战方法–经验总结 基本的功能实现方式，并进行细化 分析每个步骤，每个细节中，哪些是可变的，哪些是不可变的。通常分析3个部分：数据输入、具体实现、数据产出 分析这个细节步骤的功能和其他步骤的关系，比如：顺序、平行、依赖等，以确定这些职责的粒度和分离方式，从而考虑他们之间的组合方式，也需要分离这些组合方式的变与不变 根据前面的分析的结果，进行相应的类，方法的设计，进行职责的划分，并通过合适的方式把他们组织起来。 通常这个时候，就会融合进一个或多个设计模式的应用。当然也可能是没有现成的设计模式，需要自己来灵活组织和实现。 按照前面讲述的评价标准，进行系统的思考和调整，以形成最终的设计。 软件设计的一些思考 设计的基本技巧: 发现和封装变化，进行抽象和封装，实现高内聚和低耦合 设计就是危险的平衡艺术，尽可能找到最佳平衡点 没有完美的设计，设计总是在不断演变中 设计是没有标准答案的，只要能更好的实现功能，更好的满足那些评价标准，就是好东西 不要过度设计不等于不设计，而是更要精巧设计 关于重构思考，重构其实是变相的打补丁，是手段不要依赖 关于敏捷的思考， 高手怎么样都玩得转 设计是否增加了复杂度 设计是否增加了软件成本","link":"/2016/11/01/pattern%20design%20core/%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1%E7%AC%AC%E4%B8%80%E7%AF%87/"},{"title":"软件功能设计第二篇","text":"项目背景：订单管理–来自韩国ST电子商务系统 技能点 学习多模块的业务状态跟踪处理的方式 学习处理多模块循环引用、交叉引用的问题 综合应用简单工厂模式、代理模式、中介者模式，包含着这些模式但不限于这些模式该设计方式可应用于多种有类似功能的系统，比如：OA中的各种审批单流程……基本功能 有效性核实 分单，分给不同的业务部门或者仓库去处理 仓库备货、出库 运输部门负责运送 快递部门负责送货，或者是自提 收款结算基本要求 订单处理模块需要能够察看到当前订单处理的阶段和状态 仓储、运输、快递和财务模块都有自己的业务状态 任何阶段都要支持退货的处理 每个模块处理的时候，都需要检查订单状态适合本模块处理模式回顾简单工厂模式定义 提供一个创建对象实例的功能，而无须关心其具体实现。被创建实例的类型可以是接口、抽象类，也可以是具体的类。 结构和说明Api: 定义客户所需要的功能接口Impl: 具体实现Api的实现类，可能会有多个Factory: 工厂，选择合适的实现类来创建Api接口对象**Client:**客户端，通过Factory去获取Api接口对象，然后面向Api接口编程 简单工厂的要点 简单工厂位于对外提供接口的模块内 简单工厂的主要功能就是用来创建对象实例，被创建的对象可以是接口、抽象类或者普通的类 简单工厂可以实现成为单例，也可以实现成静态工厂 简单工厂的内部实现，主要是做”选择合适的实现”，实现是已经做好的，简单工厂只是来选择使用即可 简单工厂在进行选择的时候，需要的参数可以从客户端传入、配置文件、或者是运行期程序某个运行结果等 如果使用反射 + 配置文件的方式，可以写出通用的简单工厂简单工厂的本质 简单工厂的本质是:选择实现 何时选用简单工厂 如果想要完全封装隔离具体实现，让外部只能通过接口来操作封装体，那么可以选用简单工厂，让客户端通过工厂来获取相应的接口，而无需关心具体实现 如果想要把对外创建对象的职责集中管理和控制，可以选用简单工厂，一个简单工厂可以创建很多的、不相关的对象，可以把对外创建对象的职责集中到一个简单工厂来，从而实现集中管理和控制 代理模式定义 为其它对象提供一种代理以控制对这个对象的访问。 结构和说明 代理模式的要点 代理模式是通过创建一个代理对象，用这个代理对象去代表真实的对象，客户端得到这个代理对象后，直接当真实对象去操作 代理对象夹在客户端和被代理的真实对象中间，相当于一个中转，那么在中转的时候就可以做很多工作，代理模式的功能也主要通过在中转的时候进行实现，比如在中转前后附加很多操作等 代理分成很多种类，开发中最常用的是虚代理和保护代理 虚代理是：刚开始创建一个”虚”代理对象返回给客户端，直到客户端要真正使用这个对象的时候，代理才真正去创建这个对象，从而变相实现一个延迟装载，节省资源 保护代理是一种控制对原始对象访问的代理，保护代理会检查调用者是否具有请求所必需的访问权限，如果没有相应的权限，那么就不会调用目标对象，从而实现对目标对象的保护 JAVA中的静态和动态代理，不过JAVA的动态代理目前只能代理接口，基本的实现是依靠JAVA的反射机制和动态生成Class的技术，来动态生成被代理的接口的实现对象代理模式的本质 代理模式的本质:控制对象访问 何时选用代理模式 需要为一个对象在不同的地址空间提供局部代表的时候，可以使用远程代理 需要按照需要创建开销很大的对象的时候，可以使用虚代理 需要控制对原始对象的访问的时候，可以使用保护代理 需要在访问对象的时候执行一些附加操作的时候，可以使用智能指引代理 中介这模式定义 用一个中介对象来封装一系列的对象交互。中介者使得各对象不需要显示地相互引用，从而使其耦合松散，而且可以独立的改变他们之间的交互。 结构和说明 中介者模式要点 中介者主要用来封装对象之间的交互，把对象之间的交互全部集中到中介者对象里面，所有的对象就只是跟中介者对象进行通信，相互之间不再有联系，从而松散对象间的耦合，并对交互关系进行统一的管理 在实现中介者的时候，如果中介者的实现只有一种，而今后也没有扩展的需要，那么可以不要Mediator 同事和中介者必须有关系，首先是同事对象需要知道中介者对象是谁，反过来，中介者对象也需要知道相关的同事对象，这样它才能与同事对象进行交互。也就是说中介者对象和同事对象之间是相互依赖的 同事和中介者通信的方式，通常的实现方式，一种是在Mediator接口中定义一个特殊的通知接口，作为一个通用的方法，让各个同事类来调用这个方法；另一种实现方式是可以采用观察者模式，把Mediator实现成为观察者，而各个同事类实现成为Subject,这样同事类发生了改变，会通知Mediator 在实际应用开发中，经常会简化中介者模式，来使得开发变得简单，我们称其为广义中介者模式中介者模式本质 中介者模式本质是：封装交互 何时选用中介者模式 如果一组对象之间的通信模式比较复杂，导致相互依赖，结构混乱，可以采用中介者模式，把这些对象相互的交互管理起来，各个对象都只需要和中介者交互，从而使得各个对象松散耦合，结构也更清晰易懂 如果一个对象引用很多的对象，并直接跟这些对象交互，导致难以复用该对象。可以采用中介者模式，把这个对象跟其他对象的交互封装到中介者对象里面，这个对象就只需要和中介者对象交互就可以了","link":"/2016/11/01/pattern%20design%20core/%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1%E7%AC%AC%E4%BA%8C%E7%AF%87/"},{"title":"react native js初次体验","text":"react native 安装环境介绍 官网地址 :http://facebook.github.io/react-native/docs/getting-started.html brew install node brew install watchman npm install -g react-native-cli react native 新建项目 react-native init pro_name","link":"/2018/02/01/react%20native%E8%B7%A8%E5%B9%B3%E5%8F%B0/react%20native%E5%88%9D%E6%AC%A1%E4%BD%93%E9%AA%8C/"},{"title":"nodejs初次体验","text":"node安装介绍(OSX环境下) 通过brew instsll node 安装 通过官网 https://nodejs.org/en/ 下载安装包，一路next 安装 ，默认 node、npm命令在 /usr/local/bin/查看安装版本: node -v 执行node计算: node 回车 3+5 回车 就可看到结果 8 退出node ：press ^C again or type .exit node环境下web框架 express express官网地址: https://www.npmjs.com/package/express express框架安装: sudo npm install -g express-generator@4 创建web项目: mkdir pro_name &amp;&amp; cd pro_name &amp;&amp; express -e service 查看项目依赖的框架: cd service &amp;&amp; cat package.json 安装依赖的框架: npm install 在service目录下会多出 node_modules 目录 启动项目: npm start, 默认3000端口,查看web启动情况：http://localhost:3000/ 可以修改端口: cd service/bin &amp;&amp; cat www &amp;&amp; 修改端口就可以了 项目运行流程介绍 webstorm打开 service,app.js是启动入口,里面有路由信息var index = require(‘./routes/index’);var users = require(‘./routes/users’); 路由控制跳转 或者渲染情况2.1. 在route目录下有路由文件，index.js 是指把 json数据 title传给 view目录下的 index.ejs进行渲染,再返回给客户端router.get(‘/‘, function(req, res, next) {res.render(‘index’, { title: ‘Express’ });});2.2 在route目录下有路由文件，users.js 是直接返回数据给客户端，不进行渲染router.get(‘/‘, function(req, res, next) {res.send(‘respond with a resource’);}); 安装一个依赖包，自动监听修改重启操作: cd service &amp;&amp; sudo npm install -g supervisor &amp;&amp; 通过supervisor启动项目: supervisor bin/www demo 接口服务示例 service的public目录下 建立data目录 data目录下 建 json文件 ，例如 it.json 在 routes目录新建 data.js 做具体URL控制 和 逻辑判断处理 最后在 app.js绑定 新建的 data 路由var data = require(‘./routes/data’);app.use(‘/data’,data); node有防止xss攻击模块 示例 npm install xss require(‘xss’) var str = xss(name); demo后台系统设计示例 后台系统 登录涉及session ,安装session插件 cd service &amp;&amp; npm install express-session –save 在app.js引入 express-sessionvar session = require(‘express-session’);app.use(session({secret:‘#sddjswjdhww22ygfw223333@@@@%!@Q!*12455’,resave:false,saveUninitialized:true}));","link":"/2018/02/01/nodejs/nodejs%E5%88%9D%E6%AC%A1%E4%BD%93%E9%AA%8C/"},{"title":"产品心得--用户画像","text":"用户特征分析的逻辑","link":"/2018/12/16/%E4%BA%A7%E5%93%81%E5%BF%83%E5%BE%97/%E4%BA%A7%E5%93%81%E5%BF%83%E5%BE%97%E4%BA%8C--%E7%94%A8%E6%88%B7%E7%94%BB%E5%83%8F/"},{"title":"产品心得--用户调研","text":"用户调研为什么要做用户调研 为了了解用户对产品的使用过程 为了目标用户群的使用场景和过程 为了总结用户的问题和流程 为了提出最合理的解决方案 用户调研常见误区 指望从用户调研中获得需求是产品经理懒惰的表现 用户调研 ≠ 用户访谈，访谈只是其中一种方式 把个体当整体 从用户调研中找自我感觉的证明 用户调研结论不要谈占比 用户调研中最忌讳什么 直接问用户想要什么，有什么需求 直接问用户有没有用，好不好用 快速打断用户 说服用户 常用工具 录屏软件：MacBook + screenflow 手机端录屏： iPhone + MacBook + AirServer 统计系统：growingio，诸葛IO，appsee(国外) 录音笔 电话，QQ，微信等 用户调研怎么做 明确调研的背景和目的 背景:什么情况下发起的调研？是否必须通过用户调研来解决？目的：希望通过用户调研，希望得到的结果是什么？忌大而全：调研的方向越聚焦，越有价值忌假大空：针对行业用户的调研，针对满意度的调研，价值都不大 确定用户调研的对象 基于背景和目的，先挑选出大量符合行为的用户选定部分目标用户，针对性分析(用户画像)选定合适的用户(时间，地点，感兴趣程度等)邀约用户：直接说明目的，并告知可能发生的情况数量:一般不超过5个","link":"/2018/12/15/%E4%BA%A7%E5%93%81%E5%BF%83%E5%BE%97/%E4%BA%A7%E5%93%81%E5%BF%83%E5%BE%97%E4%B8%80/"},{"title":"DAM与JVM的区别","text":"区别DVM与JVM 首要差别 dalvik:基于寄存器，编译和运行都会更快些 jvm:基于栈，编译和运行都会慢些 字节码的区别 dalvik:执行.dex格式的字节码，是对.class文件进行压缩后产生的，文件变小 jvm:执行.class格式的字节码 运行环境的区别 dalvik: 一个应用启动都运行一个单独的虚拟机，运行在一个单独的进程中 jvm:只能运行一个实例，也就是所有应用都运行在同一个jvm中 配置安卓环境变量 path=..\\sdk\\platform-tool;…\\sdk\\tools 安卓模拟器 ART模式概述 ART模式是Android Runtime的简称，从Android 4.2开始出现。在Android 4.2以前，安卓手机系统的应用程序均在Dalvik Java的虚拟机上运行，这种运行模式是还要依靠一个编译器来实现与应用程序的沟通。应程序每次运行时，都需要将程序内的代码及时转变为机器码才能运行，这无形中多附加了一道手续，这就造成了耗电相对较快、占用内存大、即使是旗舰机用久了也会卡顿严重的现象。ART模式通过在安装应用程序时，自动对程序进行代码预读取编译，让程序直接编译成机器语言，免去了Dalvik模式要时时转换代码，实现高效率、省电、占用更低的系统内存、手机运行流畅。但凡事总有正反两面，ART在解决了该问题的同时，同时也有如：会占用略高一些的存储空间、安装程序时要相比普通Dalvik模式要长一些时间来实现预编译。","link":"/2014/10/20/%E5%AE%89%E5%8D%93/DAM%E4%B8%8EJVM%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"title":"Eclipse工具","text":"快捷键记录字符大写转换 MAC：command键 + shift键 + x windows: control键 + shift键 + x 字符小写转换 MAC：command键 + shift键 + y windows: control键 + shift键 + y a) 命令提示：alt+/ (main, syso) b) 文件选择： i. Shift+ 上下左右，home，end键 ii. Ctrl+Shift+ 左右 单词选中 c) 删除一行：ctrl+d d) 复制一行到下面或上面： ctrl+alt+上下 e) 换行：alt+上下 f) 编辑文件切换：ctrl+F6，或者ctrl+E，上下 g) 视图切换：ctrl+F7 h) 查看错误建议：ctrl+1 i) 导入类：ctrl+shift+o 查看类之间的继承关系MAC：command键 + t windows: control键 + t 查看类有哪些方法MAC：command键 + o windows: control键 + o 抽取方法MAC command键 + alt键 + m windows: control键 + alt键 + m 搜索类Windows Ctrl + Shift + T: 打开Open Type查找类文件","link":"/2015/08/03/%E5%B7%A5%E5%85%B7/eclipse/"},{"title":"git工具","text":"开发场景场景一:备份 场景二:代码还原 场景三:协同开发 场景四:追溯问题代码的编写人和编写时间! git历史Git是分布式的,Git不需要有中心服务器，我们每台电脑拥有的东西都是一样的。我们使用Git并且有个 中心服务器，仅仅是为了方便交换大家的修改，但是这个服务器的地位和我们每个人的PC是一样的。我们可以 把它当做一个开发者的pc就可以就是为了大家代码容易交流不关机用的。没有它大家一样可以工作，只不 过“交换”修改不方便而已。 git是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。Git是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 同生活中的许多伟大事物一样，Git 诞生于一个极富纷争大举创新的年代。Linux 内核开源项目有着为数众 多的参与者。 绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上(1991-2002 年间)。 到 2002 年，整个项目组开始启用一个专有的分布式版本控制系统 BitKeeper 来管理和维护代 码。 到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。 这就迫使 Linux 开源社区(特别是 Linux 的缔造者 Linus Torvalds)基于使用 BitKeeper 时的经验教训，开发出自己的版本系统。 他们对新的系统制订 了若干目标: 速度 简单的设计 对非线性开发模式的强力支持(允许成千上万个并行开发的分支) 完全分布式 有能力高效管理类似 Linux 内核一样的超大规模项目(速度和数据量) git常用命令1. clone(克隆): 从远程仓库中克隆代码到本地仓库 2. checkout (检出):从本地仓库中检出一个仓库分支然后进行修订 3. add(添加): 在提交前先将代码提交到暂存区 4. commit(提交): 提交到本地仓库。本地仓库中保存修改的各个历史版本 5. fetch (抓取) : 从远程库，抓取到本地仓库，不进行任何的合并动作，一般操作比较少。 6. pull (拉取) : 从远程库拉到本地库，自动进行合并(merge)，然后放到到工作区，相当于 fetch+merge 7. push(推送) : 修改完成后，需要和团队成员共享代码时，将代码推送到远程仓库 git常用配置#基本配置 git config --global user.name “用户名” git config --global user.email “邮箱” 查看配置信息 git config --global user.name git config --global user.email # 为常用指令配置别名 ~/.bashrc #用于输出git提交日志 alias git-log='git log --pretty=oneline --all --graph --abbrev-commit' git-windos下乱码解决#GitBash乱码问题 git config --global core.quotepath false # ${git_home}/etc/bash.bashrc 文件最后加入下面两行 export LANG=&quot;zh_CN.UTF-8&quot; export LC_ALL=&quot;zh_CN.UTF-8&quot; git本地仓库# 创建一个新的本地仓库 git init #基础操作指令 #Git工作目录下对于文件的修改(增加、删除、更新)会存在几个状态，这些修改的状态会随着我们执行Git 的命令而发生变化。 git add 单个文件名|通配符 #(工作区 --&gt; 暂存区) git commit -m '注释内容' #(暂存区 --&gt; 本地仓库) git status #查看修改的状态 # 查看提交日志记录 git log [option] options --all 显示所有分支 --pretty=oneline 将提交信息显示为一行 --abbrev-commit 使得输出的commitId更简短 --graph 以图的形式显示 # 版本回退 git reset --hard commitID #commitID 可以使用 git-log 或 git log 指令查看 # 看到已经删除的提交记录 git reflog 添加文件至忽略列表一般我们总会有些文件无需纳入Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以在工作目录中创建一个名为 .gitignore 的文件(文件名称固定)，列出要忽略的文件模式。下面是一个示例: # no .a files *.a # but do track lib.a, even though you're ignoring .a files above !lib.a # only ignore the TODO file in the current directory, not subdir/TODO /TODO # ignore all files in the build/ directory build/ # ignore doc/notes.txt, but not doc/server/arch.txt doc/*.txt # ignore all .pdf files in the doc/ directory doc/**/*.pdf 分支几乎所有的版本控制系统都以某种形式支持分支。 使用分支意味着你可以把你的工作从开发主线上分离开来进行重大的Bug修改、开发新的功能，以免影响开发主线。 #查看本地分支 命令:git branch 3.4.2、创建本地分支 命令:git branch 分支名 3.4.4、*切换分支(checkout) 命令:git checkout 分支名 我们还可以直接切换到一个不存在的分支(创建并切换) 命令:git checkout -b 分支名 3.4.6、*合并分支(merge) #一个分支上的提交可以合并到另一个分支 命令:git merge 分支名称 #删除分支 #不能删除当前分支，只能删除其他分支 git branch -d b1 #删除分支时，需要做各种检查 git branch -D b1 #不做任何检查，强制删除 #解决冲突 #当两个分支上对文件的修改可能会存在冲突，例如同时修改了同一个文件的同一行，这时就需要手动解决冲突，解决冲突步骤如下: 1.处理文件中冲突的地方 2.将解决完冲突的文件加入暂存区(add) 3.提交到仓库(commit) 冲突部分的内容处理如下所示: 开发中分支使用原则与流程 几乎所有的版本控制系统都以某种形式支持分支。 使用分支意味着你可以把你的工作从开发主线上分离开来进行重大的Bug修改、开发新的功能，以免影响开发主线。 在开发中，一般有如下分支使用原则与流程: master (生产) 分支 线上分支，主分支，中小规模项目作为线上运行的应用对应的分支; develop(开发)分支 是从master创建的分支，一般作为开发部门的主要开发分支，如果没有其他并行开发不同期上线 要求，都可以在此版本进行开发，阶段开发完成后，需要是合并到master分支,准备上线。 feature/xxxx分支 从develop创建的分支，一般是同期并行开发，但不同期上线时创建的分支，分支上的研发任务完成后合并到develop分支。 hotfix/xxxx分支， 从master派生的分支，一般作为线上bug修复使用，修复完成后需要合并到master、test、 develop分支。 还有一些其他分支，在此不再详述，例如test分支(用于代码测试)、pre分支(预上线分支)等等。 操作远程仓库#此操作是先初始化本地库，然后与已创建的远程库进行对接。 命令: git remote add &lt;远端名称&gt; &lt;仓库路径&gt; 远端名称，默认是origin，取决于远端服务器设置仓库路径，从远端服务器获取此URL 例如: git remote add origin git@gitee.com:**(你的路径)/**(你具体的项目名).git #查看远程仓库 命令:git remote #推送到远程仓库 命令:git push [-f] [--set-upstream] [远端名称 [本地分支名][:远端分支名] ] #如果远程分支名和本地分支名称相同，则可以只写本地分支 git push origin master -f #表示强制覆盖 --set-upstream #推送到远端的同时并且建立起和远端分支的关联关系。 git push --set-upstream origin master #如果当前分支已经和远端分支关联，则可以省略分支名和远端名。 git push #将master分支推送到已关联的远端分支。 #本地分支与远程分支的关联关系 git branch -vv 命令 # 从远程仓库克隆 git clone &lt;仓库路径&gt; [本地目录] # 从远程仓库中抓取和拉取 git fetch [remote name] [branch name] #用得少，抓取指令就是将仓库里的更新都抓取到本地，不会进行合并，如果不指定远端名称和分支名，则抓取所有分支 # 拉取 命令 git pull [remote name] [branch name] #拉取指令就是将远端仓库的修改拉到本地并自动进行合并，等同于fetch+merge 如果不指定远端名称和分支名，则抓取所有并更新当前分支","link":"/2015/08/15/%E5%B7%A5%E5%85%B7/git%E5%AE%9E%E6%88%98/"},{"title":"idea工具","text":"快捷键记录 查看一个类的所有子类 mac:command + alt + B 查看一个类的子类树状图 mac:ctrl + h 查看当前类有哪些方法 mac:command + F12 当前类创建测试类 mac:command + shift + t 快速生成try..catch mac:command + alt + t 快速重命名快捷键 mac:ctrl + t","link":"/2016/08/03/%E5%B7%A5%E5%85%B7/idea/"},{"title":"Linux常规命令","text":"查看服务器CPU核数，内存大小 磁盘大小CPU核数 top 回车，输入1，就可看出内存大小 free -m硬盘大小 df -h 压缩解压缩命令1.压缩命令： 命令格式：tar -zcvf 压缩文件名.tar.gz 被压缩文件名 可先切换到当前目录下。压缩文件名和被压缩文件名都可加入路径。2.解压缩命令： 命令格式：tar -zxvf 压缩文件名.tar.gz 解压缩后的文件只能放在当前的目录。 服务器上实时看日志tail -f xxxx.log","link":"/2015/08/03/%E5%B7%A5%E5%85%B7/linux%E5%B8%B8%E8%A7%84%E5%91%BD%E4%BB%A4/"},{"title":"maven工具","text":"可能遇到的问题","link":"/2016/11/03/%E5%B7%A5%E5%85%B7/maven%E5%B7%A5%E5%85%B7%E9%97%AE%E9%A2%98/"},{"title":"Photoshop快速抠图、修图、切图了解","text":"本篇Photoshop介绍旨在达到三个目的 会简单的抠图 会简单的修改PSD效果图 熟练的切图 PS界面组成菜单栏、选项栏、工具栏、浮动面板（拖拽名称，可单独操作面板）、绘图窗口，窗口菜单，可显示隐藏所有面板 基本操作文件下拉菜单：​1、新建 新建文档 CTRL+N(cmd + N)单位：像素 厘米 毫米 屏幕显示： 单位 像素 72像素/英寸 RGB颜色模式印刷行业： 单位 CM/MM 300像素/英寸 CMYK颜色模式 2、关闭文档 CTRL+W3、存储 CTRL+S （替存）4、存储为 CTRL+SHIFT+S 另存一份文件5、格式：​ .psd PS源文件格式 图层、文字、样式等，可再次编辑​ （给自己）​ .jpg 有损压缩格式 （给客户） 品质 最高126、文件打开：​ 1）文件下拉菜单-打开（CTRL+O欧）（双击软件空白处=打开）​ 2）拖拽文件至选项栏上方，释放鼠标 移动工具 V1、不同文件之间拖拽图像。 自由变形CTRL + T(CMD + T) 可以改变图像大小 图层操作图层面板快捷键 F7图层选择： 使用移动工具V 1、图层缩览图判断 2、按住CTRL,在目标图像上单击 3、将光标放置在目标图像上右键，选择图层名称 图层面板中加选图层： 1、按SHIFT，单击另一目标图层 中间所有图层被选中 2、按CTRL，单击另一目标图层 只选中目标图层 复制图层：选中目标图层后（移动工具状态下） 1、按ALT拖拽图像 2、CTRL+J （重合） 3、拖拽目标至创建新图层按钮 图层编组选中目标图层，CTRL+G 取消编组：CTRL+SHIFT+G 双击图层名称可重新命名 双击组名称，可命名组 移动工具V选择组或图层时，需设置选项栏 图层上下位置移动1、选中目标图层，在图层面拖拽 2、CTRL+] 向上移动图层​ CTRL+[ 向下移动图层 3、CTRL+SHIFT+] 图层置顶​ CTRL+SHIFT+[ 图层置底 移动选区或图像时： 移动过程中，没释放鼠标，按住SHIFT，可同一水平线、同一垂线、45度移动。 图层合并CRTL + E (CMD + E) 合并图层 图层透明度不透明度：设置图层的不透明程度 0%完全透明，不可见 ​ 100%完全不透明，真实可见 填充：与不透明度效果类似 键盘数字键，可快速设置透明度数值 矩形选区工具用来选择某部分区域，取消选区 CRTL + d (cmd + d)shift + alt + 滚轮 ：圆形选区 颜色填充alt + del : 前景色填充快捷键ctrl + del (cmd + del): 背景色填充快捷键选区 + 填充综合运用完成米奇效果 套索工具 L1、套索工具 L 在屏幕上拖拽鼠标左键，释放后生成选区 2、多边形套索 L 连续单击绘制多边形选区 ​ 闭合方法：1、单击起始点 2、双击任意位置 ​ DELETE删除当前点 3、磁性套索工具 L 单击颜色交界后，沿交界线拖拽鼠标，可生成选区。 磁性套索 LL 在颜色交界的位置单击后拖动。单击起始点后，生成选区。 大小写键：CAPSLOCK 可控制光标精确状态。 魔棒工具 W以单击位置为选择色，选择相似颜色生成选区。 容差：选择颜色的范围 容差小，颜色选择精确。 0-255 连续：勾选连续时，相连颜色生成选区。 ​ 不勾选，画面中所有相似颜色被选中生成选区。 按SHIFT在未生成选区位置单击，可选区相加。 选区反选：CTRL+SHIFT+I (CMD + SHIFT + I) 选区布尔运算选区面积大小的变化。 新选区：保持选中状态 添加到选区：相加运算（按住SHIFT再绘制选区） 从选区减去：相减（按住ALT再绘制选区） 与选区交叉：重合部分保留。（按住ALT+SHIFT再绘制选区） 钢笔工具： P作用：绘制路径，生成选区，抠图。 组成;路径线和锚点 绘制路径后，CTRL+回车，生成选区。 路径类型： 直线型路径：连续单击 曲线型路径：第一点单击，第二点拖动鼠标。 Photoshop 切图PS切图 可以 分为 手动 利用切片切图 以及 利用PS的插件快速切图 切片工具 利用切片工具手动划出 图层—新建基于图层的切片 利用标尺 ，然后拖拽参考线， 然后选择切片工具，点击 基于参考线的切片 导出切片，存储为web 辅助线和切片清除视图菜单–清除辅助线/清除切片 切图插件Cutterman是一款运行在photoshop中的插件，能够自动将你需要的图层进行输出， 以替代传统的手工 “导出web所用格式” 以及使用切片工具进行挨个切图的繁琐流程。 它支持各种各样的图片尺寸、格式、形态输出，方便你在pc、ios、Android等端上使用。 它不需要你记住一堆的语法、规则，纯点击操作，方便、快捷，易于上手。","link":"/2016/11/04/%E5%B7%A5%E5%85%B7/photoshop01/"},{"title":"sublime工具","text":"html的快捷键 mac环境下 html:xt+tab 自动生成HTML 4.0的整体结构文档 !html + tab 自动生成HTML 5的整体结构文档 tab键 补全标签代码 command + shift + d 快速复制一行 control+shift+k 快速删除一行 command+shift+l 编辑多行 command+鼠标左键 选中任意多行，就可以集体开始编辑 command + alt + f 查找 替换 command + / 注释 command + l 快速选中一行 command + control + 上下箭头 快速上移下移 command + alt + 2 页面分屏分组","link":"/2016/11/03/%E5%B7%A5%E5%85%B7/sublime/"},{"title":"vim工具","text":"vim 替换文件内容vim redis.conf 将该文件的6379全部替换为6380 :%s/6379/6380/g vim跳转首行和尾行G 回车 跳到尾行gg 回车 跳到首行 vim搜索内容/key_word 回车press n 可查找下一个","link":"/2016/11/03/%E5%B7%A5%E5%85%B7/vim/"},{"title":"UML介绍","text":"UML介绍 UML（UnifiedModelingLanguage）统一建模语言，是面向对象软件的标准化建模语言。由于面向对象软件开发需要经过OOA（面向对象分析），OOD（面向对象设计），OOP（面向对象编程）三个阶段，每个阶段都需要统一的符号设计描述和交流，而UML就是这种统一的符号表示。 本文主要讲述UML2.0（最新版本）的各种图的定义及用法，UML2.0一共包括13种图形（大致分成静态图和动态图两类）：活动图，类图，通信图（对应UML1.x的协作图），组件图，复合结构图（UML2.0新增），部署图，交互概观图（UML2.0新增），对象图，包图，顺序图，状态机图，定时图（UML2.0新增），用例图，如下图所示：其中，最常用的UML图包括：用例图，类图，组件图，部署图，顺序图，活动图，状态机图等。 用例图用例图作用 用例图用于描述系统提供的系列功能，方便与客户交流。而每个用例则代表了系统的一个功能模块。用例图主要目的是帮助开发团队以一种可视化的方式理解系统的需求功能，仅仅是系统功能的描述。 用例图的组成部分 用例图包括用例（以一个椭圆表示，用例的名称放在椭圆的中心或椭圆下面）、角色（Actor,也就是与系统交互的其它实体，以一个人形符号表示）、角色和用例之间的关系（以简单的线段来表示），以及系统内用例间的关系。 从图上可以看出该系统提供的功能。允许注册用户登录、发帖和回复，其中发帖和回复需要依赖登录；允许管理员删除其他人的帖子，删帖也需要依赖登录。 类图类图作用 类图表示系统中有哪些实体及其它们之间的关系，用于系统设计阶段.它一方面显示了系统的静态结构，另一方面还表示了实体之间的相互关系。 类图静态结构组成部分 包含三个矩形描述，最上面显示类名称，中间包含类的属性，最下面包含类的方法。 类之间的基本关系 类之间的基本关系：关联（包含聚合和组合）、泛化（继承）、实现、依赖 关联(包括聚合、组合) 关联是一种拥有的关系，具有方向性，如果一个类单方向的访问另一个类，则称为单向关联（用一个箭头的实线表示）；如果两个类对象可以互相访问，则称为双向关联（用两个箭头或不用箭头的实线表示）；一个对象能访问关联对象的数目叫做“多重性”。 1.1 聚合整体与部分的关系，当某个实体聚合成另一个实体时，该实体还可以是另一个实体的部分，例如，学生既可以是篮球俱乐部的成员，也可以是书法俱乐部的成员。带空心菱形的实线，菱形指向整体。1.2 组合整体与部分的关系，组合比聚合更加严格，当某个实体组合成另一个实体时，该实体还不可以是另一个实体的部分，例如手臂和人之间存在的是组合关系。带实心菱形的实线，菱形指向整体。 泛化(与继承同一个概念) 泛化与继承是同一个概念。带三角箭头的实线，箭头指向父类。 实现(子类与接口的关系) 一种类与接口的关系。【箭头及指向】：带三角箭头的虚线，箭头指向父接口。 依赖 组件图 对于现代的大型应用程序而言，通常不只是单独一个类或单独一组类所能完成的，通常会由一个或多个可部署的组件组成。对Java程序而言，可复用的组件通常打包成一个JAR、WAR等文件；对CC++应用而言，可复用的组件通常是一个函数库，或者是一个DLL（动态链接库）文件。组件图提供系统的物理视图，它的用途是显示系统中的软件对其他软件组件（例如，库函数）的依赖关系。组件图可以在一个非常高的层次上显示，仅显示系统中粗粒度的组件,也可以在组件包层次上显示。组件图通常包含组件、接口和Port等图元，UML使用带符号的矩形来表示组件，使用圆圈代表接口，使用位于组件边界上的小矩形代表Port.组件的接口表示它能对外提供的服务规范，这个接口通常有两种表现形式。用一条实线连接到组件边界的圆圈表示使用位于组件内部的圆圈表示。组件除了可以对外提供服务接口之外，组件还可能依赖于某个接口，组件依赖于某个接口使用一条带半圆的实线来表示。图2.15显示了组件的接口和组件依赖的接口。图2.15显示了一个简单的Order组件，该组件对外提供一个 Payable接口，该组件需要依赖于一个CustomerLookup接口–通常这个 CustomerLookup接口也是系统中已有的接口。图2.16显示了包含组件关系的组件图。 从图2.16可以看出，本系统绘制电子购物平台的几个核心组件，其中 Order组件提供 OrderQuery接口，该接口允许 Dispatch组件查询系统中的订单及其状态， Order组件又需要依赖于 Customer组件的CustomerLookup接口，通过该接口查询系统中的顾客信息； Order组件也需要依赖于 Inventory组件的 ProductQuery接口，通过该接口查询系统中的产品信息。 部署图 顺序图顺序图也叫时序图，描述对象之间消息的发送顺序，强调时间顺序。用箭头表示消息、用竖虚线表示对象生命线。 活动图活动图和状态机图都被称为演化图，其区别和联系如下。活动图:用于描述用例内部的活动或方法的流程，如果除去活动图中的并行活动描述，它就变成流程图。状态机图:描述某一对象生命周期中需要关注的不同状态，并会详细描述刺激对象状态改变的事件，以及对象状态改变时所采取的动作。演化图的5要素如下。**状态:**状态是对象响应事件前后的不同面貌，状态是某个时间段对象所保持的稳定态，目前的软件计算都是基于稳定态的，对象的稳定态是对象的固有特征，一个对象的状态一般是有限的。有限状态的对象是容易计算的，对象的状态越多，对象的状态迁移越复杂，对象状态可以想象成对象演化过程中的快照。**事件:**来自对象外界的刺激，通常的形式是消息的传递，只是相对对象而言发生了事件。事件是对象状态发生改变的原动力。**动作:**动作是对象针对所发生事件所做的处理，实际上通常表现为某个方法被执行。**活动:**活动是动作激发的后续系统行为。**条件:**条件指事件发生所需要具备的条件。对于激发对象状态改变的事件，通常有如下两种类型。**内部事件:**从系统内部激发的事件，一个对象的方法（动作）调用（通过事件激活）另一个对象的方法（动作）外部事件:从系统边界外激发的事件，例如用户的鼠标、键盘动作。活动图主要用于描述过程原理、业务逻辑以及工作流技术。活动图非常类似于传统的流程图，它也使用圆角矩形表示活动，使用带箭头的实线表示事件；区别是活动图支持并发。图2.19显示了简单的活动图。 状态机图状态机图表示某个对象所处的不同状态和该类的状态转换信息。实际上，通常只对“感兴趣的”对象绘制状态机图。也就是说，在系统活动期间具有三个或更多潜在状态的对象才需要考虑使用状态机图进行描述。状态机图的符号集包括5个基本元素初始状态，使用实心圆来绘制。状态之间的转换，使用具有带箭头的线段来绘制。状态，使用圆角矩形来绘制。判断点，使用空心圆来绘制。一个或者多个终止点，使用内部包含实心圆的圆来绘制。要绘制状态机图，首先绘制起点和一条指向该类的初始状态的转换线段。状态本身可以在图中的任意位置绘制，然后使用状态转换线段将它们连接起来。图2.20显示了 Hibernate实体的状态机图。图2.20描绘了 Hibernate实体具有三个状态:瞬态、持久化和脱管。当程序通过new直接创建一个对象时，该对象处于瞬态；对一个瞬态的对象执行 save、 saveOrUpdate方法后该对象将会变成持久化状态；对一个持久化状态的实体执行 delete方法后该对象将变成瞬态；持久化状态和脱管状态也可以相互转换。","link":"/2014/11/01/%E5%BB%BA%E6%A8%A1/UML%E4%BB%8B%E7%BB%8D/"},{"title":"微信小程序开发","text":"微信小程序介绍 小程序:一种新的应用形态 一种不需要安装下载即可使用的应用。 触手可及:通过扫一扫，或者搜索，或者通过公众号跳转。 用完即走:用户不同关心是否安装太多应用的问题，应用无处不在， 随时可用，无需安装，也无需卸载。 小程序官方文档： https://developers.weixin.qq.com/miniprogram/dev/framework 准备步骤 注册小程序账号：https://mp.weixin.qq.com/wxopen/waregister?action=step1 可以根据需求选择个人，企业，组织等 安装小程序开发环境https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html 熟悉开发环境 熟悉小程序代码结构 .json 后缀的 JSON 配置文件 .wxml 后缀的 WXML 模板文件 .wxss 后缀的 WXSS 样式文件 .js 后缀的 JS 脚本逻辑文件 小程序的生命周期app.jsapp生命周期 onLaunch onShow onHide 页面生命周期 page.js onLoad：只调用一次 onShow onReady:只调用一次 onHide onUnload:页面卸载 navigateTo：navigateTo无法跳转到tabBar上已有的页面，只能跳到tabBar上没有的页面。redirectTo：后面页面替换前面页面，无法返回去navigator 元素参数传递配置详解app.jsonpages 提示: pages里面， 第一个页面是缺省启动页面，这个约定俗称，无法通过其他方法控制。 windowtabBar 提示:在tabBar上没有涉及的页面，tabBar不 显示。 debug小程序UI布局小程序的弹性盒布局flex display:flex flex-direction: 主轴方向 row：默认值，水平方向，从左到右； row-reverse:水平方向，从右到左； column:垂直方向，从上到下； cokumn-reverse:垂直方向，从下到上 justify-content：主轴线对齐方式 flex-start:默认值，左对齐； flex-end:右对齐； center：居中对齐； space-between：两端对齐，元素间隔相等；s pace-around:项目等距分布在行里，两端保留项目间距一半的空间。 align-items:侧轴对齐属性 flex-start:默认值，左对齐； flex-end:右对齐； center：居中对齐； baseline：项目第一行文字的基线对齐； stretch:默认值，上下两侧对齐，将占满整个容器高度示例：```css.container { width: 100%; height: 500rpx; background-color: #DDDDDD; display: flex; flex-direction: row; justify-content: flex-start; align-items: flex-end;} ### 样式 ### 组件 ### 表单","link":"/2018/11/01/%E5%BE%AE%E4%BF%A1%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"},{"title":"微信支付介绍","text":"微信支付产品介绍微信支付产品：https://pay.weixin.qq.com/wiki/doc/api/index.html 付款码支付 用户打开微信钱包-付款码的界面，商户扫码后提交完成支付 JSAPI支付 用户通过微信扫码、关注公众号等方式进入商家H5页面，并在微信内调用JSSDK完成支付 Native支付(之前微信文档叫做扫码支付) 用户打开”微信扫一扫“,扫描商户的二维码后完成支付 APP支付 商户APP中集成微信SDK，用户点击后跳转到微信内完成支付 H5支付 用户在微信以外的手机浏览器请求微信支付的场景唤起微信支付 小程序支付 用户在微信小程序中使用微信支付的场景 刷脸支付 用户在微信小程序中使用微信支付的场景 二维码预热 需要的pom依赖 &lt;!-- google生成二维码依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.zxing&lt;/groupId&gt; &lt;artifactId&gt;core&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.zxing&lt;/groupId&gt; &lt;artifactId&gt;javase&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;/dependency&gt; 示例生成一个二维码，包含简单信息@Test public void testQRCode() throws WriterException, IOException { String content = &quot;{name:sxm,school:ecit}&quot;; //二维码的宽高 int width = 200; int hight = 200; //创建map集合 Map&lt;EncodeHintType,Object&gt; hints = new HashMap&lt;&gt;(); hints.put(EncodeHintType.CHARACTER_SET, &quot;UTF-8&quot;) ; //创建一个 矩阵对象 BitMatrix bitMatrix = new MultiFormatWriter().encode(content, BarcodeFormat.QR_CODE, width, hight,hints) ;//生成的路径 String filePath = &quot;/Users/sxm/Desktop&quot;; String fileName = &quot;testQRCode.jpg&quot;; //创建一个路径对象 Path path = FileSystems.getDefault().getPath(filePath, fileName) ; //将矩阵对象生成一个图片 MatrixToImageWriter.writeToPath (bitMatrix, &quot;jpg&quot; ,path); } 生成复杂二维码，带边框背景颜色```java ```","link":"/2017/06/01/%E5%BE%AE%E4%BF%A1%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98/"},{"title":"栈算法实现--动态栈(链表实现)","text":"#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdbool.h&gt; typedef struct Node { int data; struct Node *pNext; } NODE, *PNODE; typedef struct Stack { PNODE pTop; //栈顶 PNODE pBottom; //栈底 } STACK, *PSTACK; /** * 初始化栈 */ void init(PSTACK); /** * 压栈 * @param pstack * @param data * @return */ void push(PSTACK pstack, int data); /** * 出栈 * @param pstack * @param popData * @return */ bool pop(PSTACK pstack, int *popData); bool isEmpty(PSTACK pstack); /** * 遍历栈 * @param pstack */ void traverse(PSTACK pstack); /** * 清空栈 * @param pstack */ void clear(PSTACK pstack); void handEcxeption(PNODE node); int main() { STACK stack; int popData; init(&amp;stack); push(&amp;stack, 3); push(&amp;stack, 5); push(&amp;stack, 30); push(&amp;stack, 50); traverse(&amp;stack); if (pop(&amp;stack, &amp;popData)) { printf(&quot;出栈成功数据: %d\\n&quot;, popData); } else { printf(&quot;出栈失败!\\n&quot;); } clear(&amp;stack); traverse(&amp;stack); return 0; } void init(PSTACK pstack) { PNODE head = (PNODE) malloc(sizeof(NODE)); handEcxeption(head); pstack-&gt;pTop = head; pstack-&gt;pBottom = head; pstack-&gt;pTop-&gt;pNext = NULL; } void push(PSTACK pstack, int data) { PNODE pNewNode = (PNODE) malloc(sizeof(NODE)); handEcxeption(pNewNode); pNewNode-&gt;data = data; pNewNode-&gt;pNext = pstack-&gt;pTop; pstack-&gt;pTop = pNewNode; return; } bool pop(PSTACK pstack, int *popData) { if (isEmpty(pstack)) { return false; } else { PNODE pnode = pstack-&gt;pTop; *popData = pnode-&gt;data; pstack-&gt;pTop = pstack-&gt;pTop-&gt;pNext; free(pnode); return true; } } void traverse(PSTACK pstack) { PNODE pnode = pstack-&gt;pTop; while (pnode != pstack-&gt;pBottom) { printf(&quot;%d &quot;, pnode-&gt;data); pnode = pnode-&gt;pNext; } printf(&quot;\\n&quot;); } bool isEmpty(PSTACK pstack) { if (pstack-&gt;pTop == pstack-&gt;pBottom) return true; else return false; } void clear(PSTACK pstack) { if (isEmpty(pstack)) { return; } else { PNODE pnode = pstack-&gt;pTop; PNODE q ; while (pnode!=pstack-&gt;pBottom){ q = pnode-&gt;pNext; free(pnode); pnode = q; } pstack-&gt;pTop = pstack-&gt;pBottom; } } void handEcxeption(PNODE node) { if (NULL == node) { printf(&quot;申请内存失败,程序异常退出!\\n&quot;); exit(-1); } }","link":"/2014/10/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8A%A8%E6%80%81%E6%A0%88-%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0/"},{"title":"重温数据结构--概论和复杂度","text":"数据结构概论 数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的学科 传统上，我们把数据结构分为逻辑结构和物理结构 逻辑结构：是指数据对象中数据元素之间的相互关系，也是我们今后最需要关注和讨论的问题 四大逻辑结构： 物理结构：是指数据的逻辑结构在计算机中的存储形式，数据元素的存储结构形式有两种：顺序存储和链式存储。 顺序存储结构：是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的,如数组等。 链式存储结构：是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的，如银行，医院排队等号场景。 衡量算法的标准 时间复杂度 大概程序执行的次数，而非执行的时间，一般用大写O()来体现算法时间复杂度的记法，我们称之为大O记法。一般情况下，随着输入规模n的增大，T(n)增长最慢的算法为最优算法。 空间复杂度 算法执行过程中大概所占用的最大内存 难易程度 健壮性 算法时间复杂度推导大 O 阶方法 用常数 1 取代运行时间中的所有加法常数。 在修改后的运行次数函数中，只保留最高阶项。 如果最高阶项存在且不是 1 ，则去除与这个项相乘的常数。得到的结果就是大 O 阶 常数阶 首先顺序结构的时间复杂度。下面这个算法，也是所说的高斯算法，为什么时间复杂度不是O(3),而是O(1). int sum = 0,n = 100; /* 执行一次 */ sum = (1+n) * n / 2; /* 执行一次 */ printf(&quot;%d&quot;,sum); /* 执行一次 */ 这个算法的运行次数函数是 f(n) = 3. 根据我们推导大 O 阶的方法，第一步就是把常数项 3 改为 1.在保留最高阶项时发现，它根本没有最高阶项，所以这个算法的时间复杂度为 O(1). 对于分支结构而言，无论是真，还是假，执行的次数都是恒定的，不会随着 n 的变大而发生变化，所以单纯的分支结构(不包含在循环结构中)，其时间复杂度也是 O(1)。 线性阶 线性阶的循环结构会复杂很多。要确定某个算法的阶次，我们常常需要确定某个特定语句或某个语句集运行的次数。因此，我们要分析算法的复杂度，关键是要分析循环结构的运行情况。 示例 循环的时间复杂度为 O(n),因为循环体中的代码需要执行 n 次。： int i; for(i=0;i&lt;n;i++) { /*时间复杂度为 O(1) 的程序步骤序列*/ } 对数阶示例: int count = 1; while(count &lt;n) { count = count * 2; /*时间复杂度为O(1)的程序步骤序列*/ } LaTeX 公式由于每次count 乘以 2之后，就距离 n更近了一分。也就是说，有多少个2相乘后大于 n,则会退出循环。由 $2^count=n$ 可以创建行内公式，例如 $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$。或者块级公式： $$ x = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$","link":"/2020/10/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%80%E7%AF%87/"},{"title":"递归-汉诺塔","text":"#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdbool.h&gt; /** * 汉诺塔问题 ，用递归实现描述 * 有A,B,C三个柱子，把A上面的盘子借助B柱子，移动到C柱子 * 1. 要求一次只能移动一个盘子 * 2. 移动过程中大盘子永远不能放在小盘子上面 */ /** * * @param n * @param A 始终是存在盘子的柱子，移动过程中注意名称为A，不一定就是A柱子 * @param B 始终是中间需要借助的柱子，不一定就是B柱子，不要被字母搞混淆 * @param C 始终是最后移到的盘子 */ void hannuota(int n, char A, char B , char C){ /** * 如果是一个盘子 * 直接将A柱子上的盘子从A移动到C柱子 * 否则 * 先将A柱子的n-1个盘子借助C移动到B * 直接将A柱子上盘子从A移到C * 最后将B柱子的n-1个盘子借助A移到C */ if(n==1){ printf(&quot;将编号为 %d的盘子直接从 %c 柱子移到 %c柱子上 \\n&quot;,n,A,C); } else{ hannuota(n-1,A,C,B); printf(&quot;将编号为 %d的盘子直接从 %c 柱子移到 %c柱子上 \\n&quot;,n,A,C); hannuota(n-1,B,A,C); } } int main(){ int n; printf(&quot;请输入A柱子上的盘子个数&quot;); scanf(&quot;%d&quot;,&amp;n); hannuota(n,'A','B','C'); } /** *请输入A柱子上的盘子个数4 将编号为 1的盘子直接从 A 柱子移到 B柱子上 将编号为 2的盘子直接从 A 柱子移到 C柱子上 将编号为 1的盘子直接从 B 柱子移到 C柱子上 将编号为 3的盘子直接从 A 柱子移到 B柱子上 将编号为 1的盘子直接从 C 柱子移到 A柱子上 将编号为 2的盘子直接从 C 柱子移到 B柱子上 将编号为 1的盘子直接从 A 柱子移到 B柱子上 将编号为 4的盘子直接从 A 柱子移到 C柱子上 将编号为 1的盘子直接从 B 柱子移到 C柱子上 将编号为 2的盘子直接从 B 柱子移到 A柱子上 将编号为 1的盘子直接从 C 柱子移到 A柱子上 将编号为 3的盘子直接从 B 柱子移到 C柱子上 将编号为 1的盘子直接从 A 柱子移到 B柱子上 将编号为 2的盘子直接从 A 柱子移到 C柱子上 将编号为 1的盘子直接从 B 柱子移到 C柱子上 */","link":"/2014/11/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%80%92%E5%BD%92-%E6%B1%89%E8%AF%BA%E5%A1%94/"},{"title":"队列算法实现--静态队列(数组实现)","text":"#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdbool.h&gt; typedef struct Queue { int *pBase; int front; int rear; } QUEUE; /** * 初始化队列 */ void init(QUEUE *); /** * 入队操作 * @param value */ bool in_queue(QUEUE *, int value); bool isFull(QUEUE *queue); /** * 遍历队列 * @param queue */ void traverse(QUEUE *queue); bool isEmpty(QUEUE *queue); /** * 出队 * @param queue * @param val * @return */ bool out_queue(QUEUE *queue,int *val); int main() { QUEUE queue; int val; init(&amp;queue); in_queue(&amp;queue, 1); in_queue(&amp;queue, 2); in_queue(&amp;queue, 3); in_queue(&amp;queue, 4); in_queue(&amp;queue, 5); in_queue(&amp;queue, 6); in_queue(&amp;queue, 7); traverse(&amp;queue); if(out_queue(&amp;queue,&amp;val)){ printf(&quot;出队数：%d \\n&quot;,val); } else{ printf(&quot;出队失败！\\n&quot;); } traverse(&amp;queue); return 0; } void init(QUEUE *queue) { queue-&gt;pBase = malloc(sizeof(int) * 6);//暂定队列6个元素 queue-&gt;front = 0; queue-&gt;rear = 0; } bool isFull(QUEUE *queue) { if ((queue-&gt;rear + 1) % 6 == queue-&gt;front) return true; else return false; } bool in_queue(QUEUE *queue, int value) { if (isFull(queue)) { return false; } else { queue-&gt;pBase[queue-&gt;rear] = value; queue-&gt;rear = (queue-&gt;rear + 1) % 6; return true; } } bool isEmpty(QUEUE *queue) { if (queue-&gt;front == queue-&gt;rear) return true; else return false; } void traverse(QUEUE *queue) { if (isEmpty(queue)) { return; } else { int i = queue-&gt;front; while (i != queue-&gt;rear) { printf(&quot;%d &quot;, queue-&gt;pBase[i]); i = (i+1)%6; } printf(&quot;\\n&quot;); } } bool out_queue(QUEUE *queue,int *val){ if(isEmpty(queue)){ return false; } else{ *val = queue-&gt;pBase[queue-&gt;front]; queue-&gt;front = (queue-&gt;front + 1)%6; return true; } }","link":"/2014/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%99%E6%80%81%E9%98%9F%E5%88%97-%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0/"},{"title":"非循环单链表","text":"#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdbool.h&gt; /** * 非循环单链表数据结构类型 */ typedef struct Node { int data; //数据域 struct Node *pNext; //后继节点地址 } NODE, *PNODE; /** * 创建链表 * @param head */ PNODE createLinkedList(PNODE head); /** * 遍历链表数据 * @param head */ void traverseLinkedList(PNODE head); /** * 判断链表是否为空 * @return */ bool isEmpty(PNODE); /** * 获取链表的长度 * @return */ int size(PNODE); /** * 对链表进行排序 * @return */ void sortLinkedList(PNODE); /** * 把新元素插入到 pos的位置 * @param headNode * @param pos 元素的逻辑位置 * @param data 新元素数据 * @return */ bool insertNode(PNODE headNode, int pos, int data); /** * 删除 POS位置的元素 * @param headNode * @param pos * @param deletedDataVal * @return */ bool deleteNode(PNODE headNode, int pos, int *deletedDataVal); /** * 处理分配失败的情形 * @param node */ void handEcxeption(PNODE node); void showMenu(); int main(void) { PNODE head = NULL;//定义一个头结点 int select; int pos, val; while (true) { showMenu(); scanf(&quot;%d&quot;, &amp;select); switch (select) { case 1: head = createLinkedList(head); break; case 2: traverseLinkedList(head); break; case 3: printf(&quot;链表长度 %d&quot;, size(head)); break; case 4: { printf(&quot;输入要插入的元素值, 插入位置 中间以空格隔开\\n&quot;); scanf(&quot;%d %d&quot;, &amp;val, &amp;pos); printf(&quot;接收到 pos=%d,val=%d \\n&quot;, pos, val); bool flag = insertNode(head, pos, val); if (flag) printf(&quot;插入新元素成功!\\n&quot;); else printf(&quot;插入新元素失败\\n&quot;); } break; case 5: sortLinkedList(head); traverseLinkedList(head); break; break; case 6: { printf(&quot;输入要删除元素的位置 \\n&quot;); scanf(&quot;%d&quot;, &amp;pos); printf(&quot;要删除的位置 pos=%d \\n&quot;, pos); int delVal; bool flag = deleteNode(head, pos, &amp;delVal); if (flag) printf(&quot;删除成功，删除的元素值是 %d \\n&quot;, delVal); else printf(&quot;插入新元素失败\\n&quot;); } break; case 0: free(head); exit(1); default: system(&quot;clear&quot;); break; } } } PNODE createLinkedList(PNODE head) { int len, val = 0; head = (PNODE) malloc(sizeof(NODE)); handEcxeption(head); PNODE tailNode = head; //复制一个尾节点，方便每次操作新增的节点 printf(&quot;请输入要申请的节点个数 &quot;); scanf(&quot;%d&quot;, &amp;len); for (int i = 0; i &lt; len; ++i) { PNODE pnode = (PNODE) malloc(sizeof(NODE)); //新增节点 handEcxeption(pnode); printf(&quot;请输入要存入的数据 &quot;); scanf(&quot;%d&quot;, &amp;val); pnode-&gt;data = val; tailNode-&gt;pNext = pnode; //挂到链表后面 tailNode = pnode; } tailNode-&gt;pNext = NULL; //链表最后一个节点不指向任何节点 return head; } void traverseLinkedList(PNODE head) { PNODE tailNode; if (head != NULL) { tailNode = head-&gt;pNext; } printf(&quot;链表遍历结果输出: &quot;); while (tailNode != NULL) { printf(&quot;%d &quot;, tailNode-&gt;data); tailNode = tailNode-&gt;pNext; } printf(&quot;\\n&quot;); } bool isEmpty(PNODE pnode) { if (pnode-&gt;pNext == NULL) return true; else return false; } int size(PNODE headNode) { if (headNode == NULL) return 0; PNODE tailNode = headNode-&gt;pNext; int length = 0; while (tailNode != NULL) { length++; tailNode = tailNode-&gt;pNext; } return length; } void sortLinkedList(PNODE head) { int length = size(head); int temVal; int i, j; PNODE p, q; for (i = 0, p = head-&gt;pNext; i &lt; length - 1; i++, p = p-&gt;pNext) for (j = i + 1, q = p-&gt;pNext; j &lt; length; j++, q = q-&gt;pNext) { if (p-&gt;data &gt; q-&gt;data) { temVal = p-&gt;data; p-&gt;data = q-&gt;data; q-&gt;data = temVal; } } } bool insertNode(PNODE headNode, int pos, int data) { int currentPos = 0; //找到 pos-1的元素 PNODE p = headNode; while (p != NULL &amp;&amp; currentPos &lt; pos - 1) { //新增必须得有头结点 currentPos++; p = p-&gt;pNext; } //无效判断 if (p == NULL || currentPos &gt; pos-1) { return false; } PNODE pNewNode = (PNODE) malloc(sizeof(NODE)); handEcxeption(pNewNode); pNewNode-&gt;data = data; PNODE q = p-&gt;pNext; p-&gt;pNext = pNewNode; pNewNode-&gt;pNext = q; return true; } bool deleteNode(PNODE headNode, int pos, int *deletedDataVal) { int currentPos = 0; //找到 pos-1的元素 PNODE p = headNode; while (p-&gt;pNext != NULL &amp;&amp; currentPos &lt; pos - 1) { //删除时前提至少得有一个有效节点，即首节点 currentPos++; p = p-&gt;pNext; } //无效判断 if (p-&gt;pNext == NULL || currentPos &gt; pos-1) { return false; } PNODE q = p-&gt;pNext; *deletedDataVal = q-&gt;data; p-&gt;pNext = p-&gt;pNext-&gt;pNext; free(q); return true; } void handEcxeption(PNODE node) { if (NULL == node) { printf(&quot;申请内存失败,程序异常退出!\\n&quot;); exit(-1); } } void showMenu() { printf(&quot;\\t\\t******主菜单*******\\t\\t\\n&quot;); printf(&quot;\\t\\t** 1.新增数据 **\\t\\t\\n&quot;); printf(&quot;\\t\\t** 2.遍历展示 **\\t\\t\\n&quot;); printf(&quot;\\t\\t** 3.链表长度 **\\t\\t\\n&quot;); printf(&quot;\\t\\t** 4.插入元素 **\\t\\t\\n&quot;); printf(&quot;\\t\\t** 5.链表排序 **\\t\\t\\n&quot;); printf(&quot;\\t\\t** 6.删除元素 **\\t\\t\\n&quot;); printf(&quot;\\t\\t** 0.退出系统 **\\t\\t\\n&quot;); printf(&quot;\\t\\t****************** \\t\\t\\n&quot;); }","link":"/2014/10/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%9E%E5%BE%AA%E7%8E%AF%E5%8D%95%E9%93%BE%E8%A1%A8%E7%AE%97%E6%B3%95/"},{"title":"重温汇编","text":"编程语言的发展机器语言 由0和1组成 汇编语言（Assembly Language） 用符号代替了0和1，比机器语言便于阅读和记忆 高级语言 C\\C++\\Java\\Swift等，更接近人类自然语言 操作：将寄存器BX的内容送入寄存器AX 机器语言：1000100111011000 汇编语言：mov ax, bx 高级语言：ax = bx; 汇编语言与机器语言一一对应，每一条机器指令都有与之对应的汇编指令汇编语言可以通过编译得到机器语言，机器语言可以通过反汇编得到汇编语言高级语言可以通过编译得到汇编语言\\机器语言，但汇编语言\\机器语言几乎不可能还原成高级语言 汇编语言的特点 可以直接访问、控制各种硬件设备，比如存储器、CPU等，能最大限度地发挥硬件的功能 汇编指令是机器指令的助记符,同机器指令一一对应。每一种CPU都有自己的机器指令集\\汇编指令集，所以汇编语言不具备可移植性 知识点过多，开发者需要对CPU等硬件结构有所了解，不易于编写、调试、维护 不区分大小写，比如mov和MOV是一样的 汇编语言的用途 编写驱动程序、操作系统（比如Linux内核的某些关键部分） 对性能要求极高的程序或者代码片段，可与高级语言混合使用（内联汇编） 软件安全 病毒分析与防治 逆向\\加壳\\脱壳\\破解\\外挂\\免杀\\加密解密\\漏洞\\黑客 是理解整个计算机系统的最佳起点和最有效途径 为编写高效代码打下基础 弄清代码的本质 sizeof ++a + ++a + ++a switch和if的效率究竟谁高？为什么？ 汇编语言的分类 目前讨论比较多的汇编语言有 8086汇编（8086处理器是16bit的CPU） Win32汇编 Win64汇编 AT&amp;T汇编（Mac、iOS模拟器） ARM汇编（嵌入式、iOS设备）入门建议先从学些8086汇编开始，结构简洁、经典 ，参考书籍：王爽《汇编语言》 了解硬件程序的执行过程 总线 每一个CPU芯片都有许多管脚，这些管脚和总线相连，CPU通过总线跟外部器件进行交互 总线：一根根导线的集合 内存 8086寻址方式 CPU访问内存单元时，要给出内存单元的地址 8086有20位地址总线，可以传送20位的地址，1M的寻址能力 但它又是16位结构的CPU，它内部能够一次性处理、传输、暂时存储的地址为16位。如果将地址从内部简单地发出，那么它只能送出16位的地址，表现出来的寻址能力只有64KB 8086寻址方式计算：物理地址=段地址×16+偏移地址 结论: CPU可以用不同的段地址和偏移地址形成同一个物理地址。 比如CPU要访问21F60H单元，则它给出的段地址SA和偏移地址EA满足SA x 16 + EA = 21F60H即可。 内存分段管理 CPU的典型构成寄存器 对程序员来说，CPU中最主要部件是寄存器，可以通过改变寄存器的内容来实现对CPU的控制 不同的CPU，寄存器的个数、结构是不相同的（8086是16位结构的CPU） 8086有14个寄存器 都是16位的寄存器 可以存放2个字节 段寄存器-提供段地址 8086在访问内存时要由相关部件提供内存单元的段地址和偏移地址，送入地址加法器合成物理地址。是什么部件提供段地址？段地址在8086的段寄存器中存放 8086有4个段寄存器：CS、DS、SS、ES，当CPU需要访问内存时由这4个段寄存器提供内存单元的段地址 CS (Code Segment)：代码段寄存器 DS (Data Segment)：数据段寄存器 SS (Stack Segment)：堆栈段寄存器 ES (Extra Segment)：附加段寄存器 8086不支持将数据直接送入段寄存器中，mov ds,1000H是错误的,将地址10000H（1000:0）【CS:IP】中的内存数据赋值到al寄存器,正确写法: mov bx, 1000H mov ds, bx mov al, [0] 栈：是一种具有特殊的访问方式的存储空间（后进先出， Last In Firt Out ，LIFO） 8086会将CS作为代码段的段地址，将CS:IP指向的指令作为下一条需要取出执行的指令 8086会将DS作为数据段的段地址，mov ax,[address]就是取出DS:address的内存数据放到ax寄存器中 8086会将SS作为栈段的段地址，任意时刻，SS:SP指向栈顶元素 8086提供了PUSH（入栈）和POP （出栈）指令来操作栈段的数据 比如push ax是将ax的数据入栈，pop ax是将栈顶的数据送入ax栈结构示例：入栈示例：出栈示例：栈顶超界 - push示例：栈顶超界 - pop示例： 大小端模式 大端模式，是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中（高低\\低高） (Big Endian)，Big Endian 如: PowerPC、IBM、 Sun 小端模式，是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中（高高\\低低）(Little Endian)，Little Endian如 : x86、DEC，ARM既可以工作在大端模式,也可以工作在小端模式 指令执行过程(重点cs、ip) CS为代码段寄存器，IP为指令指针寄存器，它们指示了CPU当前要读取指令的地址 任意时刻，8086CPU都会将CS:IP指向的指令作为下一条需要取出执行的指令 通过上面的过程展示，8086CPU的工作过程可以简要描述如下。(1)从CS:IP指向的内存单元读取指令，读取的指令进入指令缓冲器;(2) IP=IP+所读取指令的长度， 从而指向下一条指令;(3)执行指令。转到步骤(1)，重复这个过程。在8086CPU加电启动或复位后(即CPU刚开始工作时)CS和IP被设置为CS=FFFFH，IP-=0000H， 即在8086PC机刚启动时，CPU从内存FFFF0H单元中读取指令执行，FFFF0H单元中的指令是8086PC机开机后执行的第一条指令。 指令和数据 指令集mov指令 mov 寄存器，数据 比如: mov ax,8 mov 寄存器，寄存器 比如: mov ax,bx mov 寄存器，内存单元 比如: mov ax,[0] mov 内存单元，寄存器 比如: mov [0],ax mov 段寄存器， 寄存器 比如: mov ds,ax mov 寄存器，段寄存器“ mov内存单元，内存单元”是不允许的，比如mov [0], [1] add和sub指令 add 寄存器， 数据 比如: add ax,8 add 寄存器，寄存器 比如: add ax,bx add 寄存器， 内存单元 比如: add ax,[0] add 内存单元，寄存器 比如: add [0],ax sub 寄存器，数据 比如: sub ax,9 sub 寄存器，寄存器 比如: sub ax,bx sub 寄存器，内存单元 比如: sub ax,[0] sub 内存单元，寄存器 比如: sub [0],ax jmp指令 CPU从何处执行指令是由CS、IP中的内容决定的，我们可以通过改变CS、IP的内容来控制CPU执行目标指令 8086提供了一个mov指令（传送指令），可以用来修改大部分寄存器的值。但是，mov指令不能用于设置CS、IP的值，8086没有提供这样的功能 8086提供了另外的指令来修改CS、IP的值，这些指令统称为转移指令，最简单的是jmp指令 push和pop指令 在8086中，push、pop操作的数据都是2个字节的 push 寄存器 ;将一个寄存器中的数据入栈 pop 寄存器 ;出栈，用一个寄存器接收出栈的数据 push 段寄存器 ;将一个段寄存器中的数据入栈 pop 段寄存器 ;出栈，用一个段寄存器接收出栈的数据 push 内存单元 ;将一个内存字单元处的字入栈(注意:栈操作都是以字为单位) pop 内存单元 ;出栈，用一个内存字单元接收出栈的数据mov ax, 1000H mov ds, ax;内存单元的段地址要放在ds中 push [0];将1000:0处的字压入栈中 pop [2];出栈，出栈的数据送入1000:2处 loop指令 call和ret指令 call 标号：将下一条指令的偏移地址入栈后，转到标号处执行指令 ret：将栈顶的值出栈，赋值给ip call和ret联合使用的作用其实就是高级语言中的函数调用 实践，考虑以下几种情况 有无参数 有无返回值 现场保护 局部变量 堆栈平衡 附录工具使用-dosboxAlt+Enter //切换全屏Alt+Pause //暂停模拟Ctrl+F1 //改变键盘映射Ctrl+Alt+F5 //开始/停止录制视频Ctrl+F4 //交换挂载的磁盘映像，也就是更新磁盘文件Ctrl+F5 //截图Ctrl+F6 //开始/停止录制声音Ctrl+F7 //减少跳帧Ctrl+F8 //增加跳帧Ctrl+F9 //关闭DOSBOXCtrl+F10 //捕捉/释放鼠标Ctrl+F11 //模拟减速Ctrl+F12 //加速模拟Alt+F12 //不锁定速度 debug命令 Debug是DOS、Windows 都提供的实模式(8086方式)程序的调试工具。使用它，可以查看CPU各种寄存器中的内容、内存的情况和在机器码级跟踪程序的运行。 debug常用功能 用Debug的R命令查看、改变CPU寄存器的内容; 用Debug的D命令查看内存中的内容; 用Debug的E命令改写内存中的内容; 用Debug的U命令将内存中的机器指令翻译成汇编指令;. 用Debug的T命令执行一条机器指令; 用Debug的A命令以汇编指令的格式在内存中写入一条机器指令。 “q”命令: :退出debug “p”命令:类似于step over (“t”命令类似于step into) ，可用于跳过loop循环 “g”命令:跳过前面的代码，停留到指定的代码位置 附录图形化开发工具-emu8086-v4.05快捷键 F5：调试运行 F4：重新加载 F8：下一步（单步执行） F9：直接一步到位运行整个程序 Ctrl + F8：跳过前面代码，断点到单击选中的代码那行注意：emu8086的语法检查并非100%严格（比较严谨的还是使用MASM进行编译） 汇编程序步骤 使用汇编语言编写一个完整的程序，步骤大致如下 编写源代码，文件名拓展名为.asm 编译、链接（可以使用微软的MASM编译器） 调试、运行 语言组成 源程序与可执行程序 调试可执行程序 伪指令 – segment、ends、end 退出程序 中断 中断是由于软件的或硬件的信号，使得CPU暂停当前的任务，转而去执行另一段子程序。也就是说，在程序运行过程中，系统出现了一个必须由CPU立即处理的情况，此时，CPU暂时中止当前程序的执行转而处理这个新情况的过程就叫做中断 中断的分类 硬中断（外中断），由外部设备(比如网卡、硬盘)随机引发的，比如当网卡收到数据包的时候，就会发出一个中断 软中断（内中断），由执行中断指令产生的，可以通过程序控制触发 软中断 可以通过指令int n产生中断 n是中断码，内存中有一张中断向量表，用来存放中断码对应中断处理程序的入口地址。CPU在接收到中断信号后，暂停当前正在执行的程序，跳转到中断码对应的中断向量表地址处，去执行中断处理程序 常见中断 int 10h用于执行BIOS中断 int 3是“断点中断”，用于调试程序 int 21h用于执行DOS系统功能调用，AH寄存器存储功能号 其它中断码请参考如下附件: DOS系统功能调用 DOS系统功能调用表(int 21h) BIOS-DOS中断功能调用大全 完整汇编程序示例 dw（define word）使用dw定义字型数据，数据之间用逗号隔开,类似的还有db（define byte）、dd（define double word） start 和 end start是对应的，end start标记程序的执行入口 使用int 21h显示的字符串必须要以$结尾,字符串可以用双引号或者单引号括住 assume cs:code,ds:data ;关联代码段和数据段 ;data段开始 data segment db 'hello world!$' data ends ;code段开始 code segment start: ;代码开始标志 mov ax,data mov ds,ax mov ah,9h ;屏幕显示模块功能号 mov dx,0h ;指向data段第一个字节 int 21h ;dos系统功能调用中断， mov al,4ch ;退出模块功能号 int 21h ;dos系统功能调用中断， code ends end start ;代码结束标志 给数据段字节数据定义变量名 assume cs:code,ds:data data segment age db 52h msg db 'hello world!$' data ends code segment start: ;代码开始标志 mov ax,data mov ds,ax mov ah,9h ;屏幕显示模块功能号 mov dx,offset msg ;偏移到data段字符'h'上一个字节 int 21h ;dos系统功能调用中断， mov ah,4ch ;退出模块功能号 int 21h ;dos系统功能调用中断， code ends end start ;代码结束标志 指令处理数据长度 8086指令能处理2种尺寸的数据：byte、word mov byte ptr [0], 20H 将20H放入0位置内存的字节单元，占用1个字节 mov word ptr [0], 20H 将20H放入0位置内存的字单元，占用2个字节 很多指令都可以通过“byte ptr”或者“word ptr”来指明所需要操作内存的数据长度 inc byte ptr [0] add word ptr [0], 2 有些指令有默认的操作数据长度，比如push [0]、pop [0]的操作数据长度只能是2个字节","link":"/2020/11/01/%E6%B1%87%E7%BC%96/review-%E6%B1%87%E7%BC%96/"},{"title":"浅谈辅助","text":"可执行文件的格式PE Windows平台 (比如exe文件)ELF Linux平台、Android平台Mach-o Mac、 ios平台","link":"/2020/12/01/%E6%B1%87%E7%BC%96/%E6%B5%85%E8%B0%88%E8%BE%85%E5%8A%A9/"},{"title":"高中物理公式大全","text":"物理公式纪念","link":"/2012/09/09/%E7%89%A9%E7%90%86/%E9%AB%98%E4%B8%AD%E7%89%A9%E7%90%86%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8-2012-09-09/"},{"title":"","text":"title:英语技巧 英语听力技巧总结 英语动漫学习地址：学习电影动漫练习","link":"/2017/09/17/%E8%8B%B1%E8%AF%AD%E5%A4%A9%E5%9C%B0/english/"},{"title":"音标总结","text":"美式音标对照 a [æ] b [b] c [k] d [d] e [ε] aa –&gt; 暗暗，bb –&gt; 不不(土话)，cc –&gt; kk,dd–&gt;dede, ee –&gt; an an（短），ff –&gt; ff,gg –&gt; gg,hh–&gt;hh,ii –&gt;yi yi jj –&gt; ju ju, kk –&gt; kk, ll–&gt;le le(靠单词位置前发 le le), ll –&gt; ao ao(靠单词位置尾发 ao ao) mm –&gt; me me(靠单词位置前发 me(么) me（么）)， mm –&gt; mu mu(靠单词位置前尾 mu mu) nn –&gt; ne ne(靠单词位置前发 ne ne), nn–&gt; eng eng(靠单词位置尾发 eng eng(鼻子发音)) oo –&gt; 啊！啊！， pp –&gt; pp, qq–&gt;kuo kuo, rr –&gt; 入入(土话的音)（靠单词位置前发 入入），rr –&gt; er er(靠单词位置尾发) ss –&gt; si si, tt –&gt;te te, uu–&gt;a a, vv–&gt;wu wu(短促)， ww–&gt;呜呜， xx–&gt;ks ks yy –&gt; ye ye, zz –&gt; ri ri 规则一除了 5个 母音字母音标 a,e,i,o,u可能有变，其他子音音标不变，基本对应示例：cat |kæt| , desk |dεsk| 五个母音重音节 选择音标不是重音节 选择音标 a[e] [æ][ə] e[i] [ε] [ə] i[ai] [I] [ə] o[o] [ɑ] [ɔ] [ʌ][ə] u[ju] [ʌ][ə] 示例重音节(第一个o) 与非重音节(最后的o)的音标 doctor [ˈdɑ:ktə(r)] , mister[‘mɪstər] 规则二 单音节的字，末尾的母音字母不发音，前面的母音字母发他本身的音示例 name [nem] ，ride[raid],came[kem],take[tek] ,home[hom],fine[fain] 规则三ar,er,ir,or,ur 重音节发音与非重音节发音 五个母音+r重音节(单词第一个碰到) 选择音标不是重音节(尾巴) 选择音标 ar[ar] [ə(r)] [ɚ] er[ɜr] [ə(r)] [ɚ] ir[ɜr] [ə(r)] [ɚ] or[ɜr] [or] [ɔr][ə(r)] [ɚ] ur[ɜr][ə(r)] [ɚ] 示例：work [wɜ:rk], bird[bɜ:rd], her [hɚr], worker[ˈwɜ:rkə(r)] 规则四oo常常发[ʊ] [u]音book [bʊk], foot[fʊt], room [rʊm] 规则五au,ou,aw,ow连在一起常常发 [aʊ]音house [haʊs], hour[aʊr] 规则六th[θ][ð],ch[tʃ],sh[ʃ],ph[f],ng[ŋ] [ŋg], nk[ŋk]thank [θæŋk] ,chair[tʃer],this[ðɪs]","link":"/2017/09/09/%E8%8B%B1%E8%AF%AD%E5%A4%A9%E5%9C%B0/%E8%8B%B1%E8%AF%AD%E5%8F%91%E9%9F%B3--%E9%9F%B3%E6%A0%87/"},{"title":"规则引擎Drools","text":"","link":"/2015/08/15/%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E/%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E-01/"},{"title":"JAVA设计模式分类","text":"JAVA设计模式分类 创建型模式单例模式单例模式不同实现方法 性能测试示例 10个线程，每个线程获取100万次 import java.util.concurrent.CountDownLatch; public class Client3 { public static void main(String[] args) throws Exception { long start = System.currentTimeMillis(); int threadnum = 10; final CountDownLatch countdownlatch = new CountDownLatch(threadnum); for (int i = 0; i &lt; threadnum; i++) { new Thread(new Runnable() { public void run() { for (int j = 0; j &lt; 100_0000; j++) { Object o = SingleTen.getInstance(); } countdownlatch.countDown(); } }).start(); } countdownlatch.await();// main线程阻塞,直到计数器变为0,才会继续往下执行 long end = System.currentTimeMillis(); System.out.println(&quot;总耗时:&quot; + (end - start)); } } 工厂模式 建造者模式 原型模式 结构型模式适配器模式 桥接模式 组合模式 外观模式 享元模式(FlyWeight) 代理模式 静态代理 动态代理 装饰模式 结构型模式汇总 行为型模式行为型模式汇总 状态模式state 责任链模式 迭代器模式 中介者模式(Mediator) 命令模式 解释器模式 访问者模式 策略模式 模板方法模式 观察者模式 备忘录模式","link":"/2015/10/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/JAVA-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%86%E7%B1%BB/"},{"title":"UML建模","text":"UML定义 UML又称统一建模语言或标准建模语言，是始于1997年一个OMG标准，它是一个支持模型化和软件系统开发的图形化语言，为软件开发的所有阶段提供模型化和可视化支持，包括由需求分析到规格，到构造和配置。 建模的必要性模型是什么？简单地说：模型是对现实的简化 模型提供了系统的蓝图。模型既可以包括详细的计划，也可以包括从很高的层次考虑系统的总体计划。一个好的模型包括那些有广泛影响的主要元素，而忽略那些与给定的抽象水平不相关的次要元素。每个系统都可以从不同的方面用不同的模型来描述，因而每个模型都是一个在语义上闭合的系统抽象。模型可以是结构性的，强调系统的组织。它也可以是行为性的，强调系统的动态方面。 为什么要建模？一个基本理由是：建模是为了能够更好地理解正在开发的系统 通过建模，要达到4个目的： （1）模型有助于按照实际情况或按照所需要的样式对系统进行可视化。 （2）模型能够规约系统的结构或行为。 （3）模型给出了指导构造系统的模板。 （4）模型对做出的决策进行文档化。 UML使用的必要性 UML就是要解决建模的描述问题。因为大家使用的表示或记录方法不一样，就会导致理解上的偏差和协作上的困难，所以就建立UML这样一个标准，大家共同来遵守，这样大大降低了沟通成本和维护成本。 UML特点1、统一的标准 2、面向对象。UML是支持面向对象软件开发的建模语言。 3、可视化、表现能力强 4、独立于过程，UML不依赖于特定的软件开发过程。 5、概念明确，建模表示法简洁，图形结构清晰，容易掌握和使用。 UML分类UML有很多种图，大体可以分为两类： 结构型的图（Structure Diagram） 类图（Class Diagram） 对象图（Object Diagram） 构件图（Component Diagram） 部署图（Deployment Diagram） 包图（Package Diagram） 行为型的图（Behavior Diagram） 活动图（Activity Diagram） 状态机图（State Machine Diagram） 顺序图（Sequence Diagram） 通信图（Communication Diagram） 用例图（Use Case Diagram） 时序图（Timing Diagram）","link":"/2018/02/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/uml/"},{"title":"代理模式","text":"代理设计模式 动态代理在Java中有着广泛的应用，比如Spring AOP、Hibernate数据查询、测试框架的后端mock、RPC远程调用、Java注解对象获取、日志、用户鉴权、全局性异常处理、性能监控，甚至事务处理等。代理模式一般涉及到的角色有 抽象角色：声明真实对象和代理对象的共同接口 代理角色：代理对象角色内部含有对真实对象的引用，从而可以操作真实对象，同时代理对象提供与真实对象相同的接口以便在任何时刻都能代替真实对象。同时，代理对象可以在执行真实对象操作时，附加其他的操作，相当于对真实对象进行封装 真实角色：代理角色所代表的真实对象，是我们最终要引用的对象 代理模式分类按照职责分类 **虚代理:**根据需要来创建开销很大的对象，该对象只有在需要的时候才会被真正创建 **远程代理:**用来在不同的地址空间上代表同一一个对象，这个不同的地址空间可以是在本机， 也可以在其它机器上，在Java里面最典型的就是RMI技术 copy-on-write代理: 在客户端操作的时候，只有对象确实改变了，才会真的拷贝(或克隆)一个目标对象，算是虚代理的一个分支 **保护代理:**控制对原始对象的访问，如果有需要，可以给不同的用户提供不同的访问权，限，以控制他们对原始对象的访问 **Cache代理:**为那些昂贵的操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果 **防火墙代理:**保护对象不被恶意用户访问和操作 **同步代理:**使多个用户能够同时访问目标对象而没有冲突 **智能指引:**在访问对象时执行一些附加操作，比如:对指向实际对象的引用计数、第一次引用一个持久对象时，将它装入内存等在这些代理类型中。最常见的是:虚代理、保护代理、远程代理和智能指引这几种。虛代理和保护代理，在实际开发中使用频率最高的。按照字节码创建时机分类 静态代理 所谓静态也就是在程序运行前就已经存在代理类的字节码文件，代理类和真实主题角色的关系在运行前就确定了 动态代理 而动态代理的源码是在程序运行期间由JVM根据反射等机制动态的生成，所以在运行前并不存在代理类的字节码文件 静态代理例子静态代理代码示例： public interface Subject{ // 定义Subject接口 public String say(String name,int age) ; // 定义抽象方法say } public class RealSubject implements Subject{ // 真实实现类 public String say(String name, int age) { // 覆写say()方法 return &quot;姓名：&quot; + name + &quot;，年龄：&quot; + age; // 返回信息 } } //代理角色 public class ProxySubject implements Subject { private RealSubject realSubject; // 以真实角色作为代理角色的属性 public ProxySubject() { } private void preRequest() { System.out.println(&quot;代理前准备----&quot;); } private void postRequest() { System.out.println(&quot;代理后操作-----&quot;); } @Override public String say(String name, int age) { preRequest(); String tmp; if (realSubject == null) { realSubject = new RealSubject(); } tmp = realSubject.say(name, age); // 此处执行真实对象的request方法 postRequest(); return tmp; } } //客户端操作 public class Client { public static void main(String[] args) { Subject sub = new ProxySubject(); System.out.println(sub.say(&quot;songxm&quot;, 23)); } } 虽然静态代理实现简单，且不侵入原代码，但是，当场景稍微复杂一些的时候，静态代理的缺点也会暴露出来。1、 当需要代理多个类的时候，由于代理对象要实现与目标对象一致的接口，有两种方式：只维护一个代理类，由这个代理类实现多个接口，但是这样就导致代理类过于庞大新建多个代理类，每个目标对象对应一个代理类，但是这样会产生过多的代理类2、 当接口需要增加、删除、修改方法的时候，目标对象与代理类都要同时修改，不易维护。如何改进？当然是让代理类动态的生成啦，也就是动态代理。 动态代理通过类加载机制实现类的动态加载创建，可以参看 Java的类加载机制与反射机制 Blog，了解JVM类加载的过程以及获取二进制字节码方式。运行时计算生成，这种场景使用最多的是动态代理技术，在 java.lang.reflect.Proxy 类中，就是用了 ProxyGenerator.generateProxyClass 来为特定接口生成形式为 *$Proxy 的代理类的二进制字节流 常见的字节码操作类库 Apache BCEL (Byte Code Engineering Library)：是Java classworking广泛使用的一种框架，它可以深入到JVM汇编语言进行类操作的细节。 ObjectWeb ASM：是一个Java字节码操作框架。它可以用于直接以二进制形式动态生成stub根类或其他代理类，或者在加载时动态修改类。 CGLIB(Code Generation Library)：是一个功能强大，高性能和高质量的代码生成库，用于扩展JAVA类并在运行时实现接口。 Javassist：是Java的加载时反射系统，它是一个用于在Java中编辑字节码的类库; 它使Java程序能够在运行时定义新类，并在JVM加载之前修改类文件。 JDK方式实现动态代理 JDK动态代理主要涉及两个类：java.lang.reflect.Proxy 和 java.lang.reflect.InvocationHandler//代理中的抽象角色 public interface IUserDao { void save(); boolean delete(); } //代理中的真实角色 public class UserDaoImpl implements IUserDao { @Override public void save() { System.out.println(&quot;----已经保存数据!----&quot;); } @Override public boolean delete() { return true; } } ```javaimport java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;/** 创建动态代理对象 动态代理不需要实现接口,但是需要指定接口类型 */public class ProxyFactory{ //维护一个目标对象 private Object target; public ProxyFactory(Object target){ this.target=target; }//给目标对象生成代理对象 public Object getProxyInstance(){ return Proxy.newProxyInstance( target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(“[log] “+System.currentTimeMillis()+”开始事务”); //运用反射执行目标对象方法 Object returnValue = method.invoke(target, args); System.out.println(“[log] “+System.currentTimeMillis()+”截取真实角色方法的返回值:” + returnValue); System.out.println(“[log] “+System.currentTimeMillis()+”提交事务”); return returnValue; } } ); } } ```java public class Client { public static void main(String[] args) { // 目标对象 IUserDao target = new UserDaoImpl(); // 【原始的类型 class cn.itcast.b_dynamic.UserDao】 System.out.println(target.getClass()); // 给目标对象，创建代理对象 IUserDao proxy = (IUserDao) new ProxyFactory(target).getProxyInstance(); // class $Proxy0 内存中动态生成的代理对象 System.out.println(proxy.getClass()); // 执行方法 【代理对象】 proxy.save(); proxy.delete(); } } 输出结果 class com.ecit.UserDaoImpl class com.sun.proxy.$Proxy0 [log] 1592302642751开始事务 ----已经保存数据!---- [log] 1592302642751 截取真实角色方法的返回值:null [log] 1592302642751 提交事务 [log] 1592302642751 开始事务 [log] 1592302642752 截取真实角色方法的返回值:true [log] 1592302642752 提交事务 代理类的动态生成的真实实例import sun.misc.ProxyGenerator;; import java.io.FileOutputStream; import java.io.IOException; class ProxyUtils { /** * 将根据类信息动态生成的二进制字节码保存到硬盘中，默认的是clazz目录下 * params: clazz 需要生成动态代理类的类 * proxyName: 为动态生成的代理类的名称 */ public static void generateClassFile(Class clazz, String proxyName) { // 根据类信息和提供的代理类名称，生成字节码 byte[] classFile = ProxyGenerator.generateProxyClass(proxyName, clazz.getInterfaces()); String paths = clazz.getResource(&quot;.&quot;).getPath(); System.out.println(paths); FileOutputStream out = null; try { //保留到硬盘中 out = new FileOutputStream(paths + proxyName + &quot;.class&quot;); out.write(classFile); out.flush(); } catch (Exception e) { e.printStackTrace(); } finally { try { out.close(); } catch (IOException e) { e.printStackTrace(); } } } } public class Client2 { public static void main(String[] args) { // 目标对象 IUserDao target = new UserDaoImpl(); // 【原始的类型 class cn.itcast.b_dynamic.UserDao】 System.out.println(target.getClass()); // 给目标对象，创建代理对象 IUserDao proxy = (IUserDao) new ProxyFactory(target).getProxyInstance(); // class $Proxy0 内存中动态生成的代理对象 System.out.println(proxy.getClass()); // 执行方法 【代理对象】 proxy.save(); proxy.delete(); ProxyUtils.generateClassFile(target.getClass(), &quot;UserDaoProxy&quot;); } } CGLIB动态代理maven引入CGLIB包 &lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/dependency&gt; public class ProxyFactory implements MethodInterceptor { //维护目标对象 private Object target; public ProxyFactory(Object target) { this.target = target; } //给目标对象创建一个代理对象 public Object getProxyInstance(){ //1.工具类 Enhancer en = new Enhancer(); //2.设置父类 en.setSuperclass(target.getClass()); //3.设置回调函数 en.setCallback(this); //4.创建子类(代理对象) return en.create(); } @Override public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable { System.out.println(&quot;[log] start exec&quot;); //执行目标对象的方法 Object returnValue = method.invoke(target, args); System.out.println(&quot;[log] end exec&quot;); return returnValue; } } public class Client { public static void main(String[] args) { // 目标对象 UserDaoImpl target = new UserDaoImpl(); // 给目标对象，创建代理对象 UserDaoImpl proxy = (UserDaoImpl) new ProxyFactory(target).getProxyInstance(); // 执行方法 【代理对象】 proxy.save(); } } // 输出结果: // [log] start exec // ----已经保存数据!---- // [log] end exec 如果加入容器的目标对象有实现接口,用JDK代理 如果目标对象没有实现接口,用Cglib代理 JDK动态代理和CGLIB代理对比 JDK 动态代理： 为了解决静态代理中，生成大量的代理类造成的冗余； JDK 动态代理只需要实现 InvocationHandler 接口，重写 invoke 方法便可以完成代理的实现， jdk的代理是利用反射生成代理类 Proxyxx.class 代理类字节码，并生成对象 jdk动态代理之所以只能代理接口是因为代理类本身已经extends了Proxy，而java是不允许多重继承的，但是允许实现多个接口优点：解决了静态代理中冗余的代理实现类问题。缺点：JDK 动态代理是基于接口设计实现的，如果没有接口，会抛异常。 CGLIB 代理： 由于 JDK 动态代理限制了只能基于接口设计，而对于没有接口的情况，JDK方式解决不了； CGLib 采用了非常底层的字节码技术，其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑，来完成动态代理的实现。 实现方式实现 MethodInterceptor 接口，重写 intercept 方法，通过 Enhancer 类的回调方法来实现。 但是CGLib在创建代理对象时所花费的时间却比JDK多得多，所以对于单例的对象，因为无需频繁创建对象，用CGLib合适，反之，使用JDK方式要更为合适一些。 同时，由于CGLib由于是采用动态创建子类的方法，对于final方法，无法进行代理。优点：没有接口也能实现动态代理，而且采用字节码增强技术，性能也不错。缺点：技术实现相对难理解些。 Spring中Aop代理选择方式 Spring中强制使用Cglib代理&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot; /&gt; SpringBoot中强制使用Cglib代理@SpringBootApplication //强制使用cglib代理 @EnableAspectJAutoProxy( proxyTargetClass = true) public class AopDemoApplication { public static void main(String[] args) { SpringApplication.run(AopDemoApplication.class, args); } } 代理模式 VS 适配器模式代理模式，即Proxy，它和Adapter模式很类似。我们先回顾Adapter模式，它用于把A接口转换为B接口： public BAdapter implements B { private A a; public BAdapter(A a) { this.a = a; } public void b() { a.a(); } } 而Proxy模式不是把A接口转换成B接口，它还是转换成A接口： public AProxy implements A { private A a; public AProxy(A a) { this.a = a; } public void a() { this.a.a(); } }","link":"/2015/07/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-up1/"},{"title":"单例设计模式探究","text":"单例设计模式深入探讨单例模式介绍 单例模式有饿汉式和懒汉式之分，懒汉式即延迟初始化单例。在多线程环境下，简单的懒汉式会有线程安全之困扰。 使用场景： 要求生产唯一序列号。 WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。 创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。 实现懒汉式单例模式探究 使用双重检查加锁机制解决线程安全问题。 单例模式还有更好的解决方案，即使用静态类方式 懒汉式单例模式代码在单线程运行安全public class SingleTen { private static SingleTen singleTen; private SingleTen() { System.out.println(&quot;懒汉式单例模式 初始化...&quot;); } public static SingleTen getInstance() { if(singleTen==null){ singleTen = new SingleTen(); } return singleTen; } public static void main(String[] args) { SingleTen.getInstance(); SingleTen.getInstance(); SingleTen.getInstance(); } } //输出结果： 懒汉式单例模式 初始化... 懒汉式单例模式代码在多线程运行不安全现象出现class SThread implements Runnable{ @Override public void run() { SingleTen.getInstance(); } } public class SingleTen { private static SingleTen singleTen; private SingleTen() { System.out.println(&quot;懒汉式单例模式 初始化...&quot;); } public static SingleTen getInstance() { if (singleTen == null) { singleTen = new SingleTen(); } return singleTen; } public static void main(String[] args) throws InterruptedException { SThread t1 = new SThread(); SThread t2 = new SThread(); SThread t3 = new SThread(); new Thread(t1).start(); // Thread.sleep(5_100l); new Thread(t2).start(); new Thread(t3).start(); } } //输出结果 不只是被创建了一次，故而不安全一览无余： 懒汉式单例模式 初始化... 懒汉式单例模式 初始化... 懒汉式单例模式 初始化... 懒汉式单例模式代码在多线程运行不安全 加锁解决public class SingleTen { private static SingleTen singleTen; private SingleTen() { System.out.println(&quot;懒汉式单例模式 初始化...&quot;); } public static SingleTen getInstance() { //在此同步代码块加锁解决了 ，安全隐患 synchronized (SingleTen.class) { if (singleTen == null) { singleTen = new SingleTen(); } } return singleTen; } public static void main(String[] args) throws InterruptedException { SThread t1 = new SThread(); SThread t2 = new SThread(); SThread t3 = new SThread(); new Thread(t1).start(); // Thread.sleep(5_100l); new Thread(t2).start(); new Thread(t3).start(); } } //输出结果: 懒汉式单例模式 初始化... 懒汉式单例模式代码在多线程运行不安全 加锁解决 性能优化(开发常用) 虽然加锁解决了懒汉式单例在多线程模式下的安全隐患，但是性能不是最佳的，每次都要加锁，现在优化为只要在第一次加锁，其余不加锁，则性能提升。代码示例如下： public class SingleTon { private volatile static SingleTon singleTon; //volatile使用避免 JIT编译汇编语句重排 private SingleTon() { System.out.println(&quot;懒汉式单例模式 初始化...&quot;); } public static SingleTon getInstance() { //这里优化，看上去就是双重检查加锁 解决多线程下懒汉式单例模式的线程安全问题 if (singleTon == null) { synchronized (SingleTon.class) { if (singleTon == null) { singleTon = new SingleTon(); } } } return singleTon; } public static void main(String[] args) throws InterruptedException { SThread t1 = new SThread(); SThread t2 = new SThread(); SThread t3 = new SThread(); new Thread(t1).start(); // Thread.sleep(5_100l); new Thread(t2).start(); new Thread(t3).start(); } } 饿汉式模式实现(开发常用) 类加载到内存后，就实例化一个单例，jvm保证线程安全，简单实用，推荐使用，唯一缺点，不管用到与否，类装载时就完成实例化 public class SingleTon { private static final SingleTon INSTANCE = new SingleTon(); private SingleTon() {}; public static SingleTon getInstance(){ return INSTANCE; } public void otherBusiness(){ System.out.println(&quot;process other thing...&quot;); } public static void main(String[] args) { SingleTon singleTon1 = SingleTon.getInstance(); SingleTon singleTon2 = SingleTon.getInstance(); System.out.println(singleTon1==singleTon2); } } public class SingleTon { private static final SingleTon INSTANCE ; static { INSTANCE = new SingleTon(); } private SingleTon() {}; public static SingleTon getInstance(){ return INSTANCE; } public void otherBusiness(){ System.out.println(&quot;process other thing...&quot;); } public static void main(String[] args) { SingleTon singleTon1 = SingleTon.getInstance(); SingleTon singleTon2 = SingleTon.getInstance(); System.out.println(singleTon1==singleTon2); } } 静态内部类实现方式，实现懒加载效果(开发常用) JVM保证单例，加载外部类时不会加载内部类，这样可以实现懒加载效果 public class SingleTon { private SingleTon(){}; private static class SingletonHolder{ private static final SingleTon INSTANCE = new SingleTon(); } public static SingleTon getInstance(){ return SingletonHolder.INSTANCE; } public void otherBusiness(){ System.out.println(&quot;process other thing...&quot;); } public static void main(String[] args) { SingleTon singleTon1 = SingleTon.getInstance(); SingleTon singleTon2 = SingleTon.getInstance(); System.out.println(singleTon1==singleTon2); } } 枚举方式实现（Effective Java推荐开发使用） 枚举方式不仅可以解决线程同步，还可以防止反序列化 public enum SingleTon { INSTANCE; public void otherBusiness(){ System.out.println(&quot;process other thing...&quot;); } }","link":"/2015/07/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%8E%A2%E7%A9%B6-2015-11-11/"},{"title":"原型模式-浅克隆与深克隆","text":"原型模式 Prototype模式是一种对象创建型模式，它采取复制原型对象的方法来创建对象的实例。使用Prototype模式创建的实例，具有与原型一样的数据。 原型模式的特点 由原型对象自身创建目标对象。也就是说，对象创建这一动作发自原型对象本身。2.目标对象是原型对象的一个克隆。也就是说，通过Prototype模式创建的对象，不仅仅与原型对象具有相同的结构，还与原型对象具有相同的值。3.根据对象克隆深度层次的不同，有浅度克隆与深度克隆。 原型模式应用场景 在创建对象的时候，我们不只是希望被创建的对象继承其基类的基本结构，还希望继承原型对象的数据。 希望对目标对象的修改不影响既有的原型对象（深度克隆的时候可以完全互不影响）。 隐藏克隆操作的细节。很多时候，对对象本身的克隆需要涉及到类本身的数据细节。 浅克隆只是可以把对象的基本类型属性复制一份，深克隆可以把引用类型属性复制一份，不是简单的引用赋值 代码示例：import java.util.ArrayList; import java.util.List; public class Person implements Cloneable{ //克隆必须实现的接口标识 private String name; private int age; private String sex; private List&lt;String&gt; friends;//引用类型 public List&lt;String&gt; getFriends() { return friends; } public void setFriends(List&lt;String&gt; friends) { this.friends = friends; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getSex() { return sex; } public void setSex(String sex) { this.sex = sex; } public Person clone() { try { Person person = (Person)super.clone();//基本类型可以直接复制 List&lt;String&gt; newfriends = new ArrayList&lt;String&gt;();//引用类型就得注意处理一下了 for(String friend : this.getFriends()) { newfriends.add(friend); } person.setFriends(newfriends); return person; } catch (CloneNotSupportedException e) { e.printStackTrace(); return null; } } }","link":"/2015/10/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F(%E6%B5%85%E5%85%8B%E9%9A%86%E4%B8%8E%E6%B7%B1%E5%85%8B%E9%9A%86)/"},{"title":"命令模式","text":"命令模式 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化;对请求排队或记录请求日志，以及支持可撤销的操作。 Command:定义命令的接口，声明执行的方法。 ConcreteCommand:命令接口实现对象，是“虚”的实现;通常会持有接收者，并调用接收者的功能来完成命令要执行的操作。 Receiver: 接收者，真正执行命令的对象。任何类都可能成为一个接收者，只要它能够实现命令要求实现的相应功能。 Invoker: 要求命令对象执行请求，通常会持有命令对象，可以持有很多的命令对象。这个是客户端真正触发命令并要求命令执行相应操作的地方，也就是说相当于使用命令对象的入口。 Client:创建具体的命令对象，并且设置命令对象的接收者。注意这个不是我们常规意义上的客户端，而是在组装命令对象和接收者，或许，把这个Client称为装 配者会更好理解，因为真正使用命令的客户端是从Invoker来触发执行。 命令模式调用图 命令模式使用 队列请求 所谓队列请求，就是对命令对象进行排队，组成工作队列，然后依次取出命令对象来执行。多用多线程或者线程池来进行命令队列的处理，当然也可以不用多线程，就是一个线程，一个命令一个命令的循环处理，就是慢点。 日志请求 所谓日志请求，就是把请求的历史记录保存下来，一般是采用永久存储的方式。如果运行请求的过程中，系统崩溃了，那么在系统再次运行时，就可以从保存的历史记录里面获取日志请求，并重新执行命令。日志请求的实现有两种方案，一种就是直接使用Java中的序列化方法，另 外一种就是在命令对象里面添加上存储和装载的方法，其实就是让命令对象自己 实现类似序列化的功能。当然要简单就直接使用Java中的序列化 。 命令模式优缺点命令模式的优缺点 1:更松散的耦合 2:更动态的控制 3:能很自然的复合命令 4:更好的扩展性 思考 命令模式的本质 命令模式的本质是:封装请求 n 何时选用命令模式 1:如果需要抽象出需要执行的动作，并参数化这些对象，可以选用命令模式，把这 些需要执行的动作抽象成为命令，然后实现命令的参数化配置 2:如果需要在不同的时刻指定、排列和执行请求，可以选用命令模式，把这些请求 封装成为命令对象，然后实现把请求队列化 3:如果需要支持取消操作，可以选用命令模式，通过管理命令对象，能很容易的实 现命令的恢复和重做的功能 4:如果需要支持当系统崩溃时，能把对系统的操作功能重新执行一遍，可以选用命 令模式，把这些操作功能的请求封装成命令对象，然后实现日志命令，就可以在 系统恢复回来后，通过日志获取命令列表，从而重新执行一遍功能 5:在需要事务的系统中，可以选用命令模式，命令模式提供了对事务进行建模的方 法，命令模式有一个别名就是Transaction。","link":"/2015/11/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"},{"title":"外观模式","text":"外观模式定义 体会外观模式 外观模式问题解决 理解外观模式 外观模式本质–思考 外观模式示例 代码示例package com.enjoy.structure.facade; /** * 客户服务一条龙 */ public class CustomerClient { public static void main(String[] args){ doOrderFacade(); } public static void doOrder(){ PickService pickService = new PickService(); PackService packService = new PackService(); SendService sendService = new SendService(); //采摘 System.out.println(&quot;--------------&quot;); pickService.doPick(); //包装 System.out.println(&quot;--------------&quot;); packService.doPack(); //快递 System.out.println(&quot;--------------&quot;); sendService.doSend(); } public static void doOrderFacade(){ OrderFacade orderFacade = new OrderFacade(); orderFacade.doOrder(); } } /** * 客户服务一条龙 */ public class OrderFacade { private PickService pickService; private PackService packService; private SendService sendService; public OrderFacade(){ pickService = new PickService(); packService = new PackService(); sendService = new SendService(); } /** * 客户订单处理类 */ public void doOrder(){ //采摘 System.out.println(&quot;--------------&quot;); pickService.doPick(); //包装 System.out.println(&quot;--------------&quot;); packService.doPack(); //快递 System.out.println(&quot;--------------&quot;); sendService.doSend(); } } package com.enjoy.structure.facade; import com.enjoy.create.fatory.abstractFactory.AbstractFactory; import com.enjoy.create.fatory.abstractFactory.AppleFactory; import com.enjoy.entity.Bag; import com.enjoy.structure.decorator.CheckedBagDecorator; import com.enjoy.structure.decorator.ReinforceBagDecorator; import com.enjoy.structure.decorator.SpeedDecorator; /** * 包装服务 */ public class PackService { /** * 水果打包：防伪/加固/加急等 */ public void doPack(){ AbstractFactory factory = new AppleFactory(); //得到包装 Bag bag = factory.getBag(); //现需要增加防伪标识 bag = new CheckedBagDecorator(bag);//防伪功能 bag = new ReinforceBagDecorator(bag);//加固功能 bag = new SpeedDecorator(bag);//加急功能 bag.pack(); } public void doOther(){ System.out.println(&quot;其它服务&quot;); } } import com.enjoy.structure.bridge.bag.BagAbstraction; import com.enjoy.structure.bridge.bag.SmallBag; import com.enjoy.structure.bridge.material.Material; import com.enjoy.structure.bridge.material.Paper; /** * 采摘服务 */ public class PickService { /** * 采摘水果 */ public void doPick(){ //袋子型号 BagAbstraction pickBag = new SmallBag(); //袋子材质 Material material = new Paper(); pickBag.setMaterial(material); //开始采摘 pickBag.pick(); } public void doOther(){ System.out.println(&quot;其它服务&quot;); } } import com.alibaba.fastjson.JSON; import com.enjoy.structure.composite.DistrictNode; import com.enjoy.structure.composite.LeafNode; /** * 快递服务 */ public class SendService { /** * 指定目的地，发送快递 */ public void doSend(){ //根目录 DistrictNode root = new DistrictNode(&quot;根&quot;); //一线目录 root.addChild(new DistrictNode(&quot;上海&quot;)); root.addChild(new DistrictNode(&quot;天津&quot;)); DistrictNode districtNode = new DistrictNode(&quot;北京&quot;); root.addChild(districtNode); //二级目录 districtNode.addChild(new DistrictNode(&quot;海淀区&quot;)); districtNode.addChild(new DistrictNode(&quot;西城区&quot;)); DistrictNode districtNode2 = new DistrictNode(&quot;朝阳区&quot;); districtNode.addChild(districtNode2); //三级目录 districtNode2.addChild(new LeafNode(&quot;三里屯&quot;)); districtNode2.addChild(new LeafNode(&quot;朝阳外街&quot;)); System.out.println(&quot;请选定目的地：&quot;+JSON.toJSON(root)); //以下物流运输业务。。。。 System.out.println(&quot;本次快递目的地：北京-朝阳区-三里屯&quot;); } public void doOther(){ System.out.println(&quot;其它服务&quot;); } }","link":"/2015/10/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%96%E8%A7%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"title":"工厂方法模式","text":"工厂方法模式 工厂方法模式同样属于类的创建型模式又被称为多态工厂模式 。工厂方法模式的意义是定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类当中。核心工厂类不再负责产品的创建，这样核心类成为一个抽象工厂角色，仅负责具体工厂子类必须实现的接口，这样进一步抽象化的好处是使得工厂方法模式可以使系统在不修改具体工厂角色的情况下引进新的产品。 模式中包含的角色及其职责 1.抽象工厂（Creator）角色工厂方法模式的核心，任何工厂类都必须实现这个接口。2.具体工厂（ Concrete Creator）角色具体工厂类是抽象工厂的一个实现，负责实例化产品对象。3.抽象（Product）角色工厂方法模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口。4.具体产品（Concrete Product）角色工厂方法模式所创建的具体实例对象 工厂方法模式和简单工厂模式比较 工厂方法模式与简单工厂模式在结构上的不同不是很明显。工厂方法类的核心是一个抽象工厂类，而简单工厂模式把核心放在一个具体类上。工厂方法模式之所以有一个别名叫多态性工厂模式是因为具体工厂类都有共同的接口，或者有共同的抽象父类。当系统扩展需要添加新的产品对象时，仅仅需要添加一个具体对象以及一个具体工厂对象，原有工厂对象不需要进行任何修改，也不需要修改客户端，很好的符合了“开放－封闭”原则。而简单工厂模式在添加新产品对象后不得不修改工厂方法，扩展性不好。工厂方法模式退化后可以演变成简单工厂模式 练习代码示例工厂抽象化 public interface FruitFactory { public Fruit getFruit(); } 具体工厂 public class AppleFactory implements FruitFactory { public Fruit getFruit() { return new Apple(); } } public class BananaFactory implements FruitFactory { public Fruit getFruit() { return new Banana(); } } public class PearFactory implements FruitFactory { public Fruit getFruit() { return new Pear(); } } 抽象（Product）角色 public interface Fruit { public void get(); } 具体产品（Concrete Product）角色 public class Apple implements Fruit{ public void get(){ System.out.println(&quot;采集苹果&quot;); } } public class Banana implements Fruit{ public void get(){ System.out.println(&quot;采集香蕉&quot;); } } public class Pear implements Fruit { public void get() { System.out.println(&quot;采集梨子&quot;); } } 工厂方法模式应用 java.util.Collection接口的iterator()方法： Java消息服务JMS(Java Messaging Service) //使用上下文和JNDI得到连接工厂的引用，ctx是上下文Context类型的对象 QueueConnectionFactory qConnFact=(QueueConnectionFactory)ctx.lookup(&quot;cfJndi&quot;); //使用连接工厂创建一个连接 QueueConnection qConn=qConnFact.createQueueConnection(); //使用连接创建一个会话 QueueSession qSess=qConn.createQueueSession(false,javax.jms.QueueSession. AUTO_ACKNOWLEDGE); //使用上下文和JNDI得到消息队列的引用 Queue q=(Queue)ctx.lookup(&quot;myQueue&quot;); //使用连接创建一个需要发送的消息类型的实例 QueueSender qSend=qSess.createSender(q); System.out.println(&quot;开始发送消息......&quot;); JDBC中的工厂方法 Connection conn=DriverManager.getConnection(&quot;jdbc:microsoft:sqlserver://localhost:1433; DatabaseName=DB;user=sa;password=&quot;); Statement statement=conn.createStatement(); ResultSet rs=statement.executeQuery(&quot;select * from UserInfo&quot;);","link":"/2015/10/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"},{"title":"建造者模式","text":"承上抽象工厂模式，建造者模式引出 建造者模式 Builder模式也叫建造者模式或者生成器模式，是由GoF提出的23种设计模式中的一种。Builder模式是一种对象创建型模式之一，用来隐藏复合对象的创建过程，它把复合对象的创建过程加以抽象，通过子类继承和重载的方式，动态地创建具有复合属性的对象。 建造者模式的结构 建造者模式应用场景 对象的创建：Builder模式是为对象的创建而设计的模式 创建的是一个复合对象：被创建的对象为一个具有复合属性的复合对象 关注对象创建的各部分的创建过程：不同的工厂（这里指builder生成器）对产品属性有不同的创建方法 建造者模式与工厂方法模式异同 代码示例：/** * 实际的指挥者 */ public class HouseDirector { public void makeHouse(HouseBuilder builder) { builder.makeFloor(); builder.makeWall(); builder.makeHousetop(); } } /* * 抽象的建造者 */ public interface HouseBuilder { //建楼层 public void makeFloor(); //建墙 public void makeWall(); //建房顶 public void makeHousetop(); public House getHouse(); } /** * 平房建造队 */ PingFangBuilder implements HouseBuilder { House house = new House(); public void makeFloor() { house.setFloor(&quot;平房--&gt;楼层&quot;); } public void makeHousetop() { house.setHousetop(&quot;平房--&gt;房顶&quot;); } public void makeWall() { house.setWall(&quot;平房--&gt;墙&quot;); } public House getHouse() { return house; } } /** * 公寓建造队 */ public class GongyuBuilder implements HouseBuilder{ House house = new House(); public House getHouse() { return house; } public void makeFloor() { house.setFloor(&quot;公寓--&gt;地板&quot;); } public void makeHousetop() { house.setHousetop(&quot;公寓--&gt;房顶&quot;); } public void makeWall() { house.setWall(&quot;公寓--&gt;墙&quot;); } } /* * 具体的对象 */ public class House { private String floor; private String wall; private String housetop; public String getFloor() { return floor; } public void setFloor(String floor) { this.floor = floor; } public String getWall() { return wall; } public void setWall(String wall) { this.wall = wall; } public String getHousetop() { return housetop; } public void setHousetop(String housetop) { this.housetop = housetop; } } public class MainClass { public static void main(String[] args) { // //客户直接造房子 // House house = new House(); // house.setFloor(&quot;地板&quot;); // house.setWall(&quot;墙&quot;); // house.setHousetop(&quot;屋顶&quot;); //由工程队来修 HouseBuilder builder = new GongyuBuilder(); //设计者来做 HouseDirector director = new HouseDirector(); director.makeHouse(builder); House house = builder.getHouse(); System.out.println(house.getFloor()); System.out.println(house.getWall()); System.out.println(house.getHousetop()); } } 工厂模式总结","link":"/2015/10/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"title":"抽象工厂模式","text":"抽象工厂模式 抽象工厂模式是所有形态的工厂模式中最为抽象和最其一般性的。抽象工厂模式可以向客户端提供一个接口，使得客户端在不必指定产品的具体类型的情况下，能够创建多个产品族的产品对象. ##抽象工厂模式背景引出 产品族和产品等级结构 模式中包含的角色及其职责1.抽象工厂（Creator）角色抽象工厂模式的核心，包含对多个产品结构的声明，任何工厂类都必须实现这个接口。 2.具体工厂（ Concrete Creator）角色具体工厂类是抽象工厂的一个实现，负责实例化某个产品族中的产品对象。 3.抽象（Product）角色抽象模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口。 4.具体产品（Concrete Product）角色抽象模式所创建的具体实例对象 总结：抽象工厂中方法对应产品结构，具体工厂对应产品族。 练习代码示例抽象工厂（Creator）角色示例： public interface FruitFactory { //获取苹果的产品 public Fruit getApple(); //获取香蕉的产品 public Fruit getBanana(); } 具体工厂（ Concrete Creator）角色示例： public class NorthFruitFactory implements FruitFactory { public Fruit getApple() { return new NorthApple(); } public Fruit getBanana() { return new NorthBanana(); } } public class SouthFruitFactory implements FruitFactory { public Fruit getApple() { return new SouthApple(); } public Fruit getBanana() { return new SouthBanana(); } } 抽象（Product）角色示例： public interface Fruit { public void get(); } public abstract class Apple implements Fruit{ public abstract void get(); } public abstract class Banana implements Fruit{ public abstract void get(); } 具体产品（Concrete Product）角色示例 public class NorthApple extends Apple { public void get() { System.out.println(&quot;采集到北方苹果&quot;); } } public class NorthBanana extends Banana { public void get() { System.out.println(&quot;采集到北方香蕉&quot;); } } public class SouthApple extends Apple { public void get() { System.out.println(&quot;采集到南方苹果&quot;); } } public class SouthBanana extends Banana { public void get() { System.out.println(&quot;采集到南方香蕉&quot;); } } 抽象工厂模式应用 Java SE AWT（抽象窗口工具包）在Java语言的AWT（抽象窗口工具包）中就使用了抽象工厂模式，它使用抽象工厂模式来实现在不同的操作系统中应用程序呈现与所在操作系统一致的外观界面","link":"/2015/10/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"title":"桥接模式","text":"桥接模式 桥接模式(Bridge Pattern)：将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体(Handle and Body)模式或接口(Interface)模式。重点需要理解如何将抽象化(Abstraction)与实现化(Implementation)脱耦，使得二者可以独立地变化。抽象化：抽象化就是忽略一些信息，把不同的实体当作同样的实体对待。在面向对象中，将对象的共同性质抽取出来形成类的过程即为抽象化的过程。实现化：针对抽象化给出的具体实现，就是实现化，抽象化与实现化是一对互逆的概念，实现化产生的对象比抽象化更具体，是对抽象化事物的进一步具体化的产物。脱耦：脱耦就是将抽象化和实现化之间的耦合解脱开，或者说是将它们之间的强关联改换成弱关联，将两个角色之间的继承关系改为关联关系。桥接模式中的所谓脱耦，就是指在一个软件系统的抽象化和实现化之间使用关联关系（组合或者聚合关系）而不是继承关系，从而使两者可以相对独立地变化，这就是桥接模式的用意。 代码示例package com.enjoy.structure.bridge; import com.enjoy.structure.bridge.bag.BagAbstraction; import com.enjoy.structure.bridge.bag.SmallBag; import com.enjoy.structure.bridge.material.Material; import com.enjoy.structure.bridge.material.Paper; /** * 园丁采摘水果 */ public class BridgeClient { public static void main(String[] args) { //袋子型号 BagAbstraction bag = new SmallBag(); //袋子材质 Material material = new Paper(); bag.setMaterial(material); //开始采摘 bag.pick(); } } package com.enjoy.structure.bridge.bag; import com.enjoy.structure.bridge.material.Material; /** * 采摘容器 */ public abstract class BagAbstraction { protected Material material; // protected Material material; public void setMaterial(Material material){ this.material = material; } //采摘 public abstract void pick(); } package com.enjoy.structure.bridge.bag; /** * 采摘大袋 */ public class BigBag extends BagAbstraction { public void pick(){ System.out.println(&quot;采摘水果开始&quot;); this.material.draw(); System.out.println(&quot;采摘了一大袋&quot;); } } /** * 采摘小袋 * Material */ public class SmallBag extends BagAbstraction { public void pick(){ System.out.println(&quot;采摘水果开始&quot;); this.material.draw(); System.out.println(&quot;采摘了一小包&quot;); } } package com.enjoy.structure.bridge.material; /** * Material */ public interface Material { public void draw(); } package com.enjoy.structure.bridge.material; /** * 包装接口 * Material */ public class Paper implements Material{ public void draw(){ System.out.print(&quot;用纸盒&quot;); } } /** * 包装接口 * Material */ public class Sack implements Material{ public void draw(){ System.out.print(&quot;用麻袋&quot;); } } /** * 包装接口 * Material */ public class Plastic implements Material{ public void draw(){ System.out.print(&quot;用塑料袋&quot;); } } 桥接模式应用 Java语言通过Java虚拟机实现了平台的无关性 一个 Java桌面软件总是带有所在操作系统的视感(LookAndFeel)，如果一个Java软件是在Unix系统上开发的，那么开发人员看到的是Motif用户界面的视感；在Windows上面使用这个系统的用户看到的是Windows用户界面的视感；而一个在Macintosh上面使用的用户看到的则是Macintosh用户界面的视感，Java语言是通过所谓的Peer架构做到这一点的。Java为AWT中的每一个GUI构件都提供了一个Peer构件，在AWT中的Peer架构就使用了桥接模式。 JDBC驱动程序也是桥接模式的应用之一。使用JDBC驱动程序的应用系统就是抽象角色，而所使用的数据库是实现角色。一个JDBC驱动程序可以动态地将一个特定类型的数据库与一个Java应用程序绑定在一起，从而实现抽象角色与实现角色的动态耦合。 跨平台视频播放器如果需要开发一个跨平台视频播放器，可以在不同操作系统平台（如Windows、Linux、Unix等）上播放多种格式的视频文件，常见的视频格式包括MPEG、RMVB、AVI、WMV等。现使用桥接模式设计该播放器。","link":"/2015/10/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"},{"title":"模板方法模式","text":"模板方法模式 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 模板方法模式的本质是:固定算法骨架,模板方法很好的体现了开闭原则和里氏替换原则。 模板方法场景典型应用:排序模板方法模式的一个非常典型的应用，就是实现排序的功能。 在java.util包中，有一个Collections类，它里面实现了对列表排序的功能，它提供了一个静态的sort方法，接受一个列表和一个Comparator接口的实例，这个方法实现的大致步骤是: : 先把列表转换成为对象数组 :通过Arrays的sort方法来对数组进行排序，传入Comparator接口的实例 :然后再把排好序的数组的数据设置回到原来的列表对象中去这其中的算法步骤是固定的，也就是算法骨架是固定的了，只是其中具体 比较数据大小的步骤，需要由外部来提供，也就是传入的Comparator接口的实例，就是用来实现数据比较的，在算法内部会通过这个接口来回调具体的实现。 排序，到底是模板方法模式，还是策略模式的实例，到底哪个说法更合适? 1:认为是策略模式的实例的理由: (1)首先上面的排序实现，并没有如同标准的模板方法模式那样，使用子类来扩展父 类，至少从表面上看不太像模板方法模式; (2)其次排序使用的Comparator的实例，可以看成是不同的算法实现，在具体排序时， 会选择使用不同的Comparator实现，就相当于是在切换算法的实现。 2:认为是模板方法模式的实例的理由: (1)首先，模板方法模式的本质是固定算法骨架，虽然使用继承是标准的实现方式，但 是通过回调来实现，也不能说这就不是模板方法模式; (2)其次，从整体程序上看，排序的算法并没有改变，不过是某些步骤的实现发生了变 化，也就是说通过Comparator来切换的是不同的比较大小的实现，相对于整个排序算 法而言，它不过是其中的一个步骤而已。 总结:排序的实现，实际上组合使用了模板方法模式和策略模式，从整体来看是模板方 法模式，但到了局部，比如排序比较算法的实现上，就是使用的策略模式了。 代码示例package com.enjoy.action.template; import com.enjoy.action.strategy.Discount; import com.enjoy.action.strategy.FullDiscount; import com.enjoy.action.strategy.NewerDiscount; import com.enjoy.action.strategy.SecondDiscount; import com.enjoy.create.fatory.simple.StaticFactory; import com.enjoy.entity.Fruit; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; /** * 模板方法模式 * 订单费用结算过程 */ public class ShoppingCartClient { private static Map&lt;String,Discount&gt; disCounts = new HashMap(); static { disCounts.put(&quot;full&quot;,new FullDiscount()); disCounts.put(&quot;newer&quot;,new NewerDiscount()); disCounts.put(&quot;second&quot;,new SecondDiscount()); } public static void main(String[] args) { List&lt;Fruit&gt; products = new ArrayList(); products.add(StaticFactory.getFruitApple()); products.add(StaticFactory.getFruitBanana()); products.add(StaticFactory.getFruitOrange()); ShoppingCart cart = new OtherPayShopping(products); //注入优惠方案 // String discount = &quot;second&quot;; // cart.setDiscount(disCounts.get(discount)); cart.submitOrder(); } } package com.enjoy.action.template; import com.enjoy.action.strategy.Discount; import com.enjoy.entity.Fruit; import java.util.ArrayList; import java.util.List; /** * 模板方法模式 * 购物车费用结算过程 */ public abstract class ShoppingCart { private Discount discount; private List&lt;Fruit&gt; products = new ArrayList&lt;&gt;(); public ShoppingCart(List&lt;Fruit&gt; products){ this.products = products; } public void setDiscount(Discount discount) { this.discount = discount; } //提交订单主流程 public void submitOrder(){ //计算商品金额 int money = balance(); System.out.println(&quot;商品总金额为：&quot;+money+&quot;元&quot;); //优惠减免 money = discount.calculate(money); System.out.println(&quot;优惠减免后：&quot;+ money+&quot;元，&quot;); //保存订单 pay(money); //送货上门 sendHome(); } //计算金额 private int balance(){ int money = 0; System.out.print(&quot;商品清单：&quot;); for (Fruit fruit : products){ fruit.draw(); System.out.print(&quot;,&quot;); money += fruit.price(); } return money; } private void sendHome(){ System.out.println(&quot;三公里以内，免费送货上门&quot;); } //提交保存 protected abstract void pay(int money); } package com.enjoy.action.template; import com.enjoy.entity.Fruit; import java.util.List; /** * 模板方法模式 * 购物车费用结算过程 */ public class OtherPayShopping extends ShoppingCart{ public OtherPayShopping(List&lt;Fruit&gt; products) { super(products); } @Override protected void pay(int money) { System.out.println(&quot;代付成功&quot;); } } package com.enjoy.action.template; import com.enjoy.entity.Fruit; import com.enjoy.service.OrderService; import com.enjoy.service.impl.OrderServiceImpl; import java.util.List; /** * 模板方法模式 * 购物车费用结算过程 */ public class OnlineShopping extends ShoppingCart{ private OrderService orderService = new OrderServiceImpl(); public OnlineShopping(List&lt;Fruit&gt; products) { super(products); } @Override protected void pay(int money) { System.out.println(&quot;微信/支付宝结算，减免5元,请支付：&quot;+(money - 5)+&quot;元&quot;); int orderId = orderService.saveOrder(); } } package com.enjoy.action.template; import com.enjoy.entity.Fruit; import java.util.List; /** * 模板方法模式 * 购物车费用结算过程 */ public class CashShopping extends ShoppingCart{ public CashShopping(List&lt;Fruit&gt; products) { super(products); } @Override protected void pay(int money) { System.out.println(&quot;现金结算，假一罚十&quot;); } } package com.enjoy.action.template; import com.enjoy.entity.Fruit; import java.util.List; /** * 模板方法模式 * 购物车费用结算过程 */ public class CartShopping extends ShoppingCart{ public CartShopping(List&lt;Fruit&gt; products) { super(products); } @Override protected void pay(int money) { System.out.println(&quot;会员卡结算，立减10，金额：&quot;+ (money - 10)+&quot;,增加积分：&quot;+10*money); } }","link":"/2015/10/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F-up1/"},{"title":"策略模式","text":"策略模式 Strategy模式也叫策略模式是行为模式之一，它对一系列的算法加以封装，为所有算法定义一个抽象的算法接口，并通过继承该抽象算法接口对所有的算法加以封装和实现，具体的算法选择交由客户端决定（策略）。Strategy模式主要用来平滑地处理算法的切换 。 策略模式的结构 策略模式的角色和职责 Strategy:策略（算法）抽象。ConcreteStrategy 各种策略（算法）的具体实现。Context 策略的外部封装类，或者说策略的容器类。根据不同策略执行不同的行为。策略由外部环境决定。 策略模式的优点 它的优点有： 策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族。恰当使用继承可以把公共的代码移到父类里面，从而避免重复的代码。 策略模式提供了可以替换继承关系的办法。继承可以处理多种算法或行为。如果不是用策略模式，那么使用算法或行为的环境类就可能会有一些子类，每一个子类提供一个不同的算法或行为。但是，这样一来算法或行为的使用者就和算法或行为本身混在一起。决定使用哪一种算法或采取哪一种行为的逻辑就和算法或行为的逻辑混合在一起，从而不可能再独立演化。继承使得动态改变算法或行为变得不可能。 使用策略模式可以避免使用多重条件转移语句。多重转移语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起，统统列在一个多重转移语句里面，比使用继承的办法还要原始和落后。 策略模式的缺点 策略模式的缺点有： 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。换言之，策略模式只适用于客户端知道所有的算法或行为的情况。 策略模式造成很多的策略类。有时候可以通过把依赖于环境的状态保存到客户端里面，而将策略类设计成可共享的，这样策略类实例可以被不同客户端使用。换言之，可以使用享元模式来减少对象的数量。 代码示例：Strategy:策略（算法）抽象。 public interface Strategy { public void encrypt(); } ConcreteStrategy 各种策略（算法）的具体实现。 public class MD5Strategy implements Strategy{ public void encrypt() { System.out.println(&quot;ִMD5Strategy&quot;); } } public class MDSStrategy implements Strategy{ public void encrypt() { System.out.println(&quot;ִMDSStrategy&quot;); } } Context 策略的外部封装类，或者说策略的容器类。根据不同策略执行不同的行为 public class Context { private Strategy strategy; public Context(Strategy strategy) { this.strategy = strategy; } public void encrypt() { this.strategy.encrypt(); } } 最终调用示例: public class MainClass { public static void main(String[] args) { // Strategy stra = new MDSStrategy(); // stra.encrypt(); Context context = new Context(new MDSStrategy()); context.encrypt(); } }","link":"/2015/10/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F-up1/"},{"title":"简单工厂设计模式","text":"简单工厂设计模式定义 简单工厂模式属于类的创建型模式,又叫做静态工厂方法模式。通过专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。 模式中包含的角色及其职责 1.工厂（Creator）角色简单工厂模式的核心，它负责实现创建所有实例的内部逻辑。工厂类可以被外界直接调用，创建所需的产品对象。2.抽象（Product）角色简单工厂模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口。3.具体产品（Concrete Product）角色简单工厂模式所创建的具体实例对象. 简单工厂模式的优缺点 在这个模式中，工厂类是整个模式的关键所在。它包含必要的判断逻辑，能够根据外界给定的信息，决定究竟应该创建哪个具体类的对象。用户在使用时可以直接根据工厂类去创建所需的实例，而无需了解这些对象是如何创建以及如何组织的。有利于整个软件体系结构的优化。不难发现，简单工厂模式的缺点也正体现在其工厂类上，由于工厂类集中了所有实例的创建逻辑，所以“高内聚”方面做的并不好。另外，当系统中的具体产品类不断增多时，可能会出现要求工厂类也要做相应的修改，扩展性并不很好.—&gt;演化出工厂方法模式解决这个缺陷 接下来可以查看工厂方法模式解决简单工厂模式的缺陷 练习代码工厂（Creator）角色 示例 public class FruitFactory { // /* // * 获取苹果的实例对象 // */ // public static Fruit getApple() { // return new Apple(); // } // // /* // * 获取香蕉的实例对象 // */ // public static Fruit getBanana() { // return new Banana(); // } /* * get方法，获得所有产品对象 */ public static Fruit getFruit(String type) throws InstantiationException, IllegalAccessException, ClassNotFoundException { // if(type.equalsIgnoreCase(&quot;apple&quot;)) { // return Apple.class.newInstance(); // // } else if(type.equalsIgnoreCase(&quot;banana&quot;)) { // return Banana.class.newInstance(); // } else { // System.out.println(&quot;找不到相应的实例化类&quot;); // return null; // } Class fruit = Class.forName(type); //用反射虽然可以克服简单工厂的扩展性问题，但是适用性变弱了，反而不如根据字符串名字判断 new对象。 return (Fruit) fruit.newInstance(); } } 抽象角色示例 public interface Fruit { /* * 封装不同实例通性 采集性质 */ public void get(); } 具体产品（Concrete Product）角色 示例 苹果实例 public class Apple implements Fruit{ /* * 采集苹果 */ public void get(){ System.out.println(&quot;采集苹果); } } 香蕉实例 public class Banana implements Fruit{ /* * 采集香蕉 */ public void get(){ System.out.println(&quot;采集香蕉&quot;); } } 简单工厂模式归纳一:初识简单工厂 包括:定义、结构、参考实现二:体会简单工厂 包括:场景问题、不用模式的解决方案、使用模式的解决方案三：理解简单工厂 包括:典型疑问、认识简单工厂、简单工厂中方法的写法、可配置的简单工厂、简单工厂的优缺点四:思考简单工厂 包括:简单工厂的本质、何时选用 应用方面数据库连接的创建就用到了 简单工厂模式。 MSsql,oracle,mysql 三种不同实例对象 通过简单工厂模式 获取实际连接数据库的连接。 在JDK类库中广泛使用了简单工厂模式，如工具类java.text.DateFormat，它用于格式化一个本地日期或者时间public final static DateFormat getDateInstance(); public final static DateFormat getDateInstance(int style); public final static DateFormat getDateInstance(int style,Locale locale); Java加密技术//获取不同加密算法的密钥生成器 KeyGenerator keyGen=KeyGenerator.getInstance(&quot;DESede&quot;); //创建密码器 Cipher cp=Cipher.getInstance(&quot;DESede&quot;);","link":"/2015/10/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"title":"组合模式","text":"组合模式定义 组合模式示例 代码示例package com.enjoy.structure.composite; import com.alibaba.fastjson.JSON; /** * 组合模式 * 省市县目录组织结构 */ public class CompositeClient { public static void main(String[] args){ sendFruit(); } public static void sendFruit(){ //根目录 DistrictNode root = new DistrictNode(&quot;根&quot;); //一线目录 root.addChild(new DistrictNode(&quot;上海&quot;)); root.addChild(new DistrictNode(&quot;天津&quot;)); DistrictNode districtNode = new DistrictNode(&quot;北京&quot;); root.addChild(districtNode); //二级目录 districtNode.addChild(new DistrictNode(&quot;海淀区&quot;)); districtNode.addChild(new DistrictNode(&quot;西城区&quot;)); DistrictNode districtNode2 = new DistrictNode(&quot;朝阳区&quot;); districtNode.addChild(districtNode2); //三级目录 districtNode2.addChild(new LeafNode(&quot;三里屯&quot;)); districtNode2.addChild(new LeafNode(&quot;朝阳外街&quot;)); System.out.println(JSON.toJSON(root)); //以下物流运输业务。。。。 } } package com.enjoy.structure.composite; import java.util.ArrayList; import java.util.List; public class DistrictNode extends Node{ private List&lt;Node&gt; children = new ArrayList&lt;&gt;(); public DistrictNode(String name) { super(name); } @Override public List&lt;Node&gt; getChildren() { return children; } public void addChild(Node node){ children.add(node); } public void delChild(int i){ children.remove(i); } } package com.enjoy.structure.composite; import java.util.List; public abstract class Node { private String name; public Node(String name){ this.name = name; } public abstract List&lt;Node&gt; getChildren(); public String getName() { return name; } } import java.util.List; public class LeafNode extends Node{ public LeafNode(String name) { super(name); } @Override public List&lt;Node&gt; getChildren() { return null; } }","link":"/2015/10/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"},{"title":"装饰模式","text":"装饰模式 装饰（ Decorator ）模式又叫做包装模式。通过一种对客户端透明的方式来扩展对象的功能，是继承关系的一个替换方案。动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式比生成子类更为灵活。 装饰模式的结构 装饰模式的角色和职责 抽象组件角色： 一个抽象接口，是被装饰类和装饰类的父接口。具体组件角色：为抽象组件的实现类。抽象装饰角色：包含一个组件的引用，并定义了与抽象组件一致的接口。具体装饰角色：为抽象装饰角色的实现类。负责具体的装饰 代码示例：抽象组件角色： 一个抽象接口，是被装饰类和装饰类的父接口。 public interface Car { public void show(); public void run(); } 抽象装饰角色： public abstract class CarDecorator implements Car{ private Car car; public Car getCar() { return car; } public void setCar(Car car) { this.car = car; } public CarDecorator(Car car) { this.car = car; } public abstract void show(); } 具体装饰角色 public class FlyCarDecorator extends CarDecorator{ public FlyCarDecorator(Car car) { super(car); } public void show() { this.getCar().show(); this.fly(); } public void fly() { System.out.println(&quot;可以飞&quot;); } public void run() { } } public class SwimCarDecorator extends CarDecorator { public SwimCarDecorator(Car car) { super(car); } public void show() { this.getCar().show(); this.swim(); } public void swim() { System.out.println(&quot;可以游&quot;); } public void run() { } } 具体组件角色 public class RunCar implements Car { public void run() { System.out.println(&quot;可以跑&quot;); } public void show() { this.run(); } } 最后的调用示例 public class MainClass { public static void main(String[] args) { Car car = new RunCar(); car.show(); System.out.println(&quot;---------&quot;); Car swimcar = new SwimCarDecorator(car); swimcar.show(); System.out.println(&quot;---------&quot;); Car flySwimCar = new FlyCarDecorator(swimcar); flySwimCar.show(); } } 示例最精简的装饰模式 java io 过滤流public abstract class Reader { public abstract void close(); } //思考：对FileReader这个类的close方法进行扩展: //1.继承(不推荐，代码耦合度太高。不利于项目的扩展。) //2.装饰者模式. public class FileReader extends Reader { public void close(){ System.out.println(&quot;FileReader closed!&quot;); } } //使用BufferedReader对FileReader中的close方法进行扩展 //1.装饰者模式中要求：装饰者中含有被装饰者的引用. //2.装饰者模式中要求：装饰者和被装饰者应该实现同一个类型. public class BufferedReader extends Reader //BufferedReader 装饰者 { //关联关系 Reader reader; //FileReader就是被装饰者. //Constructor BufferedReader(Reader reader){ this.reader = reader; } //对FileReader中的close方法进行扩展 public void close(){ //扩展 System.out.println(&quot;扩展代码1&quot;); reader.close(); System.out.println(&quot;扩展代码2&quot;); } } 装饰模式场景 示例package com.enjoy.structure.decorator; import com.enjoy.create.fatory.abstractFactory.AbstractFactory; import com.enjoy.create.fatory.abstractFactory.AppleFactory; import com.enjoy.entity.Bag; import com.enjoy.entity.Fruit; /** * 装饰器模式测试 */ public class DecoratorClient { public static void main(String[] args){ sendFruit(); } public static void sendFruit(){ AbstractFactory factory = new AppleFactory(); //得到水果 Fruit fruit = factory.getFruit(); fruit.draw(); //得到包装 Bag bag = factory.getBag(); //现需要增加防伪标识 bag = new CheckedBagDecorator(bag);//防伪功能 bag = new ReinforceBagDecorator(bag);//加固功能 bag = new SpeedDecorator(bag);//加急功能 bag.pack(); //以下物流运输业务。。。。 } } package com.enjoy.structure.decorator; import com.enjoy.entity.Bag; public class BagDecorator implements Bag { private Bag bag; //维持一个对抽象构件对象的引用 public BagDecorator(Bag bag) //注入一个抽象构件类型的对象 { this.bag = bag; } public void pack() { bag.pack(); } } import com.enjoy.entity.Bag; public class SpeedDecorator extends BagDecorator { public SpeedDecorator(Bag bag) { super(bag); } public void pack() { super.pack(); //调用原有业务方法 speedy(); } //快件加急 public void speedy() { System.out.println(&quot;------&quot;); System.out.println(&quot;打上加急标识&quot;); } } public class ReinforceBagDecorator extends BagDecorator { public ReinforceBagDecorator(Bag bag) { super(bag); } public void pack() { super.pack(); //调用原有业务方法 reinforce(); } //加固包装 public void reinforce() { System.out.println(&quot;------&quot;); System.out.println(&quot;加固了包装&quot;); } } public class CheckedBagDecorator extends BagDecorator { public CheckedBagDecorator(Bag bag) { super(bag); } public void pack() { super.pack(); //调用原有业务方法 checked(); //打印防伪标识 } //增加防伪标识 public void checked() { System.out.println(&quot;------&quot;); System.out.println(&quot;打印上防伪标识&quot;); } }","link":"/2015/10/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"},{"title":"观察者模式","text":"观察者模式 Observer模式是行为模式之一，它的作用是当一个对象的状态发生变化时，能够自动通知其他关联对象，自动刷新对象状态。Observer模式提供给关联对象一种同步通信的手段，使某个对象与依赖它的其他对象之间保持状态同步 观察者模式是对象的行为模式，又叫发布-订阅(Publish/Subscribe)模式、模型-视图(Model/View)模式、源-监听器(Source/Listener)模式或从属者(Dependents)模式。 观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。 观察者模式的结构 观察者模式的角色和职责 Subject（被观察者） 被观察的对象。当需要被观察的状态发生变化时，需要通知队列中所有观察者对象。Subject需要维持（添加，删除，通知）一个观察者对象的队列列表。ConcreteSubject 被观察者的具体实现。包含一些基本的属性状态及其他操作。Observer（观察者） 接口或抽象类。当Subject的状态发生变化时，Observer对象将通过一个callback函数得到通知。ConcreteObserver 观察者的具体实现。得到通知后将完成一些具体的业务逻辑处理。 观察者模式初步体验例子 package com.enjoy.action.observer; /** * 观察者模式 * 顾客关注了芒果，降价时通知他们 */ public class ObserverClient { public static void main(String[] args) { MangoAttention attentions = new MangoAttention();//目标 attentions.add(new CustomerObserver(&quot;deer&quot;)); attentions.add(new CustomerObserver(&quot;james&quot;)); attentions.add(new CustomerObserver(&quot;lison&quot;)); attentions.add(new CustomerObserver(&quot;mark&quot;)); //到货 attentions.perform(); } } package com.enjoy.action.observer; import java.util.ArrayList; import java.util.List; public abstract class Attentions { //关注客户列表 protected List&lt;Observer&gt; observers = new ArrayList(); //关注顾客 public void add(Observer observer) { observers.add(observer); } //取消关注 public void remove(Observer observer) { observers.remove(observer); } //发通知 public abstract void notifyObservers(); } package com.enjoy.action.observer; public class MangoAttention extends Attentions{ @Override public void notifyObservers() { //遍历观察者集合，调用每一个顾客的购买方法 for(Observer obs : observers) { obs.update(); } } //芒果到货了 public void perform(){ this.notifyObservers(); } } package com.enjoy.action.observer; public interface Observer { void update(); } package com.enjoy.action.observer; public class CustomerObserver implements Observer { private String name; public CustomerObserver(String name){ this.name = name; } @Override public void update() { System.out.println(name + &quot;购买青芒&quot;); } } 观察者模式的典型应用JDK 提供的观察者接口观察者模式在Java语言中的地位非常重要。在JDK的 java.util 包中，提供了 Observable 类以及 Observer 接口，它们构成了JDK对观察者模式的支持。其中的 Observer 接口为观察者，只有一个 update 方法，当观察目标发生变化时被调用，其代码如下 public interface Observer { //观察者 void update(Observable o, Object arg); } Observable 类则为目标类，类多了并发和NPE方面的考虑 public class Observable { //被观察者或者目标类 private boolean changed = false; private Vector&lt;Observer&gt; obs = new Vector(); public Observable() { } // 用于注册新的观察者对象到向量中 public synchronized void addObserver(Observer var1) { if (var1 == null) { throw new NullPointerException(); } else { if (!this.obs.contains(var1)) { this.obs.addElement(var1); } } } // 用于删除向量中的某一个观察者对象 public synchronized void deleteObserver(Observer var1) { this.obs.removeElement(var1); } public void notifyObservers() { this.notifyObservers((Object)null); } // 通知方法，用于在方法内部循环调用向量中每一个观察者的update()方法 public void notifyObservers(Object var1) { Object[] var2; synchronized(this) { if (!this.changed) { return; } var2 = this.obs.toArray(); this.clearChanged(); } for(int var3 = var2.length - 1; var3 &gt;= 0; --var3) { ((Observer)var2[var3]).update(this, var1); } } // 用于清空向量，即删除向量中所有观察者对象 public synchronized void deleteObservers() { this.obs.removeAllElements(); } // 该方法被调用后会设置一个boolean类型的内部标记变量changed的值为true，表示观察目标对象的状态发生了变化 protected synchronized void setChanged() { this.changed = true; } // 用于将changed变量的值设为false，表示对象状态不再发生改变或者已经通知了所有的观察者对象，调用了它们的update()方法 protected synchronized void clearChanged() { this.changed = false; } // 返回对象状态是否改变 public synchronized boolean hasChanged() { return this.changed; } // 返回向量中观察者的数量 public synchronized int countObservers() { return this.obs.size(); } } 利用JDK内置的事件机制模拟微信公众号发推文给用户的过程package com.example.demo.observer; import lombok.AllArgsConstructor; import lombok.Data; @Data @AllArgsConstructor public class WechatNotice { //定义通知的实体 private String publisher; private String articleName; } package com.example.demo.observer; import java.util.Observable; import java.util.Observer; public class WeChatClientObserver implements Observer { //模拟微信普通用户(观察者) private String username; public WeChatClientObserver(String username) { this.username = username; } @Override public void update(Observable o, Object arg) { //WeChatAccounts weChatAccounts = (WeChatAccounts) o; //预留的回调 WechatNotice notice = (WechatNotice) arg; System.out.println(String.format(&quot;用户&lt;%s&gt; 接收到 &lt;%s&gt;微信公众号 的推送，文章标题为 &lt;%s&gt;&quot;, username, notice.getPublisher(), notice.getArticleName())); } } package com.example.demo.observer; import java.util.Observable; public class WeChatAccountsObservable extends Observable { //模拟的微信公众号(被观察者) private String name; public WeChatAccountsObservable(String name) { this.name = name; } public void publishArticles(String articleName, String content) { //发送微信文章触发通知 System.out.println(String.format(&quot;\\n&lt;%s&gt;微信公众号 发布了一篇推送，文章名称为 &lt;%s&gt;，内容为 &lt;%s&gt; &quot;, this.name, articleName, content)); setChanged(); notifyObservers(new WechatNotice(this.name, articleName)); } } package com.example.demo.observer; public class Test { public static void main(String[] args) { WeChatAccountsObservable accounts = new WeChatAccountsObservable(&quot;晋城新闻公众号账号&quot;); //实例化一个微信公众号 WeChatClientObserver user1 = new WeChatClientObserver(&quot;张三&quot;); WeChatClientObserver user2 = new WeChatClientObserver(&quot;李四&quot;); WeChatClientObserver user3 = new WeChatClientObserver(&quot;王五&quot;); accounts.addObserver(user1); //添加订阅 accounts.addObserver(user2); //添加订阅 accounts.addObserver(user3); //添加订阅 accounts.publishArticles(&quot;城乡提速&quot;, &quot;市内增加二十条交通线路...&quot;); //公众号发文章 accounts.deleteObserver(user1); // 张三用户取消订阅关注 accounts.publishArticles(&quot;反腐先锋&quot;, &quot;我市张三获得反腐个人先锋称号.&quot;); //公众号发文章 } } // 输出结果: // &lt;晋城新闻公众号账号&gt;微信公众号 发布了一篇推送，文章名称为 &lt;城乡提速&gt;，内容为 &lt;市内增加二十条交通线路...&gt; // 用户&lt;王五&gt; 接收到 &lt;晋城新闻公众号账号&gt;微信公众号 的推送，文章标题为 &lt;城乡提速&gt; // 用户&lt;李四&gt; 接收到 &lt;晋城新闻公众号账号&gt;微信公众号 的推送，文章标题为 &lt;城乡提速&gt; // 用户&lt;张三&gt; 接收到 &lt;晋城新闻公众号账号&gt;微信公众号 的推送，文章标题为 &lt;城乡提速&gt; // &lt;晋城新闻公众号账号&gt;微信公众号 发布了一篇推送，文章名称为 &lt;反腐先锋&gt;，内容为 &lt;我市张三获得反腐个人先锋称号.&gt; // 用户&lt;王五&gt; 接收到 &lt;晋城新闻公众号账号&gt;微信公众号 的推送，文章标题为 &lt;反腐先锋&gt; // 用户&lt;李四&gt; 接收到 &lt;晋城新闻公众号账号&gt;微信公众号 的推送，文章标题为 &lt;反腐先锋&gt; Guava EventBus 中的观察者模式 Guava 中的 EventBus 封装了友好的 “生产/消费模型”，通过非常简单的方式，实现了观察者模式中的监听注册，事件分发。 使用了 Guava EventBus 之后，如果需要订阅消息，不需要实现任何接口，只需在监听方法上加上 @Subscribe 注解即可，EventBus 提供了 register 和 unregister 方法用于注册与取消注册事件，当 EventBus 调用 post 方法时将把事件分发给注册的对象 利用Guava EventBus改写微信公众号发送文章```javapackage com.example.demo.evenbus;import com.google.common.eventbus.EventBus;import com.google.common.eventbus.Subscribe;import lombok.AllArgsConstructor;import lombok.Data;@Data@AllArgsConstructorclass WechatNotice { private String publisher; private String articleName;}class WeChatClient { //模拟微信客户端 观察者角色 private String username; public WeChatClient(String username) { this.username = username; } @Subscribe public void listen(WechatNotice notice) { //通过注解相当于 之前实现的接口Observer System.out.println(String.format(“用户&lt;%s&gt; 接收到 &lt;%s&gt;微信公众号 的推送，文章标题为 &lt;%s&gt;”, username, notice.getPublisher(), notice.getArticleName())); } }class WeChatAccounts { //模拟微信公众号角色 被观察者角色 让EventBus具体充当被观察者角色 private String name; private EventBus eventBus; public WeChatAccounts(String name) { this.name = name; this.eventBus = new EventBus(); } public void publishArticles(String articleName, String content) { //发布微信文章触发事件 System.out.println(String.format(“\\n&lt;%s&gt;微信公众号 发布了一篇推送，文章名称为 &lt;%s&gt;，内容为 &lt;%s&gt; “, this.name, articleName, content)); this.eventBus.post(new WechatNotice(this.name, articleName)); } public void register(WeChatClient weChatClient) { this.eventBus.register(weChatClient); } public void unregister(WeChatClient weChatClient) { this.eventBus.unregister(weChatClient); }}public class Test { public static void main(String[] args) { WeChatAccounts accounts = new WeChatAccounts(“晋城新闻公众号账号”); WeChatClient user1 = new WeChatClient(“张三”); WeChatClient user2 = new WeChatClient(“李四”); WeChatClient user3 = new WeChatClient(“王五”); accounts.register(user1); accounts.register(user2); accounts.register(user3); accounts.publishArticles(“城乡提速”, “市内增加二十条交通线路…”); //公众号发文章 accounts.unregister(user1); accounts.publishArticles(“反腐先锋”, “我市张三获得反腐个人先锋称号.”); //公众号发文章 }} ### Spring ApplicationContext 事件机制中的观察者模式 - spring的事件机制是从java的事件机制拓展而来，ApplicationContext 中事件处理是由 ApplicationEvent 类和 ApplicationListener 接口来提供的。如果一个Bean实现了 ApplicationListener 接口，并且已经发布到容器中去，每次 ApplicationContext 发布一个 ApplicationEvent 事件，这个Bean就会接到通知 - ApplicationContext：事件源，其中的 publishEvent()方法用于触发容器事件 - ApplicationEvent：事件本身，自定义事件需要继承该类，可以用来传递数据 - ApplicationListener：事件监听器接口，事件的业务逻辑封装在监听器里面 #### 利用Spring ApplicationContext 事件机制重新实现上面例子 ```java package com.example.demo.springevent; import lombok.Data; import org.springframework.beans.BeansException; import org.springframework.context.ApplicationContext; import org.springframework.context.ApplicationContextAware; import org.springframework.context.ApplicationEvent; import org.springframework.context.ApplicationListener; import org.springframework.context.support.ClassPathXmlApplicationContext; @Data class WechatNotice extends ApplicationEvent { private String publisher; private String articleName; public WechatNotice(Object source, String publisher, String articleName) { super(source); this.publisher = publisher; this.articleName = articleName; } } class WeChatClient implements ApplicationListener { private String username; public WeChatClient(String username) { this.username = username; } @Override public void onApplicationEvent(ApplicationEvent event) { if (event instanceof WechatNotice) { WechatNotice notice = (WechatNotice) event; System.out.println(String.format(&quot;用户&lt;%s&gt; 接收到 &lt;%s&gt;微信公众号 的推送，文章标题为 &lt;%s&gt;&quot;, username, notice.getPublisher(), notice.getArticleName())); } } public void setUsername(String username) { this.username = username; } } class WeChatAccounts implements ApplicationContextAware { private ApplicationContext ctx; private String name; public WeChatAccounts(String name) { this.name = name; } public void setName(String name) { this.name = name; } @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException { this.ctx = applicationContext; } public void publishArticles(String articleName, String content) { System.out.println(String.format(&quot;\\n&lt;%s&gt;微信公众号 发布了一篇推送，文章名称为 &lt;%s&gt;，内容为 &lt;%s&gt; &quot;, this.name, articleName, content)); ctx.publishEvent(new WechatNotice(this.name, this.name, articleName)); } } public class Test { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;); WeChatAccounts accounts = (WeChatAccounts) context.getBean(&quot;WeChatAccounts&quot;); accounts.setName(&quot;晋城新闻公众号账号&quot;); accounts.setApplicationContext(context); accounts.publishArticles(&quot;城乡提速&quot;, &quot;市内增加二十条交通线路...&quot;); } } &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;WeChatAccounts&quot; class=&quot;com.observer.sprintevent.WeChatAccounts&quot; scope=&quot;prototype&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id=&quot;WeChatClient1&quot; class=&quot;com.observer.sprintevent.WeChatClient&quot;&gt; &lt;constructor-arg name=&quot;username&quot; value=&quot;张三&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id=&quot;WeChatClient2&quot; class=&quot;com.observer.sprintevent.WeChatClient&quot;&gt; &lt;constructor-arg name=&quot;username&quot; value=&quot;李四&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id=&quot;WeChatClient3&quot; class=&quot;com.observer.sprintevent.WeChatClient&quot;&gt; &lt;constructor-arg name=&quot;username&quot; value=&quot;王五&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;/beans&gt; 其它场景Java中的DEM事件机制 责任链模式一章中曾谈到，AWT1.0的事件处理的模型是基于责任链的。这种模型不适用于复杂的系统，因此在AWT1.1版本及以后的各个版本中，事件处理模型均为基于观察者模式的委派事件模型（Delegation Event Model或DEM）。 使用DEM的用词，发布者叫做事件源（event source），而订阅者叫做事件聆听者（event listener）。在Java里面，事件由类代表，事件的发布是通过同步地调用成员方法做到的。推拉模型 推模型:目标对象主动向观察者推送目标的详细信息，不管观察者是否需要，推送的信息通常是目标对象的全部或部分数据，相当于是在广播通信。 拉模型:目标对象在通知观察者的时候，只传递少量信息，如果观察者需要更具体的信息，由观察者主动到目标对象中获取，相当于是观察者从目标对象中拉数据。一般这种模型的实现中，会把目标对象自身通过update方法传递给观察者，这样在观察者需要获取数据的时候，就可以通过这个引用来获取了Swing中的观察者模式 Swing中到处都是观察者模式的身影，比如大家熟悉的事件处理，就是典型的观察者模式的应用。(说明一 下:早期的Swing事件处理用的是职责链) Swing组件是被观察的目标，而每个实现监听器的类就是观察者，监听器的接口就是观察者的接口，在调用addXXXListener方法的时候就相当于注册观察者。当组件被点击，状态发生改变的时候，就会产生相应的通知，会调用注册的观察者的方法，就是我们所实现的监听器的方法。从这里还可以学-招:如何处理-一个观察者观察多个目标对象MVC模式 MVC模式是一种架构模式，它包含三个角色：模型(Model)，视图(View)和控制器(Controller)。观察者模式可以用来实现MVC模式，观察者模式中的观察目标就是MVC模式中的模型(Model)，而观察者就是MVC中的视图(View)，控制器(Controller)充当两者之间的中介者(Mediator)。当模型层的数据发生改变时，视图层将自动改变其显示内容。 观察者模式体会 观察者模式的主要优点如下：观察者模式可以实现表示层和数据逻辑层的分离，定义了稳定的消息更新传递机制，并抽象了更新接口，使得可以有各种各样不同的表示层充当具体观察者角色。观察者模式在观察目标和观察者之间建立一个抽象的耦合。观察目标只需要维持一个抽象观察者的集合，无须了解其具体观察者。由于观察目标和观察者没有紧密地耦合在一起，因此它们可以属于不同的抽象化层次。观察者模式支持广播通信，观察目标会向所有已注册的观察者对象发送通知，简化了一对多系统设计的难度。观察者模式满足 “开闭原则” 的要求，增加新的具体观察者无须修改原有系统代码，在具体观察者与观察目标之间不存在关联关系的情况下，增加新的观察目标也很方便。 观察者模式的主要缺点如下：如果一个观察目标对象有很多直接和间接观察者，将所有的观察者都通知到会花费很多时间。如果在观察者和观察目标之间存在循环依赖，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化","link":"/2015/10/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F-up1/"},{"title":"设计模式重温","text":"设计模式认知的层次境界看山是山，看水是水(基本入门级): 要求能够正确理解和掌握每个设计模式的基本知识，能够识别在什么场景下，出现了什么样的问题，采用何种方案来解决它，并能够在实际的程序设计和开发中套用相应的设计模式 看山不是山，看水不是水(基本掌握级): 除了具备基本入门级的要求外，还要求能够结合实际应用的场景，对设计模式进行变形的使用。事实上，实际开发中，经常会碰到跟标准模式的应用场景有一些不一样的情况，此时要合理的使用设计模式，就需要对它们做适当的变形，而不是僵硬的套用了。当然能变形的前提是要能准确深入的理解和把握设计模式的本质，万变不离其宗，只有把握住本质，才能够确保正确变形使用而不是误用。 看山还是山，看水还是水(深入理解和掌握级):除了具备基本掌握级的要求外，更主要是从思想上和方法上吸收设计模式的精髓，并融入到自己的思路里面去，在进行软件的分析设计的时候，能随意的、自然而然的应用，就像是自己思维的一部分。 设计模式的六大原则","link":"/2018/10/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E9%87%8D%E6%B8%A9-2018-10-21/"},{"title":"责任链模式","text":"责任链模式 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止 。 责任链优缺点优点： 1。责任的分担。每个类只需要处理自己该处理的工作（不该处理的传递给下一个对象完成），明确各类的责任范围，符合类的最小封装原则。 2。可以根据需要自由组合工作流程。如工作流程发生变化，可以通过重新分配对象链便可适应新的工作流程。 3。类与类之间可以以松耦合的形式加以组织。 缺点： 因为处理时以链的形式在对象间传递消息，根据实现方式不同，有可能会影响处理的速度。 责任链模式场景 代码示例package com.enjoy.action.chain; import com.enjoy.action.template.OtherPayShopping; import com.enjoy.action.template.ShoppingCart; import com.enjoy.create.fatory.simple.StaticFactory; import com.enjoy.entity.Fruit; import java.util.ArrayList; import java.util.List; /** * 订单费用结算过程 */ public class ChainCartClient { //初始化满减优惠券 private static MultyDiscount multyDiscount = new FullMultyDiscount(null); static { multyDiscount = new NewerMultyDiscount(multyDiscount); multyDiscount = new SecondMultyDiscount(multyDiscount); multyDiscount = new HolidayMultyDiscount(multyDiscount); } public static void main(String[] args) { List&lt;Fruit&gt; products = new ArrayList(); products.add(StaticFactory.getFruitApple()); products.add(StaticFactory.getFruitBanana()); products.add(StaticFactory.getFruitOrange()); ShoppingCart cart = new OtherPayShopping(products); //注入优惠方案 cart.setDiscount(multyDiscount); cart.submitOrder(); } } package com.enjoy.action.chain; import com.enjoy.action.strategy.Discount; public abstract class MultyDiscount implements Discount{ protected MultyDiscount nextMultyDiscount; public MultyDiscount(MultyDiscount nextMultyDiscount){ this.nextMultyDiscount = nextMultyDiscount; } public int calculate(int money){ if (this.nextMultyDiscount != null){ return this.nextMultyDiscount.calculate(money); } return money; } } package com.enjoy.action.chain; /** * 满减 */ public class FullMultyDiscount extends MultyDiscount { public FullMultyDiscount(MultyDiscount nextMultyDiscount) { super(nextMultyDiscount); } @Override public int calculate(int money) { if (money &gt; 200){ System.out.println(&quot;优惠满减20元&quot;); money = money - 20; } return super.calculate(money); } } package com.enjoy.action.chain; /** * 假日一律减5元 */ public class HolidayMultyDiscount extends MultyDiscount { public HolidayMultyDiscount(MultyDiscount nextMultyDiscount) { super(nextMultyDiscount); } @Override public int calculate(int money) { if (money &gt; 20){ System.out.println(&quot;假日一律减5元&quot;); money = money - 5; } return super.calculate(money); } } package com.enjoy.action.chain; /** * 首次购 */ public class NewerMultyDiscount extends MultyDiscount { public NewerMultyDiscount(MultyDiscount nextMultyDiscount) { super(nextMultyDiscount); } @Override public int calculate(int money) { if (money &gt; 100){ System.out.println(&quot;首次购买减20元&quot;); money = money - 30; } return super.calculate(money); } } package com.enjoy.action.chain; /** * 第二单9折优惠 */ public class SecondMultyDiscount extends MultyDiscount { public SecondMultyDiscount(MultyDiscount nextMultyDiscount) { super(nextMultyDiscount); } @Override public int calculate(int money) { System.out.println(&quot;第二单打9折&quot;); Double balance = money * 0.9; return super.calculate(balance.intValue()); } }","link":"/2015/10/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"},{"title":"适配器模式","text":"适配器模式定义 适配器模式(Adapter Pattern) ：将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。 适配器模式示例 //典型的类适配器代码： public class Adapter extends Adaptee implements Target { public void request() { specificRequest(); } } //典型的对象适配器代码： public class Adapter extends Target { private Adaptee adaptee; public Adapter(Adaptee adaptee) { this.adaptee=adaptee; } public void request() { adaptee.specificRequest(); } } 代码示例package com.enjoy.structure.adapter; import com.enjoy.entity.bag.AppleBag; import com.enjoy.entity.bag.OrangeBag; import com.enjoy.entity.fruit.Orange; public class AdapterClient { public static void main(String[] args){ Orange orange = new Orange(&quot;peter&quot;,100); OrangeBag bag = getBag2(); orange.pack(bag); } /** * 取桔子包装 * @return */ // private static OrangeBag getBag(){ // OrangeBag bag = new OrangeBag(); // return bag; // } private static OrangeBag getBag2(){ //准备用途苹果盒代替 AppleBag appleBag = new AppleBag(); //把苹果盒适配成桔子包装盒 OrangeBag orangeBag = new OrangeBagAdapter(appleBag); return orangeBag; } } package com.enjoy.structure.adapter; import com.enjoy.entity.bag.AppleBag; import com.enjoy.entity.bag.OrangeBag; /** * 桔子包装适配器 */ public class OrangeBagAdapter extends OrangeBag { private AppleBag appleBag; public OrangeBagAdapter(AppleBag appleBag){ this.appleBag = appleBag; } @Override public void pack() { appleBag.pack(); } } package com.enjoy.entity; /** * 包装接口 */ public interface Bag { void pack(); } /** * 苹果包装 */ public class AppleBag implements Bag { @Override public void pack() { System.out.print(&quot;--苹果使用纸箱包装&quot;); } } /** * 桔子包装 */ public class OrangeBag implements Bag { @Override public void pack() { System.out.print(&quot;--桔子使用网兜包装&quot;); } }","link":"/2015/10/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"title":"右脑开发","text":"大脑信息处理概览 数字转码法 记忆宫殿 只要是有一定的空间或者顺序可以帮助我们进行检索的都可以称之为记忆宫殿 1.1数字记忆宫殿 如数字编码记三十六计 1.2身体记忆宫殿 桩点：1.头发 2.眼晴 3.鼻子 4.嘴巴 5.脖子 6.肩膀 7.前胸 8.肚子 9.大腿 10.膝盖 11.小腿 12.脚 如身体定桩法记忆十二星座 在西方占星学上.黄道12星座是宇宙方位的代名词.一个人出生时.各星体落入黄道上的位置.说明了一个人的先天性格及天赋。黄道12星座象征心理层面,反映出一个人行为的表现的方式。于是将黄道分成12个星座,称为黄道12星座。依次为白羊座、金牛座.双子座、巨蟹座、狮子座、处女座、天秤座、天蝎座、射手座、摩羯座、水瓶座、双鱼座。 1.3汽车记忆宫殿 1.4人物记忆宫殿 桩点：爷爷，奶奶，爸爸，妈妈，哥哥，妹妹，七仙女，猪八戒 案例：记忆八荣八耻 1.5地点记忆宫殿1.6万事万物记忆宫殿","link":"/2020/07/06/%E9%9A%8F%E7%AC%94/%E5%8F%B3%E8%84%91%E5%BC%80%E5%8F%91/"},{"title":"电商行业","text":"电商行业的几种模式B2B:企业到企业，商家到商家。代表:阿里巴巴、慧聪网B2C:商家到客户。代表:京东、淘宝商城（B2B2C）C2C:客户到客户。淘宝集市。O2O:线上到线下 电商行业技术特点 技术新 技术范围广 分布式 高并发，集群，负载均衡，高可用 海量数据 业务复杂 系统安全性要求高","link":"/2018/02/20/%E9%9A%8F%E7%AC%94/%E7%94%B5%E5%95%86%E8%A1%8C%E4%B8%9A/"},{"title":"面试的整体流程","text":"简单的自我介绍 我是xxxx,工作xxx年.我先后在xxxx公司、yyyy公司工作。先后做个xxxx项目、yyyy项目。 介绍一下 XXX 项目 为了解决xxxx问题，开发了一套xxxx系统，该系统主要有那些部分组成。简单介绍项目的整体架构。参与某个模块的开发。就要求你说一下这个模块的业务及设计 会问一下专业技能 详细的专业技能要点 面试官会问还有需要询问他什么的吗 公司要做的项目？项目中会使用一下什么技术？业务的目前大致情况 注意：经历了多轮面试后，对于你的自我介绍和项目项目经验面试官就不太关心了。 你说一下你最擅长的什么？你简单说一下？就谈下自己对什么技术有点研究 最终技术面试完成后，都会让你回家等消息，或者等hr来和你谈薪资和福利。","link":"/2015/07/06/%E9%9A%8F%E7%AC%94/%E9%9D%A2%E8%AF%95%E7%9A%84%E5%A4%A7%E6%A6%82%E6%B5%81%E7%A8%8B/"},{"title":"网络爬虫普及","text":"网络爬虫介绍 网络爬虫（Web crawler），是一种按照一定的规则，自动的抓取万维网信息的程序或者脚本。从功能上来讲，爬虫一般分为数据采集，处理，储存三个部分，爬虫从一个或若干初始网页的URL开始，获得初始网页上的URL，在抓取网页的过程中，不断从当前页面上抽取新的URL放入队列,直到满足系统的一定停止条件。 网络框架HttpClient","link":"/2018/10/20/framework/crawler/crawler/"},{"title":"solr","text":"solr solr 是Apache下的一个顶级开源项目，采用Java开发，它是基于Lucene的全文搜索服务器。Solr提供了比Lucene更为丰富的查询语言，同时实现了可配置、可扩展，并对索引、搜索性能进行了优化。 solr可以独立运行，运行在Jetty、Tomcat等这些Servlet容器中，solr 索引的实现方法很简单，用 POST 方法向 solr 服务器发送一个描述 Field 及其内容的 XML 文档，solr根据xml文档添加、删除、更新索引 。solr 搜索只需要发送 HTTP GET 请求，然后对 solr 返回Xml、json等格式的查询结果进行解析，组织页面布局。solr不提供构建UI的功能，solr提供了一个管理界面，通过管理界面可以查询Solr的配置和运行情况。 solr与lucene的区别 Lucene是一个开放源代码的全文检索引擎工具包，它不是一个完整的全文检索引擎，Lucene提供了完整的查询引擎和索引引擎，目的是为软件开发人员提供一个简单易用的工具包，以方便的在目标系统中实现全文检索的功能，或者以Lucene为基础构建全文检索引擎。 solr的目标是打造一款企业级的搜索引擎系统，它是一个搜索引擎服务，可以独立运行，通过solr可以非常快速的构建企业的搜索引擎，通过solr也可以高效的完成站内搜索功能。 solr安装及配置 从solr官方网站（http://lucene.apache.org/solr/ ）下载solr4.10.3，根据solr的运行环境，Linux下需要下载lucene-4.10.3.tgz，windows下需要下载lucene-4.10.3.zip。 solr使用指南可参考：https://wiki.apache.org/solr/FrontPage。 Solr的文件夹结构 bin：solr的运行脚本 contrib：solr的一些贡献软件/插件，用于增强solr的功能。 dist：该目录包含build过程中产生的war和jar文件，以及相关的依赖文件。 docs：solr的API文档 example：solr工程的例子目录： example/solr： 该目录是一个包含了默认配置信息的solr的core目录。 example/multicore： 该目录包含了在solr的multicore中设置的多个core目录。 example/webapps： 该目录中包括一个solr.war，该war可作为solr的运行实例工程。 licenses：solr相关的一些许可信息 solr运行环境 solr 需要运行在一个servlet容器中，solr4.10.3要求jdk使用1.7以上，solr默认提供Jetty（java写的Servlet容器）。 solr与tomcat整合 第一步：安装tomcat，例如：apache-tomcat-7.0.53 第二步：把solr的war包复制到tomcat 的webapp目录下。把\\solr-4.10.3\\dist\\solr-4.10.3.war复制到apache-tomcat-7.0.53\\webapps下。改名为solr.war 第三步：solr.war解压。使用压缩工具解压或者启动tomcat自动解压。解压之后删除solr.war 第四步：把\\solr-4.10.3\\example\\lib\\ext目录下的所有的jar包添加到apache-tomcat-7.0.53\\webapps\\solr\\WEB-INF\\lib目录下。 第五步：配置solrHome和solrCore。 1）创建一个solrhome（存放solr所有配置文件的一个文件夹）。\\solr-4.10.3\\example\\solr目录就是一个标准的solrhome。 2）把\\solr-4.10.3\\example\\solr文件夹下的文件及目录都要复制到/usr/data/solr-home路径下。 3）在solr-home下有一个文件夹叫做collection1这就是一个solrcore。就是一个solr的实例。一个solrcore相当于mysql中一个数据库。solrcore之间是相互隔离。 i. 在solrcore中有一个文件夹叫做conf，包含了索引solr实例的配置信息。 ii. 在conf文件夹下有一个solrconfig.xml。配置实例的相关信息。如果使用默认配置可以不用做任何修改。Xml的配置信息：Lib：solr服务依赖的扩展包，默认的路径是collection1\\lib文件夹，如果没有就创建一个dataDir：配置了索引库的存放路径。默认路径是collection1\\data文件夹，如果没有data文件夹，会自动创建。requestHandler： 第六步：告诉solr服务器配置文件也就是solrHome的位置。修改web.xml使用jndi的方式告诉solr服务器。Solr/home名称必须是固定的。 vim apache-tomcat-7.0.53/webapps/solr/WEB-INF/web.xml &lt;env-entry&gt; &lt;env-entry-name&gt;solr/home&lt;/env-entry-name&gt; &lt;env-entry-value&gt;/usr/data/solr-home&lt;/env-entry-value&gt; &lt;env-entry-type&gt;java.lang.String&lt;/env-entry-type&gt; &lt;/env-entry&gt; 第七步：启动tomcat 第八步：访问http://localhost:8080/solr/ 扩展补充：再添加一个solrcoreSolr Core的管理界面。Solr Core 是Solr的一个独立运行实例单位，它可以对外提供索引和搜索服务，一个Solr工程可以运行多个SolrCore（Solr实例），一个Core对应一个索引目录。添加solrcore：第一步：复制collection1改名为collection2第二步：修改core.properties。name=collection2第三步：重启tomcat solr 后台的使用。solr后台介绍 Dashboard 仪表盘，显示了该Solr实例开始启动运行的时间、版本、系统资源、jvm等信息。 Logging Solr运行日志信息 Core Admin Solr Core的管理界面. java properties Solr在JVM 运行环境中的属性信息，包括类路径、文件编码、jvm内存设置等信息 Tread Dump 显示Solr Server中当前活跃线程信息，同时也可以跟踪线程运行栈信息 Core selector 选择一个SolrCore进行详细操作,可以进行索引的维护 Analysis 通过此界面可以测试索引分析器和搜索分析器的执行情况 Dataimport 可以定义数据导入处理器，从关系数据库将数据导入 到Solr索引库中 Document 通过此菜单可以创建索引、更新索引、删除索引等操作，界面如下: /update表示更新索引，solr默认根据id（唯一约束）域来更新Document的内容，如果根据id值搜索不到id域则会执行添加操作，如果找到则更新. Query 通过/select执行搜索索引，必须指定“q”查询条件方可搜索 管理索引库 添加/更新文档 删除文档 删除索引格式如下：1） 删除制定ID的索引 &lt;delete&gt; &lt;id&gt;8&lt;/id&gt; &lt;/delete&gt; &lt;commit/&gt; 2） 删除查询到的索引数据 &lt;delete&gt; &lt;query&gt;name:张三&lt;/query&gt; &lt;/delete&gt; &lt;commit/&gt; 3） 删除所有索引数据 &lt;delete&gt; &lt;query&gt;*:*&lt;/query&gt; &lt;/delete&gt; &lt;commit/&gt; 使用solrJ维护索引库。 solrj是访问Solr服务的java客户端，提供索引和搜索的请求方法，SolrJ通常在嵌入在业务系统中，通过SolrJ的API接口操作Solr服务，如下图 添加jar依赖&lt;dependency&gt; &lt;groupId&gt;org.apache.solr&lt;/groupId&gt; &lt;artifactId&gt;solr-solrj&lt;/artifactId&gt; &lt;version&gt;4.10.3&lt;/version&gt; &lt;/dependency&gt; 添加文档@Test public void addDocument() throws Exception { //和solr服务器创建连接 //参数：solr服务器的地址 SolrServer solrServer = new HttpSolrServer(&quot;http://localhost:8080/solr/collection1&quot;); //创建一个文档对象 SolrInputDocument document = new SolrInputDocument(); //向文档中添加域 //第一个参数：域的名称，域的名称必须是在schema.xml中定义的 //第二个参数：域的值 document.addField(&quot;id&quot;, &quot;0001&quot;); document.addField(&quot;title&quot;, &quot;使用solrJ添加的文档&quot;); document.addField(&quot;content&quot;, &quot;文档的内容001&quot;); //把document对象添加到索引库中 solrServer.add(document); //提交修改 solrServer.commit(); } 删除文档@Test public void deleteIndex() throws Exception, IOException{ //获取solr的服务器 用于连接solr项目 SolrServer solrServer = new HttpSolrServer(&quot;http://localhost:8080/solr/collection1&quot;); //solrServer.deleteById(&quot;1&quot;);//根据id删除 solrServer.deleteByQuery(&quot;id:0001&quot;);//根据条件删除 //solrServer.deleteByQuery(&quot;*:*&quot;);//全删 solrServer.commit(); } 修改文档 在solrJ中修改没有对应的update方法，只有add方法，只需要添加一条新的文档，和被修改的文档id一致就，可以修改了。本质上就是先删除后添加。 查询文档@Test public void searchIndex() throws Exception, IOException{ //获取solr的服务器 用于连接solr项目 SolrServer solrServer = new HttpSolrServer(&quot;http://localhost:8080/solr/collection1&quot;); //设置查询条件 SolrQuery solrQuery = new SolrQuery(); solrQuery.setQuery(&quot;*:*&quot;); //执行查询 QueryResponse queryResponse = solrServer.query(solrQuery); //获取结果 SolrDocumentList results = queryResponse.getResults(); System.out.println(&quot;总记录数:&quot;+results.getNumFound()); for (SolrDocument doc : results) { System.out.println(doc.get(&quot;id&quot;)); System.out.println(doc.get(&quot;name&quot;)); System.out.println(doc.get(&quot;content&quot;)); } }","link":"/2017/06/03/framework/lucene/solr/"},{"title":"lucene","text":"lucene系统架构 特点 灵活的接口函数 分块索引和批量索引 数据源灵活多样 索引字段可以定制 索引文件与平台无关 面向对象的系统架构 lucene基础 数据分类 我们生活中的数据总体分为两种：结构化数据和非结构化数据。 结构化数据：指具有固定格式或有限长度的数据，如数据库，元数据等。 非结构化数据：指不定长或无固定格式的数据，如邮件，word文档等磁盘上的文件 结构化数据搜索 常见的结构化数据也就是数据库中的数据,有行有列而且数据格式、数据长度都是固定的。在数据库中搜索很容易实现，通常都是使用sql语句进行查询，而且能很快的得到查询结果。 非结构化数据查询方法 顺序扫描法(Serial Scanning) 所谓顺序扫描，比如要找内容包含某一个字符串的文件，就是一个文档一个文档的看，对于每一个文档，从头看到尾，如果此文档包含此字符串，则此文档为我们要找的文件，接着看下一个文件，直到扫描完所有的文件。如利用windows的搜索也可以搜索文件内容，只是相当的慢。 全文检索(Full-text Search) 将非结构化数据中的一部分信息提取出来，重新组织，使其变得有一定结构，然后对此有一定结构的数据进行搜索，从而达到搜索相对较快的目的。这部分从非结构化数据中提取出的然后重新组织的信息，我们称之索引。 这种先建立索引，再对索引进行搜索的过程就叫全文检索(Full-text Search)。 虽然创建索引的过程也是非常耗时的，但是索引一旦创建就可以多次使用，全文检索主要处理的是查询，所以耗时间创建索引是值得的。 应用场景 对于数据量大、数据结构不固定的数据可采用全文检索方式搜索，比如： 1、搜索引擎百度 搜狗 360 谷歌 2、站内搜索淘宝、 京东、微博、论坛 Lucene的创新之处大部分的搜索（数据库）引擎都是用B树结构来维护索引，索引的更新会导致大量的IO操作，Lucene在实现中，对此稍微有所改进：不是维护一个索引文件，而是在扩展索引的时候不断创建新的索引文件，然后定期的把这些新的小索引文件合并到原先的大索引中（针对不同的更新策略，批次的大小可以调整），这样在不影响检索的效率的前提下，提高了索引的效率。 lucene经典应用 Eclipse-Eclipse 的帮助系统的搜索功能。 Jive-一个广受欢迎的开放的源码的论坛项目,其目标是建设一个开放结构的、强壮的、易于扩展的基于JSP的论坛。Jive的搜索使用了lucene搜索引擎。 Cocoon-基于XML的web发布框架，全文检索部分使用了Lucene。 lucene下载 Lucene是apache下的一个开放源代码的全文检索引擎工具包。提供了完整的查询引擎和索引引擎，部分文本分析引擎。下载地址:https://lucene.apache.org/core/downloads.html lucene使用在全文索引工具中，都是由这样的三部分组成 索引部分 分词部分 搜索部分 1、绿色表示索引过程，对要搜索的原始内容进行索引构建一个索引库，索引过程包括：确定原始内容即要搜索的内容采集文档创建文档分析文档索引文档 2、红色表示搜索过程，从索引库中搜索内容，搜索过程包括：用户通过搜索界面创建查询执行搜索，从索引库搜索渲染搜索结果 索引建立 对文档索引的过程，将用户要搜索的文档内容进行索引，索引存储在索引库（index）中。这里我们要搜索的文档是磁盘上的文本文件，根据案例描述：凡是文件名或文件内容包括关键字的文件都要找出来，这里要对文件名和文件内容创建索引。1、获得原始文档 原始文档是指要索引和搜索的内容。原始内容包括互联网上的网页、数据库中的数据、磁盘上的文件等。 从互联网上(网页)、数据库(SQL)、文件系统(IO)中等获取需要搜索的原始信息，这个过程就是信息采集，信息采集的目的是为了对原始内容进行索引。 在Internet上采集信息的软件通常称为爬虫或蜘蛛，也称为网络机器人，爬虫访问互联网上的每一个网页，将获取到的网页内容存储起来。 Nutch:(http://lucene.apache.org/nutch), Nutch是apache的一个子项目，包括大规模爬虫工具，能够抓取和分辨web网站数据。jsoup（http://jsoup.org/ ），jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。heritrix（http://sourceforge.net/projects/archive-crawler/files/），Heritrix 是一个由 java 开发的、开源的网络爬虫，用户可以使用它来从网上抓取想要的资源。其最出色之处在于它良好的可扩展性，方便用户实现自己的抓取逻辑。 2、建文档对象 获取原始内容的目的是为了索引，在索引前需要将原始内容创建成文档（Document），文档中包括一个一个的域（Field），域中存储内容。 一个Document对象中放的是:一个网页内容、或一个文件内容、或表中的一条数据这里我们可以将磁盘上的一个文件当成一个document，Document中包括一些Field（file_name文件名称、file_path文件路径、file_size文件大小、file_content文件内容）。 3、分析文档 将原始内容创建为包含域（Field）的文档（document），需要再对域中的内容进行分析，分析的过程是经过对原始文档提取单词、将字母转为小写、去除标点符号、去除停用词等过程生成最终的语汇单元，可以将语汇单元理解为一个一个的单词。 比如下边的文档经过分析如下： 原文档内容： Lucene is a Java full-text search engine. Lucene is not a complete application, but rather a code library and API that can easily be used to add search capabilities to applications. 分析后得到的语汇单元： lucene、java、full、search、engine。。。。 每个单词叫做一个Term，不同的域中拆分出来的相同的单词是不同的term。term中包含两部分一部分是文档的域名，另一部分是单词的内容。例如：文件名中包含apache和文件内容中包含的apache是不同的term。举例:一个文件包含的信息:1、文件名称2、文件大小3、文件路径4、文件内容一个网页包含的信息:1、网络地址URL2、网页标题3、网页内容一个sql数据包含的信息:一条数据每个列的内容 4、创建索引 对所有文档分析得出的语汇单元进行索引，索引的目的是为了搜索，最终要实现只搜索被索引的语汇单元从而找到Document（文档）。 注意：创建索引是对语汇单元索引，通过词语找文档，这种索引的结构叫倒排索引结构。 传统方法是根据文件找到该文件的内容，在文件内容中匹配搜索关键字，这种方法是顺序扫描方法，数据量大、搜索慢。 倒排索引结构是根据内容（词语）找文档，倒排索引结构也叫反向索引结构，包括索引和文档两部分，索引即词汇表，它的规模较小，而文档集合较大 查询索引 查询索引也是搜索的过程。搜索就是用户输入关键字，从索引（index）中进行搜索的过程。根据关键字搜索索引，根据索引找到对应的文档，从而找到要搜索的内容。1、用户查询接口 全文检索系统提供用户搜索的界面供用户提交搜索的关键字，搜索完成展示搜索结果 2、创建查询 用户输入查询关键字执行搜索之前需要先构建一个查询对象，查询对象中可以指定查询要搜索的Field文档域、查询关键字等，查询对象会生成具体的查询语法，例如：语法 “fileName:lucene”表示要搜索Field域的内容为“lucene”的文档 3、执行查询 搜索索引过程：根据查询语法在倒排索引词典表中分别找出对应搜索词的索引，从而找到索引所链接的文档链表。比如搜索语法为“fileName:lucene”表示搜索出fileName域中包含Lucene的文档。搜索过程就是在索引上查找域为fileName，并且关键字为Lucene的term，并根据term找到文档id列表。 4、渲染结果 以一个友好的界面将查询结果展示给用户，用户根据搜索结果找自己想要的信息，为了帮助用户很快找到自己的结果，提供了很多展示的效果，比如搜索结果中将关键字高亮显示，百度提供的快照等。 核心API 索引过程中的核心类 Document文档：他是承载数据的实体（他可以集合信息域Field），是一个抽象的概念，一条记录经过索引之后，就是以一个Document的形式存储在索引文件中的。 Field：Field 索引中的每一个Document对象都包含一个或者多个不同的域(Field),域是由域名(name)和域值(value)对组成，每一个域都包含一段相应的数据信息。 IndexWriter：索引过程的核心组件。这个类用于创建一个新的索引并且把文档 加到已有的索引中去，也就是写入操作。 Directroy：是索引的存放位置，是个抽象类。具体的子类提供特定的存储索引的地址。（FSDirectory 将索引存放在指定的磁盘中，RAMDirectory ·将索引存放在内存中。） Analyzer：分词器，在文本被索引之前，需要经过分词器处理，他负责从将被索引的文档中提取词汇单元，并剔除剩下的无用信息（停止词汇），分词器十分关键，因为不同的分词器，解析相同的文档结果会有很大的不同。Analyzer是一个抽象类，是所有分词器的基类。 搜索过程中的核心类 IndexSearcher ：IndexSearcher 调用它的search方法，用于搜索IndexWriter 所创建的索引。 Term ：Term 使用于搜索的一个基本单元。 Query ： Query Lucene中含有多种查询（Query）子类。它们用于查询条件的限定其中TermQuery 是Lucene提供的最基本的查询类型，也是最简单的，它主要用来匹配在指定的域（Field）中包含了特定项(Term)的文档。 **TermQuery :**Query下的一个子类TermQuery（单词条查询） ，Query lucene中有很多类似的子类。 TopDocs: 是一个存放有序搜索结果指针的简单容器，在这里搜索的结果是指匹配一个查询条件的一系列的文档。 入门例子 核心jar依赖&lt;dependency&gt; &lt;groupId&gt;org.apache.lucene&lt;/groupId&gt; &lt;artifactId&gt;lucene-core&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--一般分词器，适用于英文分词--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.lucene&lt;/groupId&gt; &lt;artifactId&gt;lucene-analyzers-common&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.lucene&lt;/groupId&gt; &lt;artifactId&gt;lucene-queryparser&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.1&lt;/version&gt; &lt;/dependency&gt; 创建索引@Test public void createIndex() throws Exception { //1、创建一个Director对象，指定索引库保存的位置。 //把索引库保存在内存中 //Directory directory = new RAMDirectory(); //把索引库保存在磁盘 Directory directory = FSDirectory.open(new File(&quot;/Users/sxm/Downloads/indextest&quot;).toPath()); //2、基于Directory对象创建一个IndexWriter对象 IndexWriterConfig config = new IndexWriterConfig(new StandardAnalyzer()); IndexWriter indexWriter = new IndexWriter(directory, config); //3、读取磁盘上的文件，对应每个文件创建一个文档对象。 File dir = new File(&quot;/Users/sxm/Downloads/searchsource&quot;); File[] files = dir.listFiles(); for (File f : files) { //取文件名 String fileName = f.getName(); //文件的路径 String filePath = f.getPath(); //创建Field //参数1：域的名称，参数2：域的内容，参数3：是否存储 Field fieldName = new TextField(&quot;name&quot;, fileName, Field.Store.YES); //Field fieldPath = new TextField(&quot;path&quot;, filePath, Field.Store.YES); Field fieldPath = new StoredField(&quot;path&quot;, filePath); //Field fieldContent = new TextField(&quot;content&quot;, FileUtils.readFileToString(f),Field.Store.YES); Field fieldContent = new TextField(&quot;content&quot;, new FileReader(f)); Field fieldSize = new TextField(&quot;size&quot;, f.length() + &quot;&quot;, Field.Store.YES); //创建文档对象 Document document = new Document(); //向文档对象中添加域 document.add(fieldName); document.add(fieldPath); document.add(fieldContent); document.add(fieldSize); //5、把文档对象写入索引库 indexWriter.addDocument(document); } //6、关闭indexwriter对象 indexWriter.close(); } 搜索索引@Test public void searchIndex() throws Exception { //1、创建一个Director对象，指定索引库的位置 Directory directory = FSDirectory.open(new File(&quot;/Users/sxm/Downloads/indextest&quot;).toPath()); //2、创建一个IndexReader对象 IndexReader indexReader = DirectoryReader.open(directory); //3、创建一个IndexSearcher对象，构造方法中的参数indexReader对象。 IndexSearcher indexSearcher = new IndexSearcher(indexReader); //4、创建一个Query对象，TermQuery Query query = new TermQuery(new Term(&quot;content&quot;, &quot;java&quot;)); //5、执行查询，得到一个TopDocs对象 //参数1：查询对象 参数2：查询结果返回的最大记录数 TopDocs topDocs = indexSearcher.search(query, 10); //6、取查询结果的总记录数 System.out.println(&quot;查询总记录数：&quot; + topDocs.totalHits); //7、取文档列表 ScoreDoc[] scoreDocs = topDocs.scoreDocs; //8、打印文档中的内容 for (ScoreDoc doc : scoreDocs) { //取文档id int docId = doc.doc; //根据id取文档对象 Document document = indexSearcher.doc(docId); System.out.println(document.get(&quot;name&quot;)); System.out.println(document.get(&quot;path&quot;)); System.out.println(document.get(&quot;size&quot;)); System.out.println(&quot;-----------------&quot;); } //9、关闭IndexReader对象 indexReader.close(); } lukeall-查看索引的可视化界面工具下载地址：https://github.com/DmitryKey/luke/releases nohup java -jar lukeall.jar &gt; /dev/null 2&gt;&amp;1 &amp; lukeall lukeall document lukeall search 分析器 从一个Reader字符流开始，创建一个基于Reader的Tokenizer分词器，经过三个TokenFilter生成语汇单元Token。要看分析器的分析效果，只需要看Tokenstream中的内容就可以了。每个分析器都有一个方法tokenStream，返回一个tokenStream对象。 StandardAnalyzer标准分析器public void doStandardAnalyzerToken(String text) throws IOException { Analyzer analyzer = new StandardAnalyzer(); TokenStream tokenStream = analyzer.tokenStream(null,text); CharTermAttribute charTermAttribute = tokenStream.addAttribute(CharTermAttribute.class); tokenStream.reset();//设置指针 while (tokenStream.incrementToken()){ System.out.print(charTermAttribute + &quot;|&quot;); } tokenStream.end(); tokenStream.close(); analyzer.close(); } @Test public void testLucene() throws IOException { String englishText = &quot;I'm fine,thanks!&quot;; String chineseText = &quot;中国是一个伟大的国家!&quot;; //标准分析器 System.out.print(&quot;英文分词效果:\\n&quot; ); doStandardAnalyzerToken(englishText); System.out.print(&quot;\\n中文分词效果:\\n&quot;); doStandardAnalyzerToken(chineseText); } // 输出结果： // 英文分词效果: // i'm|fine|thanks| // 中文分词效果: // 中|国|是|一|个|伟|大|的|国|家| CJKAnalyzer中日韩分词器中文被按两个字，拆分 public void doCJKAnalyzerToken(String text) throws IOException { Analyzer analyzer = new CJKAnalyzer(); TokenStream tokenStream = analyzer.tokenStream(null,text); CharTermAttribute charTermAttribute = tokenStream.addAttribute(CharTermAttribute.class); tokenStream.reset();//设置指针 while (tokenStream.incrementToken()){ System.out.print(charTermAttribute + &quot;|&quot;); } tokenStream.end(); tokenStream.close(); analyzer.close(); } @Test public void testLucene() throws IOException { String englishText = &quot;I'm fine,thanks!&quot;; String chineseText = &quot;中国是一个伟大的国家!&quot;; //标准分析器 System.out.print(&quot;英文分词效果:\\n&quot; ); doCJKAnalyzerToken(englishText); System.out.print(&quot;\\n中文分词效果:\\n&quot;); doCJKAnalyzerToken(chineseText); } // 输出结果: // 英文分词效果: // i'm|fine|thanks| // 中文分词效果: // 中国|国是|是一|一个|个伟|伟大|大的|的国|国家| SmartChineseAnalyzer 上边两个分词器无法满足中文分词需求，SmartChineseAnalyzer对中文支持较好，但扩展性差，扩展词库，禁用词库和同义词库等不好处理,处理英文也容易出现缺字母现象 &lt;dependency&gt; &lt;groupId&gt;org.apache.lucene&lt;/groupId&gt; &lt;artifactId&gt;lucene-analyzers-smartcn&lt;/artifactId&gt; &lt;version&gt;4.10.3&lt;/version&gt; &lt;/dependency&gt; public void doSmartChineseAnalyzerToken(String text) throws IOException { Analyzer analyzer = new SmartChineseAnalyzer(); TokenStream tokenStream = analyzer.tokenStream(null,text); CharTermAttribute charTermAttribute = tokenStream.addAttribute(CharTermAttribute.class); tokenStream.reset();//设置指针 while (tokenStream.incrementToken()){ System.out.print(charTermAttribute + &quot;|&quot;); } tokenStream.end(); tokenStream.close(); analyzer.close(); } @Test public void testLucene() throws IOException { String englishText = &quot;Apache I'm fine,thanks!&quot;; String chineseText = &quot;中国是一个伟大的国家,整个民族自强不屈,艰苦奋斗,屹立于民族之林!&quot;; //标准分析器 System.out.print(&quot;英文分词效果:\\n&quot; ); doSmartChineseAnalyzerToken(englishText); System.out.print(&quot;\\n中文分词效果:\\n&quot;); doSmartChineseAnalyzerToken(chineseText); } // 输出结果： // 英文分词效果: // apach|i|m|fine|thank| // 中文分词效果: // 中国|是|一个|伟大|的|国家|整个|民族|自强|不屈|艰苦奋斗|屹立|于|民族之林| 其它的针对中文的三方分析器jar paoding： 庖丁解牛最新版在 https://code.google.com/p/paoding/ 中最多支持Lucene 3.0，且最新提交的代码在 2008-06-03，在svn中最新也是2010年提交，已经过时，不予考虑。 mmseg4j：最新版已从 https://code.google.com/p/mmseg4j/ 移至 https://github.com/chenlb/mmseg4j-solr，支持Lucene 4.10，且在github中最新提交代码是2014年6月，从09年～14年一共有：18个版本，也就是一年几乎有3个大小版本，有较大的活跃度，用了mmseg算法。 IK-analyzer： 最新版在https://code.google.com/p/ik-analyzer/上，支持Lucene 4.10从2006年12月推出1.0版开始， IKAnalyzer已经推出了4个大版本。最初，它是以开源项目Luence为应用主体的，结合词典分词和文法分析算法的中文分词组件。从3.0版本开 始，IK发展为面向Java的公用分词组件，独立于Lucene项目，同时提供了对Lucene的默认优化实现。在2012版本中，IK实现了简单的分词 歧义排除算法，标志着IK分词器从单纯的词典分词向模拟语义分词衍化。 但是也就是2012年12月后没有在更新。 ansj_seg：最新版本在 https://github.com/NLPchina/ansj_seg tags仅有1.1版本，从2012年到2014年更新了大小6次，但是作者本人在2014年10月10日说明：“可能我以后没有精力来维护ansj_seg了”，现在由”nlp_china”管理。2014年11月有更新。并未说明是否支持Lucene，是一个由CRF（条件随机场）算法所做的分词算法。 imdict-chinese-analyzer：最新版在 https://code.google.com/p/imdict-chinese-analyzer/ ， 最新更新也在2009年5月，下载源码，不支持Lucene 4.10。是利用HMM（隐马尔科夫链）算法。 Jcseg：最新版本在git.oschina.net/lionsoul/jcseg，支持Lucene 4.10，作者有较高的活跃度。利用mmseg算法。 IK-analyzer三方流行的中文分词器&lt;dependency&gt; &lt;groupId&gt;org.wltea&lt;/groupId&gt; &lt;artifactId&gt;IKAnalyzer&lt;/artifactId&gt; &lt;version&gt;2012FF_hf1&lt;/version&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;systemPath&gt;${project.basedir}/lib/IKAnalyzer2012FF_u1.jar&lt;/systemPath&gt; &lt;/dependency&gt; 项目classpath下添加配置文件IKAnalyzer.cfg.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE properties SYSTEM &quot;http://java.sun.com/dtd/properties.dtd&quot;&gt; &lt;properties&gt; &lt;comment&gt;IK Analyzer 扩展配置&lt;/comment&gt; &lt;!--用户可以在这里配置自己的扩展字典 &lt;entry key=&quot;ext_dict&quot;&gt;ext.dic;&lt;/entry&gt; --&gt; &lt;!--用户可以在这里配置自己的扩展停止词字典--&gt; &lt;entry key=&quot;ext_stopwords&quot;&gt;stopword.dic;&lt;/entry&gt; &lt;/properties&gt; stopword.dic文件也需要添加到项目classpath下，扩展配置停止字词,这里面配置的不会变成term词语ext.dic 这个可以添加一些专有名词，这样分词器可以解析成term词语 public void doIKAnalyzerToken(String text) throws IOException { Analyzer analyzer = new IKAnalyzer(); TokenStream tokenStream = analyzer.tokenStream(null,text); CharTermAttribute charTermAttribute = tokenStream.addAttribute(CharTermAttribute.class); tokenStream.reset();//设置指针 while (tokenStream.incrementToken()){ System.out.print(charTermAttribute + &quot;|&quot;); } tokenStream.end(); tokenStream.close(); analyzer.close(); } @Test public void testLucene() throws IOException { String englishText = &quot;Apache I'm fine,thanks!&quot;; String chineseText = &quot;中国是一个伟大的国家,整个民族自强不屈,艰苦奋斗,屹立于民族之林!&quot;; //标准分析器 System.out.print(&quot;英文分词效果:\\n&quot; ); doIKAnalyzerToken(englishText); System.out.print(&quot;\\n中文分词效果:\\n&quot;); doIKAnalyzerToken(chineseText); } // 输出结果： // 英文分词效果: // 加载扩展停止词典：stopword.dic // apache|i|m|fine|thanks| // 中文分词效果: // 中国|国是|一个|一|个|伟大|国家|整个|民族|自强|不屈|艰苦奋斗|艰苦|奋斗|屹立|立于|民族之林|民族|之|林| 分词器的使用时机 1、需要查询就需要分词 2、查询时也需要分词 索引库的维护添加文档。示例添加： @Test public void addDocument() throws Exception { //索引库存放路径 Directory directory = FSDirectory.open(new File(&quot;/Users/sxm/indextest&quot;)); IndexWriterConfig config = new IndexWriterConfig(Version.LATEST, new IKAnalyzer()); //创建一个indexwriter对象 IndexWriter indexWriter = new IndexWriter(directory, config); //创建一个Document对象 Document document = new Document(); //向document对象中添加域。 //不同的document可以有不同的域，同一个document可以有相同的域。 document.add(new TextField(&quot;filename&quot;, &quot;新添加的文档&quot;, Field.Store.YES)); document.add(new TextField(&quot;content&quot;, &quot;新添加的文档的内容&quot;, Field.Store.NO)); document.add(new TextField(&quot;content&quot;, &quot;新添加的文档的内容第二个content&quot;, Field.Store.YES)); document.add(new TextField(&quot;content1&quot;, &quot;新添加的文档的内容要能看到&quot;, Field.Store.YES)); //添加文档到索引库 indexWriter.addDocument(document); //关闭indexwriter indexWriter.close(); } Field域的属性 是否分析：是否对域的内容进行分词处理。前提是我们要对域的内容进行查询。 是否索引：将Field分析后的词或整个Field值进行索引，只有索引方可搜索到。比如：商品名称、商品简介分析后进行索引，订单号、身份证号不用分析但也要索引，这些将来都要作为查询条件。 是否存储：将Field值存储在文档中，存储在文档中的Field才可以从Document中获取。比如：商品名称、订单号，凡是将来要从Document中获取的Field都要存储。是否存储的标准：是否要将内容展示给用户 Field类 数据类型 Analyzed是否分析 Indexed是否索引 Stored是否存储 说明 StringField(FieldName, FieldValue,Store.YES) 字符串 N Y Y或N 这个Field用来构建一个字符串Field，但是不会进行分析，会将整个串存储在索引中，比如(订单号,姓名等)是否存储在文档中用Store.YES或Store.NO决定 LongField(FieldName, FieldValue,Store.YES) Long型 Y Y Y或N 这个Field用来构建一个Long数字型Field，进行分析和索引，比如(价格)是否存储在文档中用Store.YES或Store.NO决定 StoredField(FieldName, FieldValue) 重载方法，支持多种类型 N N Y 这个Field用来构建不同类型Field不分析，不索引，但要Field存储在文档中 TextField(FieldName, FieldValue, Store.NO)或TextField(FieldName, reader) 字符串或流 Y Y Y或N 如果是一个Reader, lucene猜测内容比较多,会采用Unstored的策略. 删除文档。示例删除： //删除全部索引 @Test public void deleteAllIndex() throws Exception { IndexWriter indexWriter = getIndexWriter(); //删除全部索引 indexWriter.deleteAll(); //关闭indexwriter indexWriter.close(); } //根据查询条件删除索引 @Test public void deleteIndexByQuery() throws Exception { IndexWriter indexWriter = getIndexWriter(); //创建一个查询条件 Query query = new TermQuery(new Term(&quot;filename&quot;, &quot;apache&quot;)); //根据查询条件删除 indexWriter.deleteDocuments(query); //关闭indexwriter indexWriter.close(); } 修改文档。示例修改 @Test public void updateIndex() throws Exception { IndexWriter indexWriter = getIndexWriter(); //创建一个Document对象 Document document = new Document(); //向document对象中添加域。 //不同的document可以有不同的域，同一个document可以有相同的域。 document.add(new TextField(&quot;filename&quot;, &quot;要更新的文档&quot;, Store.YES)); document.add(new TextField(&quot;content&quot;, &quot;Lucene 简介 Lucene 是一个基于 Java 的全文信息检索工具包,它不是一个完整的搜索应用程序,而是为你的应用程序提供索引和搜索功能。&quot;, Store.YES)); indexWriter.updateDocument(new Term(&quot;content&quot;, &quot;java&quot;), document); //关闭indexWriter indexWriter.close(); } Lucene的查询 对要搜索的信息创建Query查询对象，Lucene会根据Query查询对象生成最终的查询语法，类似关系数据库Sql语法一样Lucene也有自己的查询语法，比如：“name:lucene”表示查询Field的name为“lucene”的文档信息。可通过两种方法创建查询对象,第一种是使用Lucene提供Query子类，第二种是使用QueryParse解析查询表达式 使用 Query的子类查询。 Query是一个抽象类，lucene提供了很多查询对象，比如TermQuery项精确查询，NumericRangeQuery数字范围查询等。 1)、MatchAllDocsQuery 2)、TermQuery。 3)、NumericRangeQuery 4)、BooleanQuery.//使用MatchAllDocsQuery查询索引目录中的所有文档 @Test public void testMatchAllDocsQuery() throws Exception { IndexSearcher indexSearcher = getIndexSearcher(); //创建查询条件 Query query = new MatchAllDocsQuery(); //执行查询 printResult(query, indexSearcher); } TermQuery，通过项查询，TermQuery不使用分析器所以建议匹配不分词的Field域查询，比如订单号、分类ID号等。指定要查询的域和要查询的关键词//使用Termquery查询 @Test public void testTermQuery() throws Exception { IndexSearcher indexSearcher = getIndexSearcher(); //创建查询对象 Query query = new TermQuery(new Term(&quot;content&quot;, &quot;lucene&quot;)); //执行查询 TopDocs topDocs = indexSearcher.search(query, 10); //共查询到的document个数 System.out.println(&quot;查询结果总数量：&quot; + topDocs.totalHits); //遍历查询结果 for (ScoreDoc scoreDoc : topDocs.scoreDocs) { Document document = indexSearcher.doc(scoreDoc.doc); System.out.println(document.get(&quot;filename&quot;)); //System.out.println(document.get(&quot;content&quot;)); System.out.println(document.get(&quot;path&quot;)); System.out.println(document.get(&quot;size&quot;)); } //关闭indexreader indexSearcher.getIndexReader().close(); } //数值范围查询 Query query = NumericRangeQuery.newLongRange(&quot;size&quot;, 1l, 1000l, true, true); //可以组合查询条件,创建一个布尔查询对象 BooleanQuery query = new BooleanQuery(); //创建第一个查询条件 Query query1 = new TermQuery(new Term(&quot;filename&quot;, &quot;apache&quot;)); Query query2 = new TermQuery(new Term(&quot;content&quot;, &quot;apache&quot;)); //组合查询条件 query.add(query1, Occur.MUST); query.add(query2, Occur.MUST); // Occur.MUST：必须满足此条件，相当于and // Occur.SHOULD：应该满足，但是不满足也可以，相当于or // Occur.MUST_NOT：必须不满足。相当于not 使用QueryParsers QueryParse会将用户输入的查询表达式解析成Query对象实例,通过QueryParser可以创建Query，QueryParser提供一个Parse方法，此方法可以直接根据查询语法来查询。查询需要使用到分析器。建议创建索引时使用的分析器和查询索引时使用的分析器要一致。jar依赖:&lt;dependency&gt; &lt;groupId&gt;org.apache.lucene&lt;/groupId&gt; &lt;artifactId&gt;lucene-queryparser&lt;/artifactId&gt; &lt;version&gt;4.10.3&lt;/version&gt; &lt;/dependency&gt; 1)、QueryParserQueryParser queryParser = new QueryParser(&quot;name&quot;, new IKAnalyzer()); Query query = queryParser.parse(&quot;name:lucene&quot;); // QueryParser queryParser2 = new QueryParser(&quot;content&quot;, new IKAnalyzer()); Query query2 = queryParser2.parse(&quot;Lucene是java开发的&quot;); 2)、MulitFieldQueryParser。@Test public void testMultiFiledQueryParser() throws Exception { //可以指定默认搜索的域是多个 String[] fields = {&quot;filename&quot;, &quot;content&quot;}; //创建一个MulitFiledQueryParser对象 MultiFieldQueryParser queryParser = new MultiFieldQueryParser(fields, new IKAnalyzer()); Query query = queryParser.parse(&quot;java and apache&quot;); } 查询语法 1、基础的查询语法，关键词查询： 域名+“：”+搜索的关键字，例如：content:java 2、范围查询 域名+“:”+[最小值 TO 最大值] 例如：size:[1 TO 1000] 范围查询在lucene中不支持数值类型，支持字符串类型。在solr中支持数值类型。 3、组合条件查询 1）+条件1 +条件2：两个条件之间是并且的关系and 例如：+filename:apache +content:apache 2）+条件1 条件2：必须满足第一个条件，应该满足第二个条件 例如：+filename:apache content:apache 3）条件1 条件2：两个条件满足其一即可。例如：filename:apache content:apache 4）-条件1 条件2：必须不满足条件1，要满足条件2 例如：-filename:apache content:apache 相关度排序(竞价排序) 相关度排序是查询结果按照与查询关键字的相关性进行排序，越相关的越靠前。比如搜索“Lucene”关键字，与该关键字最相关的文章应该排在前边。 相关度打分 Lucene对查询关键字和索引文档的相关度进行打分，得分高的就排在前边。如何打分呢？Lucene是在用户进行检索时实时根据搜索的关键字计算出来的，分两步： 1）计算出词（Term）的权重 2）根据词的权重值，采用空间向量模型算法计算文档相关度得分。 什么是词的权重？ 通过索引部分的学习明确索引的最小单位是一个Term(索引词典中的一个词)，搜索也是要从Term中搜索，再根据Term找到文档，Term对文档的重要性称为权重，影响Term权重有两个因素： Term Frequency (tf)： 指此Term在此文档中出现了多少次。tf 越大说明越重要。词(Term)在文档中出现的次数越多，说明此词(Term)对该文档越重要，如“Lucene”这个词，在文档中出现的次数很多，说明该文档主要就是讲Lucene技术的。 Document Frequency (df) 即有多少文档包含次Term。df 越大说明越不重要。 比如，在一篇英语文档中，this出现的次数更多，就说明越重要吗？不是的，有越多的文档包含此词(Term), 说明此词(Term)太普通，不足以区分这些文档，因而重要性越低。 设置boost影响打分结果 boost是一个加权值（默认加权值为1.0f），它可以影响权重的计算。 在索引时对某个文档的Field域设置加权值高，在搜索时匹配到这个Field就可能排在前边。lucene在执行搜索时对某个域进行加权，在进行组合域查询时，匹配到加权值高的域最后计算的相关度得分就高。 如果希望某些文档更重要，当此文档中包含所要查询的词则应该得分较高，这样相关度排序可以排在前边，可以在创建索引时设定文档中某些域（Field）的boost值来实现，如果不进行设定，则Field Boost默认为1.0f。一旦设定，除非删除此文档，否则无法改变。 代码：field. setBoost(XXXf); XXX即权值。if(file_name.equals(&quot;springmvc.txt&quot;)){ //设置比默认值 1.0大的 field_file_content.setBoost(20.0f); } if(file_name.equals(&quot;spring_README.txt&quot;)){ //设置比默认值 1.0大的 field_file_content.setBoost(30.0f); } //向文档中添加Field document.add(field_file_content);","link":"/2017/06/02/framework/lucene/lucene/"},{"title":"SpringBatch批处理框架","text":"什么是批处理面向海量数据离线、自动、不需要人工参与。高效处理复杂数据分析基础设施 批处理与大数据Mapreduce 批处理与消息传递互补和整合 批处理的流程 Spring Batch特点满足批处理需求基于 Spring和Java轻量级组件和模式文件、数据库、读写方式健壮和可靠跟踪、重试、跳过、重启 Spring Batch－应用定期提交批处理任务按顺序处理依赖的任务部分处理批处理事务支持消息传递等基础设施集成 Spring Batch－离线并行并行计算,分片操作SpringBatch与Hadoop整合离线服务 Spring Batch－流式流式处理SpringBatch与消息中间件整合 Spring Batch－技术目标Spring编程模型管理流程，专注业务通用核心的服务以接口形式提供完整的默认核心执行接囗实现明确分离批处理的执行环境和应用部署模型简单 Spring Batch基本架构 Spring Batch 领域模型 Spring Batch集成 案例介绍 ETL 数据导入 基本模型 扩展模型 基本接口 读取文本 实现mapper 配置reader 实现writer 配置job 解压文件 启动job 启动job基础配置 中间遇到异常处理","link":"/2017/05/03/framework/spring/springbatch%E6%89%B9%E5%A4%84%E7%90%86/"},{"title":"Spring框架-整合其它框架","text":"JUnit4测试Spring 添加依赖jar包&lt;dependency&gt; &lt;groupId&gt;org.hamcrest&lt;/groupId&gt; &lt;artifactId&gt;hamcrest-all&lt;/artifactId&gt; &lt;version&gt;1.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;4.3.12.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; 添加执行器和Spring环境上下文import org.junit.runner.RunWith; import org.springframework.test.context.ContextConfiguration; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; import org.junit.Test; @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(locations = &quot;classpath:bean.xml&quot;) public class Spring4Test { @Test public void testResource(){ //test ..... } }","link":"/2013/11/11/framework/spring/spring%E6%A1%86%E6%9E%B6-%E6%95%B4%E5%90%88%E5%85%B6%E4%BB%96%E6%A1%86%E6%9E%B6/"},{"title":"Spring注解驱动开发","text":"容器AnnotationConfigApplicationContext 使用AnnotationConfigApplicationContext可以实现基于Java的配置类加载Spring的应用上下文。避免使用application.xml进行配置。相比XML配置，更加便捷。 AnnotationConfigApplicationContext actx = new AnnotationConfigApplicationContext(AppConfig.class);//启动加载配置类 DataSource dataSource = (DataSource) actx.getBean(&quot;dataSource&quot;); System.out.println(dataSource); DataSource dataSource1 = actx.getBean(DataSource.class); System.out.println(dataSource ==dataSource1?true:false); //返回true,默认单例模式 组件添加@Configuration注解 @Configuration相当于之前的spring容器的application.xmlimport com.ecit.domain.User; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; //配置类==spring之前application.xml的配置文件 @Configuration import com.ecit.domain.User; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; //配置类==spring之前application.xml的配置文件 @Configuration public class AppConfig { //给容器中注册一个Bean ;类型为返回值的类型，id默认是用方法名作为id,也可以通过 @Bean(name = &quot;user&quot;)指定id @Bean public User user(){ return new User(); } } @ComponentScan自动扫描组件 1.创建一个配置类，在配置类上添加 @ComponentScan 注解。该注解默认会扫描该类所在的包下所有的配置类，相当于之前的 &lt;context:component-scan&gt;。@Configuration @ComponentScan public class AppConfig { } 2.使用 ApplicationContext 的 getBeanDefinitionNames() 方法获取已经注册到容器中的 bean 的名称。 AnnotationConfigApplicationContext actx = new AnnotationConfigApplicationContext(AppConfig.class); String[] beans = actx.getBeanDefinitionNames(); for (String name: beans) { System.out.println(name); } // 输出结果: // org.springframework.context.annotation.internalConfigurationAnnotationProcessor // org.springframework.context.annotation.internalAutowiredAnnotationProcessor // org.springframework.context.annotation.internalRequiredAnnotationProcessor // org.springframework.context.annotation.internalCommonAnnotationProcessor // appConfig // org.springframework.context.annotation.ConfigurationClassPostProcessor.importAwareProcessor // org.springframework.context.annotation.ConfigurationClassPostProcessor.enhancedConfigurationProcessor 3.指定要扫描的包（使用@ComponentScan 的 valule 属性来配置），创建一个controller 包，并在该包下新建一个 UserController 类,在类上加了@Controller注解，说明该类是一个 Component。在 AppConfig 类中修改：@Configuration @ComponentScan(value = &quot;com.ecit.controller&quot;) public class AppConfig { } // 运行测试结果： // org.springframework.context.annotation.internalConfigurationAnnotationProcessor // org.springframework.context.annotation.internalAutowiredAnnotationProcessor // org.springframework.context.annotation.internalRequiredAnnotationProcessor // org.springframework.context.annotation.internalCommonAnnotationProcessor // appConfig // org.springframework.context.annotation.ConfigurationClassPostProcessor.importAwareProcessor // org.springframework.context.annotation.ConfigurationClassPostProcessor.enhancedConfigurationProcessor // userController 4.excludeFilters 和 includeFilters 的使用 使用 excludeFilters 来按照规则排除某些包的扫描。excludeFilters 的参数是一个 Filter[] 数组，然后指定 FilterType 的类型为 ANNOTATION，也就是通过注解来过滤，最后的 value 则是Controller 注解类。配置之后，在 spring 扫描的时候，就会跳过对应包下，所有被 @Controller 注解标注的类。@Configuration @ComponentScan(value = &quot;com.ecit.controller&quot;,excludeFilters = {@Filter( //示例不扫描@Controller注解的类 type = FilterType.ANNOTATION,value = Controller.class ) }) public class AppConfig { } 使用 includeFilters 来按照规则只包含某些包的扫描。在创建一个 service 的包，并创建一个 UserService 类，再加上一个 @Service 注解。@Configuration @ComponentScan(value = &quot;com.ecit&quot;,includeFilters = {@Filter( type = FilterType.ANNOTATION,value = Service.class ) }) public class AppConfig { } //运行测试结果： // org.springframework.context.annotation.internalConfigurationAnnotationProcessor // org.springframework.context.annotation.internalAutowiredAnnotationProcessor // org.springframework.context.annotation.internalRequiredAnnotationProcessor // org.springframework.context.annotation.internalCommonAnnotationProcessor // appConfig // org.springframework.context.annotation.ConfigurationClassPostProcessor.importAwareProcessor // org.springframework.context.annotation.ConfigurationClassPostProcessor.enhancedConfigurationProcessor // userController // userService 配置里面，应该是只包含 @Service 注解的类才会被注册到容器中，为什么 @Controller 注解的类也被注册了呢？这里涉及到 @ComponentScan 的一个 useDefaultFilters 属性的用法，该属性默认值为 true，也就是说 spring 默认会自动发现被 @Component、@Repository、@Service 和 @Controller 标注的类，并注册进容器中。要达到只包含某些包的扫描效果，就必须将这个默认行为给禁用掉（在 @ComponentScan 中将 useDefaultFilters 设为 false 即可）。@Configuration @ComponentScan(value = &quot;com.ecit&quot;,includeFilters = {@Filter( type = FilterType.ANNOTATION,value = Service.class ) },useDefaultFilters = false) public class AppConfig { } // 运行测试结果 // org.springframework.context.annotation.internalConfigurationAnnotationProcessor // org.springframework.context.annotation.internalAutowiredAnnotationProcessor // org.springframework.context.annotation.internalRequiredAnnotationProcessor // org.springframework.context.annotation.internalCommonAnnotationProcessor // appConfig // org.springframework.context.annotation.ConfigurationClassPostProcessor.importAwareProcessor // org.springframework.context.annotation.ConfigurationClassPostProcessor.enhancedConfigurationProcessor // userService 5.添加多种扫描规则 如果使用的 jdk8，则可以直接添加多个 @ComponentScan 来添加多个扫描规则，但是在配置类中要加上 @Configuration 注解，否则无效。@ComponentScan(value = &quot;com.ecit.controller&quot;) @ComponentScan(value = &quot;com.ecit.service&quot;) @Configuration public class AppConfig { } 也可以使用@ComponentScans来添加多个@ComponentScan从而实现添加多个扫描规则。同样，也需要加上 @Configuration 注解，否则无效。@ComponentScans(value = { @ComponentScan(value = &quot;com.ecit.controller&quot;), @ComponentScan(value = &quot;com.ecit.service&quot;)}) @Configuration public class AppConfig { } 6.添加自定义过滤规则 在前面使用过 @Filter 注解，里面的 type 属性是一个 FilterType 的枚举类型：public enum FilterType { ANNOTATION, ASSIGNABLE_TYPE, ASPECTJ, REGEX, CUSTOM; private FilterType() { } } 使用 CUSTOM 类型，就可以实现自定义过滤规则。 1、 首先创建一个实现 TypeFilter 接口的 SelfCustomTypeFilter 类，并实现其 match 方法。 public class SelfCustomTypeFilter implements TypeFilter { @Override public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException { // 获取当前扫描到的类的注解元数据 AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata(); // 获取当前扫描到的类的元数据 ClassMetadata classMetadata = metadataReader.getClassMetadata(); // 获取当前扫描到的类的资源信息 Resource resource = metadataReader.getResource(); if (classMetadata.getClassName().contains(&quot;Co&quot;)) { //这里简单对扫描到的类名进行判断，如果类名包含”Co“的就符合条件，也就会注入到容器中。 return true; } return false; } } @ComponentScan(value = &quot;com.ecit&quot;,includeFilters ={ @Filter(type = FilterType.CUSTOM,value = SelfCustomTypeFilter.class) },useDefaultFilters = false) @Configuration public class AppConfig { } // 运行测试结果 // org.springframework.context.annotation.internalConfigurationAnnotationProcessor // org.springframework.context.annotation.internalAutowiredAnnotationProcessor // org.springframework.context.annotation.internalRequiredAnnotationProcessor // org.springframework.context.annotation.internalCommonAnnotationProcessor // org.springframework.context.event.internalEventListenerProcessor // org.springframework.context.event.internalEventListenerFactory // appConfig // userController @Scope作用域和创建时机@Lazy@Configuration public class AppConfig { // prototype:多实例的(容器初始化不创建,用到时在创建,懒加载效果) // singleton:单实例的(默认值,容器初始化时就创建,要想懒加载就得组合@Lazy实现懒加载) // request:同一次请求创建一个实例 // session: 同一个sess ion创建一个实例 . @Scope(&quot;singleton&quot;) @Bean @Lazy public User user(){ return new User(); } } @Conditional来按照条件注册bean @Conditional 基于条件的自动配置，一般配合Condition接口一起使用，只有接口（一个或多个）的实现类都返回true，才装配，否则不装配,它可以用在方法上面，则只对该方法起作用。还可以用在类上面，则对该类下面的所有方法起作用 @Import三种用法 1)、@Import(要导入到容器中的组件);容器中就会自动注册这个组件，bean的id默认是全类名```java@Import({Airticle.class,User.class})@Configurationpublic class AppConfig {} - 2)、ImportSelector:返回需要导入的组件的全类名数组; ImportSelector是一个接口：返回需要的组件的全类名的数组，需要实现 ImportSelector 这个接口，自定义逻辑返回需要导入的组件 ```java public class SelfImportSelector implements ImportSelector { @Override public String[] selectImports(AnnotationMetadata annotationMetadata) { return new String[]{&quot;com.ecit.service.AccountService&quot;}; } } @Import({Airticle.class,User.class,SelfImportSelector.class}) @Configuration public class AppConfig { } // 输出结果： // org.springframework.context.annotation.internalConfigurationAnnotationProcessor // org.springframework.context.annotation.internalAutowiredAnnotationProcessor // org.springframework.context.annotation.internalRequiredAnnotationProcessor // org.springframework.context.annotation.internalCommonAnnotationProcessor // org.springframework.context.event.internalEventListenerProcessor // org.springframework.context.event.internalEventListenerFactory // appConfig // com.ecit.domain.Airticle // com.ecit.domain.User // com.ecit.service.AccountService 3)、ImportBeanDefinitionRegistrar:手动注册bean到容器中I```javapublic class SelfImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar { @Override public void registerBeanDefinitions(AnnotationMetadata annotationMetadata, BeanDefinitionRegistry beanDefinitionRegistry) { boolean definition = beanDefinitionRegistry.containsBeanDefinition(“com.ecit.domain.Airticle”); boolean definition2 = beanDefinitionRegistry.containsBeanDefinition(“com.ecit.domain.User”); if (definition &amp;&amp; definition2) { //指定bean的定义信息，参数里面指定要注册的bean的类型：RainBow.class RootBeanDefinition rootBeanDefinition = new RootBeanDefinition(AccountService.class); //注册一个bean，并且指定bean名 beanDefinitionRegistry.registerBeanDefinition(“newAccountService”, rootBeanDefinition ); } } }@Import({Airticle.class,User.class,SelfImportSelector.class,SelfImportBeanDefinitionRegistrar.class})@Configurationpublic class AppConfig {}// 输出测试结果:// org.springframework.context.annotation.internalConfigurationAnnotationProcessor// org.springframework.context.annotation.internalAutowiredAnnotationProcessor// org.springframework.context.annotation.internalRequiredAnnotationProcessor// org.springframework.context.annotation.internalCommonAnnotationProcessor// org.springframework.context.event.internalEventListenerProcessor// org.springframework.context.event.internalEventListenerFactory// appConfig// com.ecit.domain.Airticle// com.ecit.domain.User// com.ecit.service.AccountService// newAccountService ``` 组件赋值组件注入AOP声明式事务扩展原理BeanFactoryPostProcessorBeanDefinitionRegistryPostProcessorApplicationListenerSpring容器创建过程webservlet3.0异步请求","link":"/2015/11/15/framework/spring/spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"},{"title":"Spring框架-AOP","text":"AOP介绍 AOP（ Aspect Orient Programming），面向切面编程，是面向对象编程OOP的一种补充面向对象编程是从静态角度考虑程序的结构，而面向切面编程是从动态角度考虑程序运行过程。AOP底层，就是采用动态代理模式实现的。采用了两种代理:JDK的动态代理，与CGLB的动态代理 AOP为 Aspect Oriented Programming的缩写，意为:面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是 Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率 将交叉业务逻辑封装成切面，利用AOP容器的功能将切面织入到主业务逻辑中。所谓交叉业务逻辑是指，通用的、与主业务逻辑无关的代码，如安全检查、事务、日志等。若不使用AOP，则会出现代码纠缠，即交叉业务逻辑与主业务逻辑混合在一起。这样会使主业务逻辑变的混杂不清，例如，转账，在真正转账业务逻辑前后，需要权限控制、日志记录、加载事务、结束事务 AOP编程术语切面 (Aspect)切面泛指交叉业务逻辑，上例中的事务处理、日志处理就可以理解为切面，常用的切面有通知与顾问，实际就是对主业务逻辑的一种增强织入（Weaving）类中的织入是指将切面代码插入到目标对象的过程，是指把增强应用到目标对象来创建新的代理对象的过程。spring 采用动态代理织入，而 AspectJ 采用编译期织入和类装载期织入。连接点（ Joinpoint）连接点指可以被切面织入的方法。通常业务接口中的方法均为连接点，所谓连接点是指那些被拦截到的点。在spring 中,这些点指的是方法,因为 spring 只支持方法类型的连接点。切入点（ Pointcut）切入点指切面具体织入的方法。所谓切入点是指我们要对哪些 Joinpoint 进行拦截的定义。被标记为 final的方法是不能作为连接点与切入点的。因为最终的是不能被修改的，不能被增强的。目标对象（ Target）目标对象指将要被增强的对象。即包含主业务逻辑的类的对象。上例中的 Studentservicelmpl的对象若被增强，则该类称为目标类，该类对象称为目标对象。当然不被增强，也就无所谓目标不目标了。通知（ Advice）通知是切面的一种实现，可以完成简单织入功能（织功能就是在这里完成的）。所谓通知是指拦截到 Joinpoint 之后所要做的事情就是通知。 通知的类型:前置通知,后置通知,异常通知,最终通知,环绕通知。切入点定义切入的位置，通知定义时间。顾问（ Advisor）顾问是切面的另一种实现，能够将通知以更为复杂的方式织入到目标对象中，是将通知包装为更复杂切面的装配器 通知详解前置通知 Methodbeforeadvice定义前置通知，需要实现 MethodBeforeAdvice接口。该接口中有一个方法 before，会在目标方法执行之前执行。前置通知的特点在目标方法执行之前先执行不改变目标方法的执行流程，前置通知代码不能阻止目标方法执行不改变目标方法执行的结果 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:c=&quot;http://www.springframework.org/schema/c&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;beans&gt; &lt;!-- 注册目标对象 --&gt; &lt;bean id=&quot;someService&quot; class=&quot;com.songxm.learning.spring.service.SomeServiceImpl&quot;&gt; &lt;/bean&gt; &lt;!-- 注册切面:前置通知 --&gt; &lt;bean id=&quot;beforeAdvice&quot; class=&quot;com.songxm.learning.spring.aop.MyMethodBeforeAdvice&quot;&gt;&lt;/bean&gt; &lt;!-- 代理模式工厂bean配置 --&gt; &lt;bean id=&quot;serviceProxy&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt; &lt;property name=&quot;target&quot; ref=&quot;someService&quot;&gt;&lt;/property&gt; &lt;property name=&quot;interceptorNames&quot; value=&quot;beforeAdvice&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; &lt;/beans&gt; 前置通知实现类 package com.songxm.learning.spring.aop; import java.lang.reflect.Method; import org.springframework.aop.MethodBeforeAdvice; public class MyMethodBeforeAdvice implements MethodBeforeAdvice { @Override public void before(Method arg0, Object[] arg1, Object arg2) throws Throwable { System.out.println(&quot;执行前置通知&quot;); } } 目标对象 package com.songxm.learning.spring.service; public interface ISomeService { public String doSome(String task); } package com.songxm.learning.spring.service; public class SomeServiceImpl implements ISomeService { public SomeServiceImpl() { System.out.println(&quot;执行无参构造器!!!!&quot;); } @Override public String doSome(String task) { System.out.println(&quot;doSome.....&quot; + task); return task; } } 后置通知 AfterReturningAdvice定义后置通知，需要实现接口 AfterReturningAdvice.该接口中有一个方法 afterReturning会在目标方法执行之后执行。后置通知的特点:在目标方法执行之后执行不改变目标方法的执行流程，后置通知代码不能阻止目标方法执行不改变目标方法执行的结果 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:c=&quot;http://www.springframework.org/schema/c&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;beans&gt; &lt;!-- 注册目标对象 --&gt; &lt;bean id=&quot;someService&quot; class=&quot;com.songxm.learning.spring.service.SomeServiceImpl&quot;&gt; &lt;/bean&gt; &lt;!-- 注册切面:前置通知 --&gt; &lt;bean id=&quot;beforeAdvice&quot; class=&quot;com.songxm.learning.spring.aop.MyMethodBeforeAdvice&quot;&gt;&lt;/bean&gt; &lt;!-- 注册切面:后置通知 --&gt; &lt;bean id=&quot;afterAdvice&quot; class=&quot;com.songxm.learning.spring.aop.MyAfterReturn&quot;&gt;&lt;/bean&gt; &lt;!-- 代理模式工厂bean配置 --&gt; &lt;bean id=&quot;serviceProxy&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt; &lt;property name=&quot;target&quot; ref=&quot;someService&quot;&gt;&lt;/property&gt; &lt;property name=&quot;interceptorNames&quot; value=&quot;beforeAdvice,afterAdvice&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; &lt;/beans&gt; afterAdvice 实现类 package com.songxm.learning.spring.aop; import java.lang.reflect.Method; import org.springframework.aop.AfterReturningAdvice; public class MyAfterReturn implements AfterReturningAdvice { @Override public void afterReturning(Object arg0, Method arg1, Object[] arg2, Object arg3) throws Throwable { System.out.println(&quot;执行后置通知&quot;); } } 输出结果： 执行无参构造器!!!! 执行前置通知 doSome.....aaa 后置通知 环绕通知 Methodlnterceptor定义环绕通知，需要实现 MethodInterceptor接口。环绕通知，也叫方法拦截器，可以在目标方法调用之前及之后做处理，可以改变目标方法的返回值，也可以改变程序执行流程。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:c=&quot;http://www.springframework.org/schema/c&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;beans&gt; &lt;!-- 注册目标对象 --&gt; &lt;bean id=&quot;someService&quot; class=&quot;com.songxm.learning.spring.service.SomeServiceImpl&quot;&gt; &lt;/bean&gt; &lt;!-- 注册切面:前置通知 --&gt; &lt;bean id=&quot;beforeAdvice&quot; class=&quot;com.songxm.learning.spring.aop.MyMethodBeforeAdvice&quot;&gt;&lt;/bean&gt; &lt;!-- 注册切面:后置通知 --&gt; &lt;bean id=&quot;afterAdvice&quot; class=&quot;com.songxm.learning.spring.aop.MyAfterReturn&quot;&gt;&lt;/bean&gt; &lt;!-- 注册切面:环绕通知 --&gt; &lt;bean id=&quot;interceptorAdvice&quot; class=&quot;com.songxm.learning.spring.aop.MyMethodInterceptor&quot;&gt;&lt;/bean&gt; &lt;!-- 代理模式工厂bean配置 --&gt; &lt;bean id=&quot;serviceProxy&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt; &lt;property name=&quot;target&quot; ref=&quot;someService&quot;&gt;&lt;/property&gt; &lt;property name=&quot;interceptorNames&quot; value=&quot;beforeAdvice,afterAdvice,interceptorAdvice&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; &lt;/beans&gt; package com.songxm.learning.spring.aop; import org.aopalliance.intercept.MethodInterceptor; import org.aopalliance.intercept.MethodInvocation; // 环绕通知可以修改目标方法 public class MyMethodInterceptor implements MethodInterceptor { @Override public Object invoke(MethodInvocation invocation) throws Throwable { System.out.println(&quot;执行环绕通知之前。。。。。。。&quot;); Object result = invocation.proceed(); //执行目标方法 System.out.println(&quot;执行环绕通知之后。。。。。。。&quot;); return ((String)result).toUpperCase(); } } 输出结果: 执行无参构造器!!!! 执行前置通知 执行环绕通知之前。。。。。。。 doSome.....aaa 执行环绕通知之后。。。。。。。 执行后置通知 AAA 异常通知只在连接点抛出异常时才执行异常通知 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:c=&quot;http://www.springframework.org/schema/c&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;beans&gt; &lt;!-- 注册目标对象 --&gt; &lt;bean id=&quot;someService&quot; class=&quot;com.songxm.learning.spring.service.SomeServiceImpl&quot;&gt; &lt;/bean&gt; &lt;!-- 注册切面:前置通知 --&gt; &lt;bean id=&quot;beforeAdvice&quot; class=&quot;com.songxm.learning.spring.aop.MyMethodBeforeAdvice&quot;&gt;&lt;/bean&gt; &lt;!-- 注册切面:后置通知 --&gt; &lt;bean id=&quot;afterAdvice&quot; class=&quot;com.songxm.learning.spring.aop.MyAfterReturn&quot;&gt;&lt;/bean&gt; &lt;!-- 注册切面:环绕通知 --&gt; &lt;bean id=&quot;interceptorAdvice&quot; class=&quot;com.songxm.learning.spring.aop.MyMethodInterceptor&quot;&gt;&lt;/bean&gt; &lt;!-- 注册切面:异常通知 --&gt; &lt;bean id=&quot;exceptionAdvice&quot; class=&quot;com.songxm.learning.spring.aop.MyExceptionAdvice&quot;&gt;&lt;/bean&gt; &lt;!-- 代理模式工厂bean配置 --&gt; &lt;bean id=&quot;serviceProxy&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt; &lt;property name=&quot;target&quot; ref=&quot;someService&quot;&gt;&lt;/property&gt; &lt;property name=&quot;interceptorNames&quot; value=&quot;beforeAdvice,afterAdvice,interceptorAdvice,exceptionAdvice&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; &lt;/beans&gt; package com.songxm.learning.spring.exception; public class UserException extends Exception { public UserException() { super(); } public UserException(String message) { super(message); } } package com.songxm.learning.spring.exception; public class UserNaneException extends UserException { public UserNaneException() { super(); } public UserNaneException(String message) { super(message); } } package com.songxm.learning.spring.exception; public class PasswdException extends UserException { public PasswdException() { super(); } public PasswdException(String message) { super(message); } } 连接点 业务类接口 package com.songxm.learning.spring.service; import com.songxm.learning.spring.exception.UserException; public interface ISomeService { public String doSome(String task); public boolean login(String username,String passwd) throws UserException; } package com.songxm.learning.spring.service; import com.songxm.learning.spring.exception.PasswdException; import com.songxm.learning.spring.exception.UserException; import com.songxm.learning.spring.exception.UserNaneException; public class SomeServiceImpl implements ISomeService { public SomeServiceImpl() { System.out.println(&quot;执行无参构造器!!!!&quot;); } @Override public String doSome(String task) { System.out.println(&quot;doSome.....&quot; + task); return task; } @Override public boolean login(String username, String passwd) throws UserException { if(&quot;111111&quot;.equals(username)) { throw new UserNaneException(&quot;用户名太简单&quot;); } if(&quot;111111&quot;.equals(passwd)){ throw new PasswdException(&quot;密码太简单&quot;); } //double a = 3 / 0; return true; } } 测试 import org.junit.Test; import org.springframework.context.ApplicationContext; import org.springframework.context.support.FileSystemXmlApplicationContext; import com.songxm.learning.spring.exception.UserException; import com.songxm.learning.spring.service.ISomeService; public class TestSpring { @Test public void testApplicationContext() throws UserException { ApplicationContext ac = new FileSystemXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;); ISomeService someservice = (ISomeService) ac.getBean(&quot;serviceProxy&quot;); someservice.login(&quot;ss&quot;, &quot;111111&quot;); } } 输出: 执行无参构造器!!!! 执行前置通知 执行环绕通知之前。。。。。。。 密码异常:com.songxm.learning.spring.exception.PasswdException: 密码太简单 异常通知注意点ps:注意默认代理类会自动根据 业务类是否有接口，而使用不同的底层代理实现类 ，有接口默认使用jdk自带的，没接口使用cglib代理实现类，若要明确强制指定使用cglib，可有两种方式设置 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:c=&quot;http://www.springframework.org/schema/c&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;beans&gt; &lt;!-- 注册目标对象 --&gt; &lt;bean id=&quot;someService&quot; class=&quot;com.songxm.learning.spring.service.SomeServiceImpl&quot;&gt; &lt;/bean&gt; &lt;!-- 注册切面:前置通知 --&gt; &lt;bean id=&quot;beforeAdvice&quot; class=&quot;com.songxm.learning.spring.aop.MyMethodBeforeAdvice&quot;&gt;&lt;/bean&gt; &lt;!-- 注册切面:后置通知 --&gt; &lt;bean id=&quot;afterAdvice&quot; class=&quot;com.songxm.learning.spring.aop.MyAfterReturn&quot;&gt;&lt;/bean&gt; &lt;!-- 注册切面:环绕通知 --&gt; &lt;bean id=&quot;interceptorAdvice&quot; class=&quot;com.songxm.learning.spring.aop.MyMethodInterceptor&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;exceptionAdvice&quot; class=&quot;com.songxm.learning.spring.aop.MyExceptionAdvice&quot;&gt;&lt;/bean&gt; &lt;!-- 代理模式工厂bean配置 --&gt; &lt;bean id=&quot;serviceProxy&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt; &lt;property name=&quot;target&quot; ref=&quot;someService&quot;&gt;&lt;/property&gt; &lt;property name=&quot;interceptorNames&quot; value=&quot;beforeAdvice,afterAdvice,interceptorAdvice,exceptionAdvice&quot;&gt;&lt;/property&gt; &lt;property name=&quot;proxyTargetClass&quot; value=&quot;true&quot;&gt;&lt;/property&gt;&lt;!-- 代理模式工厂第一种方式设置代理实现类cglib--&gt; &lt;!-- 代理模式工厂第二种方式设置代理实现类cglib &lt;property name=&quot;optimize&quot; value=&quot;true&quot;&gt;&lt;/property&gt; --&gt; &lt;/bean&gt; &lt;/beans&gt; &lt;/beans&gt; 顾问 Advisor通知（ Advice）是 Spring提供的一种切面（ Aspect）。但其功能过于简单:只能将切面织入到目标类的所有目标方法中，无法完成将切面织入到指定目标方法中顾问（ Advisor）是 Spring提供的另一种切面。其可以完成更为复杂的切面织入功能 Pointcutadvisor是顾间的一种，可以指定具体的切入点。顾问将通知进行了包装，会根据不同的通知类型，在不同的时间点，将切面织入到不同的切入点。Pointcutadvisor接口有两个较为常用的实现类 NameMatchMethodPointcutAdvisor名称匹配方法切入点顾问 RegexpMethodPointcutadvisor正则表达式匹配方法切入点顾问 名称匹配方法切入点顾问NameMatchMethodPointcutAdvisor，即名称匹配方法切入点顾问。容器可根据配置文件中指定的方法名来设置切入点。代码不用修改，只在配置文件中注册一个顾问，然后使用通知属性 advice与切入点的法名 mappedname对其进行配置。代理中的切面，使用这个顾问即可。示例 配置顾问，只对前置通知包装，只切入业务层的指定的一个具体方法 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:c=&quot;http://www.springframework.org/schema/c&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;beans&gt; &lt;!-- 注册目标对象 --&gt; &lt;bean id=&quot;someService&quot; class=&quot;com.songxm.learning.spring.service.SomeServiceImpl&quot;&gt; &lt;/bean&gt; &lt;!-- 注册切面:前置通知 --&gt; &lt;bean id=&quot;beforeAdvice&quot; class=&quot;com.songxm.learning.spring.aop.MyMethodBeforeAdvice&quot;&gt;&lt;/bean&gt; &lt;!-- 注册切面:后置通知 --&gt; &lt;bean id=&quot;afterAdvice&quot; class=&quot;com.songxm.learning.spring.aop.MyAfterReturn&quot;&gt;&lt;/bean&gt; &lt;!-- 注册切面:环绕通知 --&gt; &lt;bean id=&quot;interceptorAdvice&quot; class=&quot;com.songxm.learning.spring.aop.MyMethodInterceptor&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;exceptionAdvice&quot; class=&quot;com.songxm.learning.spring.aop.MyExceptionAdvice&quot;&gt;&lt;/bean&gt; &lt;!-- 注册顾问 --&gt; &lt;bean id=&quot;nameMatchadvisor&quot; class=&quot;org.springframework.aop.support.NameMatchMethodPointcutAdvisor&quot;&gt; &lt;property name=&quot;advice&quot; ref=&quot;beforeAdvice&quot;&gt;&lt;/property&gt; &lt;property name=&quot;mappedName&quot; value=&quot;doSome&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 代理模式工厂bean配置 --&gt; &lt;bean id=&quot;serviceProxy&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt; &lt;property name=&quot;target&quot; ref=&quot;someService&quot;&gt;&lt;/property&gt; &lt;property name=&quot;interceptorNames&quot; value=&quot;nameMatchadvisor&quot;&gt;&lt;/property&gt; &lt;property name=&quot;proxyTargetClass&quot; value=&quot;true&quot;&gt;&lt;/property&gt;&lt;!-- 代理模式工厂第一种方式设置代理实现类cglib--&gt; &lt;!-- 代理模式工厂第二种方式设置代理实现类cglib &lt;property name=&quot;optimize&quot; value=&quot;true&quot;&gt;&lt;/property&gt; --&gt; &lt;/bean&gt; &lt;/beans&gt; &lt;/beans&gt; 测试结果 import org.junit.Test; import org.springframework.context.ApplicationContext; import org.springframework.context.support.FileSystemXmlApplicationContext; import com.songxm.learning.spring.exception.UserException; import com.songxm.learning.spring.service.ISomeService; public class TestSpring { @Test public void testApplicationContext() throws UserException { ApplicationContext ac = new FileSystemXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;); ISomeService someservice = (ISomeService) ac.getBean(&quot;serviceProxy&quot;); someservice.doSome(&quot;aaaa&quot;); someservice.login(&quot;ss&quot;, &quot;11&quot;); } } 输出： 执行无参构造器!!!! 执行前置通知 doSome.....aaaa 自动代理生成器 解决ProxyFactoryBean的问题一次只能代理一个bean前面代码中所使用的代理对象，均是由 ProxyFactoryBean代理工具类生成的，而该代理工具类存在着如下缺点: （1）一个代理对象只能代理一个Bean，即如果有两个Bean同时都要织同一个切面，这时，不仅要配置这两个Bean，即两个目标对象，同时还要配置两代理对象 （2）在客户类中获取Bean时，使用的是代理类的id，而非我们定义的目标对象Bean的id我们真正想要执行的应该是目标对象。从形式上看，不符合正常的逻辑 Spring提供了自动代理生成器，用于解决 ProxyFactoryBean的问题。常用的自动代理生成器有两个: 默认advisor自动代理生成器 ,Bean名称自动代理生成器 需要注意的是，自动代理生成器均继承自Bean后处理器 BeanPostProcessor。容器中所有Bean在初始化时均会自动执行Bean后处理器中的方法，故其无需id属性。所以自动代理生成器的Bean也没有id属性，客户类直接使用目标对象bean的id 默认advisor自动代理生成器&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:c=&quot;http://www.springframework.org/schema/c&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;beans&gt; &lt;!-- 注册目标对象 --&gt; &lt;bean id=&quot;someService&quot; class=&quot;com.songxm.learning.spring.service.SomeServiceImpl&quot; /&gt; &lt;!-- 注册目标对象2 --&gt; &lt;bean id=&quot;someService2&quot; class=&quot;com.songxm.learning.spring.service.SomeServiceImpl&quot; /&gt; &lt;!-- 注册切面:前置通知 --&gt; &lt;bean id=&quot;beforeAdvice&quot; class=&quot;com.songxm.learning.spring.aop.MyMethodBeforeAdvice&quot;&gt;&lt;/bean&gt; &lt;!-- 注册顾问 --&gt; &lt;bean id=&quot;nameMatchadvisor&quot; class=&quot;org.springframework.aop.support.NameMatchMethodPointcutAdvisor&quot;&gt; &lt;property name=&quot;advice&quot; ref=&quot;beforeAdvice&quot;&gt;&lt;/property&gt; &lt;property name=&quot;mappedName&quot; value=&quot;doSome&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 注册自动代理生成器 --&gt; &lt;bean class=&quot;org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator&quot;&gt;&lt;/bean&gt; &lt;/beans&gt; &lt;/beans&gt; import org.junit.Test; import org.springframework.context.ApplicationContext; import org.springframework.context.support.FileSystemXmlApplicationContext; import com.songxm.learning.spring.exception.UserException; import com.songxm.learning.spring.service.ISomeService; public class TestSpring { @Test public void testApplicationContext() throws UserException { ApplicationContext ac = new FileSystemXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;); ISomeService someservice = (ISomeService) ac.getBean(&quot;someService&quot;); someservice.doSome(&quot;aaaa&quot;); someservice.login(&quot;ss&quot;, &quot;11&quot;); ISomeService someservice2 = (ISomeService) ac.getBean(&quot;someService2&quot;); someservice2.doSome(&quot;bbbb&quot;); someservice2.login(&quot;bb&quot;, &quot;bb&quot;); } } 输出: 执行无参构造器!!!! 执行无参构造器!!!! 执行前置通知 doSome.....aaaa 执行前置通知 doSome.....bbbb 问题 Bean名称自动代理生成器可指定具体的目标对象，可指定具体的顾问 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:c=&quot;http://www.springframework.org/schema/c&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;beans&gt; &lt;!-- 注册目标对象 --&gt; &lt;bean id=&quot;someService&quot; class=&quot;com.songxm.learning.spring.service.SomeServiceImpl&quot; /&gt; &lt;!-- 注册目标对象2 --&gt; &lt;bean id=&quot;someService2&quot; class=&quot;com.songxm.learning.spring.service.SomeServiceImpl&quot; /&gt; &lt;!-- 注册切面:前置通知 --&gt; &lt;bean id=&quot;beforeAdvice&quot; class=&quot;com.songxm.learning.spring.aop.MyMethodBeforeAdvice&quot;&gt;&lt;/bean&gt; &lt;!-- 注册顾问1 --&gt; &lt;bean id=&quot;nameMatchadvisor&quot; class=&quot;org.springframework.aop.support.NameMatchMethodPointcutAdvisor&quot;&gt; &lt;property name=&quot;advice&quot; ref=&quot;beforeAdvice&quot;&gt;&lt;/property&gt; &lt;property name=&quot;mappedName&quot; value=&quot;doSome&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 注册顾问2 --&gt; &lt;bean id=&quot;nameMatchadvisor2&quot; class=&quot;org.springframework.aop.support.NameMatchMethodPointcutAdvisor&quot;&gt; &lt;property name=&quot;advice&quot; ref=&quot;beforeAdvice&quot;&gt;&lt;/property&gt; &lt;property name=&quot;mappedName&quot; value=&quot;doSome&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 注册自动代理生成器 --&gt; &lt;bean class=&quot;org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator&quot;&gt; &lt;property name=&quot;beanNames&quot; value=&quot;someService2&quot;&gt;&lt;/property&gt; &lt;property name=&quot;interceptorNames&quot; value=&quot;nameMatchadvisor2&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; &lt;/beans&gt; AspectJ 对AOP的实现–基于注解方式对于AOP这种编程思想，很多框架都进行了实现。 Spring就是其中之一，可以完成面向切面编程。然而， Aspect也实现了AOP的功能，且其实现方式更为简捷，使用更为方便而且还支持注解式开发。所以， Spring又将 Aspect的对于AOP的实现也引入到了自己的框架中.在 Spring中使用AOP开发时，一般使用 AspectJ的实现方式 AspectJ简介 AspectJ是一个面向切面的框架，它扩展了Java语言。 AspectJ定义了AOP语法，它有个专门的编译器用来生成遵守Java字节编码规范的 Class文件,用 AspectJ 注解声明切面,要在 Spring中声明AspectJ切面, 只需要在IOC容器中将切面声明为Bean实例. 当在 Spring IOC 容器中初始化 AspectJ 切面之后, Spring IOC 容器就会为那些与 AspectJ 切面相匹配的 Bean 创建代理. 在 AspectJ 注解中, 切面只是一个带有 @Aspect 注解的 Java 类. 通知是标注有某种注解的简单的 Java 方法.AspectJ 支持 5 种类型的通知注解: @Before: 前置通知, 在方法执行之前执行 @After: 后置通知, 在方法执行之后执行 @AfterRunning: 返回通知, 在方法返回结果之后执行 @AfterThrowing: 异常通知, 在方法抛出异常之后 @Around: 环绕通知, 围绕着方法执行 在 AspectJ 中, 切入点表达式可以通过操作符 &amp;&amp;, ||, ! 结合起来. Aspect除了提供了六种通知外，还定义了专门的表达式用于指定切入点。表达式的原型是:execution(表达式)表达式语法:execution([修饰符] 返回值类型 包名.类名.方法名(参数))execution（［ modifiers－pattern］访问权限类型 ret－type－ pattern 返回值类型 [declaring－type－pattern］全限定性类名 name－pattern（param－pattern）方法名（参数名) [throws－ pattern］抛出异常类型 ) 切入点表达式要匹配的对象就是目标方法的方法名。所以， execution表达式中明显就是方法的签名。注意，表达式中加［的部分表示可省略部分，各部分间用空格分开。在其中可以使用以下符号:切入点表达式举例：```java//返回值可以使用号，表示任意返回值 * com.ecit.service.impl.AccountServiceImpl.saveAccount(com.ecit.domain.Account)//包名可以使用号，表示任意包，但是有几级包，需要写几个* ....AccountServiceImpl.saveAccount(com.ecit.domain.Account)//使用..来表示当前包，及其子包 com..AccountServiceImpl.saveAccount(com.ecit.domain.Account)//类名可以使用*号，表示任意类 com...saveAccount(com.ecit.domain.Account)//方法名可以使用号，表示任意方法 com...(com.ecit.domain.Account)//参数列表可以使用*，表示参数可以是任意数据类型，但是必须有参数 com...(*)//参数列表可以使用..表示有无参数均可，有参数可以是任意类型 com...(..)//注:全通配方式: ...(..)//通常情况下，我们都是对业务层的方法进行增强，所以切入点表达式都是切到业务层实现类。execution( com.ecit.service.impl..(..))``` AspectJ开发环境 依赖的jar包,需要再添加 两个&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.6.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt; &lt;version&gt;1.6.8&lt;/version&gt; &lt;/dependency&gt; 要在 Spring IOC 容器中启用 AspectJ 注解支持, 只要在 Bean 配置文件中定义一个空的 XML 元素&lt;aop:aspectj-autoproxy&gt; 前置通知 让通知访问当前连接点的细节 可以在通知方法中声明一个类型为 JoinPoint 的参数. 然后就能访问链接细节. 如方法名称和参数值 后置通知 后置通知是在连接点完成之后执行的, 即连接点返回结果或者抛出异常的时候, 下面的后置通知记录了方法的终止. 一个切面可以包括一个或者多个通知. 返回通知 无论连接点是正常返回还是抛出异常, 后置通知都会执行. 如果只想在连接点返回的时候记录日志, 应使用返回通知代替后置通知. 异常通知 只在连接点抛出异常时才执行异常通知，将 throwing 属性添加到 @AfterThrowing 注解中, 也可以访问连接点抛出的异常. Throwable 是所有错误和异常类的超类. **所以在异常通知方法可以捕获到任何错误和异常.**如果只对某种特殊的异常类型感兴趣, 可以将参数声明为其他异常的参数类型. 然后通知就只在抛出这个类型及其子类的异常时才被执行. 环绕通知 通常情况下环绕通知都是单独使用的，它可囊括AOP通知的各个阶段 环绕通知是所有通知类型中功能最为强大的, 能够全面地控制连接点. 甚至可以控制是否执行连接点. 对于环绕通知来说, 连接点的参数类型必须是 ProceedingJoinPoint. 它是 JoinPoint 的子接口, 允许控制何时执行, 是否执行连接点. 在环绕通知中需要明确调用 ProceedingJoinPoint 的 proceed() 方法来执行被代理的方法. 如果忘记这样做就会导致通知被执行了, 但目标方法没有被执行. 注意: 环绕通知的方法需要返回目标方法执行之后的结果, 即调用 joinPoint.proceed(); 的返回值, 否则会出现空指针异常 指定切面的优先级 在同一个连接点上应用不止一个切面时, 除非明确指定, 否则它们的优先级是不确定的. 切面的优先级可以通过实现 Ordered 接口或利用 @Order 注解指定. 实现 Ordered 接口, getOrder() 方法的返回值越小, 优先级越高. 若使用 @Order 注解, 序号出现在注解中@Aspect @Order(0) public class CalculaotorValidationAspect {} @Aspect @Order(1) public class CalculatorLogginghspect {} 重用切入点定义 在 AspectJ 切面中, 可以通过 @Pointcut 注解将一个切入点声明成简单的方法. 切入点的方法体通常是空的. 切入点方法的访问控制符同时也控制着这个切入点的可见性. 如果切入点要在多个切面中共用, 最好将它们集中在一个公共的类中. 在这种情况下, 它们必须被声明为 public. 在引入这个切入点时, 必须将类名也包括在内. 如果类没有与这个切面放在同一个包中, 还必须包含包名. AspectJ 对AOP的实现–基于XML方式 基于XML声明切面当使用 XML 声明切面时, 需要在 &lt;beans&gt; 根元素中导入 aop Schema,在 Bean 配置文件中, 所有的 Spring AOP 配置都必须定义在 &lt;aop:config&gt; 元素内部. 对于每个切面而言, 都要创建一个 &lt;aop:aspect&gt; 元素来为具体的切面实现引用后端 Bean 实例. 切面 Bean 必须有一个标示符, 供 &lt;aop:aspect&gt; 元素引用 基于XML声明切入点切入点使用 &lt;aop:pointcut&gt; 元素声明 切入点必须定义在 &lt;aop:aspect&gt; 元素下, 或者直接定义在 &lt;aop:config&gt; 元素下. 定义在 &lt;aop:aspect&gt; 元素下: 只对当前切面有效 定义在 &lt;aop:config&gt; 元素下: 对所有切面都有效 基于 XML 的 AOP 配置不允许在切入点表达式中用名称引用其他切入点. 基于 XML声明通知在 aop Schema 中, 每种通知类型都对应一个特定的 XML 元素. 通知元素需要使用 &lt;pointcut-ref&gt; 来引用切入点, 或用 &lt;pointcut&gt; 直接嵌入切入点表达式. method 属性指定切面类中通知方法的名称. AOP实战例子-数据库事务不依赖Spring-tx模块使用基于注解方式的aop示例:(环绕注解方式实现的事务) 添加所用到的jar包依赖&lt;dependencies&gt; &lt;!--bean的get set简化--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.12&lt;/version&gt; &lt;/dependency&gt; &lt;!--spring框架核心的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.3.12.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--aop用到的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;4.3.12.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;aopalliance&lt;/groupId&gt; &lt;artifactId&gt;aopalliance&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.7&lt;/version&gt; &lt;/dependency&gt; &lt;!--封装的JDBC操作工具类--&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbutils&lt;/groupId&gt; &lt;artifactId&gt;commons-dbutils&lt;/artifactId&gt; &lt;version&gt;1.5&lt;/version&gt; &lt;/dependency&gt; &lt;!--数据库连接池--&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql数据库驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.45&lt;/version&gt; &lt;/dependency&gt; &lt;!--纯JUnit测试包--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--日志框架--&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 添加spring-bean.xml资源配置文件&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;context:property-placeholder location=&quot;db-pro.properties&quot; /&gt; &lt;!--配置spring创建容器时要扫描的包--&gt; &lt;context:component-scan base-package=&quot;com.ecit&quot;&gt;&lt;/context:component-scan&gt; &lt;!--配置QueryRunner--&gt; &lt;bean id=&quot;runner&quot; class=&quot;org.apache.commons.dbutils.QueryRunner&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;!--连接数据库的必备信息--&gt; &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driver}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.url}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;user&quot; value=&quot;${jdbc.username}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--开启spring对注解AOP的支持--&gt; &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; &lt;/beans&gt; 准备的SQL表结构CREATE TABLE `account` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT '主键', `money` float(8,2) DEFAULT NULL COMMENT '余额', `name` varchar(20) DEFAULT NULL COMMENT '姓名', PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4; 抽取事务管理类```javapackage com.ecit.utils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;import javax.sql.DataSource;import java.sql.Connection;/** 连接的工具类，它用于从数据源中获取一个连接，并且实现和线程的绑定 /@Component(“connectionUtils”)public class ConnectionUtils { private ThreadLocal tl = new ThreadLocal(); @Autowired private DataSource dataSource; /* 获取当前线程上的连接 @return / public Connection getThreadConnection() { try{ //1.先从ThreadLocal上获取 Connection conn = tl.get(); //2.判断当前线程上是否有连接 if (conn == null) { //3.从数据源中获取一个连接，并且存入ThreadLocal中 conn = dataSource.getConnection(); tl.set(conn); } //4.返回当前线程上的连接 return conn; }catch (Exception e){ throw new RuntimeException(e); } } /* 把连接和线程解绑 / public void removeConnection(){ tl.remove(); }} javapackage com.ecit.utils;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Pointcut;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;/* 和事务管理相关的工具类，它包含了，开启事务，提交事务，回滚事务和释放连接 /@Component(“txManager”)@Aspectpublic class TransactionManager { @Autowired private ConnectionUtils connectionUtils; @Pointcut(“execution( com.ecit.service.impl..(..))”) //注解方式的切入点 private void pt1(){} /** 开启事务 / public void beginTransaction(){ try { connectionUtils.getThreadConnection().setAutoCommit(false); }catch (Exception e){ e.printStackTrace(); } } /* 提交事务 / public void commit(){ try { connectionUtils.getThreadConnection().commit(); }catch (Exception e){ e.printStackTrace(); } } /* 回滚事务 / public void rollback(){ try { connectionUtils.getThreadConnection().rollback(); }catch (Exception e){ e.printStackTrace(); } } /* 释放连接 */ public void release(){ try { connectionUtils.getThreadConnection().close();//还回连接池中 connectionUtils.removeConnection(); }catch (Exception e){ e.printStackTrace(); } } @Around(“pt1()”) //注解配置环绕通知 public Object aroundAdvice(ProceedingJoinPoint pjp){ Object rtValue = null; try { //1.获取参数 Object[] args = pjp.getArgs(); //2.开启事务 this.beginTransaction(); //3.执行方法 rtValue = pjp.proceed(args); //4.提交事务 this.commit(); //返回结果 return rtValue; }catch (Throwable e){ //5.回滚事务 this.rollback(); throw new RuntimeException(e); }finally { //6.释放资源 this.release(); } }}``` 账户的实体类```javapackage com.ecit.domain;import lombok.Data;import java.io.Serializable;/** 账户的实体类 */@Datapublic class Account implements Serializable { private Integer id; private String name; private Float money;}``` 账户的DAO层```javapackage com.ecit.dao;import com.ecit.domain.Account;import java.util.List;/** 账户的持久层接口 /public interface IAccountDao { /* 查询所有 @return / List findAllAccount(); /* 更新 @param account / int updateAccount(Account account); /* 根据名称查询账户 @param accountName @return 如果有唯一的一个结果就返回，如果没有结果就返回null 如果结果集超过一个就抛异常 / Account findAccountByName(String accountName);} javapackage com.ecit.dao.impl;import com.ecit.dao.IAccountDao;import com.ecit.domain.Account;import com.ecit.utils.ConnectionUtils;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanListHandler;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Repository;import java.util.List;/* 账户的持久层实现类 */@Repository(“accountDao”)public class AccountDaoImpl implements IAccountDao { @Autowired private QueryRunner runner; @Autowired private ConnectionUtils connectionUtils; @Override public List findAllAccount() { try{ return runner.query(connectionUtils.getThreadConnection(),”select * from account”,new BeanListHandler(Account.class)); }catch (Exception e) { throw new RuntimeException(e); } } @Override public int updateAccount(Account account) { try{ return runner.update(connectionUtils.getThreadConnection(),”update account set name=?,money=? where id=?”,account.getName(),account.getMoney(),account.getId()); }catch (Exception e) { throw new RuntimeException(e); } } @Override public Account findAccountByName(String accountName) { try{ List accounts = runner.query(connectionUtils.getThreadConnection(),”select * from account where name = ?”,new BeanListHandler(Account.class),accountName); if(accounts == null || accounts.size() == 0){ return null; } if(accounts.size() &gt; 1){ throw new RuntimeException(“结果集不唯一，数据有问题”); } return accounts.get(0); }catch (Exception e) { throw new RuntimeException(e); } }}``` 账户的业务层```javapackage com.ecit.service;import com.ecit.domain.Account;import java.util.List;/** 账户的业务层接口 /public interface IAccountService { /* 查询所有 @return / List findAllAccount(); /* 转账 @param sourceName 转出账户名称 @param targetName 转入账户名称 @param money 转账金额 */ void transfer(String sourceName,String targetName,Float money) throws Exception;}```java package com.ecit.service.impl; import com.ecit.dao.IAccountDao; import com.ecit.domain.Account; import com.ecit.service.IAccountService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import java.util.List; @Service(&quot;accountService&quot;) public class AccountServiceImpl implements IAccountService { @Autowired private IAccountDao accountDao; @Override public List&lt;Account&gt; findAllAccount() { return accountDao.findAllAccount(); } @Override public void transfer(String sourceName, String targetName, Float money) throws Exception{ System.out.println(&quot;transfer....&quot;); //2.1根据名称查询转出账户 Account source = accountDao.findAccountByName(sourceName); //2.2根据名称查询转入账户 Account target = accountDao.findAccountByName(targetName); //2.3转出账户减钱 source.setMoney(source.getMoney()-money); //2.4转入账户加钱 target.setMoney(target.getMoney()+money); //2.5更新转出账户 int res = accountDao.updateAccount(source); if (res==0){ throw new RuntimeException(&quot;用户扣款异常&quot;); } // int i=1/0; 模拟出现异常，看出事务是否回滚 //2.6更新转入账户 int res2 = accountDao.updateAccount(target); if (res2==0){ throw new RuntimeException(&quot;用户收款异常&quot;); } } } 测试代码@Test public void testTx() throws Exception { //1.获取容器 ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;spring-bean.xml&quot;); //2.获取对象 IAccountService as = (IAccountService)ac.getBean(&quot;accountService&quot;); System.out.println(as); as.transfer(&quot;aa&quot;,&quot;bbb&quot;,100f); } 不依赖Spring-tx模块使用基于注解方式的aop示例:(前置，后置，异常，最终通知注解方式实现的事务) 同上依赖jar包，实体类，dao层，业务层,sping-bean.xml不变 改变 TransactionManager前置，后置，异常，最终通知```javapackage com.ecit.utils;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Pointcut;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;/** 和事务管理相关的工具类，它包含了，开启事务，提交事务，回滚事务和释放连接 /@Component(“txManager”)@Aspectpublic class TransactionManager { @Autowired private ConnectionUtils connectionUtils; @Pointcut(“execution( com.ecit.service.impl..(..))”) //注解方式的切入点 private void pt1(){} /** 开启事务 / @Before(“pt1()”) //前置通知 public void beginTransaction(){ try { connectionUtils.getThreadConnection().setAutoCommit(false); }catch (Exception e){ e.printStackTrace(); } } /* 提交事务 / @AfterReturning(“pt1()”) //后置通知 public void commit(){ try { connectionUtils.getThreadConnection().commit(); }catch (Exception e){ e.printStackTrace(); } } /* 回滚事务 / @AfterThrowing(“pt1()”) //异常通知 public void rollback(){ try { connectionUtils.getThreadConnection().rollback(); }catch (Exception e){ e.printStackTrace(); } } /* 释放连接 */ @After(“pt1()”) //最终通知 public void release(){ try { connectionUtils.getThreadConnection().close();//还回连接池中 connectionUtils.removeConnection(); }catch (Exception e){ e.printStackTrace(); } }}``` 不依赖Spring-tx模块使用基于XML的aop示例:(环绕通知方式实现的事务) 同上依赖jar包，实体类，dao层，业务层不变(去掉所有注解，添加getter方法) 改变sping-bean.xml```xml ``` 不依赖Spring-tx模块使用基于XML的aop示例:(前置，后置，异常，最终通知方式实现的事务) 同上依赖jar包，实体类，dao层，业务层不变(去掉所有注解，添加getter方法) 改变sping-bean.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;bean class= &quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt; &lt;property name=&quot;location&quot; value= &quot;classpath:db-pro.properties&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置Service --&gt; &lt;bean id=&quot;accountService&quot; class=&quot;com.ecit.service.impl.AccountServiceImpl&quot;&gt; &lt;!-- 注入dao --&gt; &lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--配置Dao对象--&gt; &lt;bean id=&quot;accountDao&quot; class=&quot;com.ecit.dao.impl.AccountDaoImpl&quot;&gt; &lt;!-- 注入QueryRunner --&gt; &lt;property name=&quot;runner&quot; ref=&quot;runner&quot;&gt;&lt;/property&gt; &lt;!-- 注入ConnectionUtils --&gt; &lt;property name=&quot;connectionUtils&quot; ref=&quot;connectionUtils&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--配置QueryRunner--&gt; &lt;bean id=&quot;runner&quot; class=&quot;org.apache.commons.dbutils.QueryRunner&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;!--连接数据库的必备信息--&gt; &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driver}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.url}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;user&quot; value=&quot;${jdbc.username}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置Connection的工具类 ConnectionUtils --&gt; &lt;bean id=&quot;connectionUtils&quot; class=&quot;com.ecit.utils.ConnectionUtils&quot;&gt; &lt;!-- 注入数据源--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置事务管理器--&gt; &lt;bean id=&quot;txManager&quot; class=&quot;com.ecit.utils.TransactionManager&quot;&gt; &lt;!-- 注入ConnectionUtils --&gt; &lt;property name=&quot;connectionUtils&quot; ref=&quot;connectionUtils&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--配置aop--&gt; &lt;aop:config&gt; &lt;!--配置通用切入点表达式--&gt; &lt;aop:pointcut id=&quot;pt1&quot; expression=&quot;execution(* com.ecit.service.impl.*.*(..))&quot;&gt;&lt;/aop:pointcut&gt; &lt;aop:aspect id=&quot;txAdvice&quot; ref=&quot;txManager&quot;&gt; &lt;!--配置前置通知：开启事务--&gt; &lt;aop:before method=&quot;beginTransaction&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:before&gt; &lt;!--配置后置通知：提交事务--&gt; &lt;aop:after-returning method=&quot;commit&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:after-returning&gt; &lt;!--配置异常通知：回滚事务--&gt; &lt;aop:after-throwing method=&quot;rollback&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:after-throwing&gt; &lt;!--配置最终通知：释放连接--&gt; &lt;aop:after method=&quot;release&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:after&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; &lt;/beans&gt; Spring内置的事务管理器(spring-tx)配置AOPspring-tx基于XML配置AOP 用到的所有依赖&lt;dependencies&gt; &lt;!--bean的get set简化--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.12&lt;/version&gt; &lt;/dependency&gt; &lt;!--spring框架核心的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.3.12.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--aop用到的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;4.3.12.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;aopalliance&lt;/groupId&gt; &lt;artifactId&gt;aopalliance&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.7&lt;/version&gt; &lt;/dependency&gt; &lt;!--Spring内置封装的JDBC操作工具类,数据库连接池--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;4.3.12.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--Spring内置的事物管理--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;4.3.12.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql数据库驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.45&lt;/version&gt; &lt;/dependency&gt; &lt;!--纯JUnit测试包--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--日志框架--&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 实体类```javapackage com.ecit.domain;import lombok.Data;import java.io.Serializable;/** 账户的实体类 */@Datapublic class Account implements Serializable { private Integer id; private String name; private Float money;}``` dao层```javapackage com.ecit.dao;import com.ecit.domain.Account;/** 账户的持久层接口 /public interface IAccountDao { /* 根据Id查询账户 @param accountId @return / Account findAccountById(Integer accountId); /* 根据名称查询账户 @param accountName @return */ Account findAccountByName(String accountName); /** 更新账户 @param account */ void updateAccount(Account account); } ```java package com.ecit.dao.impl; import com.ecit.dao.IAccountDao; import com.ecit.domain.Account; import org.springframework.jdbc.core.BeanPropertyRowMapper; import org.springframework.jdbc.core.support.JdbcDaoSupport; import java.util.List; /** * 账户的持久层实现类 */ public class AccountDaoImpl extends JdbcDaoSupport implements IAccountDao { @Override public Account findAccountById(Integer accountId) { List&lt;Account&gt; accounts = super.getJdbcTemplate().query(&quot;select * from account where id = ?&quot;,new BeanPropertyRowMapper&lt;Account&gt;(Account.class),accountId); return accounts.isEmpty()?null:accounts.get(0); } @Override public Account findAccountByName(String accountName) { List&lt;Account&gt; accounts = super.getJdbcTemplate().query(&quot;select * from account where name = ?&quot;,new BeanPropertyRowMapper&lt;Account&gt;(Account.class),accountName); if(accounts.isEmpty()){ return null; } if(accounts.size()&gt;1){ throw new RuntimeException(&quot;结果集不唯一&quot;); } return accounts.get(0); } @Override public void updateAccount(Account account) { super.getJdbcTemplate().update(&quot;update account set name=?,money=? where id=?&quot;,account.getName(),account.getMoney(),account.getId()); } } 业务层```javapackage com.ecit.service;import com.ecit.domain.Account;/** 账户的业务层接口 /public interface IAccountService { /* 根据id查询账户信息 @param accountId @return / Account findAccountById(Integer accountId); /* 转账 @param sourceName 转成账户名称 @param targetName 转入账户名称 @param money 转账金额 / void transfer(String sourceName,String targetName,Float money);} javapackage com.ecit.service.impl;import com.ecit.dao.IAccountDao;import com.ecit.domain.Account;import com.ecit.service.IAccountService;import lombok.Data;/* 账户的业务层实现类 事务控制应该都是在业务层 */@Datapublic class AccountServiceImpl implements IAccountService { private IAccountDao accountDao; public void setAccountDao(IAccountDao accountDao) { this.accountDao = accountDao; } @Override public Account findAccountById(Integer accountId) { return accountDao.findAccountById(accountId); } @Override public void transfer(String sourceName, String targetName, Float money) { System.out.println(“transfer….”); //2.1根据名称查询转出账户 Account source = accountDao.findAccountByName(sourceName); //2.2根据名称查询转入账户 Account target = accountDao.findAccountByName(targetName); //2.3转出账户减钱 source.setMoney(source.getMoney()-money); //2.4转入账户加钱 target.setMoney(target.getMoney()+money); //2.5更新转出账户 accountDao.updateAccount(source); //int i=1/0; //模拟异常事务回滚 //2.6更新转入账户 accountDao.updateAccount(target); } } - spring-bean.xml配置文件 ```xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;context:property-placeholder location=&quot;db-pro.properties&quot; /&gt; &lt;!-- 配置业务层--&gt; &lt;bean id=&quot;accountService&quot; class=&quot;com.ecit.service.impl.AccountServiceImpl&quot;&gt; &lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置账户的持久层--&gt; &lt;bean id=&quot;accountDao&quot; class=&quot;com.ecit.dao.impl.AccountDaoImpl&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置数据源--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driver}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- spring中基于XML的声明式事务控制配置步骤 1、配置事务管理器 2、配置事务的通知 此时我们需要导入事务的约束 tx名称空间和约束，同时也需要aop的 使用tx:advice标签配置事务通知 属性： id：给事务通知起一个唯一标识 transaction-manager：给事务通知提供一个事务管理器引用 3、配置AOP中的通用切入点表达式 4、建立事务通知和切入点表达式的对应关系 5、配置事务的属性 是在事务的通知tx:advice标签的内部 --&gt; &lt;!-- 配置事务管理器 --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置事务的通知--&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;!-- 配置事务的属性 isolation：用于指定事务的隔离级别。默认值是DEFAULT，表示使用数据库的默认隔离级别。 propagation：用于指定事务的传播行为。默认值是REQUIRED，表示一定会有事务，增删改的选择。查询方法可以选择SUPPORTS。 read-only：用于指定事务是否只读。只有查询方法才能设置为true。默认值是false，表示读写。 timeout：用于指定事务的超时时间，默认值是-1，表示永不超时。如果指定了数值，以秒为单位。 rollback-for：用于指定一个异常，当产生该异常时，事务回滚，产生其他异常时，事务不回滚。没有默认值。表示任何异常都回滚。 no-rollback-for：用于指定一个异常，当产生该异常时，事务不回滚，产生其他异常时事务回滚。没有默认值。表示任何异常都回滚。 --&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot; isolation=&quot;READ_COMMITTED&quot;/&gt; &lt;tx:method name=&quot;find*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot; isolation=&quot;READ_COMMITTED&quot;/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 配置aop--&gt; &lt;aop:config&gt; &lt;!-- 配置切入点表达式--&gt; &lt;aop:pointcut id=&quot;pt1&quot; expression=&quot;execution(* com.ecit.service.impl.*.*(..))&quot;&gt;&lt;/aop:pointcut&gt; &lt;!--建立切入点表达式和事务通知的对应关系 --&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:advisor&gt; &lt;/aop:config&gt; &lt;/beans&gt; 测试@Test public void testTx() throws Exception { //1.获取容器 ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;spring-bean.xml&quot;); //2.获取对象 IAccountService as = (IAccountService)ac.getBean(&quot;accountService&quot;); System.out.println(as); as.transfer(&quot;aaa&quot;,&quot;bbb&quot;,100f); } spring-tx基于注解配置AOP jar依赖不变，实体不变 spring-bean.xml修改&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 配置spring创建容器时要扫描的包--&gt; &lt;context:component-scan base-package=&quot;com.itheima&quot;&gt;&lt;/context:component-scan&gt; &lt;!-- 配置JdbcTemplate--&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置数据源--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/testDB&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;1234&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- spring中基于注解 的声明式事务控制配置步骤 1、配置事务管理器 2、开启spring对注解事务的支持 3、在需要事务支持的地方使用@Transactional注解 --&gt; &lt;!-- 配置事务管理器 --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 开启spring对注解事务的支持--&gt; &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;&gt;&lt;/tx:annotation-driven&gt; &lt;/beans&gt; dao改变@Repository(&quot;accountDao&quot;) public class AccountDaoImpl implements IAccountDao { @Autowired private JdbcTemplate jdbcTemplate; @Override public Account findAccountById(Integer accountId) { List&lt;Account&gt; accounts = jdbcTemplate.query(&quot;select * from account where id = ?&quot;,new BeanPropertyRowMapper&lt;Account&gt;(Account.class),accountId); return accounts.isEmpty()?null:accounts.get(0); } @Override public Account findAccountByName(String accountName) { List&lt;Account&gt; accounts = jdbcTemplate.query(&quot;select * from account where name = ?&quot;,new BeanPropertyRowMapper&lt;Account&gt;(Account.class),accountName); if(accounts.isEmpty()){ return null; } if(accounts.size()&gt;1){ throw new RuntimeException(&quot;结果集不唯一&quot;); } return accounts.get(0); } @Override public void updateAccount(Account account) { jdbcTemplate.update(&quot;update account set name=?,money=? where id=?&quot;,account.getName(),account.getMoney(),account.getId()); } } 业务层改变```java@Service(“accountService”)@Transactional(propagation= Propagation.SUPPORTS,readOnly=true)//只读型事务的配置public class AccountServiceImpl implements IAccountService{ @Autowired private IAccountDao accountDao; @Override public Account findAccountById(Integer accountId) { return accountDao.findAccountById(accountId); } //需要的是读写型事务配置 @Transactional(propagation= Propagation.REQUIRED,readOnly=false) @Override public void transfer(String sourceName, String targetName, Float money) { System.out.println(“transfer….”); //2.1根据名称查询转出账户 Account source = accountDao.findAccountByName(sourceName); //2.2根据名称查询转入账户 Account target = accountDao.findAccountByName(targetName); //2.3转出账户减钱 source.setMoney(source.getMoney()-money); //2.4转入账户加钱 target.setMoney(target.getMoney()+money); //2.5更新转出账户 accountDao.updateAccount(source); int i=1/0; //模拟异常，事务回滚 //2.6更新转入账户 accountDao.updateAccount(target); } } ## Spring 支持的事务传播行为 |传播属性|描述| |:----:|:----:| |REQUIRED|如果有事务在运行，当前的方法就在这个事务内运行，否则，就启动一个新的事务，并在自己的事务内运行| |REQUIRED_NEW|当前的方法必须启动新事务，并在它自己的事务内运行.如果有事务正在运行，应该将它挂起| |SUPPORTS|如果有事务在运行，当前的方法就在这个事务内运行.否则它可以不运行在事务中.| |NOT_ SUPPORTED|当前的方法不应该运行在事务中.如果有运行的事务，将它挂起| |MANDATORY|当前的方法必须运行在事务内部，如果没有正在运行的事务，就抛出异常| |NEVER|当前的方法不应该运行在事务中.如果有运行的事务，就抛出异常| |NESTED|如果有事务在运行，当前的方法就应该在这个事务的嵌套事务内运行.否则，就启动一个新的事务，并在它自己的事务内运行.|","link":"/2013/11/09/framework/spring/spring%E6%A1%86%E6%9E%B6-AOP/"},{"title":"Spring框架-IOC","text":"认识springframework的整体框架框架下载地址 https://repo.spring.io/libs-release/org/springframework/spring/4.2.7.RELEASE/ 第一个Spring框架搭建的例子第一种搭建方式maven方法搭建 pom.xml文件添加以下依赖即可&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.0.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.9&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; 第二种搭建方式单独在项目libs下添加 jar包搭建 工厂模式IOC解耦耦合 耦合性(Coupling)，也叫耦合度，是对模块间关联程度的度量。耦合的强弱取决于模块间接口的复杂性、调 用模块的方式以及通过界面传送数据的多少。模块间的耦合度是指模块之间的依赖关系，包括控制关系、调用关 系、数据传递关系。模块间联系越多，其耦合性越强，同时表明其独立性越差( 降低耦合性，可以提高其独立 性)。耦合性存在于各个领域，而非软件设计中独有的，但是我们只讨论软件工程中的耦合。 在软件工程中，耦合指的就是就是对象之间的依赖性。对象之间的耦合越高，维护成本越高。因此对象的设计 应使类和构件之间的耦合最小。软件设计中通常用耦合度和内聚度作为衡量模块独立程度的标准。划分模块的一个准则就是高内聚低耦合。耦合例子 我们在开发中，有些 依赖关系是必须的，有些依赖关系可以通过 优化代码来解除的。 请看下面的示例代码:public class AccountServiceImpl implements IAccountService { private IAccountDao accountDao = new AccountDaoImpl(); } //上面的代码表示: //业务层调用持 久层，并 且此时业 务层在依 赖持久层 的接口和实 现类。如 果此时没 有持久层 实现类， 编译 //将不能通过。这种编译期依赖关系，应该在我们开发中杜绝。我们需要优化代码解决。 //当是我们讲解 jdbc 时，是通过反射来注册驱动的，代码如下: Class.forName(&quot;com.mysql.jdbc.Driver&quot;);//此处只是一个字符串 //产生了一个新的问题，mysql 驱动的全限定类名字符串是在 java 类中写死的，一旦要改还是要修改 源码。 //解决这个问题也很简单，使用配置文件配置。 工厂模式解耦 在实际开发中我们可以把三层的对象都使用配置文件配置起来，当启动服务器应用加载的时候，让一个类中的方法通过读取配置文件，把这些对象创建出来并存起来。在接下来的使用的时候，直接拿过来用就好了。那么，这个读取配置文件，创建和获取三层对象的类就是工厂。控制反转-Inversion Of Control 之前我们在获取对象时，都是采用 new 的方式。是主动的。现在:我们获取对象时，同时跟工厂要，有工厂为我们查找或者创建对象。是被动的。 削减计算机程序的耦合(解除我们代码中的依赖关系)。 SpringIOC中的三种容器 ClassPathXmlApplicationContext 默认会去 classPath 路径下找。classPath 路径指的就是编译后的 classes 目录。@Test public void testBean(){ //单配置文件方式一 BeanFactory beanFactory=new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //单配置文件方式二 BeanFactory beanFactory=new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;); //多个配置文件 BeanFactory beanFactory=new ClassPathXmlApplicationContext(new String[]{&quot;applicationContext.xml&quot;}); //绝对路径需加“file:”前缀 BeanFactory beanFactory = new ClassPathXmlApplicationContext(&quot;file:E:\\Workspace\\idea_workspace\\spring\\springtest\\src\\main\\resources\\applicationContext.xml&quot;); TestBean bean= (TestBean) beanFactory.getBean(&quot;testBean&quot;); } 运行示例你会发现 “classpath:” 是可以缺省的。如果是绝对路径，就需要加上 “file:” 前缀，不可缺省。 FileSystemXmlApplicationContext使用方法FileSystemXmlApplicationContext 默认是去项目的路径下加载，可以是相对路径，也可以是绝对路径，若是绝对路径，“file:” 前缀可以缺省。 @Test public void testBean(){ //classes目录 BeanFactory beanFactory=new FileSystemXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;); //项目路径相对路径 BeanFactory beanFactory=new FileSystemXmlApplicationContext(&quot;src\\\\main\\\\resources\\\\applicationContext.xml&quot;); //多配置文件 BeanFactory beanFactory=new FileSystemXmlApplicationContext(new String[]{&quot;src\\\\main\\\\resources\\\\applicationContext.xml&quot;}); //绝对目录 BeanFactory beanFactory=new FileSystemXmlApplicationContext(new String[]{&quot;E:\\\\Workspace\\\\idea_workspace\\\\spring\\\\springtest\\\\src\\\\main\\\\resources\\\\applicationContext.xml&quot;}); TestBean bean= (TestBean) beanFactory.getBean(&quot;testBean&quot;); assertEquals(&quot;testStr&quot;,bean.getTestStr()); } AnnotationConfigApplicationContext当我们使用注解配置容器对象时，需要使用此类来创建 spring 容器。它用来读取注解。AnnotationConfigApplicationContext actx = new AnnotationConfigApplicationContext(AppConfig.class); DataSource dataSource = (DataSource) actx.getBean(&quot;dataSource&quot;); System.out.println(dataSource); Applicationcontext容器加载Bean 和 Beanfactory容器加载Bean区别不同点 Applicationcontext容器在进行初始化时，会将其中的所有Bean（对象）进行创建 缺点:占用系统资源（内存、CPU等） 优点:响应速度快 Beanfactory容器中的对象，在容器初始化时并不会被创建，而是在真正获取该对象时才被创建 缺点:相对来说，响应速度慢 优点:不多占用系统资源相同点都是在无参构造器调用之前 ，就已经在堆内存分配空间，动态代码块先执行中可看出public class TestSpring { @Test public void testApplicationContext() { @SuppressWarnings(&quot;resource&quot;) ApplicationContext ac = new FileSystemXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;); ISomeService someService1 = (ISomeService) ac.getBean(&quot;someServiceImpl&quot;); someService1.doSome(); } @Test public void testBeanFactory() { BeanFactory beanFactory = (BeanFactory) new XmlBeanFactory(new ClassPathResource(&quot;applicationContext.xml&quot;)); ISomeService someService1 = (ISomeService) beanFactory.getBean(&quot;someServiceImpl&quot;); someService1.doSome(); } } public class TestSpring { @Test public void testApplicationContext() { // ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); // ISomeService someService = (ISomeService) ac.getBean(&quot;someImpl&quot;); // someService.doSome(); // ApplicationContext ac = new FileSystemXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;); // ISomeService someService = (ISomeService) ac.getBean(&quot;someImpl&quot;); // someService.doSome(); // BeanFactory beanFactory = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); // ISomeService someService = (ISomeService) beanFactory.getBean(&quot;someImpl&quot;); // someService.doSome(); BeanFactory beanFactory = new FileSystemXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;); ISomeService someService = (ISomeService) beanFactory.getBean(&quot;someImpl&quot;); someService.doSome(); } } 容器加载动态工厂类，然后再由工厂类生产bean 示例 &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- bean definitions here --&gt; &lt;beans&gt; &lt;!-- 定义动态工厂 --&gt; &lt;bean id=&quot;serviceFactory&quot; class=&quot;com.songxm.learning.spring.factory.ServiceFactory&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;someServiceImpl&quot; factory-bean=&quot;serviceFactory&quot; factory-method=&quot;getSomeService&quot;&gt;&lt;/bean&gt; &lt;/beans&gt; &lt;/beans&gt; 动态工厂 public class ServiceFactory { public ISomeService getSomeService() { System.out.println(&quot;工厂生产bean&quot;); return new SomeServiceImpl(); } } 容器加载静态工厂类，然后再由工厂类生产bean 示例 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- bean definitions here --&gt; &lt;beans&gt; &lt;bean id=&quot;someServiceImpl&quot; class=&quot;com.songxm.learning.spring.factory.ServiceFactory&quot; factory-method=&quot;getSomeService&quot;&gt;&lt;/bean&gt; &lt;/beans&gt; &lt;/beans&gt; 静态工厂 public class ServiceFactory { public static ISomeService getSomeService() { System.out.println(&quot;静态工厂生产bean&quot;); return new SomeServiceImpl(); } } Bean的作用域当通过 Spring容器创建一个Bean实例时，不仅可以完成Bean的实例化，还可以通过scope属性，为Bean指定特定的作用域。 Spring支持5种作用域。 （1） singleton:单态模式。即在整个 Spring容器中，使用 singleton定义的Bean将是单例的只有一个实例。默认为单态的 （2） prototype:原型模式。即每次使用 getbean方法获取的同一个&lt;bean&gt;的实例都是一个新的实例。 （3） request对于每次HTTP请求，都将会产生一个不同的Bean实例。 （4） session:对于每个不同的 HTTP session，都将产生一个不同的Bean实例。 注意: （1）对于 scope的值 request、 session与 global session，只有在Web应用中使用Spring时，该作用域才有效 （2）对于 scope为singleton的单例模式，该Bean是在容器被创建时即被装配好了。（ (3）对于 scope为prototype的原型模式，Bean实例是在代码中使用该Bean实例时才进行装配的。 scope=prototype 原型模式 深克隆&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;beans&gt; &lt;!-- scope=&quot;prototype&quot;原型模式，其对象的创建时机不是在Spring容器初始化时创建，而是在代码中真正访问时才创建 --&gt; &lt;bean id=&quot;someServiceImpl&quot; class=&quot;com.songxm.learning.spring.service.SomeServiceImpl&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt; &lt;/beans&gt; &lt;/beans&gt; ApplicationContext ac = new FileSystemXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;); ISomeService someService1 = (ISomeService) ac.getBean(&quot;someServiceImpl&quot;); ISomeService someService2 = (ISomeService) ac.getBean(&quot;someServiceImpl&quot;); System.out.println(someService1 == someService2); 输出: 执行无参构造器!!!! 执行无参构造器!!!! false scope=singleton 单例&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;beans&gt; &lt;bean id=&quot;someServiceImpl&quot; class=&quot;com.songxm.learning.spring.service.SomeServiceImpl&quot; scope=&quot;singleton&quot;&gt;&lt;/bean&gt; &lt;/beans&gt; &lt;/beans&gt; 输出: 执行无参构造器!!!! true Bean后处理器 Bean后处理器是一种特殊的Bean，容器中所有的Bean在初始化时，均会自动执行该类的两个方法。由于该Bean是由其它Bean自动调用执行，不是程序员手工调用，故此Bean无须id属性。需要做的是，在Bean后处理器类方法中，只要对Bean类与Bean类中的方法进行判断就可实现对指定的Bean的指定方法进行功能扩展与增强。方法返回的Bean对象，即是增强过的对象。 代码中需要自定义Bean后处理器类。该类就是实现了接口 Beanpostprocessor 的类。该接口中包含两个方法，分别在目标Bean初始化完毕之前与之后执行。它们的返回值为:功能被扩展或增强后的Bean对象。Bean初始化完毕有一个标志:一个方法将被执行。即当该方法被执行时，表示该Bean被初始化完毕。所以Bean后处理器中两个方法的执行，是在这个方法之前之后执行。这个方法在后面将会讲到 public Object postprocessbeforeinitiailzation（Object bean， String beanId)throws Beansexception该方法会在目标Bean初始化完毕之前由容器自动调用。 public Object postprocessafterinitialization（Object bean， String beanId） throws Beansexception该方法会在目标Bean初始化完毕之后由容器自动调用它们的参数是:第一个参数是系统即将初始化的Bean实例，第二个参数是该Bean实例的id属性值。若Bean没有id就是name属性值。 package com.songxm.learning.spring.service; public interface ISomeService { public String doSome(String task); } package com.songxm.learning.spring.service; public class SomeServiceImpl implements ISomeService { public SomeServiceImpl() { System.out.println(&quot;执行无参构造器!!!!&quot;); } @Override public String doSome(String task) { System.out.println(&quot;doSome.....&quot; + task); return task; } } package com.songxm.learning.spring.service.processor; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; import org.springframework.beans.BeansException; import org.springframework.beans.factory.config.BeanPostProcessor; public class MyBeanPostProcessor implements BeanPostProcessor { @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { System.out.println(&quot;bean初始化前准备阶段.........&quot; + beanName + &quot;--&gt;&quot; + bean); return bean; } @Override public Object postProcessAfterInitialization(final Object bean, String beanName) throws BeansException { System.out.println(&quot;bean初始后.........&quot; + beanName + &quot;--&gt;&quot; + bean); Object proxy_obj = Proxy.newProxyInstance(bean.getClass().getClassLoader(), bean.getClass().getInterfaces(), new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(&quot;动态代理拦截bean执行方法------&quot;); Object invoke = method.invoke(bean, args); return ((String) invoke).toUpperCase(); } }); return proxy_obj; } } &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;beans&gt; &lt;bean id=&quot;someServiceImpl&quot; class=&quot;com.songxm.learning.spring.service.SomeServiceImpl&quot;&gt;&lt;/bean&gt; &lt;bean class=&quot;com.songxm.learning.spring.service.processor.MyBeanPostProcessor&quot;&gt;&lt;/bean&gt; &lt;/beans&gt; &lt;/beans&gt; import org.junit.Test; import org.springframework.context.ApplicationContext; import org.springframework.context.support.FileSystemXmlApplicationContext; import com.songxm.learning.spring.service.ISomeService; public class TestSpring { @Test public void testApplicationContext() { ApplicationContext ac = new FileSystemXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;); ISomeService someService1 = (ISomeService) ac.getBean(&quot;someServiceImpl&quot;); System.out.println(someService1.doSome(&quot;abbbbbb&quot;)); } } 执行结果: 执行无参构造器!!!! bean初始化前准备阶段.........someServiceImpl--&gt;com.songxm.learning.spring.service.SomeServiceImpl@5f86961 bean初始后.........someServiceImpl--&gt;com.songxm.learning.spring.service.SomeServiceImpl@5f86961 动态代理拦截bean执行方法------ doSome.....abbbbbb ABBBBBB 定制bean的生命始末对于bean定制的销毁调用需满足以下条件： 当前bean需要是singleton的 要手工关闭容器&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;beans&gt; &lt;bean id=&quot;someServiceImpl&quot; class=&quot;com.songxm.learning.spring.service.SomeServiceImpl&quot; init-method=&quot;init&quot; destroy-method=&quot;destroy&quot;&gt;&lt;/bean&gt; &lt;bean class=&quot;com.songxm.learning.spring.service.processor.MyBeanPostProcessor&quot;&gt;&lt;/bean&gt; &lt;/beans&gt; &lt;/beans&gt; package com.songxm.learning.spring.service; public class SomeServiceImpl implements ISomeService { public SomeServiceImpl() { System.out.println(&quot;执行无参构造器!!!!&quot;); } @Override public String doSome(String task) { System.out.println(&quot;doSome.....&quot; + task); return task; } public void destroy() { System.out.println(&quot;销毁bean........&quot;); } public void init() { System.out.println(&quot;初始化bean.......&quot;); } } import org.junit.Test; import org.springframework.context.ApplicationContext; import org.springframework.context.support.FileSystemXmlApplicationContext; import com.songxm.learning.spring.service.ISomeService; public class TestSpring { @Test public void testApplicationContext() { ApplicationContext ac = new FileSystemXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;); ISomeService someService1 = (ISomeService) ac.getBean(&quot;someServiceImpl&quot;); System.out.println(someService1.doSome(&quot;abbbbbb&quot;)); ((FileSystemXmlApplicationContext)ac).close(); } } 执行结果执行无参构造器!!!! bean初始化前准备阶段.........someServiceImpl--&gt;com.songxm.learning.spring.service.SomeServiceImpl@78ac15cd 初始化bean....... bean初始后.........someServiceImpl--&gt;com.songxm.learning.spring.service.SomeServiceImpl@78ac15cd 动态代理拦截bean执行方法------ doSome.....abbbbbb ABBBBBB 销毁bean........ Bean的生命周期Spring IOC容器对Bean的生命周期进行管理的过程: . 通过构造器或工厂方法创建Bean实例 为Bean的属性设置值和对其他Bean的引用 将Bean实例传递给Bean后置处理器的postProcessBeforelnitialization方法 调用Bean的初始化方法 将Bean实例传递给Bean后置处理器的postProcessAfterlnitialization方法 Bean可以使用了 当容器关闭时,调用Bean的销毁方法 bean 标签的id属性与name属性 一般情况下，命名 bean 使用id属性，而不使用name属性。在没有id属性的情况下name属性与id属性作用是相同的。但当bean中含有一些特殊字符时，就需要使用name属性了，id的命名需要满足XML对1D属性命名规范:必须以字母开头，可以包含字母、数字下划线、连字符、句话、冒号name属性值则可以包含各种字符 基于XML的DI注入分类Bean实例在调用无参构造器创建了空值对象后，就要对Bean对象的属性进行初始化初始化是由容器自动完成的，称为注入。根据注入方式的不同，常用的有两类: 设值注入 构造注入还有另外一种，实现特定接口注入。由于这种方式采用侵入式编程，污染了代码，所以几乎不用设值注入&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;beans&gt; &lt;bean id=&quot;school&quot; class=&quot;com.songxm.learning.spring.bean.School&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;清华大学&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;student&quot; class=&quot;com.songxm.learning.spring.bean.Student&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;sxm&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt; &lt;property name=&quot;school&quot; ref=&quot;school&quot;/&gt; &lt;/bean&gt; &lt;/beans&gt; &lt;/beans&gt; package com.songxm.learning.spring.bean; public class School { private String name; public School() {} public School(String name) { this.name = name; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return &quot;School [name=&quot; + name + &quot;]&quot;; } } package com.songxm.learning.spring.bean; public class Student { private String name; private int age; private School school; public Student() { } public Student(String name, int age, School school) { this.name = name; this.age = age; this.school = school; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public School getSchool() { return school; } public void setSchool(School school) { this.school = school; } @Override public String toString() { return &quot;Student [name=&quot; + name + &quot;, age=&quot; + age + &quot;, school=&quot; + school + &quot;]&quot;; } } 测试效果import org.junit.Test; import org.springframework.context.ApplicationContext; import org.springframework.context.support.FileSystemXmlApplicationContext; import com.songxm.learning.spring.bean.Student; public class TestSpring { @Test public void testApplicationContext() { ApplicationContext ac = new FileSystemXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;); Student studet = (Student) ac.getBean(&quot;student&quot;); System.out.println(studet); } } 输出: Student [name=sxm, age=18, school=School [name=清华大学]] 构造注入constructor-arg&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;beans&gt; &lt;bean id=&quot;school&quot; class=&quot;com.songxm.learning.spring.bean.School&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;清华大学&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;student&quot; class=&quot;com.songxm.learning.spring.bean.Student&quot;&gt; &lt;constructor-arg index=&quot;0&quot; value=&quot;sxm&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index=&quot;1&quot; value=&quot;18&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index=&quot;2&quot; ref=&quot;school&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;/beans&gt; &lt;/beans&gt; 命名空间p-设置注入&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;beans&gt; &lt;bean id=&quot;school&quot; class=&quot;com.songxm.learning.spring.bean.School&quot; p:name=&quot;清华大学&quot;&gt; &lt;/bean&gt; &lt;bean id=&quot;student&quot; class=&quot;com.songxm.learning.spring.bean.Student&quot; p:name=&quot;sxm&quot; p:age=&quot;18&quot; p:school-ref=&quot;school&quot;&gt; &lt;/bean&gt; &lt;/beans&gt; &lt;/beans&gt; 命令空间c-构造器注入&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:c=&quot;http://www.springframework.org/schema/c&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;beans&gt; &lt;bean id=&quot;school&quot; class=&quot;com.songxm.learning.spring.bean.School&quot; c:name=&quot;清华大学&quot;&gt; &lt;/bean&gt; &lt;bean id=&quot;student&quot; class=&quot;com.songxm.learning.spring.bean.Student&quot; c:name=&quot;sxm&quot; c:age=&quot;18&quot; c:school-ref=&quot;school&quot;&gt; &lt;/bean&gt; &lt;/beans&gt; &lt;/beans&gt; 集合属性注入package com.songxm.learning.spring.bean; import java.util.Arrays; import java.util.List; import java.util.Map; import java.util.Set; public class School { private String name; private String[] strArray; private List&lt;String&gt; list; private Set&lt;String&gt; set; private Map&lt;String,String&gt; map; public School() {} public String getName() { return name; } public void setName(String name) { this.name = name; } public String[] getStrArray() { return strArray; } public void setStrArray(String[] strArray) { this.strArray = strArray; } public List&lt;String&gt; getList() { return list; } public void setList(List&lt;String&gt; list) { this.list = list; } public Set&lt;String&gt; getSet() { return set; } public void setSet(Set&lt;String&gt; set) { this.set = set; } public Map&lt;String, String&gt; getMap() { return map; } public void setMap(Map&lt;String, String&gt; map) { this.map = map; } @Override public String toString() { return &quot;School [name=&quot; + name + &quot;, strArray=&quot; + Arrays.toString(strArray) + &quot;, list=&quot; + list + &quot;, set=&quot; + set + &quot;, map=&quot; + map + &quot;]&quot;; } } &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:c=&quot;http://www.springframework.org/schema/c&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;beans&gt; &lt;bean id=&quot;school&quot; class=&quot;com.songxm.learning.spring.bean.School&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;清华大学&quot;&gt;&lt;/property&gt; &lt;property name=&quot;strArray&quot; value=&quot;aaa,bbb,cccc&quot;&gt;&lt;/property&gt; &lt;property name=&quot;list&quot; value=&quot;aaa,bbb,cccc&quot;&gt;&lt;/property&gt; &lt;property name=&quot;set&quot; value=&quot;aaa,bbb,cccc&quot;&gt;&lt;/property&gt; &lt;property name=&quot;map&quot;&gt; &lt;map&gt; &lt;entry key=&quot;111&quot; value=&quot;1111&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;222&quot; value=&quot;222&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;333&quot; value=&quot;333&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;444&quot; value=&quot;444&quot;&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;student&quot; class=&quot;com.songxm.learning.spring.bean.Student&quot; c:name=&quot;sxm&quot; c:age=&quot;18&quot; c:school-ref=&quot;school&quot;&gt; &lt;/bean&gt; &lt;/beans&gt; &lt;/beans&gt; 域属性(对象bean作为另一个对象的属性)的自动注入 byName&lt;!--注册school--&gt; &lt;bean id=&quot;mySchool&quot; class=&quot;com.ecit.domain.School&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;情华大学&quot;/&gt; &lt;/bean&gt; &lt;!--注册Student autowire=&quot;byName&quot;会从容器中查找与实体类的域属性同名的Bean的id --&gt; &lt;bean id=&quot;myStudent&quot; class=&quot;com.ecit.domain.Student&quot; autowire=&quot;byName&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt; &lt;property name= &quot;age&quot; value=&quot;23&quot; /&gt; &lt;/bean&gt; byType&lt;!--注册Student autowire=&quot;byType&quot; 会从容器中查找与实体类的域属性类型相同的Bean,并将该Bean对象自动注入给该域属性--&gt; &lt;bean id=&quot;myStudent&quot; class=&quot;com.ecit.domain.Student&quot; autowire=&quot;byType&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt; &lt;property name= &quot;age&quot; value=&quot;23&quot; /&gt; &lt;/bean&gt; SPELSpring Expression Language,即 Spring EL表达式语言，以#开头，后跟一对大括号。 &lt;bean id=&quot;abc&quot; value=&quot;#{...}&quot;/&gt; &lt;!--注册User --&gt; &lt;bean id=&quot;myUser&quot; class= &quot;com.ecit.domain.User&quot;&gt; &lt;property name= &quot;username&quot; value= &quot;李四&quot;/&gt; &lt;property name= &quot;age&quot; value=&quot;#{T(java.lang.Math).random()*50}&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;myStudent&quot; class= &quot;com.ecit.domain.Student&quot;&gt; &lt;property name= &quot;name&quot; value= &quot;#{myUser.username}&quot;/&gt; &lt;property name=&quot;age&quot; value= &quot;#{myUser.computeAge()}&quot;/&gt; &lt;/bean&gt; 内部bean注入 了解 &lt;!--注册User --&gt; &lt;bean id=&quot;myUser&quot; class=&quot;com.ecit.domain.User&quot;&gt; &lt;property name=&quot;username&quot; value=&quot;李四&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;#{T(java.lang.Math).random()*50}&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;myStudent&quot; class=&quot;com.ecit.domain.Student&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;#{myUser.username}&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;#{myUser.computeAge()}&quot;/&gt; &lt;property name=&quot;school&quot;&gt; &lt;bean class=&quot;com.ecit.domain.School&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;悄华大学&quot;/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; 同类抽象bean&lt;bean id=&quot;baseStudent&quot; class=&quot;com.ecit.domain.Student&quot; abstract=&quot;true&quot;&gt; &lt;property name=&quot;school&quot; value=&quot;清华大学&quot;/&gt; &lt;property name=&quot;department&quot; value=&quot;计算机系&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;myStudent1&quot; parent=&quot;baseStudent&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;张三 &quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;23&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;myStudent2&quot; parent=&quot;baseStudent&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;李四&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;24 &quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;myStudent3&quot; parent=&quot;baseStudent&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;王五&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;25&quot;/&gt; &lt;/bean&gt; 异类抽象&lt;bean id=&quot;baseBean&quot; class=&quot;com.ecit.domain.Student&quot; abstract=&quot;true&quot;&gt; &lt;property name=&quot;school&quot; value=&quot;清华大学&quot;/&gt; &lt;property name=&quot;department&quot; value=&quot;计算机系&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;myStudent1&quot; parent=&quot;baseBean&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;张三 &quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;23&quot;/&gt; &lt;/bean&gt; &lt;bean id= &quot;myTeacher&quot; class=&quot;com.ecit.domain.Teacher&quot; parent= &quot;baseBean&quot;&gt; &lt;property name= &quot;name&quot; value= &quot;Reyco&quot;/&gt; &lt;property name= &quot;workAge&quot; value=&quot;18&quot;/&gt; &lt;/bean&gt; Spring指定多个 xml配置文件@Test public void testApplicationMutilConfig(){ String resource1 = &quot;config/spring-base.xml&quot;; String resource2 = &quot;config/spring-beans.xml&quot;; String[ ] resources = {resource1, resource2}; ApplicationContext ac = new ClassPathXmlApplicationContext(resources); Student student = (Student) ac. getBean(&quot;myStudent1&quot;); System. out. println(student); Teacher teacher = (Teacher) ac.getBean(&quot;myTeacher&quot;); System. out. println(teacher); } Spring指定多个xml配置文件 包含关系include&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;import resource=&quot;classpath:config/spring-base.xml&quot;/&gt; &lt;import resource=&quot;classpath:config/spring-beans.xml&quot;/&gt; &lt;/beans&gt; 基于注解的DI@Component //组件，表示当前类被Spring容器所管理，用在类上面 &lt;bean id=&quot;student&quot; class=&quot;com.songxm.learning.spring.bean.Student&quot; c:name=&quot;sxm&quot; c:age=&quot;18&quot; c:school-ref=&quot;school&quot;&gt; &lt;/bean&gt; 等同于注解形式的 @Component(&quot;student&quot;) public class Student { @Value(&quot;清华大学&quot;) private String name; @Value(&quot;18&quot;) private int age; @Autowired private School school; public Student() { } } 需要xml配置注解扫描器 和AOP 依赖 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.songxm.learning.spring.bean.*&quot;/&gt; &lt;/beans&gt; 扫描包注意 &lt;!--扫描com.ecit这个包及其子包--&gt; &lt;context:component-scan base-package=&quot;com.ecit&quot;/&gt; &lt;!--扫描com.ecit 这个包的子包--&gt; &lt;context:component-scan base-package=&quot;com.ecit.*&quot;/&gt; 当在组件类上使用了特定的注解之后, 还需要在 Spring 的配置文件中声明 &lt;context:component-scan&gt; ： base-package 属性指定一个需要扫描的基类包，Spring 容器将会扫描这个基类包里及其子包中的所有类. 当需要扫描多个包时, 可以使用逗号分隔. 如果仅希望扫描特定的类而非基包下的所有类，可使用 resource-pattern 属性过滤特定的类，示例： &lt;context:include-filter&gt; 子节点表示要包含的目标类 &lt;context:exclude-filter&gt; 子节点表示要排除在外的目标类 &lt;context:component-scan&gt; 下可以拥有若干个 &lt;context:include-filter&gt; 和 &lt;context:exclude-filter&gt; 子节点 &lt;context:component-scan&gt; 元素还会自动注册 AutowiredAnnotationBeanPostProcessor 实例, 该实例可以自动装配具有 @Autowired 和 @Resource 、@Inject注解的属性. @Inject 和 @Autowired 注解一样也是按类型匹配注入的 Bean， 但没有 reqired 属性,建议使用 @Autowired 注解 与注解@Componet功能相同意义不同的注解与 @Component注解功能相同，但意义不同的注解还有三个: 1）@Repository:注解在Dao实现类上 2）@Service:注解在 Service实现类上 3）@Controller:注解在 Springmvc的处理器上 @Scope@Scope(&quot;prototype&quot;) @Component(&quot;student&quot;) public class Student { @Value(&quot;清华大学&quot;) private String name; @Value(&quot;18&quot;) private int age; @Autowired private School school; public Student() { } } 基于注解域属性注入@Component(&quot;student&quot;) public class Student { @Value(&quot;清华大学&quot;) private String name; @Value(&quot;18&quot;) private int age; @Autowired @Qualifier(&quot;school&quot;) //byName方式 private School school; public Student() { } } @Resource@Component(&quot;student&quot;) public class Student { @Value(&quot;清华大学&quot;) private String name; @Value(&quot;18&quot;) private int age; @Resource //byType方式 private School school; public Student() { } } 基于注解的Bean的生命始末@PostConstruct 与 @PreDestroy@Postconstruct,与原来的 init-method等效。在方法上使用 @predestro 与 destroy-method等效。 @Configuration表示当前充当Spring容器，即所有的bean将由这个类来创建 @Configuration public class MyConfig { @Bean(name = &quot;school&quot;) public School createSchool() { return new School(); } @Bean(name=&quot;student&quot;,autowire=Autowire.BY_NAME) //将根据名字注入域属性school到 student对象里 public Student createStudent() { return new Student(); } } 基于注解的DI-XML的优先级高于注解的Spring注解和XML依赖注入IOC的选择总结 注解的优势: 配置简单，维护方便(我们找到类，就相当于找到了对应的配置)。 XML 的优势: 修改时，不用改源码。不涉及重新编译和部署。 协调作用域不同步的Bean 当singleton类型的bean引用prototype类型的bean时候，就会有问题,在这里假设A为singleton类型的bean B为prototype类型的bean A需要引用B,Class A的scope是默认的singleton，因此Context只会创建Class A的bean一次，所以也就只有一次注入依赖的机会，容器也就无法每次给Class A提供一个新的Class B.//单例的Class A @Component public class ClassA { @Autowired private ClassB classB; public void printClass() { System.out.println(&quot;This is Class A: &quot; + this); classB.printClass(); } } //非单例的Class B @Component @Scope(value = SCOPE_PROTOTYPE) public class ClassB { public void printClass() { System.out.println(&quot;This is Class B: &quot; + this); } } 查看问题@RunWith(SpringRunner.class) @ContextConfiguration(classes = {ClassA.class, ClassB.class}) public class MyTest { @Autowired private ClassA classA; @Test public void simpleTest() { for (int i = 0; i &lt; 3; i++) { classA.printClass(); } } } @LookupSpring提供了一个名为@Lookup的注解，这是一个作用在方法上的注解，被其标注的方法会被重写，然后根据其返回值的类型，容器调用BeanFactory的getBean()方法来返回一个bean。@Component public class ClassA { public void printClass() { System.out.println(&quot;This is Class A: &quot; + this); getClassB().printClass(); } @Lookup public ClassB getClassB() { //被标注的方法的返回值不再重要，因为容器会动态生成一个子类然后将这个被注解的方法重写/实现，最终调用的是子类的方法。 return null; } } xml方式的lookup&lt;lookup-method name=&quot;getClassB&quot; bean=&quot;classB&quot;/&gt;告诉 Spring用 CGLLB动态地生成一个子类。 IOC之Spring统一资源加载策略 在学Java SE 的时候我们学习了一个标准类 java.net.URL（Uniform Resource Locator），叫做统一资源定位器，但是它的实现基本只限于网络形式发布的资源的查找和定位。然而，实际上资源的定义比较广泛，除了网络形式的资源，还有以二进制形式存在的、以文件形式存在的、以字节流形式存在的等等。而且它可以存在于任何场所，比如网络、文件系统、应用程序中。所以 java.net.URL 的局限性迫使 Spring 必须实现自己的资源加载策略，该资源加载策略需要满足如下要求： 职能划分清楚。资源的定义和资源的加载应该要有一个清晰的界限； 统一的抽象。统一的资源定义和资源加载策略。资源加载后要返回统一的抽象给客户端，客户端要对资源进行怎样的处理，应该由抽象资源接口来界定。 统一资源：Resourceorg.springframework.core.io.Resource为Spring 框架所有资源的抽象和访问接口，它继承 org.springframework.core.io.InputStreamSource接口。作为所有资源的统一抽象，Source 定义了一些通用的方法，由子类 AbstractResource 提供统一的默认实现。 public interface Resource extends InputStreamSource { /** * 资源是否存在 */ boolean exists(); /** * 资源是否可读 */ default boolean isReadable() { return true; } /** * 资源所代表的句柄是否被一个stream打开了 */ default boolean isOpen() { return false; } /** * 是否为 File */ default boolean isFile() { return false; } /** * 返回资源的URL的句柄 */ URL getURL() throws IOException; /** * 返回资源的URI的句柄 */ URI getURI() throws IOException; /** * 返回资源的File的句柄 */ File getFile() throws IOException; /** * 返回 ReadableByteChannel */ default ReadableByteChannel readableChannel() throws IOException { return Channels.newChannel(getInputStream()); } /** * 资源内容的长度 */ long contentLength() throws IOException; /** * 资源最后的修改时间 */ long lastModified() throws IOException; /** * 根据资源的相对路径创建新资源 */ Resource createRelative(String relativePath) throws IOException; /** * 资源的文件名 */ @Nullable String getFilename(); /** * 资源的描述 */ String getDescription(); } 统一资源定位：ResourceLoader Spring 将资源的定义和资源的加载区分开了，Resource 定义了统一的资源，那资源的加载则由 ResourceLoader 来统一定义。org.springframework.core.io.ResourceLoader 为 Spring 资源加载的统一抽象，具体的资源加载则由相应的实现类来完成，所以我们可以将 ResourceLoader 称作为统一资源定位器。其定义如下public interface ResourceLoader { String CLASSPATH_URL_PREFIX = &quot;classpath:&quot;; Resource getResource(String var1); ClassLoader getClassLoader(); } ResourceLoader 接口提供两个方法：**getResource()、getClassLoader()**。 getResource()根据所提供资源的路径 location 返回 Resource 实例，但是它不确保该 Resource一定存在，需要调用 Resource.exist()方法判断。该方法支持以下模式的资源加载： URL位置资源，如”file:C:/test.dat” ClassPath位置资源，如”classpath:test.dat” 相对路径资源，如”WEB-INF/test.dat”，此时返回的Resource实例根据实现不同而不同该方法的主要实现是在其子类 DefaultResourceLoader 中实现public Resource getResource(String location) { Assert.notNull(location, &quot;Location must not be null&quot;); Iterator ex = this.protocolResolvers.iterator(); Resource resource; do { if(!ex.hasNext()) { if(location.startsWith(&quot;/&quot;)) { return this.getResourceByPath(location); } if(location.startsWith(&quot;classpath:&quot;)) { return new ClassPathResource(location.substring(&quot;classpath:&quot;.length()), this.getClassLoader()); } try { URL ex1 = new URL(location); return new UrlResource(ex1); } catch (MalformedURLException var5) { return this.getResourceByPath(location); } } ProtocolResolver protocolResolver = (ProtocolResolver)ex.next();//首先通过 ProtocolResolver 来加载资源，成功返回 Resource resource = protocolResolver.resolve(location, this); } while(resource == null); return resource; } 综合示例 创建一个引用Resource接口的实现类import org.springframework.core.io.Resource; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.io.UnsupportedEncodingException; @Data public class InfoBean { // Resource所代表的资源可能来自磁盘、网络、类路径. private Resource res; private String charset; public void readInfo(){ try (BufferedReader br = new BufferedReader(new InputStreamReader(res.getInputStream(), charset))){ String line = null; while( (line = br.readLine () ) != null ) { System. out.println (line) ; } }catch (UnsupportedEncodingException e ){ throw new RuntimeException(e); }catch(IOException e){ throw new RuntimeException(e); } } } 在Spring容器配置文件bean.xml添加&lt;bean id=&quot;infobean1&quot; class=&quot;com.ecit.domain.InfoBean&quot;&gt; &lt;property name=&quot;charset&quot; value=&quot;UTF-8&quot; /&gt; &lt;property name=&quot;res&quot; value=&quot;classpath:datasource.properties&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;infobean2&quot; class=&quot;com.ecit.domain.InfoBean&quot;&gt; &lt;property name=&quot;charset&quot; value=&quot;UTF-8&quot; /&gt; &lt;property name=&quot;res&quot; value=&quot;file:///Users/sxm/Desktop/test.txt&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;infobean3&quot; class=&quot;com.ecit.domain.InfoBean&quot;&gt; &lt;property name=&quot;charset&quot; value=&quot;UTF-8&quot; /&gt; &lt;property name=&quot;res&quot; value=&quot;http://www.baidu.com&quot;/&gt; &lt;/bean&gt; 测试结果import com.ecit.domain.InfoBean; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Qualifier; import org.springframework.test.context.ContextConfiguration; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; import org.junit.Test; @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(locations = &quot;classpath:bean.xml&quot;) public class Spring4Test { @Autowired @Qualifier(&quot;infobean1&quot;) InfoBean infoBean1; @Autowired @Qualifier(&quot;infobean2&quot;) InfoBean infoBean2; @Autowired @Qualifier(&quot;infobean3&quot;) InfoBean infoBean3; @Test public void testResource1(){ infoBean1.readInfo(); } @Test public void testResource2(){ infoBean2.readInfo(); } @Test public void testResource3(){ infoBean3.readInfo(); } } Bean获取Spring容器 有些时候，Bean要实现某个功能，但该功能需要借助于Spring容器来实现，此时就需要让该Bean获取它所在的容器。1.让该Beam实现 ApplicationContextAware接口2.必须实现该接口中 setApplicationContext方法。public class ServiceEvent implements ApplicationContextAware{ private ApplicationContext ctx; public void sendNotice(NoticeEvent event){ ctx.publishEvent(event); } //Spring会自动检测容器中所有Bean,如果发现某个Bean实现 ApplicationContextAware接口, //Spring容器就会在 setter方法调用之后,自动调用 setApplicationContext方法 @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException { this.ctx = applicationContext; } } 使用外部属性文件-PropertyPlaceholderConfigurer 在配置文件里配置Bean时，有时需要在Bean的配置里混入系统部署的细节信息(例如:文件路径,数据源配置信息等).而这些部署细节实际上需要和Bean配置相分离 Spring提供了一个PropertyPlaceholderConfigurer的BeanFactory后置处理器,这个处理器允许用户将Bean配置的部分内容外移到属性文件中.可以在Bean配置文件里使用形式为${var}的变量, PropertyPlaceholderConfigurer从属性文件里加载属性,并使用这些属性来替换变量. Spring还允许在属性文件中使用${propName},以实现属性之间的相互引用。 注册PropertyPlaceholderConfigurer Spring 2.0:&lt;bean class= &quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt; &lt;property name=&quot;location&quot; value= &quot;classpath:db.properties&quot;&gt;&lt;/property&gt; &lt;/bean&gt; Spring 2.5之后支持:&lt;context:property-placeholder location =&quot;classpath:db.properties&quot;/&gt;","link":"/2013/11/08/framework/spring/spring%E6%A1%86%E6%9E%B6-IOC/"},{"title":"spring整合swagger","text":"pom依赖添加 &lt;!-- Swagger --&gt; &lt;dependency&gt; &lt;groupId&gt;io.swagger&lt;/groupId&gt; &lt;artifactId&gt;swagger-core&lt;/artifactId&gt; &lt;version&gt;1.5.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.6.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.6.0&lt;/version&gt; &lt;/dependency&gt; 配置package com.songxm.qiuqiu.manage.conf; import static springfox.documentation.builders.PathSelectors.regex; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.config.annotation.EnableWebMvc; import springfox.documentation.builders.ApiInfoBuilder; import springfox.documentation.builders.RequestHandlerSelectors; import springfox.documentation.service.ApiInfo; import springfox.documentation.service.Contact; import springfox.documentation.spi.DocumentationType; import springfox.documentation.spring.web.plugins.Docket; import springfox.documentation.swagger2.annotations.EnableSwagger2; /** * SwaggerConfig */ @Configuration @EnableSwagger2 @EnableWebMvc public class Swagger2Configuration { @Bean public Docket accessToken() { return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;api&quot;)// 定义组 .select() // 选择那些路径和api会生成document .apis(RequestHandlerSelectors.basePackage(&quot;com.songxm.qiuqiu.manage.controller&quot;)) // 拦截的包路径 .paths(regex(&quot;/.*&quot;))// 拦截的接口路径 .build() // 创建 .apiInfo(apiInfo()); // 配置说明 } private ApiInfo apiInfo() { return new ApiInfoBuilder()// .title(&quot;球球&quot;)// 标题 .description(&quot;球球后台管理&quot;)// 描述 .termsOfServiceUrl(&quot;http://www.songxmtop.com&quot;)// .contact(new Contact(&quot;songxm&quot;, &quot;http://www.songxmtop.com&quot;, &quot;843048139@qq.com&quot;))// 联系 //.license(&quot;Apache License Version 2.0&quot;)// 开源协议 //.licenseUrl(&quot;https://github.com/springfox/springfox/blob/master/LICENSE&quot;)// 地址 .version(&quot;1.0&quot;)// 版本 .build(); } } springmvc-servlet.xml容器静态资源配置处理 &lt;mvc:resources location=&quot;classpath:/META-INF/resources/&quot; mapping=&quot;swagger-ui.html&quot;/&gt; &lt;mvc:resources location=&quot;classpath:/META-INF/resources/webjars/&quot; mapping=&quot;/webjars/**&quot;/&gt; 访问注意web.xml配置&lt;!-- 加载springMVC --&gt; &lt;servlet&gt; &lt;servlet-name&gt;qiuqiu-manage&lt;/servlet-name&gt; &lt;!-- 配置DispatcherServlet，springmvc入口 --&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/qiuqiu-manage-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 启动web容器就启动springMVC --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;qiuqiu-manage&lt;/servlet-name&gt; &lt;!-- 所有以rest开头的请求都进入springMVC --&gt; &lt;url-pattern&gt;/rest/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;/swagger-ui.html&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 访问路径是 http://ip:port/rest/swagger-ui.html","link":"/2016/11/06/framework/spring-mvc/spring%E4%B8%8B%E6%95%B4%E5%90%88swagger/"},{"title":"SpringBoot--RESTFul 三种拦截机制的研究","text":"总体了解三种拦截 过滤器(Filter) 拦截器(Interceptor) 切片(Aspect)","link":"/2016/12/04/framework/springboot/springboot--restful%E4%B8%89%E7%A7%8D%E6%8B%A6%E6%88%AA%E6%9C%BA%E5%88%B6%E7%9A%84%E7%A0%94%E7%A9%B6/"},{"title":"SpringBoot组件学习","text":"了解Spring4.Xspring框架的发展 在Spring1.x时代，都是通过xml文件配置bean，随着项目的不断扩大，需要将xml配置分放到不同的配置文件中，需要频繁的在java类和xml配置文件中切换 随着JDK 1.5带来的注解支持，Spring2.x可以使用注解对Bean进行申明和注入，大大的减少了xml配置文件，同时也大大简化了项目的开发。 最佳实践：1、 应用的基本配置用xml，比如：数据源、资源文件等；2、 业务开发用注解，比如：Service中注入bean等； 从Spring3.x开始提供了Java配置方式，使用Java配置方式可以更好的理解你配置的Bean，现在我们就处于这个时代，并且Spring4.x和Spring boot都推荐使用java配置的方式。 Spring的Java配置方式 Java配置是Spring4.x推荐的配置方式，可以完全替代xml配置。 @Configuration 和 @Bean Spring的Java配置方式是通过 @Configuration 和 @Bean 这两个注解实现的：1、@Configuration 作用于类上，相当于一个xml配置文件；2、@Bean 作用于方法上，相当于xml配置中的； //pom.xml文件配置 &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.xinbang&lt;/groupId&gt; &lt;artifactId&gt;songxm-springboot-stu&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.3.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;${project.artifactId}&lt;/finalName&gt; &lt;plugins&gt; &lt;!-- 资源文件拷贝插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!-- java编译插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.7&lt;/source&gt; &lt;target&gt;1.7&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; vo对象示例 dao对象示例 service对象示例 JAVA注解配置示例 启动测试示例 启动测试结果 读取外部的资源配置文件 通过@PropertySource可以指定读取的配置文件，通过@Value注解获取值，具体用法: 添加了两个资源文件 并进行JAVA的配置 JAVA配置方式 @PropertySource 读取外部资源文件显示效果 JAVA配置方式配置数据库数据源导入依赖： &lt;!-- 连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.jolbox&lt;/groupId&gt; &lt;artifactId&gt;bonecp-spring&lt;/artifactId&gt; &lt;version&gt;0.8.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; 之前的Spring xml配置： &lt;!-- 定义数据源 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.jolbox.bonecp.BoneCPDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;!-- 数据库驱动 --&gt; &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driverClassName}&quot; /&gt; &lt;!-- 相应驱动的jdbcUrl --&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.url}&quot; /&gt; &lt;!-- 数据库的用户名 --&gt; &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot; /&gt; &lt;!-- 数据库的密码 --&gt; &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt; &lt;!-- 检查数据库连接池中空闲连接的间隔时间，单位是分，默认值：240，如果要取消则设置为0 --&gt; &lt;property name=&quot;idleConnectionTestPeriod&quot; value=&quot;60&quot; /&gt; &lt;!-- 连接池中未使用的链接最大存活时间，单位是分，默认值：60，如果要永远存活设置为0 --&gt; &lt;property name=&quot;idleMaxAge&quot; value=&quot;30&quot; /&gt; &lt;!-- 每个分区最大的连接数 --&gt; &lt;!-- 判断依据：请求并发数 --&gt; &lt;property name=&quot;maxConnectionsPerPartition&quot; value=&quot;100&quot; /&gt; &lt;!-- 每个分区最小的连接数 --&gt; &lt;property name=&quot;minConnectionsPerPartition&quot; value=&quot;5&quot; /&gt; &lt;/bean&gt; 参考xml配置改造成java配置方式 示例如下： 添加jdbc资源文件，JAVA配置方式修改 显示效果 了解SpringBootSpringBoot产生背景 随着动态语言的流行(Ruby、Groovy、Scala、Node),java的开发显得格外笨重：繁多的配置，低下的开发效率，复杂的部署以及第三方集成难度大。 在上述背景下，SpringBoot应运而生。本着“习惯优于配置”的理念，加快项目开发效率。 SpringBoot优缺点： 优点：快速；最少的配置，独立运行，无须依赖servlet容器，提供监控，与云计算天然集成。 缺点：书籍文档少。 快速新建第一个SpringBoot Demo工程设置spring boot的parent &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.2.RELEASE&lt;/version&gt; &lt;/parent&gt; 说明：Spring boot的项目必须要将parent设置为spring boot的parent，该parent包含了大量默认的配置，大大简化了我们的开发。 导入spring boot的web支持&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; 添加Spring Boot的插件&lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; 第一个Spring Boot的应用@Controller @SpringBootApplication public class HelloApplication { @RequestMapping(&quot;hello&quot;) @ResponseBody public String hello(){ return &quot;hello world！&quot;; } public static void main(String[] args) { SpringApplication.run(HelloApplication.class, args); } } 代码说明：1、@SpringBootApplication：Spring Boot项目的核心注解，主要目的是开启自动配置。；3、@Controller：标明这是一个SpringMVC的Controller控制器；4、main方法：在main方法中启动一个应用，即：这个应用的入口；在Spring Boot项目中，启动的方式有两种，一种是直接run Java Application另外一种是通过Spring Boot的Maven插件运行。mvn spring-boot:run SpringBoot的核心入口类和@SpringBootApplication 之前用户使用的是3个注解注解他们的main类。分别是@Configuration,@EnableAutoConfiguration,@ComponentScan。由于这些注解一般都是一起使用，spring boot提供了一个统一的注解@SpringBootApplication。@SpringBootApplication = (默认属性)@Configuration + @EnableAutoConfiguration + @ComponentScan @SpringBootApplication public class ApplicationMain { public static void main(String[] args) { SpringApplication.run(Application.class, args); } } 关闭自动配置 如果我们不需要Spring Boot自动配置，想关闭某一项的自动配置,比如：我们不想自动配置Redis，Solr想手动配置 @SpringBootApplication(exclude = {RedisAutoConfiguration.class, SolrAutoConfiguration.class}) 自定义banner 拷贝生成的字符到一个文本文件中，并且将该文件命名为banner.txt 将banner.txt拷贝到项目的resources目录中： 重新启动程序，查看效果 https://github.com/cbornet/image2springbanner 这个开源工程可以把图片转成 banner.txt,程序就可以显示任何图案 usage: java -jar image2springbanner.jar &lt;IMAGE_FILE&gt; [-c] [-d] [-M &lt;arg&gt;] [-o &lt;arg&gt;] [-r &lt;arg&gt;] Create a Spring Boot banner from an image -c,--cie94 whether to use CIE94 algo (default is false) -d,--dark whether to invert image for a dark background. (default is false) -M,--max-width &lt;arg&gt; maximum width in characters of banner (default is 72) -o,--output &lt;arg&gt; output file path (default is ./banner.txt) -r,--aspect-ratio &lt;arg&gt; correction to makes sure height is correct to accomodate the fact that fonts are taller than they are wide. (default is 0.5) 示例： java -jar image2springbanner.jar src/main/resources/banner.jpg -M140 -d -o src/main/resources/banner.txt 如果不想看到任何的banner，也是可以将其关闭的： @SpringBootApplication public class AppStart { public static void main(String[] args) { SpringApplication app = new SpringApplication(AppStart.class); app.setBannerMode(Banner.Mode.OFF); app.run(args); } } 全局配置文件 Spring Boot项目使用一个全局的配置文件application.properties或者是application.yml，在resources目录下或者类路径下的/config下，一般我们放到resources下。修改tomcat的端口为8088 server.port=8088修改进入DispatcherServlet的规则为：*.html server.servlet-path=*.html xml配置文件 在项目的特殊情况必须要用到xml文件时 可以通过@ImportResource来加载 示例：@ImportResource(value = “classpath:dubbo/dubbo-consumer.xml”) 类型安全的配置 类型安全的配置:使用＠Value注入每个自定义配置在项目中显得很麻烦，当自定义属性很多时需要注入很多次 SpringBoot还提供了基于类型安全的配置方式，通过＠ConfigurationProperties将 properties中的属性和一个Bean的属性关联，从而实现类型安全的配置（1）在全局配置文件中自定义属性:例如application.propertiesbook.author=张三book.name=Spring Boot （2）＠ConfigurationProperties（prefix=＂book＂） Spring Boot的自动配置的原理 Spring Boot在进行SpringApplication对象实例化时会加载META-INF/spring.factories文件，将该配置文件中的配置载入到Spring容器。 SpringBoot整合测试 &lt;dependency&gt; &lt;groupId&gt;org springframework boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&gt; &lt;/dependency&gt; 示例: import junit.framework.TestCase; @SpringBootTest(classes=SpringController.class) @Runwith(SpringJUnit4ClassRunner.class) @WebAppConfiguration public class TestSpringController t @Autowired SpringController springController; @Test public void test1( { Testcase assertEquals(this.springController yes(), &quot;hello&quot;);} } SpringBoot的日志管理 Sprong Boot使用的默认日志框架是logback，并用INFO级别输出到控制台:日志输出内容元素具体如下:时间日期:精确到亳秒日志级别: ERROR，WARN，INFO， DEBUG or TRACE进程ID分隔符:一标识实际日志的开始线程名:方括号括起来（可能会截断控制台输出） Logger名:通常使用源代码的类名日志内容日志依赖:该依赖内容就是 Spring Boot默认的日志框架logback实际开发中我们不需要直接添加该依赖。 SpringBoot的日志的级别有7个:日志级别从低到高为: TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR&lt; FATAL&lt; OFF如果设置为WARN，则低于WARV的信息都不会输出。 Spring Boot中默认配置 ERROR、WARV和INFO级别的日志输出到控制台。root日志以WARN级别输出logging.level.root=WARN(只输出warn及以上级别的日志)springframework.web日志以 DEBUG级别输出logging.level.org.springframework.web=DEBUGhibernate日志以 ERROR级别输出 logging.level.org.hibernate=ERROR默认情况下， Spring Boot将日志输出到控制台，不会写到日志文件。如果要编写除控制台输出之外的日志文件，则需在 application. propertles中设置 logging.file或logging.path属性 logging.file，设置文件，可以是绝对路径，也可以是相对路径。如:logging.file=log/my.1og（相对）或者/log/my.1og（绝对） Logging.path，设置目录，会在该目录下创建 spring.log文件，并写入日志内容，如:logging.path=/var/log注:二者不能同时使用,如若同时使用,则只有logging.file生效默认情况下,日志文件的大小达到10MB时切分一次,产生新的日志文件,默认级别为: ERROR、WARN、INFO配置日志 logging.level.root=WARN logging.level.org.springframework.web=DEBUG logging.file=/User/sxm/log/info.log logging.pattern.console=%d(yyyy/MM/dd-HH: mm: ss) %thread %-5level %logger-%msg%n logging.pattern.file=%d(yyyy/MM/dd-HH: mm) %thread]%-5level %logger-%msg%n Logback: logback-spring.xml, logback-spring.groovy, logback.xml, logback.groovyLog4j: 1og4j-spring.properties, log4j-spring.xml, log4j.properties, log4j.xml JDK (Java Util Logging): logging properties Spring Boot官方推荐优先使用带有- -spring的文件名作为你的日志配置(如使用logback-spring.xm1,而不是logback.xml),命名为logback-spring.xml的日志配置文件, spring boot可以为它添加一些 spring boot特有的配置项。如果你即想完全掌控日志配置,但又不想用logback.xml作为 Logback配置的名字,可以通过logging.config属性指定自定义的名字: logging.config=classpath:logging-config.xml虽然一般并不需要改变配置文件的名字,但是如果你想针对不同运行时 Profile使用不同的日志配置,这个功能会很有用 多环境日志输出 根据不同环境（prod:生产环境，test:测试环境，dev:开发环境）来定义不同的日志输出，在1 aback- spring.xm1中使用 springProfile节点来定义，方法如下:&lt;！–测试环境+开发环境，多个使用逗号隔开-&gt; &lt;！–生产环境&gt; 在 application. properties文件中指明使用哪一种: spring profiles. active=prod SpringBoot整合redis单机版 在启动类上加上 @EnableCaching在需要缓存查询的方法上加缓存注解 SpringBoot的 web开发 Web开发的自动配置类：org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration 自动配置的ViewResolver 自动配置静态资源 如果进入SpringMVC的规则为/时，Spring Boot的默认静态资源的路径为：spring.resources.static-locations=classpath:/META-INF/resources/,classpath:/resources/,classpath:/static/,classpath:/public/ 进入规则为*.xxx 或者 不指定静态文件路径时,将静态资源放置到webapp下的static目录中即可通过地址访问,示例：http://127.0.0.1:8080/static/xx.js 自定义消息转化器 自定义消息转化器，只需要在@Configuration的类中添加消息转化器的@bean加入到Spring容器，就会被Spring Boot自动加入到容器中。 @Bean public StringHttpMessageConverter stringHttpMessageConverter(){ StringHttpMessageConverter converter = new StringHttpMessageConverter(Charset.forName(&quot;UTF-8&quot;)); return converter; } 自定义SpringMVC的配置 有些时候我们需要自已配置SpringMVC而不是采用默认，比如说增加一个拦截器，这个时候就得通过继承WebMvcConfigurerAdapter然后重写父类中的方法进行扩展。 import java.nio.charset.Charset; import java.util.List; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import org.springframework.context.annotation.Configuration; import org.springframework.http.converter.HttpMessageConverter; import org.springframework.http.converter.StringHttpMessageConverter; import org.springframework.web.servlet.HandlerInterceptor; import org.springframework.web.servlet.ModelAndView; import org.springframework.web.servlet.config.annotation.InterceptorRegistry; import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter; @Configuration //申明这是一个配置 public class MySrpingMVCConfig extends WebMvcConfigurerAdapter{ // 自定义拦截器 @Override public void addInterceptors(InterceptorRegistry registry) { HandlerInterceptor handlerInterceptor = new HandlerInterceptor() { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(&quot;自定义拦截器............&quot;); return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { } }; registry.addInterceptor(handlerInterceptor).addPathPatterns(&quot;/**&quot;); } // 自定义消息转化器的第二种方法 @Override public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) { StringHttpMessageConverter converter = new StringHttpMessageConverter(Charset.forName(&quot;UTF-8&quot;)); converters.add(converter); } }","link":"/2016/11/04/framework/springboot/springboot-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"title":"SpringBoot底层原理分析第一篇--配置文件属性注入","text":"SpringBoot特点1:为基于 －Spring的开发提供更快的入门体验2:创建可以独立运行的 Spring应用3:直接嵌入 . Tomcat 或 Jetty服务器，不需要打包成WAR文件4:提供推荐的基础POM文件（ Starter）来简化 Apache Maven配置5:尽可能的根据项目依赖来自动配置 Spring框架6:提供可以直接在生产环境中使用的功能，如性能指标、应用信息和应用健康检查7:开箱即用，没有代码生成，也无需XML配置。同时也可以修改默认值来满足特定需求8:其他大量的项目都是基于 Spring Boot之上的，如 Spring Cloud SpringBoot缺点1:依赖太多，随便的一个 ＂Spring Booth应用都有好几十M2:缺少服务的注册和发现等解决方案3:缺少监控集成方案、安全管理方案4:中文的文档和资料太少且不够深入 SpringBoot应用场景1.javaweb2.微服务 SpringBoot两种环境搭建第一种搭建示例 不使用继承方式&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.songxm&lt;/groupId&gt; &lt;artifactId&gt;learning-springboot&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;1.4.0.RELEASE&lt;/version&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;type&gt;pom&lt;/type&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; package com.songxm.learning.springboot; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.context.ConfigurableApplicationContext; import org.springframework.context.annotation.Bean; @SpringBootApplication public class App { @Bean public Runnable runnable() { return ()-&gt;{System.out.println(&quot;learning springboot.&quot;);}; } public static void main(String[] args) { ConfigurableApplicationContext context = SpringApplication.run(App.class, args); context.getBean(Runnable.class).run(); } } 第二种搭建示例 pom使用继承方式&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.4.3.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;groupId&gt;com.songxm&lt;/groupId&gt; &lt;artifactId&gt;learning-springboot&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 两种方式读取 application.properties配置文件里的值application.properties默认位置是 classpath下，或者classpath下的config目录下第一种方式读取属性值 @Value注解形式读取application.properties local.ip=192.168.7.7 local.port=8888 package com.songxm.learning.springboot; import org.springframework.beans.factory.annotation.Value; import org.springframework.stereotype.Component; @Component public class UserConfig { @Value(&quot;${local.ip}&quot;) private String ip; @Value(&quot;${local.port}&quot;) private Integer port; @Value(&quot;${tomcat.port:9999}&quot;) private String tomcatPort; public void show() { System.out.println(&quot;UserConfig [ip=&quot; + ip + &quot;, port=&quot; + port + &quot;, tomcatPort=&quot; + tomcatPort + &quot;]&quot;); } } package com.songxm.learning.springboot; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.context.ConfigurableApplicationContext; @SpringBootApplication public class App { public static void main(String[] args) { ConfigurableApplicationContext context = SpringApplication.run(App.class, args); context.getBean(UserConfig.class).show(); } } 输出: UserConfig [ip=192.168.7.7, port=8888, tomcatPort=9999] 第二种方式读取属性值 注入Environment 读取application.properties local.ip=192.168.7.7 local.port=8888 package com.songxm.learning.springboot; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.core.env.Environment; import org.springframework.stereotype.Component; @Component public class UserConfig { @Autowired private Environment env; public void show() { System.out.println(&quot;UserConfig [ip=&quot; + env.getProperty(&quot;local.ip&quot;) + &quot;, port=&quot; + env.getProperty(&quot;local.port&quot;) + &quot;, tomcatPort=&quot; + env.getProperty(&quot;tomcat.port&quot;,&quot;9999&quot;) + &quot;]&quot;); } } package com.songxm.learning.springboot; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.context.ConfigurableApplicationContext; @SpringBootApplication public class App { public static void main(String[] args) { ConfigurableApplicationContext context = SpringApplication.run(App.class, args); context.getBean(UserConfig.class).show(); } } 输出: UserConfig [ip=192.168.7.7, port=8888, tomcatPort=9999] 若要改变默认的application.properties注意以下几点1.在classpath新建 conf目录，把application.properties改为 app.properties，然后放到 conf目录下， 这时启动程序时需要在 arguments指定配置文件名字和路径的 --spring.config.location=classpath:conf/app.properties 还可以指定多个文件，多个用逗号隔开 2.若配置文件仅仅是在classpath下改名为app.properties，那么启动程序在arguments指定配置文件名字就行 --spring.config.name=app ps:文件的指定方式有两种，1：classpath：2：file： 一次加载多个properties配置文件@Configuration //@PropertySource(&quot;classpath:jdbc.properties&quot;) //@PropertySource(&quot;file:/e:/tmp/jdbc.properties&quot;) @PropertySources({@PropertySource(&quot;classpath:jdbc.properties&quot;),@PropertySource(&quot;file:/e:/tmp/jdbc.properties&quot;)}) public class FileConfig { } 指定配置文件，带前缀自动注入ds.properties ds.url=jdbc:mysql:///springboot ds.driverClassName=com.mysql.jdbc.Driver ds.username=root ds.password=123456789 import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.stereotype.Component; @Component @ConfigurationProperties(locations=&quot;classpath:ds.properties&quot;,prefix=&quot;ds&quot;) public class DataSourceProperties { private String url; private String driverClassName; private String username; private String password; public void show(){ System.out.println(&quot;===========DataSourceProperties============&quot;); System.out.println(&quot;ds.url : &quot; + url); System.out.println(&quot;ds.driverClassName : &quot; + driverClassName); System.out.println(&quot;ds.username : &quot; + username); System.out.println(&quot;ds.password : &quot; + password); } public String getUrl() { return url; } public void setUrl(String url) { this.url = url; } public String getDriverClassName() { return driverClassName; } public void setDriverClassName(String driverClassName) { this.driverClassName = driverClassName; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } } 从配置文件注入集合或者数组application.properties ds.hosts[0]=192.168.1.100 ds.hosts[1]=192.168.1.100 ds.hosts[2]=192.168.1.100 ds.ports[0]=8060 ds.ports[1]=8070 ds.ports[2]=8080 ds.ports[3]=8090 package com.songxm.learning.springboot; import java.util.ArrayList; import java.util.Arrays; import java.util.List; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.stereotype.Component; /** * 支持获取数组，集合 * 配置方式为 name[index]=value */ @Component @ConfigurationProperties(&quot;ds&quot;) public class TomcatProperties { private List&lt;String&gt; hosts = new ArrayList&lt;&gt;(); private String[] ports ; public List&lt;String&gt; getHosts() { return hosts; } public void setHosts(List&lt;String&gt; hosts) { this.hosts = hosts; } public String[] getPorts() { return ports; } public void setPorts(String[] ports) { this.ports = ports; } public void show() { System.out.println(&quot;TomcatProperties [hosts=&quot; + hosts + &quot;, ports = &quot;+Arrays.asList(ports)+&quot;]&quot;); } } package com.songxm.learning.springboot; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.context.ConfigurableApplicationContext; @SpringBootApplication public class App { public static void main(String[] args) { ConfigurableApplicationContext context = SpringApplication.run(App.class, args); context.getBean(TomcatProperties.class).show(); } } 输出: TomcatProperties [hosts=[192.168.1.100, 192.168.1.100, 192.168.1.100], ports = [8060, 8070, 8080, 8090]] SpringBoot对 properties配置文件留的扩展想要扩展properties配置文件在加载时做额外逻辑，那么需要以下几步:1.实现EnvironmentPostProcessor接口 import java.io.FileInputStream; import java.io.IOException; import java.io.InputStream; import java.util.Properties; import org.springframework.boot.SpringApplication; import org.springframework.boot.env.EnvironmentPostProcessor; import org.springframework.core.env.ConfigurableEnvironment; import org.springframework.core.env.PropertiesPropertySource; import org.springframework.stereotype.Component; @Component public class MyEnvironmentPostProcessor implements EnvironmentPostProcessor { public void postProcessEnvironment(ConfigurableEnvironment environment, SpringApplication application) { try(InputStream input = new FileInputStream(&quot;/Users/sxm/Downloads/application.properties&quot;)){ Properties source = new Properties(); source.load(input); PropertiesPropertySource propertySource = new PropertiesPropertySource(&quot;my&quot;, source); environment.getPropertySources().addLast(propertySource); }catch(IOException e){ e.printStackTrace(); } } } 2.在classpath下建立META-INF目录，再建立一个spring.factories,里面配置刚刚实现的子类 org.springframework.boot.env.EnvironmentPostProcessor=com.songxm.learning.springboot.MyEnvironmentPostProcessor 3.可以跟先前注入配置文件的属性值一样使用了 在开发 测试不同环境载入不同配置可以在classpath下新建 application-dev.properties、application-prod.properties。在启动程序时 java -jar LearnSpringBoot-0.0.1-SNAPSHOT.jar –spring.profiles.active=dev 激活具体的配置","link":"/2017/12/01/framework/springboot/springboot%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E7%AC%AC%E4%B8%80%E7%AF%87/"},{"title":"SpringBoot底层原理分析第七篇--SpringBoot AOP使用","text":"依赖引入&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.4.3.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;groupId&gt;com.songxm&lt;/groupId&gt; &lt;artifactId&gt;learning-springboot&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 切面package com.songxm.learning.springboot; import java.util.Arrays; import org.aspectj.lang.JoinPoint; import org.aspectj.lang.annotation.After; import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.Before; import org.springframework.stereotype.Component; @Aspect @Component public class LogAspect { @Before(&quot;execution(* com.songxm.learning.springboot.dao..*.*(..))&quot;) public void log() { System.out.println(&quot;before method log done &quot;); } @After(&quot;execution(* com.songxm.learning.springboot.dao..*.*(..))&quot;) public void logAfter(JoinPoint point){ System.out.println(&quot;after method log done&quot; + point.getTarget().getClass() + &quot;,args=&quot; + Arrays.asList(point.getArgs())+ &quot;,method=&quot;+point.getSignature().getName()); } } application.propertiesspring.aop.auto=true spring.aop.proxy-target-class=true 启动package com.songxm.learning.springboot; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.context.ConfigurableApplicationContext; import org.springframework.context.annotation.EnableAspectJAutoProxy; import com.songxm.learning.springboot.dao.IUserDao; /** * AOP开发流程 * 1：spring-boot-starter-aop，加入依赖，默认就开启了AOP的支持 * 2：写一个Aspect，封装横切关注点（日志，监控等等），需要配置通知（前置通知、后置通知等等）和 切入点（哪些包的哪些类的哪些方法等等） * 3：这个Aspect需要纳入到spring容器管理，并且需要加入@Aspect * * spring.aop.auto配置项决定是否启用AOP，默认启用 * * 默认是使用基于JDK的动态代理来实现AOP * spring.aop.proxy-target-class=false 或者不配置，表示使用JDK的动态代理 * =true表示使用cglib * 如果配置了false，而类没有接口，则依然使用cglib */ @EnableAspectJAutoProxy() @SpringBootApplication public class App { public static void main(String[] args) throws Exception { ConfigurableApplicationContext context = SpringApplication.run(App.class, args); System.out.println(context.getBean(IUserDao.class).getClass()); context.getBean(IUserDao.class).add(&quot;admin&quot;, &quot;123&quot;); context.close(); } } 日志使用/** * springboot默认的日志级别是info * 可以通过logging.level.*=debug 来设置， * 可以是包，也可以是某个类 * * 日志级别有：TRACE, DEBUG, INFO, WARN, ERROR, FATAL, OFF * 日志级别配置成OFF，表示关闭日志输出 * * logging.file 指定日志文件名字 * logging.path 指定日志目录（此时的日志名字为spring.log） * 日志文件输出，文件的大小10M之后，就会分割了 * * logging.pattern.console 配置控制台输出日志的pattern * logging.file.console 配置日志文件输出日志的pattern * * springboot默认支持logback * 也就是说，只需要在classptah下放一个logback.xml,logback-spring.xml的文件，即可定制日志的输出 * * 使用其他的日志组件的步骤 * 1：排除掉默认的日志组件：spring-boot-starter-logging * 2：加入新的日志路径依赖 * 3：把相应的配置文件放到classpath下 */ application.properties #logging.level.com.edu.spring.springboot.dao=off #logging.level.com.edu.spring.springboot.service=debug #logging.file=e:/tmp/my.log #logging.path=e:/tmp/logs #logging.pattern.console=%-20(%d{yyyy-MM-dd} [%thread]) %-5level %logger{80} - %msg%n #logging.file.console=%-20(%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread]) %-5level %logger{80} - %msg%n","link":"/2017/12/09/framework/springboot/springboot%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E7%AC%AC%E4%B8%83%E7%AF%87/"},{"title":"SpringBoot底层原理分析第三篇--事件监听","text":"事件流程1.自定义事件，一般是继承ApplicationEvent抽象类2.定义事件监听器，一般是实现ApplicationListener接口3.发布事件 第一个事件发布到监听 1：自定义事件，一般是继承ApplicationEvent抽象类 package com.songxm.learning.springboot; import org.springframework.context.ApplicationEvent; /** * 定义事件 */ public class MyApplicationEvent extends ApplicationEvent { private static final long serialVersionUID = 1L; public MyApplicationEvent(Object source) { super(source); } } 2：定义事件监听器，一般是实现ApplicationListener接口 package com.songxm.learning.springboot; import org.springframework.context.ApplicationListener; import org.springframework.stereotype.Component; /** * 定义事件监听器 */ public class MyApplicationListener implements ApplicationListener&lt;MyApplicationEvent&gt; { public void onApplicationEvent(MyApplicationEvent event) { System.out.println(&quot;接收到事件：&quot; + event.getClass()); } } 3：配置监听器，启动的时候，需要把监听器加入到spring容器中 4：发布事件，使用ApplicationContext.publishEvent发布事件 package com.songxm.learning.springboot; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration; import org.springframework.context.ConfigurableApplicationContext; @SpringBootApplication(exclude=ErrorMvcAutoConfiguration.class) public class App { public static void main(String[] args) { SpringApplication app = new SpringApplication(App.class); app.addListeners(new MyApplicationListener()); ConfigurableApplicationContext context = app.run(args); context.publishEvent(new MyApplicationEvent(new Object())); context.close(); } } 启动输出: 接收到事件：class com.songxm.learning.springboot.MyApplicationEvent 其它方式实现事件发布到监听承接上面，第二种方式就是在 MyApplicationListener 实现类上加上@Component注解，app启动类就可以去掉addpackage com.songxm.learning.springboot; import org.springframework.context.ApplicationListener; import org.springframework.stereotype.Component; /** * 定义事件监听器 */ @Component public class MyApplicationListener implements ApplicationListener&lt;MyApplicationEvent&gt; { public void onApplicationEvent(MyApplicationEvent event) { System.out.println(&quot;接收到事件：&quot; + event.getClass()); } } package com.songxm.learning.springboot; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration; import org.springframework.context.ConfigurableApplicationContext; @SpringBootApplication(exclude=ErrorMvcAutoConfiguration.class) public class App { public static void main(String[] args) { SpringApplication app = new SpringApplication(App.class); //app.addListeners(new MyApplicationListener()); ConfigurableApplicationContext context = app.run(args); context.publishEvent(new MyApplicationEvent(new Object())); context.close(); } } 同样输出: 接收到事件：class com.songxm.learning.springboot.MyApplicationEvent 第三种实现就是在application.properties里配置context.listener.classes=com.songxm.learning.springboot.MyApplicationListener 第四种实现方式使用@EventListener注解，在方法上面加入@EventListener注解，加载这一个就够了，最简便的获取所有的事件使用@EventListener注解，在方法上面加入@EventListener注解，且该类需要纳入到spring容器中管理（详细内容参照：EventListenerMethodProcessor，EventListenerFactory） package com.songxm.learning.springboot; import org.springframework.context.event.ContextStoppedEvent; import org.springframework.context.event.EventListener; import org.springframework.stereotype.Component; @Component public class MyEventHandle { /** * 参数任意 * 所有，该参数事件，或者其子事件（子类）都可以接收到 */ @EventListener public void event(Object event) {//获取所有的事件 System.out.println(&quot;MyEventHandle 接收到事件：&quot; + event.getClass()); } @EventListener public void event2(ContextStoppedEvent event){//获取具体的事件 System.out.println(&quot;应用停止事件：&quot; + event.getClass()); } } package com.songxm.learning.springboot; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration; import org.springframework.context.ConfigurableApplicationContext; @SpringBootApplication(exclude=ErrorMvcAutoConfiguration.class) public class App { public static void main(String[] args) { SpringApplication app = new SpringApplication(App.class); ConfigurableApplicationContext context = app.run(args); } } 启动输出: MyEventHandle 接收到事件：class org.springframework.context.event.ContextRefreshedEvent MyEventHandle 接收到事件：class org.springframework.boot.context.embedded.EmbeddedServletContainerInitializedEvent MyEventHandle 接收到事件：class org.springframework.boot.context.event.ApplicationReadyEvent MyEventHandle 接收到事件：class org.springframework.web.context.support.ServletRequestHandledEvent //请求http触发 四种方式事件监听总结 配置监听器1：SpringApplication.addListeners 添加监听器2：把监听器纳入到spring容器中管理3：使用context.listener.classes配置项配置（详细内容参照：DelegatingApplicationListener）4：使用@EventListener注解，在方法上面加入@EventListener注解，且该类需要纳入到spring容器中管理（详细内容参照：EventListenerMethodProcessor，EventListenerFactory，）","link":"/2017/12/03/framework/springboot/springboot%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E7%AC%AC%E4%B8%89%E7%AF%87/"},{"title":"SpringMVC-WEB框架","text":"三层架构和MVC模型三层架构 包括:表现层、业务层、持久层。三层架构在我们的实际开发中使用的非常多。三层架构中，每一层各司其职，接下来我们就说说每层都负责哪些方面: 表现层: 也就是我们常说的web层。它负责接收客户端请求，向客户端响应结果，通常客户端使用http协议请求web层，web需要接收http请求，完成http响应。表现层包括展示层和控制层:控制层负责接收请求，展示层负责结果的展示。表现层依赖业务层，接收到客户端请求一般会调用业务层进行业务处理，并将处理结果响应给客户端。表现层的设计一般都使用MVC模型。(MVC 是表现层的设计模型，和其他层没有关系) 业务层: 也就是我们常说的service层。它负责业务逻辑处理，和我们开发项目的需求息息相关。web层依赖业务层，但是业务层不依赖web层。业务层在业务处理时可能会依赖持久层，如果要对数据持久化需要保证事务一致性。(也就是我们说的，事务应该放到业务层来控制) 持久层: 也就是我们是常说的dao层。负责数据持久化，包括数据层即数据库和数据访问层，数据库是对数据进行持久化的载体，数据访问层是业务层和持久层交互的接口，业务层需要通过数据访问层将数据持久化到数据库中。通俗的讲，持久层就是和数据库交互，对数据库表进行曾删改查的。 MVC模型 MVC全名是Model View Controller, 是模型(model) -视图(view) -控制器(controller)的缩写，是一种用于设计创建Web应用程序表现层的模式。MVC中每个部分各司其职: Model (模型) : 通常指的就是我们的数据模型。作用一般情况下用于封装数据，常等同于封装的JavaBean来接收数据(JSR303JavaBean快捷校验) View (视图) : 通常指的就是我们的jsp或者html。作用一般就是展示数据的。通常视图是依据模型数据创建的。 Controller (控制器) : 是应用程序中处理用户交互的部分。作用一般就是处理程序逻辑的。它相对于前两个不是很好理解，这里举个例子: 例如: 我们要保存一个用户的信息，该用户信息中包含了姓名，性别，年龄等等。这时候表单输入要求年龄必须是1~100 之间的整数。姓名和性别不能为空。并且把数据填充到模型之中。此时除了js的校验之外，服务器端也应该有数据准确性的校验,那么校验就是控制器该做的。当校验失败后，由控制器负责把错误页面展示给使用者。如果校验成功，也是控制器负责把数据填充到模型，并且调用业务层实现完整的业务需求。 思考框架的产生 JAVAEE已经有 servlet 和 jsp ,加上html就可以开发web程序了，为什么还要 springmvc 这种web框架? 问题 1.servlet，jsp的路由问题：比如对于restful 接口 /user/{userId},servlet无法很好处理路由映射配置，可能只能配置成 /user/*,这就需要专门的springmvc框架来处理路由问题 2.servlet,jsp在MVC模式存在的问题：纯servlet开发，会导致大量HTML代码嵌入到Java代码里；纯jsp开发，会导致大量Java代码嵌入到HTML里，总之就是视图和数据耦合度高，这也需要springmvc这种web框架来处理MVC模式 Spring MVC框架 Spring为展现层提供的基于MVC设计理念的优秀的Web框架，是目前最主流的MVC框架之一 Spring3.0后全面超越Struts2，成为最优秀的MVC框架SpringMVC通过一套MVC注解，让POJO成为处理请求的控制器，而无须实现任何接口。 支持REST风格的URL请求 采用了松散耦合可插拔组件结构，比其他MVC框架更具扩展性和灵活性 此外,Spring MVC在数据绑定,视图解析,本地化处理及静态资源处理上都有许多不俗的表现,它在框架设计,可扩展,灵活性等方面全面超越了Struts2,WebWork等MVC框架,从原来的追赶者一跃成为了MVC的领跑者. Spring MVC框架围绕DispatcherServlet这个核心展开,DispatcherServlet负责截获请求并将其分派给相应的处理器处理.Spring MVC框架包括注解驱动控制器,请求及响应的信息处理,视图解析,本地化解析,上传文件解析,异常处理及表单标签绑定内容等 SpringMVC与Struts2优略分析共同点: ①. 它们都是表现层框架，都是基于MVC模型编写的。 ②. 它们的底层都离不开原始ServletAPI。 ③. 它们处理请求的机制都是一个核心控制器。区别 ①. Spring MVC的入口是Servlet,而Struts2 是Filter ②. Spring MVC会稍微比Struts2快些. Spring MVC是基于方法设计,而Sturts2是基于类,每次发一次请求都会实例一个Action. ③. Spring MVC使用更加简洁，开发效率Spring MVC确实比struts2高:支持JSR303,处理ajax的请求更方便 (JSR303是一套JavaBean参数校验的标准，它定义了很多常用的校验注解，我们可以直接将这些注解加在我们JavaBean的属性上面，就可以在需要校验的时候进行校验了。) ④. Struts2的OGNL表达式使页面的开发效率相比Spring MVC更高些，但执行效率并没有比JSTL提升，尤其是Struts2的表单标签，远没有html执行效率高。 SpringMVC在Spring框架的位置 SpringMVC执行流程 核心分发器DispatcherServlet DispatcherServlet是Spring MVC的”灵魂”和”心脏”,它负责接受HTTP请求并协调 Spring MVC的各个组件完成请求处理的工作。和任何Servlet一样,用户必须在web.xml中配置好DispatcherServlet。 DispatcherServlet是前端控制器设计模式的实现，提供spring Web MVC的集中访问点，而且负责职责的分派，而且与Spring IoC容器无缝集成，从而可以获得Spring的所有好处。DispatcherServlet主要职责DispatcherServlet主要用作职责调度工作，本身主要用于控制流程，主要职责如下： 1.文件上传解析，如果请求类型是multipart将通过MultipartResolver进行文件上传解析； 2.通过HandlerMapping，将请求映射到处理器（返回一个HandlerExecutionChain，它包括一个处理器、多个HandlerInterceptor拦截器）； 3.通过HandlerAdapter支持多种类型的处理器(HandlerExecutionChain中的处理器)； 4.通过ViewResolver解析逻辑视图名到具体视图实现； 5.本地化解析； 6.渲染具体的视图等； 7.如果执行过程中遇到异常将交给HandlerExceptionResolver来解析。 DispatcherServlet核心代码//前端控制器分派方法 protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception { HttpServletRequest processedRequest = request; HandlerExecutionChain mappedHandler = null; int interceptorIndex = -1; try { ModelAndView mv; boolean errorView = false; try { //检查是否是请求是否是multipart（如文件上传），如果是将通过MultipartResolver解析 processedRequest = checkMultipart(request); //步骤2、请求到处理器（页面控制器）的映射，通过HandlerMapping进行映射 mappedHandler = getHandler(processedRequest, false); if (mappedHandler == null || mappedHandler.getHandler() == null) { noHandlerFound(processedRequest, response); return; } //步骤3、处理器适配，即将我们的处理器包装成相应的适配器（从而支持多种类型的处理器） HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()); // 304 Not Modified缓存支持 //此处省略具体代码 // 执行处理器相关的拦截器的预处理（HandlerInterceptor.preHandle） //此处省略具体代码 // 步骤4、由适配器执行处理器（调用处理器相应功能处理方法） mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); // Do we need view name translation? if (mv != null &amp;&amp; !mv.hasView()) { mv.setViewName(getDefaultViewName(request)); } // 执行处理器相关的拦截器的后处理（HandlerInterceptor.postHandle） //此处省略具体代码 } catch (ModelAndViewDefiningException ex) { logger.debug(&quot;ModelAndViewDefiningException encountered&quot;, ex); mv = ex.getModelAndView(); } catch (Exception ex) { Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null); mv = processHandlerException(processedRequest, response, handler, ex); errorView = (mv != null); } //步骤5 步骤6、解析视图并进行视图的渲染 //步骤5 由ViewResolver解析View（viewResolver.resolveViewName(viewName, locale)） //步骤6 视图在渲染时会把Model传入（view.render(mv.getModelInternal(), request, response);） if (mv != null &amp;&amp; !mv.wasCleared()) { render(mv, processedRequest, response); if (errorView) { WebUtils.clearErrorRequestAttributes(request); } } else { if (logger.isDebugEnabled()) { logger.debug(&quot;Null ModelAndView returned to DispatcherServlet with name '&quot; + getServletName() + &quot;': assuming HandlerAdapter completed request handling&quot;); } } // 执行处理器相关的拦截器的完成后处理（HandlerInterceptor.afterCompletion） //此处省略具体代码 catch (Exception ex) { // Trigger after-completion for thrown exception. triggerAfterCompletion(mappedHandler, interceptorIndex, processedRequest, response, ex); throw ex; } catch (Error err) { ServletException ex = new NestedServletException(&quot;Handler processing failed&quot;, err); triggerAfterCompletion(mappedHandler, interceptorIndex, processedRequest, response, ex); throw ex; } finally { if (processedRequest != request) { cleanupMultipart(processedRequest); } } } DispatcherServlet辅助类 bean类型 说明 Controlle 处理器/页面控制器，做的是MVC中的C的事情，但控制逻辑转移到前端控制器了，用于对请求进行处理 HandlerMapping 请求到处理器的映射，如果映射成功返回一个HandlerExecutionChain对象（包含一个Handler处理器（页面控制器）对象、多个HandlerInterceptor拦截器）对象；如BeanNameUrlHandlerMapping将URL与Bean名字映射，映射成功的Bean就是此处的处理器 HandlerAdapter HandlerAdapter将会把处理器包装为适配器，从而支持多种类型的处理器，即适配器设计模式的应用，从而很容易支持很多类型的处理器；如SimpleControllerHandlerAdapter将对实现了Controller接口的Bean进行适配，并且掉处理器的handleRequest方法进行功能处理 HandlerExceptionResolver处理器异常解析器 处理器异常解析，可以将异常映射到相应的统一错误界面，从而显示用户友好的界面（而不是给用户看到具体的错误信息） ViewResolver视图解析器 ViewResolver将把逻辑视图名解析为具体的View，通过这种策略模式，很容易更换其他视图技术；如InternalResourceViewResolver将逻辑视图名映射为jsp视图 LocaleResolver &amp; LocaleContextResolver地区解析器和地区Context解析器 解析客户端中使用的地区和时区，用来提供不同的国际化的view视图。 ThemeResolver 主题解析器,解析web应用中能够使用的主题，比如提供个性化的网页布局。 MultipartResolver 多部件解析器,主要处理multi-part(多部件)request请求，例如：在HTML表格中处理文件上传。 FlashMapManager FlashMap管理器储存并检索在”input”和”output”的FlashMap中可以在request请求间(通常是通过重定向)传递属性的FlashMap, SpringMVC搭建添加pom依赖jar&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.0.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;!--spring-context-support:包含支持UI模版，邮件服务，缓存Cache等方面的类。--&gt; &lt;version&gt;4.0.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.0.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; SpringMVC在web.xml配置–即一个核心组件DispatcherServlet的配置&lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;!--SpringMVC配置文件的名字 xxx-servlet.xml 默认位置:src/resources 如果放在了 src/resources(maven),则 contextConfigLocation:classpath:文件名即可! Web-INF/xx.xml，则 contextConfigLocation:/WEB-INF/xx.xml --&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;!-- tomcat启动时就创建servlet --&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; param-name param-name param-value contextConfigLocation 引入springmvc配置文件,默认classpath:-servlet.xml,如果放在src/resources的下级文件夹,例如:resources/spring/servlet-name-servlet.xml,值可以编写成: classpath:/spring/servlet-name-servlet.xml，如果没有放在src/resources资源的根目录下,放在了WEB项目的WEB-INF/spring/servlet-name-serlvet.xml,值可以编写成:/WEB-INF/spring/servlet-name-servlet.xml。 namespace 修改DispatcherServlet对应的命名空间,默认为-servlet,可以通过namespace修改默认名字! publishContext 布尔类型的属性,默认值为ture,DispatcherServlet根据该属性决定是否将WebApplicationContext发布到ServletContext的属性列表中,以便调用者可以借用ServletContext找到WebApplicationContext实例,对应的属性名为DispatcherServlet#getServletContextAttributeName()方法返回的值 url-pattern问题&lt;url-pattern&gt;/&lt;/url-pattern&gt; 会匹配到/login这样的路径型url，不会匹配到模式为*.jsp这样的后缀型url &lt;url-pattern&gt;/*&lt;/url-pattern&gt; 会匹配所有url：路径型的和后缀型的url(包括/login,*.jsp,*.js和*.html等) 最好不要配成 /，否则虽然jsp页面跳转 正常，但是 静态资源全都报错 最好也不要写为/，因为 Dispatcherservlet会将向静态资源的获取请求，例如.CS5、js、jpg、－png等资源的获取请求，当作是一个普通的 Controller求。中央调度器会调用处理器映射器为其查找相应的处理器。当然也是找不到的，所以在这种情况下，所有的静态资源获取请求也均会报404错误。 不能配成 /*，连jsp页面跳转都到不了,静态资源更访问不了,因为 Dispatcherservlet会将向动态页面的跳转请求，即向JSP页面的跳转请求也当作是一个普通的 Controller请求。中央调度器会调用处理器映射器为其查找相应的处理器。当然是找不到的，所以在这种情况下，所有的jSP页面跳转均会报404错误 以下三种方式解决url-pattern访问静态资源的问题 第一种把静态资源后缀 在web.xml 用配置servlet-mapping方法配置，走tomcat default名的servlet示例:&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot; id=&quot;webApp&quot; version=&quot;2.5&quot;&gt; &lt;!-- 注册中央调度器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;!-- tomcat启动时就创建servlet --&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;spingmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.png&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.jpg&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.js&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.css&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; 第二种方式使用 mvc标签的 default-servlet-handlermvc: default-servlet-handler会将对静态资源的访问请求通过 Handlermapping映射到默认 Servlet请求处理器 Default Servlethttprequesthandler对象。而该处理器调用了 Tomcat的 Defaultservlet来处理静态资源的访问请求 示例mvc约束:&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;bean id=&quot;/my.do&quot; class=&quot;com.songxm.learning.springmvc.controller.MyController&quot;&gt;&lt;/bean&gt; &lt;!-- 配置视图解析器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;!-- 前缀 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;&gt;&lt;/property&gt; &lt;!-- 后缀 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;mvc:default-servlet-handler /&gt; &lt;/beans&gt; 第三种方式使用 mvc标签的 resources处理器在 Springa3.0.4版本后， Spring中定义了专门用于处理静态资源访问请求的处理器,&lt;mvc: resources location=＂/images/＂ mapping=&quot;/images/＊＊&quot; /&gt;location表示静态资源所在目录。当然，这里的目录可以是/WEB－NF/目录及其子目录,mapping表示对该资源的请求。注意，后面是两个星号,该配置会把对该静态资源的访问请求经 Handlermapping直接映射到静态资源处理器对 示例配置:&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;bean id=&quot;/my.do&quot; class=&quot;com.songxm.learning.springmvc.controller.MyController&quot;&gt;&lt;/bean&gt; &lt;!-- 配置视图解析器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;!-- 前缀 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;&gt;&lt;/property&gt; &lt;!-- 后缀 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;mvc:resources location=&quot;/images/&quot; mapping=&quot;/images/**&quot; /&gt; &lt;mvc:resources location=&quot;/css/&quot; mapping=&quot;/css/**&quot; /&gt; &lt;mvc:resources location=&quot;/js/&quot; mapping=&quot;/js/**&quot; /&gt; &lt;/beans&gt; springmvc-servlet.xml配置非注解版本，了解即可&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- 1.配置handlerMapping 1.1 找出给请求该找哪一个处理器处理 //http://localhost:8080/hello &lt;bean name=&quot;/hello&quot;&gt;&lt;/bean&gt; 根据url 匹配bean的name属性 根据name属性找处理器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;&gt; &lt;/bean&gt; &lt;!-- 1.2 根据id找处理器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;&gt; &lt;property name=&quot;mappings&quot;&gt; &lt;props&gt; &lt;!-- 通过/aaa 或者/bbb 都能找到id为hello的处理器 --&gt; &lt;prop key=&quot;/aaa&quot;&gt;hello&lt;/prop&gt; &lt;prop key=&quot;/bbb&quot;&gt;hello&lt;/prop&gt; &lt;prop key=&quot;/ccc&quot;&gt;hello2&lt;/prop&gt; &lt;prop key=&quot;/ddd&quot;&gt;hello2&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 1.3 根据处理器的类名查找 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.mvc.support.ControllerClassNameHandlerMapping&quot;&gt;&lt;/bean&gt; &lt;!-- 2.配置HandlerAdapter 2.1 处理实现Controller的处理器 1）包装成适配器对象 2）调用handler --&gt; &lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;&gt;&lt;/bean&gt; &lt;!-- 2.2 处理实现了HttpRequestHandler的处理器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter&quot;&gt;&lt;/bean&gt; &lt;!-- 3.配置处理器 handler 自己写 --&gt; &lt;bean name=&quot;/hello&quot; id=&quot;hello&quot; class=&quot;com.ecit.controller.MyController&quot;&gt;&lt;/bean&gt; &lt;bean name=&quot;/hello2&quot; id=&quot;hello2&quot; class=&quot;com.ecit.controller.MyHttpRequestHandler&quot;&gt;&lt;/bean&gt; &lt;!-- 4.配置视图解析器 //物理视图 = 前缀+逻辑视图+后缀 = &quot;/WEB-INF/jsp/&quot;+&quot;hello&quot;+&quot;.jsp&quot; = /WEB-INF/jsp/hello.jsp --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;&gt;&lt;/property&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; 注解版本&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;!--1.注解驱动 HandlerMapping HandlerAdapter --&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; &lt;!--2.处理器 handler--&gt; &lt;context:component-scan base-package=&quot;com.ecit.controller&quot;&gt;&lt;/context:component-scan&gt; &lt;!--3.视图解析器--&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--静态资源访问解决--&gt; &lt;mvc:resources location=&quot;/WEB-INF/images/&quot; mapping=&quot;/images/**&quot; /&gt; &lt;mvc:resources location=&quot;/WEB-INF/css/&quot; mapping=&quot;/css/**&quot; /&gt; &lt;mvc:resources location=&quot;/WEB-INF/js/&quot; mapping=&quot;/js/**&quot; /&gt; &lt;/beans&gt; 第一个SpringMVC程序过程记录编写一个HelloControllerpackage com.ecit.controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.servlet.ModelAndView; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; @Controller public class HelloController { @RequestMapping(&quot;/hello&quot;) public String helloNoMsg(){ return &quot;success&quot;; } @RequestMapping(&quot;/hello2&quot;) public ModelAndView helloWithMsg(HttpServletRequest arg0, HttpServletResponse arg1) throws Exception { ModelAndView mv = new ModelAndView(); mv.addObject(&quot;message&quot;,&quot;Welcome learning SpringMVC&quot;); mv.addObject(&quot;title&quot;,&quot;Hello&quot;); mv.setViewName(&quot;success&quot;); return mv; } } @Controller 来源于@Component标示为控制层，用于加在类上。 @RequestMapping(&quot;/hello&quot;) 该方法对应的uri; 控制器类的方法返回字符串类型非常常见,返回字符串,代表根据返回的字符串找到对应的视图! 根据springmvc配置文件中视图解析器(InternalResourceViewResolver) 配置的视图文件的前缀和后缀! 方法返回 &quot;success&quot; 会找到 WEB-INF/jsp/success.jsp文件! 测试Spring MVCpom文件添加web服务器，这里用jetty服务器&lt;plugin&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt; &lt;version&gt;9.3.7.v20160115&lt;/version&gt; &lt;configuration&gt; &lt;httpConnector&gt; &lt;port&gt;8080&lt;/port&gt; &lt;host&gt;localhost&lt;/host&gt; &lt;/httpConnector&gt; &lt;scanIntervalSeconds&gt;1&lt;/scanIntervalSeconds&gt; &lt;/configuration&gt; &lt;/plugin&gt; 编译运行浏览mvn compile mvn jetty:run 通过浏览器,访问 http://127.0.0.1:8080/hello2 即可! 常用注解@RequestMapping 加在类上: 给模块添加根路径 加载方法: 方法具体的路径//如果不指定method属性,可以接收任何类型的请求!如果指定但是访问类型不对会出现405错误!** @RequestMapping(value = &quot;/param&quot; ,headers={&quot;token&quot;},params = {&quot;!usernam&quot;,&quot;age!=10&quot;},method = RequestMethod.GET) //请求头中必须包含有token参数， URL参数中不能含有usernam，age参数不能等于10 public String testParam(String username , Integer age){ System.out.println(&quot;username:&quot;+username); System.out.println(&quot;age:&quot;+age); return &quot;success&quot;; } params和headers支持简单的表达式 1.param:表示请求必须包含名为param的请求参数 2.!param:表示请求中不能包含名为param的参数 3.param != value:表示请求中包含param的请求参数,但是值不能为value 4.param = value:表示请求中包含param的请求参数,但是值为value {“param1 = value1”,“param2”}:请求必须包含名为param1和param2的两个请求参数，且param1参数的值必须为value1@RequestMapping(value= &quot;/show&quot;, headers=&quot;contentType=text/*&quot;) public String test({ return &quot;user/test&quot;; } Ant风格资源地址支持3种匹配符:- 1.?:匹配文件名中的一个字符 - 2.*:匹配文件名中的任意字符 - 3.**:匹配多层路径 @RequestMapping还支持Ant风格的URL : /user/*/createUser: 匹配 /user/aaa/createUser、/user/bbb/createUser等URL /user/**/createUser:匹配 /user/createUser、/user/aaa/bbb/createUser等URL /user/createUser??: 匹配 /user/createUseraa、/user/createUserbb 等URL 接收数组参数&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;兴趣爱好&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action= &quot;/happy&quot; method= &quot;post&quot;&gt; &lt;p&gt;&lt;input type=&quot;checkbox&quot; name=&quot;happies&quot; value=&quot;足球&quot; /&gt; 足球&lt;/p&gt; &lt;p&gt;&lt;input type=&quot;checkbox&quot; name=&quot;happies&quot; value=&quot;篮球&quot; /&gt; 篮球&lt;/p&gt; &lt;p&gt;&lt;input type=&quot;checkbox&quot; name=&quot;happies&quot; value=&quot;羽毛球&quot; /&gt;羽毛球e&lt;/p&gt; &lt;p&gt;&lt;input type=&quot;checkbox&quot; name=&quot;happies&quot; value=&quot;乒乓球&quot; /&gt; 乒乓球&lt;/p&gt; &lt;p&gt;&lt;input type=&quot;checkbox&quot; name=&quot;happies&quot; value=&quot;网球&quot; /&gt; 网球&lt;/p&gt; &lt;p&gt;&lt;input type=&quot;checkbox&quot; name=&quot;happies&quot; value=&quot;计算机&quot; /&gt;计算机&lt;/p&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; @RequestMapping(&quot;/happy&quot;) public String updateAccount(String[] happies){ System.out.printf(&quot;happies:&quot; + Arrays.toString(happies)); return &quot;success&quot;; } 使用POJO对象绑定请求参数值 Spring MVC会按请求参数名和POJO属性名进行自动匹配，自动为该对象填充属性值。支持级联属性。如: dept.deptld、dept.address.tel 等@RequestMapping(&quot;/handle&quot;) public String handle8(User user){ return &quot;success&quot;; } // /handle?userName=ecit&amp;dept.deptId=1&amp;dept.address.tel=52571522 表单模式模拟&lt;form action=&quot;/user/add&quot; method=&quot;post&quot;&gt; &lt;label for=&quot;username&quot;&gt;用户名:&lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot; /&gt;&lt;/label&gt;&lt;br/&gt; &lt;label for=&quot;password&quot;&gt;密码:&lt;input type=&quot;password&quot; id=&quot;password&quot; name=&quot;password&quot; /&gt;&lt;/label&gt;&lt;br/&gt; &lt;label for=&quot;age&quot;&gt;年龄:&lt;input type=&quot;text&quot; name=&quot;age&quot; /&gt;&lt;/label&gt;&lt;br/&gt; &lt;label for=&quot;address.province&quot;&gt;省份:&lt;input type=&quot;text&quot; name=&quot;address.province&quot; /&gt;&lt;/label&gt;&lt;br/&gt; &lt;label for=&quot;address.city&quot;&gt;城市:&lt;input type=&quot;text&quot; name=&quot;address.city&quot; /&gt;&lt;/label&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt; &lt;/form&gt; public class Address { private String province; private String city; //toString,getter,setter } public class User { private String username; private String password; private Integer age; private Address address; //toString,getter,setter } @RequestMapping(&quot;/add&quot;) public String add(User user){ System.out.println(user); return &quot;success&quot;; } pojo list集合参数和map参数接受&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt; &lt;%@ page isELIgnored=&quot;false&quot; %&gt; &lt;html&gt; &lt;body&gt; &lt;form action= &quot;/updateAccount&quot; method= &quot;post&quot;&gt; 用户名称: &lt;input type= &quot;text&quot; name=&quot;username&quot;/&gt;&lt;br/&gt; 用户年龄: &lt;input type= &quot;text&quot; name= &quot;age&quot;/&gt;&lt;br/&gt; 账户1名称: &lt;input type=&quot;text&quot; name=&quot;accountList[0].name&quot;/&gt;&lt;br/&gt; 账户1金额: &lt;input type= &quot;text&quot; name= &quot;accountList[0].money&quot;/&gt;&lt;br/&gt; 账户2名称: &lt;input type=&quot;text&quot; name=&quot;accountList[1].name&quot;/&gt;&lt;br/&gt; 账户2金额: &lt;input type= &quot;text&quot; name= &quot;accountList[1].money&quot;/&gt;&lt;br/&gt; 账户3名称: &lt;input type=&quot;text&quot; name=&quot;accountMap['one'].name&quot;/&gt;&lt;br/&gt; 账户3金额: &lt;input type= &quot;text&quot; name= &quot;accountMap['one'].money&quot;/&gt;&lt;br/&gt; 账户4名称: &lt;input type=&quot;text&quot; name=&quot;accountMap['two'].name&quot;/&gt;&lt;br/&gt; 账户4金额: &lt;input type= &quot;text&quot; name= &quot;accountMap['two'].money&quot;/&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; public class Account implements Serializable{ private String name; private Double money; //toString,getter,setter } public class User implements Serializable{ private String username; private Integer age; private List&lt;Account&gt; accountList; private Map&lt;String,Account&gt; accountMap; //toString,getter,setter } @RequestMapping(&quot;/updateAccount&quot;) public String updateAccount(User user){ System.out.printf(&quot;user:&quot; + user); return &quot;success&quot;; } 使用Servlet API作为入参@RequestMapping(&quot;/handle1&quot;) public void handle1(HttpServletRequest request, HttpServletResponse response){ } @RequestMapping(&quot;/handle2&quot;) public String handle2(HttpSession session){ return &quot;success&quot; ; } @RequestMapping(&quot;/handle3&quot;) public String handle3(HttpServletRequest request,@RequestParam(&quot;userName&quot;) String userName){ return &quot;success&quot; ; } @RequestParam表单参数处理方法的参数名与表单传参的name值相同 创建一个表单&lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!--action指定controller中对应的方法路径即可!--&gt; &lt;form action=&quot;/login&quot; method=&quot;POST&quot;&gt; &lt;label for=&quot;username&quot;&gt;用户名:&lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot; /&gt;&lt;/label&gt; &lt;label for=&quot;password&quot;&gt;密码:&lt;input type=&quot;text&quot; id=&quot;password&quot; name=&quot;password&quot; /&gt;&lt;/label&gt; &lt;input type=&quot;submit&quot; value=&quot;登陆&quot;&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 获取参数的控制器 //接收form表单 @RequestMapping(value = &quot;/login&quot;,method = RequestMethod.POST) public String login(String username,String password){ System.out.println(&quot;username = &quot; + username); System.out.println(&quot;password = &quot; + password); return &quot;helloworld&quot;; } 获取参数,只需要在对应的方法中添加参数即可,如果参数名与请求传参的name值相同即可直接赋值,注意:对应类型很重要,如果是普通的输入框,使用字符串即可,如果是多选框,可以使用List类型的参数接值!如果参数名和name值相同,无需使用@RequestParam注解!注意: 将基本类型转化成包装类型! 方法的参数名与表单传参的name值不同 请求参数name的值与方法的参数名不同,我们还需要将指定的name对应参数传给方法的指定参数,这时,就不需要使用@RequestParam注解! 创建一个表单&lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!--action指定controller中对应的方法路径即可!--&gt; &lt;form action=&quot;/login&quot; method=&quot;POST&quot;&gt; &lt;label for=&quot;username&quot;&gt;用户名:&lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;name&quot; /&gt;&lt;/label&gt; &lt;label for=&quot;password&quot;&gt;密码:&lt;input type=&quot;text&quot; id=&quot;password&quot; name=&quot;password&quot; /&gt;&lt;/label&gt; &lt;input type=&quot;submit&quot; value=&quot;登陆&quot;&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 获取参数的控制器 //接收form表单 //如果客户端没有带参数，那么我们将得到null,我们不希望得到null,希望得到一个默认值,这个时候,我们还需要使用@RequestParam的defaultValue属性进行对应的设置。 @RequestMapping(value = &quot;/login&quot;,method = RequestMethod.POST) public String login(@RequestParam(value = &quot;name&quot;,defaultValue = &quot;ecit&quot;) String username,String password){ System.out.println(&quot;username = &quot; + username); System.out.println(&quot;password = &quot; + password); return &quot;helloworld&quot;; } @PathVariable获取路径参数 带占位符的URL是Spring3.0新增的功能，该功能在SpringMVC向REST目标挺进发展过程中具有里程碑的意义 我们可以通过此注解,获取路径部分的数据!例如: http://localhost:8080/user/list/1 RESTful传统： http://localhost:8080/user/list?id=1获取路径/list/后面1的数据!@RequestMapping(&quot;/user/list/{id}&quot;) public String getData(@PathVariable(value = &quot;id&quot;) Integer id){ System.out.println(&quot;id = &quot; + id); return &quot;user-list&quot; ; } @CookieValue @CookieValue注解可以获取请求中的cookie@RequestMapping(&quot;/cookie&quot;) public String testCookie(@CookieValue(&quot;JSESSIONID&quot;)String cookie) { System.out.println(&quot;cookie:&quot;+cookie); return &quot;success&quot;; } @RequestHeader @RequestHeader注解可以获取请求头中的数据!@RequestMapping(&quot;/header&quot;) public String testHeader(@CookieValue(&quot;JSESSIONID&quot;)String cookie, @RequestHeader(&quot;User-Agent&quot;)String header) { System.out.println(&quot;cookie:&quot;+cookie); System.out.println(&quot;header:&quot;+header); return &quot;success&quot;; } @RequestBody 和 @ResponseBody 这两个注解通常结合使用，处理涉及json格式的数据，使用他们还需要用到其它三个依赖包&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.9.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.9.3&lt;/version&gt; &lt;/dependency&gt; 原理理解 HttpMessageConverter转换器 HttpMessageConverter接口```javaHttpMessageConverter是Spring3.0 新添加的一个接口，负责将请求信息转换为一个对象(类型为T) , 将对象(类型为T)输出为响应信息,HttpMessageConverter接口定义的方法: Boolean canRead(Class&lt;?&gt; clazz,MediaType mediaType):指定转换器可以读取的对象类型，即转换器是否可将请求信息转换为clazz类型的对象,同时指定支持MIME类型(text/html, applaiction/json等) Boolean canWrite(Class&lt;?&gt; clazz,MediaType mediaType):指定转换器是否可將clazz类型的对象写到响应流中，响应流支持的媒体类型。 List getSupportMediaTypes() :该转换器支持的媒体类型。 T read(Class&lt;? extends T&gt; clazz,HttpInputMessage inputMessage) :将请求信息流转换为T类型的对象。 void write(T t,MediaType contnetType,HttpOutputMessgae outputMessage):将T类型的对象写到响应流中，同时指定相应的媒体类型为contentType。``` HttpMessageConverter接口的实现类 添加如下代码查看SpringMVC默认装配的有6个转换器@Autowired RequestMappingHandlerAdapter requestMappingHandlerAdapter; requestMappingHandlerAdapter.getMessageConverters().forEach(item-&gt; System.out.println(item) ); // 输出得到默认6个： // org.springframework.http.converter.ByteArrayHttpMessageConverter@737bb4d1 // org.springframework.http.converter.StringHttpMessageConverter@55549cd7 // org.springframework.http.converter.ResourceHttpMessageConverter@549c773c // org.springframework.http.converter.xml.SourceHttpMessageConverter@199dd163 // org.springframework.http.converter.support.AllEncompassingFormHttpMessageConverter@37ee23bd // org.springframework.http.converter.xml.Jaxb2RootElementHttpMessageConverter@462db3b3 如果添加了处理json的那三个jar包，则会得到默认转配的7个转换器org.springframework.http.converter.ByteArrayHttpMessageConverter@2332b9dc org.springframework.http.converter.StringHttpMessageConverter@266cb9c1 org.springframework.http.converter.ResourceHttpMessageConverter@577141fa org.springframework.http.converter.xml.SourceHttpMessageConverter@739de07e org.springframework.http.converter.support.AllEncompassingFormHttpMessageConverter@45575b88 org.springframework.http.converter.xml.Jaxb2RootElementHttpMessageConverter@6b65052 org.springframework.http.converter.json.MappingJackson2HttpMessageConverter@5b15afef 使用HttpMessageConverter 将请求信息转化并绑定到处理方法的入参中或将响应结果转为对应类型的响应信息，Spring提供了两种途径:使用@RequestBody @ResponseBody对处理方法进行标注.使用HttpEntity I ResponseEntity 作为处理方法的入参或返回值当控制器处理方法使用到@RequestBody/@ResponseBody或HttpEntity/ResponseEntity时, Spring首先根据请求头或响应头的Accept属性选择匹配的HttpMessageConverter，进而根据参数类型或泛型类型的过滤得到匹配的HttpMessageConverter , 若找不到可用的HttpMessageConverter将报错@RequestBody和@ResponseBody不需要成对出现@RequestMapping(&quot;/picToByte&quot;) @ResponseBody public byte[] returnHttpMsg() throws IOException { Resource res = new ClassPathResource(&quot;a92.jpg&quot;); byte[] mybyte = FileCopyUtils.copyToByteArray(res.getInputStream()); return mybyte; } //或 @RequestMapping(&quot;/picToByte2&quot;) public ResponseEntity&lt;byte[]&gt; returnResponseEntityHttpMsg2() throws IOException{ Resource res = new ClassPathResource(&quot;a92.jpg&quot;); byte[] mybyte = FileCopyUtils.copyToByteArray(res.getInputStream()); return new ResponseEntity&lt;byte[]&gt;(mybyte, HttpStatus.OK); } MarshallingHttpMessageConverter 接收与返回xml数据自动转换为Java对象 返回时把对象转换为xml格式数据示例添加依赖&lt;dependency&gt; &lt;groupId&gt;com.thoughtworks.xstream&lt;/groupId&gt; &lt;artifactId&gt;xstream&lt;/artifactId&gt; &lt;version&gt;1.4.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-oxm&lt;/artifactId&gt; &lt;version&gt;4.0.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; 创建一个对象类Employee,Department示例@Data @NoArgsConstructor @AllArgsConstructor @XStreamAlias(&quot;department&quot;) public class Department { @XStreamAlias(&quot;depid&quot;) @XStreamAsAttribute //会在父节点属性显示 private Integer id; private String departmentName; //默认作为父节点的子节点显示 } @Data @XStreamAlias(&quot;employee&quot;) public class Employee { @XStreamAlias(&quot;id&quot;) @XStreamAsAttribute //会在父节点属性显示 private Integer id; private String name; private String email; private List&lt;Department&gt; departments; } springmvc-servlet.xml配置对应转换器&lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;&gt; &lt;mvc:message-converters&gt; &lt;bean class=&quot;org.springframework.http.converter.xml.MarshallingHttpMessageConverter&quot;&gt; &lt;property name=&quot;marshaller&quot; ref=&quot;marshallerHandler&quot; /&gt; &lt;property name=&quot;unmarshaller&quot; ref=&quot;marshallerHandler&quot;/&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; &lt;bean id=&quot;marshallerHandler&quot; class=&quot;org.springframework.oxm.xstream.XStreamMarshaller&quot;&gt; &lt;property name=&quot;streamDriver&quot;&gt; &lt;bean class=&quot;com.thoughtworks.xstream.io.xml.StaxDriver&quot;/&gt; &lt;/property&gt; &lt;property name=&quot;annotatedClasses&quot;&gt; &lt;list&gt; &lt;value&gt;com.ecit.controller.VO.Department&lt;/value&gt; &lt;value&gt;com.ecit.controller.VO.Employee&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; 测试返回对象转换为xml数据返回如下：@RequestMapping(&quot;/employXML&quot;) @ResponseBody public Employee returnEmployXML(){ Employee employee = new Employee(); employee.setEmail(&quot;8430@163.com&quot;); employee.setId(1); employee.setName(&quot;风清扬&quot;); List&lt;Department&gt; departments = new ArrayList&lt;&gt;(); departments.add(new Department(1,&quot;客服部门&quot;)); departments.add(new Department(2,&quot;财务部门&quot;)); employee.setDepartments(departments); return employee; } //输出结果： // &lt;?xml version=&quot;1.0&quot; ?&gt; // &lt;employee id=&quot;1&quot;&gt; // &lt;name&gt;风清扬&lt;/name&gt; // &lt;email&gt;8430@163.com&lt;/email&gt; // &lt;departments&gt; // &lt;department depid=&quot;1&quot;&gt; // &lt;departmentName&gt;客服部门&lt;/departmentName&gt; // &lt;/department&gt; // &lt;department depid=&quot;2&quot;&gt; // &lt;departmentName&gt;财务部门&lt;/departmentName&gt; // &lt;/department&gt; // &lt;/departments&gt; // &lt;/employee&gt; 测试直接读取xml数据，然后转换为java对象@RequestMapping(value = &quot;/employXML2&quot;,method = RequestMethod.POST,consumes =&quot;application/xml&quot;,produces =&quot;application/xml&quot;) @ResponseBody public Employee readEmployXML(@RequestBody Employee employee){ System.out.printf(&quot;读取xml数据&quot; + employee); return employee; } // 输出结果： // 读取xml数据Employee(id=1, name=风清扬, email=8430@163.com, departments=[Department(id=1, departmentName=客服部门), Department(id=2, departmentName=财务部门)]) @RequestBody原始接收key=value&amp;key2=value2 使用说明 作用: 用于获取请求体内容。直接使用得到是key=value&amp;key2=value2.. .结构的数据。get请求方式不适用。 属性: reguired:是否必须有请求体。默认值是:true。当取值为true时，get请求方式会报错。如果取值为false; get 请求得到是null 表单&lt;html&gt; &lt;body&gt; &lt;form action= &quot;/doLogin&quot; method= &quot;post&quot;&gt; 账户: &lt;input type= &quot;text&quot; name=&quot;username&quot; /&gt;&lt;br/&gt; 密码: &lt;input type= &quot;password&quot; name=&quot;password&quot; /&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 控制器@RequestMapping(&quot;/doLogin&quot;) public String doLogin(@RequestBody String body){ //针对上述表单仅且只能这样接收 System.out.printf(&quot;body:&quot; + body); return &quot;success&quot;; } 测试结果输出: body:password=123456&amp;username=admin @RequestBody直接使用对象接收 表单&lt;html&gt; &lt;head&gt; &lt;script src=&quot;https://cdn.bootcss.com/jquery/3.4.1/jquery.js&quot;&gt; &lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(document).ready(function () { $(&quot;#submit&quot;).click(function () { var paramdata = { // 注意这里会是key=val&amp;key2=val2这种形式 username:$(&quot;#username&quot;).val(), password:$(&quot;#password&quot;).val() }; $.ajax({ url: &quot;/doLogin2&quot;, type: &quot;POST&quot;, data: JSON.stringify(paramdata), //注意转为json headers : {&quot;Content-Type&quot; : &quot;application/json;charset=utf-8&quot;}, success: function (data) { alert(&quot;request success! return data&quot; + data) } }); }); }) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form id=&quot;myform&quot;&gt; 账户: &lt;input id=&quot;username&quot; type=&quot;text&quot; name=&quot;username&quot;/&gt;&lt;br/&gt; 密码: &lt;input id=&quot;password&quot; type=&quot;password&quot; name=&quot;password&quot;/&gt;&lt;br/&gt; &lt;input type=&quot;button&quot; id=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; VO实体public class Login { private String username; private String password; //toString,getter,setter } 控制器接收@RequestMapping(value = &quot;/doLogin2&quot;) public String doLogin2(@RequestBody Login login){ System.out.println(&quot;login:&quot; + login); return &quot;success&quot;; } 测试，输出值暂且 账户：admin,密码:123456输出结果： login:Login{username='admin', password='123456'} @ResponseBody直接把返回的对象转json返回@RequestMapping(value = &quot;/doLogin2&quot;) @ResponseBody public Login doLogin2(@RequestBody Login login){ System.out.println(&quot;login:&quot; + login); return login; } 自定义类型转换–日期接收为例 带时间控件的表单&lt;html&gt; &lt;body&gt; &lt;form action= &quot;/updateDate&quot; method= &quot;post&quot;&gt; 时间: &lt;input type= &quot;datetime-local&quot; name=&quot;dateTime&quot; /&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 自定义类型转换器，import org.springframework.core.convert.converter.Converter; import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Date; public class StringDateTimeConvertDateTime implements Converter&lt;String, Date&gt; { @Override public Date convert(String source) { if (source == null || source.length() &lt;= 0) { throw new RuntimeException(&quot;时间字段不能为空&quot;); } SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd'T'HH:mm&quot;); try { return simpleDateFormat.parse(source); } catch (ParseException e1) { throw new RuntimeException(&quot;时间字段转换异常&quot;); } } } 自定义的转换器注册到服务中&lt;!--配置自定义类型转换器:它的配置方式是采用注册服务的方式来实现的。--&gt; &lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;&gt; &lt;property name=&quot;converters&quot;&gt; &lt;set&gt; &lt;bean class=&quot;com.ecit.controller.utils.StringDateTimeConvertDateTime&quot;&gt;&lt;/bean&gt; &lt;/set&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!--1.注解驱动 HandlerMapping HandlerAdapter ,添加转换器服务--&gt; &lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;&gt;&lt;/mvc:annotation-driven&gt; 测试@RequestMapping(&quot;/updateDate&quot;) public String updateDateTime(Date dateTime){ System.out.printf(&quot;dateTime:&quot; + dateTime); return &quot;success&quot;; } 转发和重定向 转发: forward,服务器端跳转 重定向:redirect,浏览器端跳转@RequestMapping(value= &quot;/forward&quot;) public String forward(){ return &quot;forward:/hello2&quot;; } @RequestMapping(value= &quot;/redirect&quot;) public String redirect(){ return &quot;redirect:/hello2&quot;; } @RequestMapping(&quot;/hello2&quot;) public ModelAndView helloWithMsg(HttpServletRequest arg0, HttpServletResponse arg1) throws Exception { ModelAndView mv = new ModelAndView(); mv.addObject(&quot;message&quot;,&quot;Welcome learning SpringMVC&quot;); mv.addObject(&quot;title&quot;,&quot;Hello&quot;); mv.setViewName(&quot;success&quot;); return mv; } SpringMVC参数乱码–针对post方式的 在web.xml配置文件中添加spring自带的Filter设置编码格式&lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; Spring MVC中 GET方式不会乱码!get请求方式:tomacat对GET和POST请求处理方式是不同的，GET 请求的编码问题，要改tomcat的server.xml配置文件，如下:&lt;Connector connectionTimeout=&quot;20000&quot; port=&quot;8080” protocol=&quot;HTTP/1.1&quot; redirestRort=&quot;8443&quot;/&gt;改为: &lt;Connector connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1” redirectRort=&quot;8443” useBodyEncodingForURI=&quot;true&quot;/&gt; 如果遇到ajax请求仍然乱码，请把: useBodyEncodingForURI=&quot;true&quot; 改为 URIEncoding=&quot;UTF-8&quot; 即可。 处理模型数据 SpringMVC提供了以下几种途径输出模型数据: ModelAndView 处理方法返回值类型为ModelAndView时,则其既包含视图信息，也包含模型数据信息。//添加模型数据: . MoelAndView addObject(String attributeName, Object attributeValue) ModelAndView addAllObject(Map&lt;String, ?&gt; modelMap) //设置视图: void setView(View view) void setViewName(String viewName) Map及Model Spring MVC在内部使用了一个rg.springframework.ui.Model接口存储模型数据，Spring MVC在调用方法前会创建一个隐含的模型对象作为模型数据的存储容器。如果方法的入参为Map或Model类型, Spring MVC会将隐含模型的引用传递给这些入参。在方法体内，开发者可以通过这个入参对象访问到模型中的所有数据，也可以向模型中添加新的属性数据 @SessionAttrilbutes 将模型中的某个属性暂存到HttpSession中，以便多个请求之间可以共享这个属性@SessionAttributes除了可以通过属性名指定需要放到会话中的属性外，还可以通过模型属性的对象类型指定哪些模型属性需要放到会话中@SessionAttributes(types=User.class)会将隐含模型中所有类型为User.class的属性添加到会话中。@SessionAttributes(value={“user1”,“user2”})@SessionAttributes(types={User.class, Dept.class})@SessionAttributes(value={“user1”,“user2”},types={Dept.class})&lt;a href=&quot;/testPut&quot;&gt;存入SessionAttribute&lt;/a&gt; &lt;hr/&gt; &lt;a href=&quot;/testGet&quot;&gt;取出SessionAttribute&lt;/a&gt; &lt;hr/&gt; &lt;a href=&quot;/testClean&quot;&gt;清除SessionAttribute&lt;/a&gt; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.ui.ModelMap; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.SessionAttributes; import org.springframework.web.bind.support.SessionStatus; @SessionAttributes(value = {&quot;username&quot;, &quot;password&quot;}, types = {Integer.class}) @Controller public class UserController { /** * 把数据存入 SessionAttribute * @param model * * @return Model 是 spring 提供的一个接口，该接口有一个实现类 ExtendedModelMap * 该类继承了 ModelMap，而 ModelMap 就是 LinkedHashMap 子类 */ @RequestMapping(&quot;/testPut&quot;) public String testPut(Model model) { model.addAttribute(&quot;username&quot;, &quot;admin&quot;); model.addAttribute(&quot;password&quot;, &quot;123456&quot;); model.addAttribute(&quot;age&quot;, 31); //跳转之前将数据保存到 username、password 和 age 中，因为注解@SessionAttribute 中有 这几个参数 return &quot;success&quot;; } @RequestMapping(&quot;/testGet&quot;) public String testGet(ModelMap model) { System.out.println(model.get(&quot;username&quot;) + &quot;;&quot; + model.get(&quot;password&quot;) + &quot;;&quot; + model.get(&quot;age&quot;)); return &quot;success&quot;; } @RequestMapping(&quot;/testClean&quot;) public String complete(SessionStatus sessionStatus) { sessionStatus.setComplete(); return &quot;success&quot;; } } // 输出结果： // admin;123456;31 // null;null;null 清除session再获取时的结果 @ModelAttribute 使用说明 作用:该注解是SpringMVC4.3版本以后新加入的。它可以用于修饰方法和参数。出现在方法上，表示当前方法会在控制器的方法执行之前，先执行。它可以修饰没有返回值的方法，也可 以修饰有具体返回值的方法。 出现在参数上，获取指定的数据给参数赋值。 属性: value:用于获取数据的keyo。key可以是POJO的属性名称，也可以是map结构的key。 应用场景: 当表单提交数据不是完整的实体类数据时，保证没有提交数据的字段使用数据库对象原来的数据。例如:我们在编辑一个用户时，用户有一个创建信息字段，该字段的值是不允许被修改的。在提交表单数据是肯定没有此字段的内容，一旦更新会把该字段内容置为null,此时就可以使用此注解解决问题。 基于POJO属性的基本使用: jsp代码&lt;a href=&quot;/doModelAtt?username=system&quot;&gt;doModelAtt&lt;/a&gt; 控制器@ModelAttribute public void showModel(Login user) { System.out.println(&quot;执行了 showModel 方法,Login:&quot; + user); } @RequestMapping(value = &quot;/doModelAtt&quot;) public String doModelAtt(Login login){ System.out.println(&quot;执行doModelAtt方法, login:&quot; + login); return &quot;success&quot;; } // 输出结果： // 执行了 showModel 方法,Login:Login{username='system', password='null'} // 执行doModelAtt方法, login:Login{username='system', password='null'} 基于 Map 的应用场景示例:ModelAttribute 修饰方法带返回值 需求:修改用户信息，要求 用户的密码不能修改&lt;form action=&quot;/doModelAtt2&quot; method=&quot;post&quot;&gt; 用户名称:&lt;input type=&quot;text&quot; name=&quot;username&quot; &gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;保存&quot;&gt; &lt;/form&gt; @ModelAttribute public Login showModel2(String username) { //模拟去数据库查询 Login abc = new Login(); abc.setPassword(&quot;123456&quot;); abc.setUsername(username); System.out.println(&quot;执行了 showModel 方法&quot;+abc); return abc; } @RequestMapping(&quot;/doModelAtt2&quot;) public String doModelAtt2(Login user) { System.out.println(&quot;控制器中处理请求的方法:修改用户:&quot;+user); return &quot;success&quot;; } // 输出结果： // 执行了 showModel 方法Login{username='system', password='123456'} // 控制器中处理请求的方法:修改用户:Login{username='system', password='123456'} 基于 Map 的应用场景示例:ModelAttribute 修饰方法不带返回值 需求:修改用户信息，要求 用户的密码不能修改&lt;form action=&quot;/doModelAtt3&quot; method=&quot;post&quot;&gt; 用户名称:&lt;input type=&quot;text&quot; name=&quot;username&quot; &gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;保存&quot;&gt; &lt;/form&gt; @ModelAttribute public void showModel3(String username,Map&lt;String,Login&gt; map) { //模拟去数据库查询 Login abc = new Login(); abc.setPassword(&quot;123456&quot;); abc.setUsername(username); System.out.println(&quot;执行了 showModel3 方法&quot;+abc); map.put(&quot;abc&quot;,abc); } @RequestMapping(&quot;/doModelAtt3&quot;) public String doModelAtt3(@ModelAttribute(&quot;abc&quot;)Login user) { System.out.println(&quot;控制器中处理请求的方法:修改用户:&quot;+user); return &quot;success&quot;; } @InitBinder 由@InitBinder标识的方法,可以对WebDataBinder对象进行初始化。WebDataBinder 是DataBinder的子类,用于完成由表单字段到JavaBean属性的绑定 @InitBinder方法不能有返回值,它必须声明为void。 @InitBinder方法的参数通常是是WebDataBinder数据绑定流程 数据格式化 对属性对象的输入/输出进行格式化，从其本质上讲依然属于“类型转换”的范畴。Spring在格式化模块中定义了一个实现ConversionService接口的FormattingConversionService 实现类，该实现类扩展了GenericConversionService，因此它既具有类型转换的功能，又具有格式化的功能.FormattingConversionService拥有一个FormattingConversionServiceFactroyBean 工厂类,后者用于在Spring上下文中构造前者 FormattingConversionServiceFactroyBean内部已经注册了: NumberFormatAnnotationFormatterFactroy :支持对数字类型的属性使用@NumberFormat注解 JodaDateTimeFormatAnnotationFormatterFactroy :支持对日期类型的属性使用@DateTimeFormat注解装配了FormattingConversionServiceFactroyBean后, 就可以在SpringMVC入参绑定及模型数据输出时使用注解驱动了。&lt;mvc:annotation-driven/&gt; 默认创建的ConversionService实 例即为FormattingConversionServiceFactroyBean 日期格式化 @DateTimeFormat注解可对java.util.Date、java.uti.Calendar 、java.long.Long 时 间类型进行标注: pattern属性:类型为字符串。指定解析/格式化字段数据的模式,如:”yyyy-MM-dd hh:mm:ss iso属性:类型为DateTimeFormat.ISO。 指定解析/格式化字段数据的ISO模式，包括四种: ISO.NONE (不使用) -默认、ISO.DATE(yyyy-MM-dd) 、ISO.TIME(hh:mm:ss.SSSZ)、ISO.DATE_TIME(yyyy-MM-dd hh:mm:ss.SSSZ) style属性:字符串类型。通过样式指定日期时间的格式，由两位字符组成，第一位表示日期的格式，第二位表示时间的格式: S :短日期/时间格式、M:中日期/时间格式、L:长日期/时间格式、F:完整日期/时间格式、-:忽略日期或时间格式 数值格式化 @NumberFormat 可对类似数字类型的属性进行标注，它拥有两个互斥的属性: style :类型为NumberFormat.Style。用于指定样式类型，包括三种: Style.NUMBER (正常数字类型)、Style.CURRENCY (货币类型)、 Style.PERCENT (百分数类型) pattern :类型为String， 自定义样式,如pattern=”#,###” ; SpringMVC-JSR303-Validation Spring3支持JSR-303验证框架，JSR-303 是JAVA EE 6 中的一项子规范，叫做Bean Validation，官方参考实现是Hibernate Validator（与Hibernate ORM 没有关系），JSR303 用于对Java Bean 中的字段的值进行验证。 依赖的jar&lt;dependency&gt; &lt;groupId&gt;javax.validation&lt;/groupId&gt; &lt;artifactId&gt;validation-api&lt;/artifactId&gt; &lt;version&gt;2.0.1.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;5.2.1.Final&lt;/version&gt; &lt;/dependency&gt; 在SpringMVC-servlet.xml配置validator&lt;!-- 校验器 --&gt; &lt;bean id=&quot;validator&quot; class=&quot;org.springframework.validation.beanvalidation.LocalValidatorFactoryBean&quot;&gt; &lt;!-- 校验器--&gt; &lt;property name=&quot;providerClass&quot; value=&quot;org.hibernate.validator.HibernateValidator&quot; /&gt; &lt;!-- 指定校验使用的资源文件，如果不指定则默认使用classpath下的ValidationMessages.properties --&gt; &lt;property name=&quot;validationMessageSource&quot; ref=&quot;messageSource&quot; /&gt; &lt;/bean&gt; &lt;!-- 校验错误信息配置文件 --&gt; &lt;bean id=&quot;messageSource&quot; class=&quot;org.springframework.context.support.ReloadableResourceBundleMessageSource&quot;&gt; &lt;!-- 资源文件名--&gt; &lt;property name=&quot;basenames&quot;&gt; &lt;list&gt; &lt;value&gt;classpath:errors&lt;/value&gt;&lt;!--errors.properties的中文一定要用Unicode码--&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- 资源文件编码格式 --&gt; &lt;property name=&quot;fileEncodings&quot; value=&quot;utf-8&quot; /&gt; &lt;!-- 对资源文件内容缓存时间，单位秒 --&gt; &lt;property name=&quot;cacheSeconds&quot; value=&quot;120&quot; /&gt; &lt;/bean&gt; 将validator加到处理器适配器 配置方式1 xml &lt;mvc:annotation-driven validator=&quot;validator&quot;&gt; &lt;/mvc:annotation-driven&gt; 配置方式2&lt;!-- 自定义webBinder --&gt; &lt;bean id=&quot;customBinder&quot; class=&quot;org.springframework.web.bind.support.ConfigurableWebBindingInitializer&quot;&gt; &lt;property name=&quot;validator&quot; ref=&quot;validator&quot; /&gt; &lt;/bean&gt; &lt;!-- 注解适配器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;&gt; &lt;property name=&quot;webBindingInitializer&quot; ref=&quot;customBinder&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 添加验证规则public class User implements Serializable{ @NotNull(message = &quot;{field.is.not.null}&quot;) @Size(min = 6,max = 20,message = &quot;{field.rang.error}&quot;) private String username; @Min(value = 18,message = &quot;{field.must.be.greater.than.min}&quot;) private Integer age; } 自定义errors.properties，放入项目classpath路径下field.is.not.null={field}\\u4e0d\\u80fd\\u4e3a\\u7a7a field.is.not.empty={field}\\u4e0d\\u80fd\\u4e3a\\u7a7a\\u6216\\u8005\\u7a7a\\u5b57\\u7b26\\u4e32 field.must.be.greater.than.min={field}\\u4e0d\\u80fd\\u5c0f\\u4e8e{value} field.must.be.letter.than.max={field}\\u4e0d\\u80fd\\u5927\\u4e8e{value} field.rang.error=\\u4e0d\\u5728\\u8303\\u56f4\\u533a\\u95f4 email.error.info=\\u4e0d\\u662f\\u90ae\\u7bb1\\u683c\\u5f0f 定义全局ValidationExceptionResovler解析器import lombok.extern.slf4j.Slf4j; import org.springframework.validation.BindException; import org.springframework.validation.BindingResult; import org.springframework.validation.ObjectError; import org.springframework.web.bind.MethodArgumentNotValidException; import org.springframework.web.bind.annotation.ResponseBody; import org.springframework.web.servlet.ModelAndView; import org.springframework.web.servlet.handler.AbstractHandlerExceptionResolver; import org.springframework.web.servlet.view.json.MappingJackson2JsonView; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.util.List; import java.util.Map; import java.util.TreeMap; @Slf4j public class ValidationExceptionResovler extends AbstractHandlerExceptionResolver { public ValidationExceptionResovler() { // 设置order，在DefaultHandlerExceptionResolver之前执行 this.setOrder(0); } @ResponseBody protected ModelAndView handleMethodArgumentNotValidException(BindingResult bindingResult, HttpServletRequest request, HttpServletResponse response, Object handler) throws IOException { List&lt;ObjectError&gt; errors = bindingResult.getAllErrors(); StringBuffer errmsgBF = new StringBuffer(); for (ObjectError error : errors) { String massage = error.getDefaultMessage(); errmsgBF.append(massage); errmsgBF.append(&quot;||&quot;); } String errmsgString = errmsgBF.toString(); errmsgString = errmsgString.length() &gt; 2 ? errmsgString.substring(0, errmsgString.length() - 2) : errmsgString; log.error(&quot;Validation failed!{}&quot;,errmsgString); Map&lt;String, Object&gt; map = new TreeMap&lt;String, Object&gt;(); map.put(&quot;success&quot;, false); map.put(&quot;errorCode&quot;, &quot;9999&quot;); map.put(&quot;errorMsg&quot;, errmsgString); ModelAndView mav = new ModelAndView(); MappingJackson2JsonView view = new MappingJackson2JsonView(); view.setAttributesMap(map); mav.setView(view); return mav; } @Override protected ModelAndView doResolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) { BindingResult bindingResult = null; if (ex instanceof MethodArgumentNotValidException) { bindingResult = ((MethodArgumentNotValidException) ex).getBindingResult(); } else if (ex instanceof BindException) { bindingResult = ((BindException) ex).getBindingResult(); } else { //other exception , ignore } if (bindingResult != null) { try { return handleMethodArgumentNotValidException(bindingResult, request, response, handler); } catch (IOException e) { log.error(&quot;doResolveException: &quot;, e); } } return null; } } 测试校验@RequestMapping(&quot;/testUser&quot;) public String item(@Validated User items) { System.out.println(&quot;items:&quot; + items); return &quot;success&quot;; } // 输出结果： // {&quot;errorCode&quot;:&quot;9999&quot;,&quot;success&quot;:false,&quot;errorMsg&quot;:&quot;不在范围区间||{field}不能小于18&quot;} 视图和视图解析器 请求处理方法执行完成后，最终返回- -个ModelAndView对象。对于那些返回String，View 或ModeMap等类型的处理方法，Spring MVC也会在内部将它们装配成一一个ModelAndView对象，它包含了逻辑名和模型对象的视图 Spring MVC借助视图解析器(ViewResolver )得到最终的视图对象(View) ，最终的视图可以是JSP , 也可能是Excel、JFreeChart 等各种表现形式的视图 对于最终究竟采取何种视图对象对模型数据进行渲染，处理器并不关心，处理器工作重点聚焦在生产模型数据的工作上，从而实现MVC的充分解耦 视图 视图的作用是渲染模型数据，将模型里的数据以某种形式呈现给客户。为了实现视图模型和具体实现技术的解耦，Spring在org.springframework.web.servlet包中定义了一个高度抽象的View接口. 视图对象由视图解析器负责实例化。由于视图是无状态的，所以他们不会有线程安全的问题 常见视图实现类 Excel视图 若希望使用Excel展示数据列表，仅需要扩展SpringMVC提供的AbstractExcelView或AbstractJExcelView即可。实现buildExcelDocument()方法，在方法中使用模型数据对象构建Excel文档就可以了。 AbstractExcelView基于POI API，而AbstractJExcelView是基于JExcelAPI的。视图对象需要配置I0C容器中的-一个Bean，使用BeanNameViewResolver作为视图解析器即可 若希望直接在浏览器中直接下载Excel文档，则可以设置响应头Content-Disposition 的值为attachment;filename=xxx.xls 视图解析器 SpringMVC为逻辑视图名的解析提供了不同的策略，可以在SpringWEB上下文中配置一种或多种解析策略，并指定他们之间的先后顺序。每一种映射策略对应一个具体的视图解析器实现类。 视图解析器的作用比较单一:将逻辑视图解析为一个具体的视图对象。 所有的视图解析器都必须实现ViewResolver接口 常见视图解析器 可以选择一种视图解析器或混用多种视图解析器 每个视图解析器都实现了Ordered接口并开放出一个order属性，可以通过order属性指定解析器的优先顺序，order 越小优先级越高。 SpringMVC会按视图解析器顺序的优先顺序对逻辑视图名进行解析，直到解析成功并返回视图对象，否则将抛出ServletException异常 BeanNameViewResolver的使用(输出excel&amp;pdf)@Data public class User implements Serializable{ private String username; private Integer age; private Date birthday; private String name; } @RequestMapping(&quot;/exportUserExcel&quot;) public String exportUserExcel(ModelMap mm){ List&lt;User&gt; userList = new ArrayList&lt;User&gt;(); for(int i = 0 ; i &lt; 101; i ++){ User user = new User(); user.setAge(i); user.setBirthday(new Date()); user.setName(&quot;ecit-excel&quot; + i ); userList.add(user); } mm.put(&quot;userList&quot;, userList); return &quot;userListExcel&quot;; } @RequestMapping(&quot;/exportUserPdf&quot;) public String exportPdf(Model model) { model.addAttribute(DATA, data()); model.addAttribute(FILENAME, &quot;战略协议合同.pdf&quot;); return &quot;userListPdf&quot;; // 与personal.hutao.view.PdfStamperView的bean id匹配 } private Map&lt;String, String&gt; data() { Map&lt;String, String&gt; data = new HashMap&lt;String, String&gt;(); data.put(&quot;partyA&quot;, &quot;海天科技有限公司&quot;); data.put(&quot;partyB&quot;, &quot;天弘科技有限公司&quot;); data.put(&quot;legalPersonA&quot;, &quot;张三&quot;); data.put(&quot;legalPersonB&quot;, &quot;李四&quot;); data.put(&quot;addressA&quot;, &quot;上海&quot;); data.put(&quot;addressB&quot;, &quot;北京&quot;); return data; } 添加视图扩展用到的三方依赖 &lt;dependency&gt; &lt;groupId&gt;com.lowagie&lt;/groupId&gt; &lt;artifactId&gt;itext&lt;/artifactId&gt; &lt;version&gt;2.1.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.lowagie&lt;/groupId&gt; &lt;artifactId&gt;itextasian&lt;/artifactId&gt; &lt;version&gt;1.5.2&lt;/version&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;systemPath&gt;${project.basedir}/lib/itextasian-1.5.2.jar&lt;/systemPath&gt; &lt;/dependency&gt; 设置Excel和PDF的viewpublic class UserListExcel extends AbstractExcelView{ @Override protected void buildExcelDocument(Map&lt;String, Object&gt; mm, HSSFWorkbook workbook, HttpServletRequest request, HttpServletResponse response) throws Exception { List&lt;User&gt; userList = (List&lt;User&gt;)mm.get(&quot;userList&quot;); HSSFSheet sheet = workbook.createSheet(&quot;ecit_sheet&quot;); HSSFRow row = sheet.createRow(0);//创建第一行数据 row.createCell((short)0).setCellValue(&quot;名字&quot;); row.createCell((short)1).setCellValue(&quot;年龄&quot;); row.createCell((short)2).setCellValue(&quot;生日&quot;); int startRow = 1; HSSFRow new_row = null; for (User user : userList) { new_row = sheet.createRow(startRow);//创建第一行数据 new_row.createCell((short)0).setCellValue(user.getName()); new_row.createCell((short)1).setCellValue(user.getAge()); new_row.createCell((short)2).setCellValue(new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).format(user.getBirthday())); startRow ++; } response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename=&quot;+new String(&quot;用户.xls&quot;.getBytes(),&quot;ISO8859-1&quot;)); } } Adobe Acrobat创建表单导入word模板，添加属性域，完成pdf导出成template.pdf,在WEB-INF 下创建template目录，template.pdf放入下面最终程序运行效果：import com.lowagie.text.DocumentException; import com.lowagie.text.pdf.AcroFields; import com.lowagie.text.pdf.PdfStamper; import org.springframework.web.servlet.view.document.AbstractPdfStamperView; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.util.Map; public class PdfStamperView extends AbstractPdfStamperView { public static final String DATA = &quot;data&quot;; public static final String FILENAME = &quot;mergePdfFileName&quot;; @SuppressWarnings(&quot;unchecked&quot;) @Override protected void mergePdfDocument(Map&lt;String, Object&gt; model, PdfStamper stamper, HttpServletRequest request, HttpServletResponse response) throws Exception { response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename=&quot; + new String(model.get(FILENAME).toString().getBytes(), &quot;ISO8859-1&quot;)); AcroFields fields = stamper.getAcroFields(); fillData(fields, (Map&lt;String, String&gt;) model.get(DATA)); stamper.setFormFlattening(true); } private void fillData(AcroFields fields, Map&lt;String, String&gt; data) throws IOException, DocumentException { for (String key : data.keySet()) { String value = data.get(key); fields.setField(key, value); } } } 注册视图解析器到SpringMVC-servlet.xml&lt;bean class=&quot;org.springframework.web.servlet.view.BeanNameViewResolver&quot;&gt; &lt;property name=&quot;order&quot;&gt; &lt;value&gt;1&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;userListExcel&quot; class=&quot;com.ecit.controller.view.document.UserListExcel&quot; /&gt; &lt;bean id=&quot;userListPdf&quot; class=&quot;com.ecit.controller.view.document.PdfStamperView&quot;&gt; &lt;property name=&quot;url&quot; value=&quot;/WEB-INF/template/template.pdf&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 测试jsp&lt;a href=&quot;/exportUserExcel&quot;&gt;exportUserExcel&lt;/a&gt;&lt;br/&gt; &lt;a href=&quot;/exportUserPdf&quot;&gt;exportUserPdf&lt;/a&gt; 国际化 国际化是设计软件应用的过程中应用被使用与不同语言和地区，国际化通常采用多属性文件的方式解决，每个属性文件保存一种语言的文字信息，不同语言的用户看到的是不同的内容 默认情况下，SpringMVC 根据Accept-Language参数判断客户端的本地化类型。当接受到请求时，SpringMVC 会在上下文中查找-一个本地化解析器(LocalResolver )，找到后使用它获取请求所对应的本地化类型信息。 SpringMVC还允许装配一个动态更改本地化类型的拦截器，这样通过指定一个请求参数就可以控制单个请求的本地化类型。 错误信息回显 每个属性在数据绑定和数据校验发生错误时,都会生成个对应的FieldError对象。 当一个属性校验失败后,校验框架会为该属性生成4个消息代码,这些代码以校验注解类名为前缀,结合modleAttribute、属性名及属性类型名生成多个对应的消息代码:例如User类中的password属性标准了一个@Pattern注解,当该属性值不满足@Pattern所定义的规则时,就会产生以下4个错误代码:一Pattern.user.password一Pattern.password一Pattern.java.lang.String一Pattern 当使用Spring MVC标签显示错误消息时, Spring MVC会查看WEB上下文是否装配了对应的国际化消息,如果没有,则显示默认的错误消息，否则使用国际化消息。 若数据类型转换或数据格式转换时发生错误, 或该有的参数不存在，或调用处理方法时发生错误，都会在隐含模型中创建错误消息。其错误代码前缀说明如下:required : 必要的参数不存在。如@RequiredParam(“param1”)标注了一个入参，但是该参数不存在typeMismatch : 在数据绑定时，发生数据类型不匹配的问题methodInvocation : Spring MVC在调用处理方法时发生了错误,注册国际化资源文件 @Data public class Employee { private Integer id; @NotNull @Size(min = 2,max = 20) private String lastName; @Email private String email; //1 male, 0 female private Integer gender; @Past @DateTimeFormat(pattern=&quot;yyyy-MM-dd&quot;) private Date birth; @NumberFormat(pattern=&quot;#,###,###.#&quot;) private Float salary; } input.jsp &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot; %&gt; &lt;%@ taglib prefix=&quot;form&quot; uri=&quot;http://www.springframework.org/tags/form&quot; %&gt; &lt;html&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;br&gt;&lt;br&gt; &lt;form:form action=&quot;/emp&quot; method=&quot;POST&quot; modelAttribute=&quot;employee&quot;&gt; LastName: &lt;form:input path=&quot;lastName&quot;/&gt; &lt;form:errors path=&quot;lastName&quot;&gt;&lt;/form:errors&gt; &lt;br&gt; Email: &lt;form:input path=&quot;email&quot;/&gt; &lt;form:errors path=&quot;email&quot;&gt;&lt;/form:errors&gt; &lt;br&gt; Birth: &lt;form:input path=&quot;birth&quot;/&gt; &lt;form:errors path=&quot;birth&quot;&gt;&lt;/form:errors&gt; &lt;br&gt; Salary: &lt;form:input path=&quot;salary&quot;/&gt; &lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;/&gt; &lt;/form:form&gt; &lt;/body&gt; &lt;/html&gt; @RequestMapping(value=&quot;/employ&quot;) public String save(@Valid Employee employee, Errors result, Map&lt;String, Object&gt; map){ if(result.getErrorCount() &gt; 0){ for(FieldError error:result.getFieldErrors()){ System.out.println(error.getField() + &quot;:&quot; + error.getDefaultMessage()); } return &quot;input&quot;; } return &quot;redirect:/employ-list&quot;; } 不同语言切换显示 1.在页面上能够根据浏览器语言设置的情况对文本(不是内容)， 时间，数值进行本地化处理 2.可以在bean中获取国际化资源文件Locale对应的消息 3.可以通过超链接切换Locale，而不再依赖于浏览器的语言设置情况 在resources下或项目任意的classpath路径下添加 message_en_US.properties,message_zh_CN.properties 在springmvc-servlet.xml配置国际化资源，本地化解析器以及本地化拦截器 &lt;!-- 存储区域设置信息 SessionLocaleResolver类通过一个预定义会话名将区域化信息存储在会话中 从session判断用户语言defaultLocale:默认语言 --&gt; &lt;bean id=&quot;localeResolver&quot; class=&quot;org.springframework.web.servlet.i18n.SessionLocaleResolver&quot;&gt; &lt;property name=&quot;defaultLocale&quot; value=&quot;zh_CN&quot; /&gt; &lt;/bean&gt; &lt;!-- 国际化资源文件 messageSource配置的是国际化资源文件的路径， classpath:messages指的是classpath路径下的 messages_zh_CN.properties文件和messages_en_US.properties文件 设置“useCodeAsDefaultMessage”，默认为false，这样当Spring在ResourceBundle中找不到messageKey的话，就抛出NoSuchMessageException， 把它设置为True，则找不到不会抛出异常，而是使用messageKey作为返回值。 --&gt; &lt;bean id=&quot;messageSource&quot; class=&quot;org.springframework.context.support.ReloadableResourceBundleMessageSource&quot;&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot; /&gt; &lt;property name=&quot;useCodeAsDefaultMessage&quot; value=&quot;true&quot; /&gt; &lt;property name=&quot;basenames&quot;&gt; &lt;list&gt; &lt;value&gt;classpath:message&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!--该拦截器通过名为”lang”的参数来拦截HTTP请求，使其重新设置页面的区域化信息 --&gt; &lt;mvc:interceptors&gt; &lt;bean id=&quot;localeChangeInterceptor&quot; class=&quot;org.springframework.web.servlet.i18n.LocaleChangeInterceptor&quot;&gt; &lt;property name=&quot;paramName&quot; value=&quot;lang&quot; /&gt; &lt;/bean&gt; &lt;/mvc:interceptors&gt; 编写控制器 是在springmvc-servlet.xml配置 &lt;mvc:view-controller path=&quot;/login&quot; view-name=&quot;login&quot;&gt;&lt;/mvc:view-controller&gt; path=”/login 就是你访问的路径（相当于RequestMapping(“/login)）view-name=”hello”是你所要的视图（如login.jsp,相当于return “login”） 配置了这个后对于/login请求,就会直接交给dispatcherServlet,然后使用ViewResolver进行解析。 相当于以下代码： @RequestMapping(value=&quot;/login&quot;) public String login(){ return &quot;login&quot;; } 在WEB-INF/jsp目录下编写login.jsp &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@ taglib uri=&quot;http://www.springframework.org/tags&quot; prefix=&quot;spring&quot;%&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;spring:message code=&quot;TITLE&quot; /&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;login&quot;&gt; &lt;h1&gt;&lt;spring:message code=&quot;TITLE&quot; /&gt; &lt;/h1&gt; &lt;form action=&quot;test.do&quot; method=&quot;post&quot;&gt; &lt;spring:message code=&quot;USERNAME&quot; /&gt;: &lt;input type=&quot;text&quot; name=&quot;name&quot; placeholder=&lt;spring:message code=&quot;USERNAME&quot; /&gt; required=&quot;required&quot; value=&quot;&quot; /&gt; &lt;br/&gt; &lt;spring:message code=&quot;PASSWORD&quot; /&gt;: &lt;input type=&quot;password&quot; name=&quot;password&quot; placeholder=&lt;spring:message code=&quot;PASSWORD&quot; /&gt; required=&quot;required&quot; value=&quot;&quot; /&gt; &lt;br/&gt; &lt;button type=&quot;submit&quot; &gt;&lt;spring:message code=&quot;LOGIN&quot; /&gt; &lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 在index.jsp添加如下测试代码,启动查看效果 &lt;a href=&quot;/login?lang=zh_CN&quot;&gt;中文&lt;/a&gt; &lt;br /&gt; &lt;a href=&quot;/login?lang=en_US&quot;&gt;英文&lt;/a&gt; &lt;/body&gt; SpringMVC文件上传文件上传的必要前提 form表单的 enctype取值必须是: multipart/form-data (默认值是:application/x-www-form-urlencoded),enctype:是表单请求正文的类型 method属性取值必须是post 文件上传的原理分析 当form表单的 enctype取值不是默认值后, request.getParameter()将失效,enctype=”application/x-www-form-urlencoded”时,form表单的正文内容是key=value&amp;key=value&amp;key=value 当form表单的 enctype取值为 Mutilpart/form-data时,请求正文内容就变成每一部分都是MIME类型描述的正文:--------------------------------7de1a433602aC 分界符 Content-Disposition: form-data ;name=userName 协议头 aaa 协议的正文 --------------------------------7de1a433602ac Content-Disposition: form-data ;name=&quot;file&quot;; filename= &quot;/Users/sxm\\Desktop\\test.txt&quot; Content-Type: text/plain 协议的类型(MIME类型) bbb bb bbbb bbbbbb bbbb bb bbbb bbbbbbb --------------------------------7de1a433602ac 文件上传的不同情况需要用到的三方依赖包&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; 传统方式文件上传 传统方式的文件上传，指的是我们上传的文件和访问的应用存在于同一台服务器上。并且上传完成之后，浏览器可能跳转。1.采用HttpServletRequest方式，文件上传&lt;form action=&quot;/fileupload1&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; 选择文件：&lt;input type=&quot;file&quot; name=&quot;upload&quot; /&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;上传&quot; /&gt; &lt;/form&gt; @RequestMapping(&quot;/fileupload1&quot;) public String fileuoload1(HttpServletRequest request) throws Exception { System.out.println(&quot;文件上传...&quot;); //判断表单是否支持文件上传 boolean isMultiForm= ServletFileUpload.isMultipartContent(request); if(!isMultiForm) { return &quot;error&quot;; } // 使用fileupload组件完成文件上传 // 上传的位置 String path = request.getSession().getServletContext().getRealPath(&quot;/uploads/&quot;); System.out.println(&quot;保存path:&quot; + path); // 判断，该路径是否存在 File file = new File(path); if(!file.exists()){ // 创建该文件夹 file.mkdirs(); } // 解析request对象，获取上传文件项 DiskFileItemFactory factory = new DiskFileItemFactory(); ServletFileUpload upload = new ServletFileUpload(factory); // 解析request List&lt;FileItem&gt; items = upload.parseRequest(request); // 遍历 for(FileItem item:items){ // 进行判断，当前item对象是否是上传文件项 if(item.isFormField()){ // 说明普通表单向 String fieldName=item.getFieldName();//普通字的字段名 String fieldvalue= item.getString(&quot;UTF-8&quot;);//普通字段的字段值,UTF8编码去取 }else{ // 说明上传文件项 // 获取上传文件的名称 String filename = item.getName(); // 把文件的名称设置唯一值，uuid String uuid = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;); filename = uuid+&quot;_&quot;+filename; // 完成文件上传 item.write(new File(path,filename)); // 删除临时文件 item.delete(); } } return &quot;success&quot;; } 2.采用SpringMVC MultipartFile 方式，文件上传配置文件上传的解析对象&lt;!--配置文件解析器对象--&gt; &lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot; /&gt; &lt;property name=&quot;maxUploadSize&quot; value=&quot;10485760&quot; /&gt; &lt;/bean&gt; &lt;form action=&quot;/fileupload2&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; 选择文件：&lt;input type=&quot;file&quot; name=&quot;upload&quot; /&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;上传&quot; /&gt; &lt;/form&gt; ```java@RequestMapping(“/fileupload2”)public String fileuoload2(HttpServletRequest request, MultipartFile upload) throws Exception { System.out.println(“springmvc文件上传…”); // 使用fileupload组件完成文件上传 // 上传的位置 String path = request.getSession().getServletContext().getRealPath(“/uploads/“); // 判断，该路径是否存在 File file = new File(path); if(!file.exists()){ // 创建该文件夹 file.mkdirs(); } // 说明上传文件项 // 获取上传文件的名称 String filename = upload.getOriginalFilename(); // 把文件的名称设置唯一值，uuid String uuid = UUID.randomUUID().toString().replace(“-“, “”); filename = uuid+”_”+filename; // 完成文件上传 upload.transferTo(new File(path,filename)); return “success”; } #### 跨服务器上传 - 准备另一台服务器，专门做图片服务器，只需要建立一个图片服务器，这里以tomcat举例 修改web.xml ```xml &lt;servlet&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.catalina.servlets.DefaultServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;debug&lt;/param-name&gt; &lt;param-value&gt;0&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;readonly&lt;/param-name&gt;&lt;!--主要设置这个参数--&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;listings&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; 并在tomcat下的webapps下 建立uploads目录，假设端口9090 添加三方jar包&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.sun.jersey&lt;/groupId&gt; &lt;artifactId&gt;jersey-client&lt;/artifactId&gt; &lt;version&gt;1.17.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.sun.jersey&lt;/groupId&gt; &lt;artifactId&gt;jersey-core&lt;/artifactId&gt; &lt;version&gt;1.17.1&lt;/version&gt; &lt;/dependency&gt; &lt;form action=&quot;/fileupload3&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; 选择文件：&lt;input type=&quot;file&quot; name=&quot;upload&quot; /&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;上传&quot; /&gt; &lt;/form&gt; 添加测试 /** * 跨服务器文件上传 * @return */ @RequestMapping(&quot;/fileupload3&quot;) public String fileuoload3(MultipartFile upload) throws Exception { System.out.println(&quot;跨服务器文件上传...&quot;); // 定义上传文件服务器路径 String path = &quot;http://127.0.0.1:9090/uploads/&quot;; // 说明上传文件项 // 获取上传文件的名称 String filename = upload.getOriginalFilename(); // 把文件的名称设置唯一值，uuid String uuid = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;); filename = uuid+&quot;_&quot;+filename; // 创建客户端的对象 Client client = Client.create(); // 和图片服务器进行连接 WebResource webResource = client.resource(path + filename); // 上传文件 webResource.put(upload.getBytes()); return &quot;success&quot;; } SpringMVC中的拦截器 SpringMVC的处理器拦截器类似于Servlet开发中的过滤器Filter,用于对处理器进行预处理和后处理。用户可以自己定义一些拦截器来实现特定的功能。谈到拦截器，还要提一个词一**拦截器链(Interceptor Chain)**。拦截器链就是将拦截器按一定的顺序联结成一条链。在访问被拦截的方法或字段时，拦截器链中的拦截器就会按其之前定义的顺序被调用。 他们的区别: 过滤器是servlet规范中的一部分，任何java web 工程都可以使用。 拦截器是SpringMVC框架自己的，只有使用了SpringMVC 框架的工程才能用。 过滤器在url-pattern中配置了/*之后，可以对所有要访问的资源拦截。 拦截器它是只会拦截访问的控制器方法，如果访问的是jsp, html,css, image或者js是不会进行拦截的。它也是AOP思想的具体应用。 我们要想自定义拦截器，要 求必须实现: HandlerInterceptor 接口。 自定义拦截器Spring MVC也可以使用拦截器对请求进行拦截处理，用户可以自定义拦截器来实现特定的功能，自定义的拦截器必须实现Handlerlnterceptor接口 preHandle() :controller执行前调用此方法，返回true表示继续执行，返回false中止执行，这里可以加入登录校验、权限拦截等 postHandle () :controller执行后但未返回视图前调用此方法，这里可在返回用户前对模型数据进行加工处理，比如这里加入公用信息以便页面显示 afterCompletion () :controller执行后且视图返回后调用此方法，这里可得到执行controller时的异常信息，这里可记录操作日志，资源清理等 针对某种mapping配置拦截器&lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;&gt; &lt;property name=&quot;interceptors&quot;&gt; &lt;list&gt; &lt;ref bean=&quot;handlerInterceptor1&quot;/&gt; &lt;ref bean=&quot;handlerInterceptor2&quot;/&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;handlerInterceptor1&quot; class=&quot;springmvc.intercapter.HandlerInterceptor1&quot;/&gt; &lt;bean id=&quot;handlerInterceptor2&quot; class=&quot;springmvc.intercapter.HandlerInterceptor2&quot;/&gt; 针对所有mapping配置全局拦截器&lt;!--拦截器 --&gt; &lt;mvc:interceptors&gt; &lt;!--多个拦截器,顺序执行 --&gt; &lt;mvc:interceptor&gt; &lt;!--/**表示所有url包括子url路径 --&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;bean class=&quot;cn.ecit.springmvc.filter.HandlerInterceptor1&quot;&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;mvc:interceptor&gt; &lt;!--/**表示所有url包括子url路径 --&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;bean class=&quot;cn.ecit.springmvc.filter.HandlerInterceptor2&quot;&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; 正常的多拦截器执行流程 多拦截器中断流程 拦截器应用–登录拦截public class LoginInterceptor implements HandlerInterceptor{ @Override Public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { //如果是登录页面则放行 if(request.getRequestURI().indexOf(&quot;login.action&quot;)&gt;=0){ return true; } HttpSession session = request.getSession(); //如果用户已登录也放行 if(session.getAttribute(&quot;user&quot;)!=null){ return true; } //用户没有登录挑战到登录页面 request.getRequestDispatcher(&quot;/WEB-INF/jsp/login.jsp&quot;).forward(request, response); return false; } @RequestMapping(&quot;/login&quot;) public String loginsubmit(HttpSession session,String userid,String pwd)throws Exception{ //向session记录用户身份信息 session.setAttribute(&quot;activeUser&quot;, userid); return &quot;redirect:system/email.jsp&quot;; } //退出 @RequestMapping(&quot;/logout&quot;) public String logout(HttpSession session)throws Exception{ //session过期 session.invalidate(); return &quot;redirect:system/ad.jsp&quot;; } 异常处理 Spring MVC通过HandlerExceptionResolver处 理程序的异常，包括Handler映射、数据绑定以及目标方法执行时发生的异常。 SpringMVC提供的HandlerExceptionResolver的实现类 DispatcherServlet默认装配的HandlerExceptionResolver//没有使用&lt;mvc:annotation-driven/&gt;配置: AnnotationMethodHandlerExceptionResolver //这个已过时了 ResponseStatusExceptionResolver DefaultHandlerExceptionResolver //使用&lt;mvc:annotation-driven/&gt;配置时，默认装配 ExceptionHandlerExceptionResolver ResponseStatusExceptionResolver DefaultHandlerExceptionResolver ExceptionHandlerExceptionResolver 主要处理Handler中用@ExceptionHandler注解定义的方法。 @ExceptionHandler注解定义的方法优先级问题:例如发生的是NullPointerException，但是声明的异常有RuntimeException和Exception，此候会根据异常的最近继承关系找到继承深度最浅的那个@ExceptionHandler注解方法，即标记了RuntimeException 的方法 ExceptionHandlerMethodResolver内部若找不到@ExceptionHandler注解的话，会找@ControllerAdvice中 的@ExceptionHandler注解方法 ResponseStatusExceptionResolverHTTP authentication [在异常及异常父类中找到@ResponseStatus 注解，然后使用这个注解的属性进行处理。 定义一个@ResponseStatus注解修饰的异常类. @ResponseStatus (HttpStatus UNAUTHORIZED) public class UnauthorizedException extends RuntimeException { } 若在处理器方法中抛出了上述异常，若ExceptionHandlerExceptionResolver不解析述异常。由于触发的异常UnauthorizedException带有@ResponseStatus注解。因此会被ResponseStatusExceptionResolver 解析到。最后响应HttpStatus.UNAUTHORIZED代码给客户端。HttpStatus.UNAUTHORIZED代表响应码401，无权限。关于其他的响应码请参考HttpStatus枚举类型源码。 DefaultHandlerExceptionResolver 对一些特殊的异常进行处理，比如NoSuchRequestHandlingMethodException、HttpRequestMethodNotSupportedException、HttpMediaTypeNotSupportedException、HttpMediaTypeNotAcceptableException等。会将Spring MVC 框架的异常转为响应的状态码 SimpleMappingExceptionResolver如果希望对所有异常进行统一处理, 可以使用SimpleMappingExceptionResolver,它将异常类名映射为视图名，即发生异常时使用对应的视图报告异常 &lt;bean id=&quot;simpleMappingExceptionResolver&quot; class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt; &lt;property name=&quot;exceptionMappings&quot;&gt; &lt;props&gt; &lt;prop key=&quot;java.lang.ArithmeticException&quot;&gt;error&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; 若Spring的Ioc容器和SpringMVC的Ioc容器扫描的包有重合的部分，就会导致有的bean会被创建2次。 解决:1.使Spring的IOC容器扫描的包和SpringMVC的IOC容器扫描的包没有重合的部分.2.使用exclude-filter和include-filter子节点来规定只能扫描的注解 &lt;context:component-scan base-package=&quot;com.ecit.**&quot; use-default-filters=&quot;false&quot;&gt; &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt; &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.web.bind.annotation.ControllerAdvice&quot;/&gt; &lt;/context:component-scan&gt; SpringMVC的I0C容器中的bean可以来引用Spring IOC容器中的bean。返回来呢?反之则不行。Spring IoC容器中的bean却不能来引用SpringMVC IoC 容器中的Bean","link":"/2016/11/04/framework/spring-mvc/web%E6%A1%86%E6%9E%B6-springmvc/"},{"title":"SpringBoot底层原理分析第九篇--SpringBoot 打包部署","text":"示例: &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.edu.mall.product&lt;/groupId&gt; &lt;artifactId&gt;mall-product&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.4.0.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-x-discovery-server&lt;/artifactId&gt; &lt;version&gt;2.11.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;!-- http://www.mojohaus.org/appassembler/appassembler-maven-plugin/index.html --&gt; &lt;plugin&gt; &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt; &lt;artifactId&gt;appassembler-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.10&lt;/version&gt; &lt;configuration&gt; &lt;!-- 生成linux, windows两种平台的执行脚本 --&gt; &lt;platforms&gt; &lt;platform&gt;windows&lt;/platform&gt; &lt;platform&gt;unix&lt;/platform&gt; &lt;/platforms&gt; &lt;!-- 根目录 --&gt; &lt;assembleDirectory&gt;${project.build.directory}/product&lt;/assembleDirectory&gt; &lt;!-- 打包的jar，以及maven依赖的jar放到这个目录里面 --&gt; &lt;repositoryName&gt;lib&lt;/repositoryName&gt; &lt;!-- 可执行脚本的目录 --&gt; &lt;binFolder&gt;bin&lt;/binFolder&gt; &lt;!-- 配置文件的目标目录 --&gt; &lt;configurationDirectory&gt;conf&lt;/configurationDirectory&gt; &lt;!-- 拷贝配置文件到上面的目录中 --&gt; &lt;copyConfigurationDirectory&gt;true&lt;/copyConfigurationDirectory&gt; &lt;!-- 从哪里拷贝配置文件 (默认src/main/config) --&gt; &lt;configurationSourceDirectory&gt;src/main/resources&lt;/configurationSourceDirectory&gt; &lt;!-- lib目录中jar的存放规则，默认是${groupId}/${artifactId}的目录格式，flat表示直接把jar放到lib目录 --&gt; &lt;repositoryLayout&gt;flat&lt;/repositoryLayout&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;logsDirectory&gt;logs&lt;/logsDirectory&gt; &lt;tempDirectory&gt;tmp&lt;/tempDirectory&gt; &lt;programs&gt; &lt;program&gt; &lt;id&gt;product&lt;/id&gt; &lt;!-- 启动类 --&gt; &lt;mainClass&gt;com.songxm.mall.product.App&lt;/mainClass&gt; &lt;jvmSettings&gt; &lt;extraArguments&gt; &lt;extraArgument&gt;-server&lt;/extraArgument&gt; &lt;extraArgument&gt;-Xmx1G&lt;/extraArgument&gt; &lt;extraArgument&gt;-Xms1G&lt;/extraArgument&gt; &lt;/extraArguments&gt; &lt;/jvmSettings&gt; &lt;/program&gt; &lt;/programs&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt;","link":"/2017/12/10/framework/springboot/springboot%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E7%AC%AC%E4%B9%9D%E7%AF%87/"},{"title":"SpringBoot底层原理分析第二篇--web","text":"web环境搭建&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.4.3.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;groupId&gt;com.songxm&lt;/groupId&gt; &lt;artifactId&gt;learning-springboot&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; jsp环境搭建&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.4.3.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;groupId&gt;com.songxm&lt;/groupId&gt; &lt;artifactId&gt;learning-springboot&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--对jsp的支持 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; application.properties添加配置 spring.mvc.view.prefix=/WEB-INF/jsp spring.mvc.view.suffix=.jsp freemarker环境搭建&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.4.3.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;groupId&gt;com.songxm&lt;/groupId&gt; &lt;artifactId&gt;learning-springboot&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 在resources新建 templates 把ftl文件放下面，templates是freemarker默认的访问路径也可以在application.properties重新制定路径 spring.freemarker.templateLoaderPath=classpath:/ftl 更换web容器为jetty&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.4.3.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;groupId&gt;com.songxm&lt;/groupId&gt; &lt;artifactId&gt;learning-springboot&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 静态资源文件路径springboot默认在 “classpath:/META-INF/resources/“, “classpath:/resources/“,”classpath:/static/“, “classpath:/public/可以在application.properties里修改 spring.resources.staticLocations=classpath:/html/ springboot用servlet api 方法一：（servlet3可以使用这种方法） 1：编写servlet，然后加上相应的注解 2：需要启用@ServletComponentScan注解 方法二：（servlet2.5及以下版本可以使用这种方法） 1：编写servlet 2：装配相应的bean到spring容器中 servlet-&gt;ServletRegistrationBean filter -&gt;FilterRegistrationBean listener -&gt; ServletListenerRegistrationBean 示例: package com.songxm.learning.springboot; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.boot.web.servlet.ServletComponentScan; import org.springframework.context.ConfigurableApplicationContext; @ServletComponentScan @SpringBootApplication public class App { public static void main(String[] args) { ConfigurableApplicationContext context = SpringApplication.run(App.class, args); } } //servlet示例 package com.songxm.learning.springboot; import java.io.IOException; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; @WebServlet(&quot;/user.do&quot;) public class ServletTest extends HttpServlet { protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { resp.getWriter().print(&quot;user servlet&quot;); } } //filter示例 package com.songxm.learning.springboot; import java.io.IOException; import javax.servlet.Filter; import javax.servlet.FilterChain; import javax.servlet.FilterConfig; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import javax.servlet.annotation.WebFilter; @WebFilter(&quot;/user.do&quot;) public class LogFilter implements Filter { public void init(FilterConfig filterConfig) throws ServletException { } public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { System.out.println(&quot;income log filter &quot; + request.getRemoteHost()); chain.doFilter(request, response); } public void destroy() { } } //示例 listener package com.songxm.learning.springboot; import java.time.LocalDateTime; import javax.servlet.ServletContextEvent; import javax.servlet.ServletContextListener; import javax.servlet.annotation.WebListener; @WebListener public class MyContextListener implements ServletContextListener { public void contextInitialized(ServletContextEvent sce) { System.out.println(&quot;app startup at &quot; + LocalDateTime.now().toString()); } public void contextDestroyed(ServletContextEvent sce) { } } SpringBoot使用拦截器 1：写一个拦截器，实现HandlerInterceptor接口 2：写一个类，集成WebMvcConfigurerAdapter抽象类，然后重写addInterceptors方法，并调用registry.addInterceptor把上一步的拦截器加进去 HandlerInterceptor preHandle：controller执行之前调用 postHandle：controller执行之后，且页面渲染之前调用 afterCompletion：页面渲染之后调用，一般用于资源清理操作 示例: package com.songxm.learning.springboot; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import org.springframework.web.servlet.HandlerInterceptor; import org.springframework.web.servlet.ModelAndView; public class LogHandlerInterceptor implements HandlerInterceptor { public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(&quot;==========preHandle==========&quot; + handler.getClass()); return true; } public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(&quot;==========postHandle==========&quot;); } public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(&quot;===========afterCompletion=========&quot;); } } package com.songxm.learning.springboot; import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.config.annotation.InterceptorRegistry; import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter; @Configuration public class WebConfiguration extends WebMvcConfigurerAdapter{ public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new LogHandlerInterceptor()); } } package com.songxm.learning.springboot; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.context.ConfigurableApplicationContext; @SpringBootApplication public class App { public static void main(String[] args) { ConfigurableApplicationContext context = SpringApplication.run(App.class, args); } } package com.songxm.learning.springboot; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class TestController { @RequestMapping(&quot;/test&quot;) public String test() { return &quot;well&quot;; } } //测试 http://127.0.0.1:8080/test 输出: ==========preHandle==========class org.springframework.web.method.HandlerMethod ==========postHandle========== ===========afterCompletion========= springboot异常处理去掉spring boot默认的异常处理逻辑SpringBoot已经把底层tomcat直接在页面抛出的异常信息，进行了简短的处理，如果不想SpringBoot的异常处理逻辑，那就通过下面的手段去掉 @SpringBootApplication(exclude=ErrorMvcAutoConfiguration.class)，这样就可以恢复容器最直接的异常抛到页面示例: package com.songxm.learning.springboot; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration; import org.springframework.context.ConfigurableApplicationContext; @SpringBootApplication(exclude=ErrorMvcAutoConfiguration.class) public class App { public static void main(String[] args) { ConfigurableApplicationContext context = SpringApplication.run(App.class, args); } } 使用ErrorPageRegistrar方法,处理错误写一个类，实现ErrorPageRegistrar接口，然后实现registerErrorPages方法，在该方法里面，添加具体的错误处理逻辑(类似web.xml里面配置错误处理方式) package com.songxm.learning.springboot; import org.springframework.boot.web.servlet.ErrorPage; import org.springframework.boot.web.servlet.ErrorPageRegistrar; import org.springframework.boot.web.servlet.ErrorPageRegistry; import org.springframework.http.HttpStatus; import org.springframework.stereotype.Component; @Component public class CommonErrorPageRegistrar implements ErrorPageRegistrar { @Override public void registerErrorPages(ErrorPageRegistry registry) { ErrorPage e404 = new ErrorPage(HttpStatus.NOT_FOUND, &quot;/404.html&quot;); ErrorPage e500 = new ErrorPage(HttpStatus.INTERNAL_SERVER_ERROR, &quot;/500.html&quot;); ErrorPage args = new ErrorPage(IllegalArgumentException.class, &quot;/args.html&quot;); registry.addErrorPages(e404, e500, args); } } 全局异常处理步骤只对当前controller抛出的异常处理当一个@ExceptionHandler(value=Exception.class) 写在controller的某个方法下，只会处理该controller下的异常示例: package com.songxm.learning.springboot; import java.io.FileNotFoundException; import org.springframework.web.bind.annotation.ExceptionHandler; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class BookController { @ExceptionHandler(value=Exception.class) public String error(Exception e){ return &quot;found exception : &quot; + e.getMessage(); } @GetMapping(&quot;/book/error1&quot;) public String error1() throws FileNotFoundException { throw new FileNotFoundException(&quot;book.txt not found&quot;); } @GetMapping(&quot;/book/error2&quot;) public String error2() throws ClassNotFoundException { throw new ClassNotFoundException(&quot;Book class not found&quot;); } } 对全局异常处理步骤全局异常处理步骤 1：写一个类，需要加上@ControllerAdvice注解 2：写一个异常处理方法，方法上面需要加上@ExceptionHandler(value=Exception.class)这个注解，在该方法里面处理异常 package com.songxm.learning.springboot; import org.springframework.web.bind.annotation.ControllerAdvice; import org.springframework.web.bind.annotation.ExceptionHandler; import org.springframework.web.bind.annotation.ResponseBody; @ControllerAdvice public class GlobalExceptionHandler { @ExceptionHandler(value=Exception.class) @ResponseBody public String errorHandler(Exception e){ return &quot;global error &quot; + e.getClass().getName(); } } Bean装配/** * BeanFactoryPostProcessor在spring容器初始化之后触发，而且只会触发一次， * 触发的时机比BeanPostProcessor早 * @author hadoop * */ @Component public class MyBeanFactoryPostProcessor implements BeanFactoryPostProcessor { public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException { System.out.println(&quot;==============&quot; + beanFactory.getBeanDefinitionCount()); } }","link":"/2017/12/01/framework/springboot/springboot%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E7%AC%AC%E4%BA%8C%E7%AF%87/"},{"title":"SpringBoot底层原理分析第五篇--SpringBoot定制和优化内嵌的tomcat","text":"两种定制tomcat容器的方法1：实现EmbeddedServletContainerCustomizer接口，并把实现类纳入到spring容器中管理2：在spring容器中装配一个EmbeddedServletContainerFactory对象 实现EmbeddedServletContainerCustomizer接口，并把实现类纳入到spring容器中管理package com.songxm.learning.springboot; import java.io.File; import org.apache.catalina.connector.Connector; import org.apache.catalina.valves.AccessLogValve; import org.apache.coyote.http11.Http11NioProtocol; import org.springframework.boot.context.embedded.ConfigurableEmbeddedServletContainer; import org.springframework.boot.context.embedded.EmbeddedServletContainerCustomizer; import org.springframework.boot.context.embedded.tomcat.TomcatConnectorCustomizer; import org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainerFactory; import org.springframework.stereotype.Component; @Component public class MyEmbeddedServletContainerCustomizer implements EmbeddedServletContainerCustomizer { public void customize(ConfigurableEmbeddedServletContainer container) { TomcatEmbeddedServletContainerFactory factory = (TomcatEmbeddedServletContainerFactory)container; factory.setPort(10003); factory.setBaseDirectory(new File(&quot;e:/tmp/tomcat&quot;)); factory.addContextValves(getLogAccessLogValve()); factory.addInitializers((servletContext) -&gt; { System.out.println(&quot;=========servletContext startup==========&quot;); }); factory.addConnectorCustomizers(new MyTomcatConnectorCustomizer()); } private AccessLogValve getLogAccessLogValve(){ AccessLogValve log = new AccessLogValve(); // log.setDirectory(&quot;e:/tmp/logs&quot;); log.setEnabled(true); log.setPattern(&quot;%h %l %u %t \\&quot;%r\\&quot; %s %b&quot;); log.setPrefix(&quot;springboot-access-log&quot;); log.setSuffix(&quot;.txt&quot;); return log; } } class MyTomcatConnectorCustomizer implements TomcatConnectorCustomizer { public void customize(Connector connector) { Http11NioProtocol protocol = (Http11NioProtocol)connector.getProtocolHandler(); protocol.setMaxConnections(2000);//设置最大连接数 protocol.setMaxThreads(500);//设置最大的线程数 } } 在spring容器中装配一个EmbeddedServletContainerFactory对象package com.songxm.learning.springboot; import org.apache.catalina.valves.AccessLogValve; import org.springframework.boot.SpringBootConfiguration; import org.springframework.boot.context.embedded.EmbeddedServletContainerFactory; import org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainerFactory; import org.springframework.boot.web.servlet.ErrorPage; import org.springframework.context.annotation.Bean; import org.springframework.http.HttpStatus; @SpringBootConfiguration public class WebServerConfiguration { @Bean public EmbeddedServletContainerFactory createEmbeddedServletContainerFactory(){ TomcatEmbeddedServletContainerFactory factory = new TomcatEmbeddedServletContainerFactory(); factory.setPort(10008); factory.addErrorPages(new ErrorPage(HttpStatus.NOT_FOUND, &quot;/404.html&quot;)); factory.addInitializers((servletContext) -&gt; { System.out.println(&quot;=========servletContext startup==========&quot;); servletContext.setAttribute(&quot;startup&quot;, &quot;true&quot;); }); factory.addContextValves(getLogAccessLogValve()); return factory; } private AccessLogValve getLogAccessLogValve(){ AccessLogValve log = new AccessLogValve(); log.setDirectory(&quot;e:/tmp/logs&quot;); log.setEnabled(true); log.setPattern(&quot;%h %l %u %t \\&quot;%r\\&quot; %s %b&quot;); log.setPrefix(&quot;springboot-access-log&quot;); log.setSuffix(&quot;.txt&quot;); return log; } }","link":"/2017/12/05/framework/springboot/springboot%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E7%AC%AC%E4%BA%94%E7%AF%87/"},{"title":"SpringBoot底层原理分析第八篇--SpringBoot 监控和度量","text":"添加度量依赖&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.4.3.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;groupId&gt;com.songxm&lt;/groupId&gt; &lt;artifactId&gt;learning-springboot&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 自定义健康状态监测，实现HealthIndicator接口，并纳入到spring容器的管理之中import org.springframework.boot.actuate.health.Health; import org.springframework.boot.actuate.health.HealthIndicator; import org.springframework.stereotype.Component; @Component public class MyHealthIndicator implements HealthIndicator { public Health health() { return Health.up().withDetail(&quot;error&quot;, &quot;spring boot error&quot;).build(); } } CounterService用来计数的服务，可以直接使用GaugeService用来统计某个值，可以直接使用import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.actuate.metrics.CounterService; import org.springframework.boot.actuate.metrics.GaugeService; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController; @RestController public class UserController { @Autowired private CounterService counterService; @Autowired private GaugeService gaugeService; @GetMapping(&quot;/user/home&quot;) public String home(@RequestParam(&quot;error&quot;) String error){ if(&quot;true&quot;.equals(error)){ throw new NullPointerException(); } counterService.increment(&quot;user.home.request.count&quot;); return &quot;home&quot;; } @GetMapping(&quot;/mp3/price&quot;) public String price(@RequestParam(&quot;name&quot;) double price){ gaugeService.submit(&quot;product.mp3.price&quot;, price); return &quot;mp3 price&quot;; } } Metric不仅可以输出到页面，还可以输出到jmx，redis等地方通过向spring容器中装配一个MetricWriter来实现定向输出import org.springframework.boot.actuate.autoconfigure.ExportMetricWriter; import org.springframework.boot.actuate.metrics.jmx.JmxMetricWriter; import org.springframework.boot.actuate.metrics.writer.MetricWriter; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.jmx.export.MBeanExporter; @Configuration public class ExportConfiguration { @Bean @ExportMetricWriter public MetricWriter createMetricWriter(MBeanExporter exporter){ return new JmxMetricWriter(exporter); } } JDK的工具来查看监控数据 jconsole, jmc, jvisualvm（需要单独安装插件）等等","link":"/2017/12/10/framework/springboot/springboot%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E7%AC%AC%E5%85%AB%E7%AF%87/"},{"title":"SpringBoot底层原理分析第六篇--SpringBoot 下jdbc","text":"依赖添加&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.4.3.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;groupId&gt;com.songxm&lt;/groupId&gt; &lt;artifactId&gt;learning-springboot&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.25&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; application.propertiesspring.datasource.driverClassName=com.mysql.jdbc.Driver spring.datasource.url=jdbc:mysql://127.0.0.1:3306/springboot spring.datasource.username=root spring.datasource.password=admin123 spring.datasource.type=com.zaxxer.hikari.HikariDataSource DataSource装配import javax.sql.DataSource; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.SpringBootConfiguration; import org.springframework.context.annotation.Bean; import org.springframework.core.env.Environment; import com.alibaba.druid.pool.DruidDataSource; @SpringBootConfiguration public class DBConfiguration { @Autowired private Environment env; @Bean public DataSource createDataSource(){ DruidDataSource ds = new DruidDataSource(); ds.setUrl(env.getProperty(&quot;spring.datasource.url&quot;)); ds.setUsername(env.getProperty(&quot;spring.datasource.username&quot;)); ds.setPassword(env.getProperty(&quot;spring.datasource.password&quot;)); ds.setDriverClassName(env.getProperty(&quot;spring.datasource.driverClassName&quot;)); return ds; } } DAO装配import org.springframework.beans.factory.annotation.Autowired; import org.springframework.jdbc.core.JdbcTemplate; import org.springframework.stereotype.Repository; import org.springframework.transaction.annotation.Transactional; @Repository public class ProductDao { @Autowired private JdbcTemplate jdbcTemplate; public void addProduct(String name){ String sql = &quot;insert into product (pname)values('&quot;+name+&quot;')&quot;; jdbcTemplate.execute(sql); } /** * rollbackFor 设置对哪些异常进行回滚，默认是运行时异常 * noRollbackFor 设置哪些异常不回滚 */ @Transactional() public void addProductBatch(String ... names) throws Exception { add(names); } @Transactional() public void add(String ... names){ for(String name : names){ String sql = &quot;insert into product (pname)values('&quot;+name+&quot;')&quot;; jdbcTemplate.execute(sql); if(&quot;&quot;.equals(&quot;&quot;)){ throw new NullPointerException(); } } } } app启动import javax.sql.DataSource; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.context.ConfigurableApplicationContext; import org.springframework.transaction.annotation.EnableTransactionManagement; /** * 装配DataSource的步骤 * 1：加入数据库驱动 * 2：配置 * spring.datasource.driverClassName= spring.datasource.url= spring.datasource.username= spring.datasource.password= 以上操作，springboot会自动装配好DataSource、JdbcTemplate，可以直接使用 spring.datasource.type可以指定具体使用哪种数据源 默认支持tomcat-jdbc，Hikari，dbcp，dbcp2 配置自己的DataSource 只需要装配一个DataSource到spring容器中即可 事务： 首先要使用@EnableTransactionManagement启用对事务的支持 然后，在需要使用事务的方法上面加上@Transactional 注意，默认只会对运行时异常进行事务回滚，非运行时异常不会回滚事务 * */ @SpringBootApplication @EnableTransactionManagement public class App { public static void main(String[] args) throws Exception { ConfigurableApplicationContext context = SpringApplication.run(App.class, args); DataSource ds = context.getBean(DataSource.class); // Connection conn = ds.getConnection(); // System.out.println(conn.getCatalog()); // conn.close(); context.getBean(ProductDao.class).addProductBatch(&quot;TV&quot;,&quot;MP3&quot;,&quot;MP4&quot;); System.out.println(ds.getClass()); } }","link":"/2017/12/08/framework/springboot/springboot%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E7%AC%AC%E5%85%AD%E7%AF%87/"},{"title":"SpringBoot底层原理分析第四篇--SpringBoot扩展特性","text":"springboot其他特性1. @EnableConfigurationProperties 是用来启用一个特性的，这个特性就是，可以把配置文件的属性注入到bean里面去，一般是要和@ConfigurationProperties一起使用 2. @EnableAsync 启用异步，一般是和@Async一起使用 3. @Import用来导入一个或多个类（会被spring容器托管），或者配置类(配置类里面的bean都会被spring容器托管) @Import({User.class, Role.class, MyConfiguration.class}) 4. @EnableAutoConfiguration 作用：从classpath中搜索所有META-INF/spring.factories配置文件,然后，将其中org.springframework.boot.autoconfigure.EnableAutoConfiguration key对应的配置项加载到spring容器,只有spring.boot.enableautoconfiguration为true（默认为true）的时候，才启用自动配置, @EnableAutoConfiguration还可以进行排除，排除方式有2中，一是根据class来排除（exclude），二是根据class name（excludeName）来排除 其内部实现的关键点有 1：ImportSelector 该接口的方法的返回值都会被纳入到spring容器管理中 2：SpringFactoriesLoader 该类可以从classpath中搜索所有META-INF/spring.factories配置文件，并读取配置 /** * ApplicationContextInitializer 接口是在spring容器执行refreshed之前的一个回调 * 使用步骤： * 1：写一个类，实现ApplicationContextInitializer接口 * 2：注册ApplicationContextInitializer * * 注册方法： * 1：SpringApplication.addInitializers * 2：通过配置项 context.initializer.classes 指定，可以指定多个，多个用逗号隔开 * 3：可以通过spring.factories机制（注册listener监听器也可以使用这种方式） * * * * CommandLineRunner、ApplicationRunner 接口是在容器启动成功后的最后一步回调（类似开机自启动） * 使用步骤： * 1：写一个类，实现CommandLineRunner接口 * 2：把该类纳入到spring容器的管理之中 * 注意：可以通过@Order注解或者Ordered接口来控制执行顺序。 * * CommandLineRunner， ApplicationRunner 区别 * 区别在于方法的参数不一样 * CommandLineRunner的参数是最原始的参数，没有做任何处理 * ApplicationRunner的参数是ApplicationArguments，是对原始参数做了进一步的封装 * * ApplicationArguments是对参数（main方法）做了进一步的处理 * 可以解析--name=value的，我们就可以通过name来获取value */ import java.time.LocalDateTime; import org.springframework.boot.CommandLineRunner; import org.springframework.core.annotation.Order; import org.springframework.stereotype.Component; @Order(3) @Component public class ServerStartedReport implements CommandLineRunner { public void run(String... args) throws Exception { System.out.println(&quot;===========应用启动后的时间是：&quot; + LocalDateTime.now().toString()); } } import java.util.Arrays; import org.springframework.boot.ApplicationArguments; import org.springframework.boot.ApplicationRunner; import org.springframework.stereotype.Component; @Component public class StartedApplicationRunner implements ApplicationRunner { public void run(ApplicationArguments args) throws Exception { System.out.println(&quot;应用已经启动，参数为：&quot; + Arrays.asList(args.getSourceArgs())); } } 补充import java.util.HashMap; import java.util.Map; import org.springframework.beans.factory.annotation.Value; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.context.ConfigurableApplicationContext; /** * @SpringBootApplication 默认扫描的包的路径是当前包以及子包下面的所有类，可以通过scanBasePackages修改这个扫描包的路径 * * 排除指定的类、配置类 * exclude 根据class来排除 * excludeName 根据class name来排除 * * ---------------------- * SpringApplication.setBannerMode(Banner.Mode.OFF);关闭输出banner * 子定义banner方法 * 在classpath下放一个banner.txt的文件即可 * banner.location 配置项用来指定文字banner的文件路径 * banner.charset 配置项用来指定banner的编码，默认UTF-8 * * springboot支持图片的banner，图片格式支持jpg，png，gif * banner.image.location 配置项用来指定图片banner的文件路径 * * ---------------------- * SpringApplication.setDefaultProperties(Map&lt;String, Object&gt; defaultProperties) * SpringApplication.setDefaultProperties(Properties defaultProperties) * 给配置项指定默认值 */ @SpringBootApplication(scanBasePackages=&quot;com.songxm.spring&quot;, excludeName=&quot;org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration&quot;) public class App { @Value(&quot;${server.host:localhost}&quot;) private String serverHost; public static void main(String[] args) { SpringApplication app = new SpringApplication(App.class); Map&lt;String, Object&gt; defaultProperties = new HashMap&lt;&gt;(); defaultProperties.put(&quot;server.host&quot;, &quot;192.168.1.100&quot;); app.setDefaultProperties(defaultProperties); // app.setBannerMode(Banner.Mode.OFF); ConfigurableApplicationContext context = app.run(args); System.out.println(context.getBean(Runnable.class)); System.out.println(context.getEnvironment().getProperty(&quot;server.host&quot;, &quot;aaa&quot;)); System.out.println(context.getBean(App.class).serverHost); context.close(); } } springboot运行流程/** * 运行流程： * 1：判断是否是web环境 * 2：加载所有classpath下面的META-INF/spring.factories ApplicationContextInitializer * 3：加载所有classpath下面的META-INF/spring.factories ApplicationListener * 4：推断main方法所在的类 * 5：开始执行run方法 * 6：设置java.awt.headless系统变量 * 7：加载所有classpath下面的META-INF/spring.factories SpringApplicationRunListener * 8：执行所有SpringApplicationRunListener的started方法 * 9：实例化ApplicationArguments对象 * 10：创建environment * 11：配置environment，主要是把run方法的参数配置到environment * 12：执行所有SpringApplicationRunListener的environmentPrepared方法 * 13：如果不是web环境，但是是web的environment，则把这个web的environment转换成标准的environment * 14：打印Banner * 15：初始化applicationContext, 如果是web环境，则实例化AnnotationConfigEmbeddedWebApplicationContext对象，否则实例化AnnotationConfigApplicationContext对象 * 16：如果beanNameGenerator不为空，就把beanNameGenerator对象注入到context里面去 * 17：回调所有的ApplicationContextInitializer方法 * 18：执行所有SpringApplicationRunListener的contextPrepared方法 * 19：依次往spring容器中注入：ApplicationArguments，Banner * 20：加载所有的源到context里面去 * 21：执行所有SpringApplicationRunListener的contextLoaded方法 * 22：执行context的refresh方法，并且调用context的registerShutdownHook方法（这一步执行完成之后，spring容器就完全初始化好了） * 23：回调，获取容器中所有的ApplicationRunner、CommandLineRunner接口，然后排序，依次调用 * 24：执行所有SpringApplicationRunListener的finished方法 */ 有条件的装配 @Conditional 基于条件的自动配置，一般配合Condition接口一起使用，只有接口（一个或多个）的实现类都返回true，才装配，否则不装配,它可以用在方法上面，则只对该方法起作用。还可以用在类上面，则对该类下面的所有方法起作用 import org.springframework.boot.SpringBootConfiguration; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Conditional; /** * @Conditional 基于条件的自动配置，一般配合Condition接口一起使用，只有接口（一个或多个）的实现类都返回true，才装配，否则不装配 * 它可以用在方法上面，则只对该方法起作用。还可以用在类上面，则对该类下面的所有方法起作用 */ @SpringBootConfiguration @Conditional({UTF8Condition.class}) public class EncodingConvertConfiguration { @Bean // @Conditional(UTF8Condition.class) public EncodingConvert createUTF8EncodingConvert(){ return new UTF8EncodingConvert(); } @Bean // @Conditional(GBKCondition.class) public EncodingConvert createGBKEncodingConvert(){ return new GBKEncodingConvert(); } } import org.springframework.context.annotation.Condition; import org.springframework.context.annotation.ConditionContext; import org.springframework.core.type.AnnotatedTypeMetadata; public class UTF8Condition implements Condition { public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) { String encoding = System.getProperty(&quot;file.encoding&quot;); if(encoding != null){ return &quot;utf-8&quot;.equals(encoding.toLowerCase()); } return false; } } public class UTF8EncodingConvert implements EncodingConvert { } import org.springframework.context.annotation.Condition; import org.springframework.context.annotation.ConditionContext; import org.springframework.core.type.AnnotatedTypeMetadata; public class GBKCondition implements Condition { public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) { String encoding = System.getProperty(&quot;file.encoding&quot;); if(encoding != null){ return &quot;gbk&quot;.equals(encoding.toLowerCase()); } return false; } } public class GBKEncodingConvert implements EncodingConvert { } springboot测试集成 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; springboot测试步骤 直接在测试类上面加上如下2个注解 @RunWith(SpringRunner.class) @SpringBootTest import org.springframework.boot.test.context.TestConfiguration; import org.springframework.context.annotation.Bean; /** * 只在测试环境下有效 * 测试环境下，只能用@TestConfiguration，不能用@Configuration */ @TestConfiguration public class TestBeanConfiguration { @Bean public Runnable createRunable(){ return () -&gt; {}; } } import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.context.ApplicationContext; import org.springframework.test.context.junit4.SpringRunner; import com.edu.spring.springboot.bean.User; import org.junit.Assert; @RunWith(SpringRunner.class) @SpringBootTest(classes=TestBeanConfiguration.class) public class ApplicationContextTest { @Autowired private ApplicationContext context; @Test public void testNull(){ Assert.assertNotNull(context.getBean(User.class)); Assert.assertNotNull(context.getBean(Runnable.class)); } } import org.junit.Assert; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.boot.test.util.EnvironmentTestUtils; import org.springframework.core.env.ConfigurableEnvironment; import org.springframework.test.context.junit4.SpringRunner; /** * springboot会优先加载测试环境下的配置文件（application.properties） * 测试环境下没有才会加载正式环境下的配置文件 */ @RunWith(SpringRunner.class) @SpringBootTest(properties={&quot;app.version=1.0.0&quot;}) public class EnvTest { @Autowired private ConfigurableEnvironment env; @Before public void init(){ EnvironmentTestUtils.addEnvironment(env, &quot;app.admin.name=admin&quot;); EnvironmentTestUtils.addEnvironment(env, &quot;app.admin.enable=true&quot;); } @Test public void testValue(){ Assert.assertEquals(&quot;springboottest&quot;, env.getProperty(&quot;app.name&quot;)); Assert.assertEquals(&quot;1.0.0&quot;, env.getProperty(&quot;app.version&quot;)); Assert.assertEquals(&quot;admin&quot;, env.getProperty(&quot;app.admin.name&quot;)); Assert.assertEquals(&quot;true&quot;, env.getProperty(&quot;app.admin.enable&quot;)); } } controller测试import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.boot.test.context.SpringBootTest.WebEnvironment; import org.springframework.boot.test.web.client.TestRestTemplate; import org.springframework.test.context.junit4.SpringRunner; import org.junit.Assert; /** * TestRestTemplate 需要运行在web环境中 * @SpringBootTest 会加载整个spring容器 * */ @RunWith(SpringRunner.class) @SpringBootTest(webEnvironment=WebEnvironment.RANDOM_PORT) public class BookControllerTest { @Autowired private TestRestTemplate restTemplate; @Test public void testHome() { String content = restTemplate.getForObject(&quot;/book/home&quot;, String.class); Assert.assertEquals(&quot;bookhome&quot;, content); } @Test public void testShow() { String content = restTemplate.getForObject(&quot;/book/show?id=100&quot;, String.class); Assert.assertEquals(&quot;book100&quot;, content); } } import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest; import org.springframework.test.context.junit4.SpringRunner; import org.springframework.test.web.servlet.MockMvc; import org.springframework.test.web.servlet.request.MockMvcRequestBuilders; import org.springframework.test.web.servlet.result.MockMvcResultMatchers; /** * @WebMvcTest 不需要运行在web环境下，但是，需要指定controllers，表示需要测试哪些controllers * 这种方式只测试controller，controller里面的一些依赖，需要你自己去mock * @WebMvcTest 不会加载整个spring容器 */ @RunWith(SpringRunner.class) @WebMvcTest(controllers=BookController.class) public class BookControllerTest2 { @Autowired private MockMvc mvc; @Test public void testHome() throws Exception { mvc.perform(MockMvcRequestBuilders.get(&quot;/book/home&quot;)).andExpect(MockMvcResultMatchers.status().isOk()); mvc.perform(MockMvcRequestBuilders.get(&quot;/book/home&quot;)).andExpect(MockMvcResultMatchers.status().isOk()).andExpect(MockMvcResultMatchers.content().string(&quot;bookhome&quot;)); } @Test public void testShow() throws Exception { mvc.perform(MockMvcRequestBuilders.get(&quot;/book/show&quot;).param(&quot;id&quot;, &quot;400&quot;)).andExpect(MockMvcResultMatchers.status().isOk()); mvc.perform(MockMvcRequestBuilders.get(&quot;/book/show&quot;).param(&quot;id&quot;, &quot;400&quot;)).andExpect(MockMvcResultMatchers.status().isOk()).andExpect(MockMvcResultMatchers.content().string(&quot;book400&quot;)); } } import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.junit4.SpringRunner; import org.springframework.test.web.servlet.MockMvc; import org.springframework.test.web.servlet.request.MockMvcRequestBuilders; import org.springframework.test.web.servlet.result.MockMvcResultMatchers; /** * @SpringBootTest 不能和 @WebMvcTest 同时使用 * 如果使用MockMvc对象的话，需要另外加上@AutoConfigureMockMvc注解 */ @RunWith(SpringRunner.class) @SpringBootTest() @AutoConfigureMockMvc public class BookControllerTest3 { @Autowired private MockMvc mvc; @Test public void testHome() throws Exception { mvc.perform(MockMvcRequestBuilders.get(&quot;/book/home&quot;)).andExpect(MockMvcResultMatchers.status().isOk()); mvc.perform(MockMvcRequestBuilders.get(&quot;/book/home&quot;)).andExpect(MockMvcResultMatchers.status().isOk()).andExpect(MockMvcResultMatchers.content().string(&quot;bookhome&quot;)); } @Test public void testShow() throws Exception { mvc.perform(MockMvcRequestBuilders.get(&quot;/book/show&quot;).param(&quot;id&quot;, &quot;400&quot;)).andExpect(MockMvcResultMatchers.status().isOk()); mvc.perform(MockMvcRequestBuilders.get(&quot;/book/show&quot;).param(&quot;id&quot;, &quot;400&quot;)).andExpect(MockMvcResultMatchers.status().isOk()).andExpect(MockMvcResultMatchers.content().string(&quot;book400&quot;)); } } dao测试import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.junit4.SpringRunner; import org.junit.Assert; @RunWith(SpringRunner.class) @SpringBootTest public class UserDaoTest { @Autowired private UserDao userDao; @Test public void testAddUser() { Assert.assertEquals(Integer.valueOf(1), userDao.addUser(&quot;root&quot;)); Assert.assertEquals(Integer.valueOf(0), userDao.addUser(null)); } } import org.junit.Test; import org.junit.runner.RunWith; import org.mockito.BDDMockito; import org.springframework.boot.test.mock.mockito.MockBean; import org.springframework.test.context.junit4.SpringRunner; import org.junit.Assert; import org.junit.Before; @RunWith(SpringRunner.class) public class UserMapperTest { @MockBean private UserMapper userMapper; @Before public void init(){ BDDMockito.given(userMapper.createUser(&quot;admin&quot;)).willReturn(Integer.valueOf(1)); BDDMockito.given(userMapper.createUser(&quot;&quot;)).willReturn(Integer.valueOf(0)); BDDMockito.given(userMapper.createUser(null)).willThrow(NullPointerException.class); } @Test(expected=NullPointerException.class) public void testCreateUser() { Assert.assertEquals(Integer.valueOf(1), userMapper.createUser(&quot;admin&quot;)); Assert.assertEquals(Integer.valueOf(0), userMapper.createUser(&quot;&quot;)); Assert.assertEquals(Integer.valueOf(0), userMapper.createUser(null)); } }","link":"/2017/12/04/framework/springboot/springboot%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E7%AC%AC%E5%9B%9B%E7%AF%87/"},{"title":"SpringBoot深度研究","text":"","link":"/2017/12/19/framework/springboot/springboot%E6%B7%B1%E5%BA%A6%E7%A0%94%E7%A9%B6/"},{"title":"SpringBoot父工程pom骨架整理","text":"父工程的pom骨架示例&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.songxm&lt;/groupId&gt; &lt;artifactId&gt;microboot&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;name&gt;microboot&lt;/name&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.8.RELEASE&lt;/version&gt; &lt;relativePath /&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;1.5.8.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt;&lt;!-- type+scope属性解决子模块提示找不到版本的bug --&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;finalName&gt;microboot&lt;/finalName&gt; &lt;plugins&gt; &lt;!-- springboot插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;!-- 上面是springboot的插件，下面是maven的插件，任选其一即可 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;${java.version}&lt;/source&gt; &lt;target&gt;${java.version}&lt;/target&gt; &lt;encoding&gt;${project.build.sourceEncoding}&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;modules&gt; &lt;module&gt;microboot-base&lt;/module&gt; &lt;/modules&gt; &lt;/project&gt; model与父工程关系-最简单的web，新建立一个子model&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.songxm&lt;/groupId&gt; &lt;artifactId&gt;microboot&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;microboot-base&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!-- springboot 的web启动依赖包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- springboot 标准测试依赖下面两个 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; web控制器示例 package com.songxm.microboot; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.EnableAutoConfiguration; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.ResponseBody; @Controller @EnableAutoConfiguration public class App { @RequestMapping(&quot;/&quot;) @ResponseBody public String hello() { return &quot;hello&quot;; } public static void main(String[] args) { SpringApplication.run(App.class, args); } } SpringBoot标准测试示例 package com.songxm.microboot.test; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; import org.springframework.test.context.web.WebAppConfiguration; import com.songxm.microboot.App; import junit.framework.TestCase; /** * @author sxm */ @SpringBootTest(classes=App.class) @RunWith(SpringJUnit4ClassRunner.class) @WebAppConfiguration public class TestApp { @Autowired App app; @Test public void testHello() { TestCase.assertEquals(&quot;hello&quot;, this.app.hello()); } } SpringBoot父工程打包插件模板&lt;build&gt; &lt;finalName&gt;${artifactId}&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;${jdk.version}&lt;/source&gt;&lt;!-- 源代码使用的开发版本 --&gt; &lt;target&gt;${jdk.version}&lt;/target&gt;&lt;!-- 需要生成的目标class文件的编译版本 --&gt; &lt;encoding&gt;${project.build.sourceEncoding}&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;!-- 该插件的主要功能是进行项目的打包发布处理 --&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;!-- 设置程序执行的主类 --&gt; &lt;mainClass&gt;com.songxm.microboot.AppStartSpringBootMain&lt;/mainClass&gt;&lt;!--每个子模块就不需要配置打包插件，直接沿用父pom里的--&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; profiles配置多环境application.yml配置格式spring: profiles: active: beta --- spring: profiles: dev server: port: 8080 --- spring: profiles: beta server: port: 9090 --- spring: profiles: product server: port: 80 application.properties配置格式 需要在resources目录下同时建立如下几个配置文件 (application-prod.properties, application-dev.properties, application-test.properties)，通过在application.properties中设置 spring.profiles.active=prod 来指定活动的profilespring.profiles.active=prod SpringBoot的 web开发依赖jar包 &lt;!-- springboot 的web启动依赖包 内嵌默认tomcat--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;","link":"/2016/11/04/framework/springboot/springboot%E7%88%B6%E5%B7%A5%E7%A8%8Bpom%E9%AA%A8%E6%9E%B6/"},{"title":"SpringCloud研究一 微服务了解","text":"总览 对比 适合走微服务？ 服务拆分 SpringCloud的两种 restful调用方式 RestTemplate Feign 多模块设计（SAAS信贷） 统一配置中心 bootstrap上下文 @SpringBootApplication public class App { public static void main(String[] args) throws Exception { // ConfigurableApplicationContext context = SpringApplication.run(App.class, // args); AnnotationConfigApplicationContext contxt = new AnnotationConfigApplicationContext(); contxt.addApplicationListener(new MyListener()); contxt.refresh(); contxt.publishEvent(new MyEvent(new String(&quot;hello event test&quot;))); } } class MyEvent extends ApplicationEvent { public MyEvent(Object source) { super(source); System.out.println(&quot;产生事件&quot; + source); } } class MyListener implements ApplicationListener&lt;MyEvent&gt; { @Override public void onApplicationEvent(MyEvent event) { System.out.println(&quot;监听器接收到事件:&quot; + event.getSource()); } } 输出以下内容： 产生事件hello event test 监听器接收到事件:hello event test SpringApplication SpringBoot事件 Actuator","link":"/2017/12/05/framework/springcloud/springcloud/"},{"title":"SpringCloud--配置客户端","text":"总览 spring environment spring profile spring properties","link":"/2017/12/07/framework/springcloud/springcloud%E9%85%8D%E7%BD%AE%E5%AE%A2%E6%88%B7%E7%AB%AF/"},{"title":"JSP基础语法--JSP内置对象response对象","text":"response对象response对象的主要作用是用于对客户端的请求进行回应，将WEB服务器处理后的结果发回给客户端。response对象属于javax.servlet.http.HttpServletResponse接口的实例。 response对象的常用方法 设置刷新头信息直接使用setHeader()方法，将头信息名称设置为refresh,同时指定刷新的时间。 示例&lt;%@ page contentType=&quot;text/html&quot; pageEncoding=&quot;GBK&quot;%&gt; &lt;html&gt; &lt;head&gt;&lt;title&gt;请求头信息&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;%! // 定义全局变量 int count = 0 ; %&gt; &lt;% response.setHeader(&quot;refresh&quot;,&quot;2&quot;) ; // 页面2秒一刷新 %&gt; &lt;h3&gt;已经访问了&lt;%=count++%&gt;次！&lt;/h3&gt; &lt;/body&gt; &lt;/html&gt; 刷新并跳转别的页面&lt;%@ page contentType=&quot;text/html&quot; pageEncoding=&quot;GBK&quot;%&gt; &lt;html&gt; &lt;head&gt;&lt;title&gt;刷新并跳转别的页面&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;h3&gt;3秒后跳转到hello.htm页面，如果没有跳转请按&lt;a href=&quot;hello.htm&quot;&gt;这里&lt;/a&gt;！&lt;/h3&gt; &lt;% response.setHeader(&quot;refresh&quot;,&quot;3;URL=hello.htm&quot;) ; // 3秒后跳转到hello.htm页面 %&gt; &lt;/body&gt; &lt;/html&gt; 刷新的HTML指令&lt;META HTTP-EQUIV=&quot;refresh&quot; CONTENT=&quot;3;URL=hello.htm&quot; /&gt; 示例&lt;html&gt; &lt;head&gt;&lt;title&gt;w刷新的HTML指令&lt;/title&gt;&lt;/head&gt; &lt;META HTTP-EQUIV=&quot;refresh&quot; CONTENT=&quot;3;URL=hello.htm&quot;&gt; &lt;body&gt; &lt;h3&gt;3秒后跳转到hello.htm页面，如果没有跳转请按&lt;a href=&quot;hello.htm&quot;&gt;这里&lt;/a&gt;！&lt;/h3&gt; &lt;/body&gt; &lt;/html&gt; 页面跳转在JSP中除了可以通过头信息的方式完成跳转，也可以使用response对象的sendRedirect()方法直接完成页面的跳转。两种跳转的区别 jsp:forward属于服务器跳转，跳转之后地址栏的信息并不会有任何的改变，而response.sendRedirect()属于客户端跳转，跳转之后地址栏会改变， 在使用request范围属性的时候，只有服务器跳转才能将request属性保存到跳转页，而如果是客户端跳转，则无法进行属性的传递。 如果使用的是服务器端跳转的话，则执行到跳转语句之后会立刻进行跳转，如果使用的客户端跳转，则是在整个页面执行完之后才能执行跳转。Cookie常用API设置cookie示例:&lt;%@ page contentType=&quot;text/html&quot; pageEncoding=&quot;GBK&quot;%&gt; &lt;html&gt; &lt;head&gt;&lt;title&gt;添加cookie&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;% Cookie c1 = new Cookie(&quot;lxh&quot;,&quot;LiXingHua&quot;) ; Cookie c2 = new Cookie(&quot;mldn&quot;,&quot;www.MLDNJAVA.cn&quot;) ; c1.setMaxAge(100) ; //100秒 过期 c2.setMaxAge(100) ; response.addCookie(c1) ; response.addCookie(c2) ; %&gt; &lt;/body&gt; &lt;/html&gt; 取出cookie&lt;%@ page contentType=&quot;text/html&quot; pageEncoding=&quot;GBK&quot;%&gt; &lt;html&gt; &lt;head&gt;&lt;title&gt;取出cookie&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;% Cookie c[] = request.getCookies() ; // 取得客户端的全部Cookie System.out.println(c) ; for(int x=0;x&lt;c.length;x++){ %&gt; &lt;h3&gt;&lt;%=c[x].getName()%&gt; --&gt; &lt;%=c[x].getValue()%&gt;&lt;/h3&gt; &lt;% } %&gt; &lt;/body&gt; &lt;/html&gt;","link":"/2014/10/14/javaee/jsp-servlet/JSP%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1response%E5%AF%B9%E8%B1%A1/"},{"title":"JSP基础语法--JSP内置对象request对象","text":"request内置对象的常用API 乱码解决由于浏览器默认的编码是UTF-8编码，而中文的GBK和UTF-8的编码是不一样的，所以在进行表单提交时造成了乱码。解决方法: setCharacterEncoding() &lt;%@ page contentType=&quot;text/html&quot; pageEncoding=&quot;GBK&quot;%&gt; &lt;html&gt; &lt;head&gt;&lt;title&gt;编码测试&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;% request.setCharacterEncoding(&quot;GBK&quot;) ;// 设置统一编码 //String content = new // String(request.getParameter(&quot;info&quot;).getBytes(&quot;ISO8859-1&quot;)) ; String content = request.getParameter(&quot;info&quot;) ; //接收表单参数 %&gt; &lt;h2&gt;&lt;%=content%&gt;&lt;/h2&gt; &lt;/body&gt; &lt;/html&gt; 接收参数request内置对象的getParameter()方法可以接收一个表单的文本框中输入的内容，如果有一组参数(同名参数)传递的话，则就必须使用getParameterValues()方法进行接收。示例: &lt;html&gt; &lt;head&gt;&lt;title&gt;request内置对象接受参数测试&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;form action=&quot;request_demo02.jsp&quot; method=&quot;post&quot;&gt; 姓名： &lt;input type=&quot;text&quot; name=&quot;uname&quot;&gt;&lt;br&gt; 兴趣： &lt;input type=&quot;checkbox&quot; name=&quot;inst&quot; value=&quot;唱歌&quot;&gt;唱歌 &lt;input type=&quot;checkbox&quot; name=&quot;inst&quot; value=&quot;跳舞&quot;&gt;跳舞 &lt;input type=&quot;checkbox&quot; name=&quot;inst&quot; value=&quot;游泳&quot;&gt;游泳 &lt;input type=&quot;checkbox&quot; name=&quot;inst&quot; value=&quot;看书&quot;&gt;看书 &lt;input type=&quot;checkbox&quot; name=&quot;inst&quot; value=&quot;旅游&quot;&gt;旅游 &lt;br&gt;&lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;3&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;input type=&quot;reset&quot; value=&quot;重置&quot;&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; &lt;%@ page contentType=&quot;text/html&quot; pageEncoding=&quot;GBK&quot;%&gt; &lt;html&gt; &lt;head&gt;&lt;title&gt;接受参数中&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;% request.setCharacterEncoding(&quot;GBK&quot;) ;// 设置的是统一编码 String id = request.getParameter(&quot;id&quot;) ; String name = request.getParameter(&quot;uname&quot;) ; String inst[] = request.getParameterValues(&quot;inst&quot;) ; %&gt; &lt;h3&gt;编号：&lt;%=id%&gt;&lt;/h3&gt; &lt;h3&gt;姓名：&lt;%=name%&gt;&lt;/h3&gt; &lt;h3&gt;兴趣： &lt;% if(inst != null) { for(int x=0;x&lt;inst.length;x++){ %&gt; &lt;%=inst[x]%&gt;、 &lt;% } } %&gt; &lt;/h3&gt; &lt;/body&gt; &lt;/html&gt; URL地址重写 另一种方式接受参数在WEB的开发中，所有的参数不一定非要由表单传递过来，也可以使用地址重写的方式进行传递，地址重写的格式如下: 动态页面地址?参数名称1=参数内容&amp;参数名称2=参数内容2&amp;... 接收全部请求参数的名称在request内置对象中还有一个灵活的方法就是getParameterNames(),本方法可以返回所有请求参数的名称，但是此方法返回值的类型是Enumeration,所以需要使用hasMoreElements()方法判断是否有内容以及使用nextElement()方法取出内容。 显示全部的头部信息在JAVA的web开发使用的是HTTP协议，只要的操作是基于请求和回应，但是在请求和回应的同时也会包含一些其他信息，如客户端IP，Cookie，语言等，那么这些信息就称为头信息。要想取得头信息的名称可以直接通过request内置对象的getHeaderNames(),而要想取出每一个头信息的内容，则需要使用getHeader()方法。 角色验证如果在某些JSP页面需要输入特定的管理员账号才能访问，那么就需要进行角色验证了，而要进行角色验证就必须使用request内置对象中的isUserInRole()方法完成。完成用户验证，则首先可以为Tomcat增加一些新的用户，此操作可以通过修改tomcat的 conf/tomcat-users.xml文件完成，此文件中加入两个新的用户：xuaming,ecut 修改tomcat-users.xml文件，增加两个新用户 &lt;?xml version='1.0' encoding='utf-8'?&gt; &lt;tomcat-users&gt; &lt;role rolename=&quot;manager&quot;/&gt; &lt;role rolename=&quot;admin&quot;/&gt; &lt;role rolename=&quot;ecutuser&quot;/&gt; &lt;user username=&quot;xuanming&quot; password=&quot;123456&quot; roles=&quot;admin&quot;/&gt; &lt;user username=&quot;admin&quot; password=&quot;admin&quot; roles=&quot;admin,manager&quot;/&gt; &lt;user username=&quot;ecut&quot; password=&quot;123456&quot; roles=&quot;ecutuser&quot; /&gt; &lt;/tomcat-users&gt; 修改项目下的web.xml```xml Welcome to Tomcat Welcome to Tomcat main.htm RegisteredUsers /requestdemo/security.jsp ecutuser admin BASIC Registered Users ecutuser admin ``` security.jsp ```jsp 测试用户验证 欢迎光临 ``` ## 其他操作 - 取得上下文路径 public String getContextPath() ,就是整个虚拟目录的映射路径，在Tomcat目录中的conf/server.xml有配置; 获取资源文件比较方便 ```jsp 虚拟目录下访问资源文件 /images/1024.jpg ``` - WEB支持的三个CLASSPATH - Tomcat_HOME/lib 目录： - WEB-INF/classes 目录: 存放所有的“包.类” 文件名称； - WEB-INF/lib 目录：存放项目jar包的目录","link":"/2014/10/13/javaee/jsp-servlet/JSP%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1request%E5%AF%B9%E8%B1%A1/"},{"title":"JSP基础语法--JSP内置对象session对象","text":"session对象在前面讲解四种属性范围的时候,已经为读者介绍了session对象的使用，实际上开发中session对象最主要的用处就是完成用户的登录login，注销logout等常见功能，每一个session对象都表示不同的访问用户，session对象是javax.servlet.http.HttpSession接口的实例化对象，所以session只能应用在HTTP协议中。 HttpSession接口的主要方法 当一个用户连接到服务器之后，服务器会自动为此session自动分配一个不会重复的sessionID，服务器依靠这些不同的sessionID来区分每一个不同的用户，在WEB中可以使用HttpSession接口中的getId() 方法取得这些编号。","link":"/2014/10/13/javaee/jsp-servlet/JSP%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1session%E5%AF%B9%E8%B1%A1/"},{"title":"JSP基础语法--JSP九大内置对象总览","text":"内置对象在JSP中为了简化用户的开发，提供了九个内置对象，这些内置对象将由容器为用户进行实例化，而用户直接使用即可，而不用像在JAVA中那样，必须通过关键字new进行实例化对象之后才可以使用。 JSP九大内置对象及其对应类型 四中属性范围1. 在JSP中提供了四中属性的保存范围，所谓的属性保存范围，指的是一个设置的对象，可以在多少个页面中保存并可以继续使用 2. 四中属性范围: 1) pageContext:只在一个页面中保存属性，跳转之后无效。 2) request：只在一次请求中保存，服务器跳转后依然有效，客户端跳转无效。 3) session: 在一次会话范围中，无论何种跳转都可以使用，但是新开浏览器无法使用。 4) application: 在整个服务器上保存，所有用户都可以使用 属性操作方法 深入研究Page属性范围–pageContext范围从javax.servlet.jsp.PageContext类中可以发现，有以下的一种设置属性的方法 pageContext操纵其他范围属性 示例 &lt;%@ page contentType=&quot;text/html&quot; pageEncoding=&quot;GBK&quot;%&gt; &lt;%@ page import=&quot;java.util.*&quot;%&gt; &lt;html&gt; &lt;head&gt;&lt;title&gt;pageContext操纵其他范围属性&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;% pageContext.setAttribute(&quot;name&quot;,&quot;xuanming&quot;,PageContext.REQUEST_SCOPE) ; pageContext.setAttribute(&quot;birthday&quot;,new Date(),PageContext.REQUEST_SCOPE) ; %&gt; &lt;jsp:forward page=&quot;request_scope_02.jsp&quot;/&gt; &lt;/body&gt; &lt;/html&gt; &lt;%@ page contentType=&quot;text/html&quot; pageEncoding=&quot;GBK&quot;%&gt; &lt;%@ page import=&quot;java.util.*&quot;%&gt; &lt;html&gt; &lt;head&gt;&lt;title&gt;接收属性范围属性值&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;% String username = (String) request.getAttribute(&quot;name&quot;) ; Date userbirthday = (Date)request.getAttribute(&quot;birthday&quot;) ; %&gt; &lt;h2&gt;姓名：&lt;%=username%&gt;&lt;/h2&gt; &lt;h2&gt;生日：&lt;%=userbirthday%&gt;&lt;/h2&gt; &lt;/body&gt; &lt;/html&gt; 总结 四中属性范围是整个web的核心操作 属性范围规定了属性的有效范围 PageContext对象可以直接操作四种属性范围","link":"/2014/10/12/javaee/jsp-servlet/JSP%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E6%80%BB%E8%A7%88/"},{"title":"JSP基础语法--JSP执行原理、注释和它的三种scriptlet","text":"JSP执行原理 JSP的注释操作在JSP中支持两种注释的语法操作，一种是显示注释，这种注释客户端是允许看见的，另外一种是隐士注释，此种注释客户端是无法看见的。 显示注释语法： &lt;!-- 注释内容 --&gt; 隐士注释语法：```jsp 格式一： //注释，单行注释 格斯二： /* 注释，多行注释 */ 格式三: &lt;%– JSP注释 –%&gt;```Scriptlet在JSP中最重要的部分是scriptlet(脚本小程序)，所有嵌入在HTML代码中的JAVA程序都必须使用scriptlet标记出来，在JSP中一共有三种scriptlet代码： 第一种：&lt;%%&gt;:在此scriptlet中可以定义局部变量、编写语句 第二种：&lt;%! %&gt; :在此scriptlet中，可以定义全局变量、方法、类 第三种：&lt;%= %&gt;:用于输出一个变量或者一个具体内容 总结 JavaScript可以控制HTML代码的输出 JSP可以控制 JavaScript与HTML代码的输出","link":"/2014/10/07/javaee/jsp-servlet/jsp%E6%B3%A8%E9%87%8A%E5%8F%8A%E4%B8%89%E7%A7%8Dscriptlet/"},{"title":"JSP基础语法--JSP的forward跳转指令","text":"跳转的作用 从WEB中可以使用jsp:forward指令，将一个用户的请求(request),从一个页面传递到另一个页面 页面跳转语法: 不传递参数: &lt;jsp:forward page=&quot;{要包含的文件路径 | &lt;%=表达式%&gt;}&quot; /&gt; 传递参数： &lt;jsp:forward page=&quot;{要包含的文件路径 | &lt;%=表达式%&gt;}&quot; &gt; &lt;jsp:param name=&quot;参数名称&quot; value=“参数内容” /&gt; ... 可以向被跳转页面中传递多个参数 &lt;/jsp:forward&gt; 示例forward_demo02.jsp示例：&lt;html&gt; &lt;head&gt;&lt;title&gt;跳转传参示例&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;% String username = &quot;xuanming&quot; ; %&gt; &lt;jsp:forward page=&quot;forward_demo02.jsp&quot;&gt; &lt;jsp:param name=&quot;name&quot; value=&quot;&lt;%=username%&gt;&quot;/&gt; &lt;jsp:param name=&quot;info&quot; value=&quot;learning&quot;/&gt; &lt;/jsp:forward&gt; &lt;/body&gt; &lt;/html&gt; forward_demo02.jsp 示例：&lt;%@ page contentType=&quot;text/html&quot; pageEncoding=&quot;GBK&quot;%&gt; &lt;h1&gt;接受服务器跳转来的参数&lt;/h1&gt; &lt;h2&gt;参数一&lt;%=request.getParameter(&quot;name&quot;)%&gt;&lt;/h2&gt; &lt;h2&gt;参数二&lt;%=request.getParameter(&quot;info&quot;)%&gt;&lt;/h2&gt; 小结 使用跳转可以完成页面请求的传递。 跳转操作属于服务器端跳转，跳转之后的页面路径不改变。","link":"/2014/10/12/javaee/jsp-servlet/jsp%E7%9A%84forward%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4/"},{"title":"JSP基础语法--JSP的include包含指令","text":"一般像以下的页面结构，都会采用到包含指令 静态包含：静态包含语法： &lt;%@include file=&quot;包含文件路径&quot; %&gt; 定义要包含的三个页面info.htm 文件内容： &lt;h2&gt;&lt;font color=&quot;red&quot;&gt;this is info.htm&lt;/font&gt; info.jsp 文件内容： &lt;h2&gt;&lt;font color=&quot;red&quot;&gt; &lt;%=&quot;this is info.jsp&quot;%&gt; &lt;/font&gt; info.inc 文件内容： &lt;h2&gt;&lt;font color=&quot;red&quot;&gt; info.inc&lt;/font&gt; 使用静态指令包含include_demo示例：&lt;%@ page contentType=&quot;text/html&quot; pageEncoding=&quot;UTF-8&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;静态包含demo&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;静态包含操作&lt;/h1&gt; &lt;%@ include file=&quot;info.html&quot;%&gt; &lt;%@ include file=&quot;info.jsp&quot;%&gt; &lt;%@ include file=&quot;info.inc&quot;%&gt; &lt;/body&gt; &lt;/html&gt; 静态包含的处理流程 动态包含动态包含&lt;jsp:include&gt; 情况一：被包含的页面属于静态文件，那么就像&lt;%@include%&gt;一样直接包含进来 情况二： 被包含的页面属于动态页面，则要分别处理后再进行包含。动态包含的语法定义 定义一：包含的时候不传参数。&lt;jsp:include page=&quot;路径&quot;/&gt; 定义二：包含的时候传递参数。&lt;jsp:include page=&quot;路径&quot;&gt; &lt;jsp:param name=&quot;参数名称&quot; value=&quot;参数内容&quot;/&gt; &lt;jsp:param name=&quot;参数名称&quot; value=&quot;参数内容&quot;/&gt; &lt;jsp:param name=&quot;参数名称&quot; value=&quot;参数内容&quot;/&gt; &lt;jsp:param name=&quot;参数名称&quot; value=&quot;参数内容&quot;/&gt; &lt;/jsp:include&gt; 所有接收的参数方式使用 request.getParameter()完成。 完成与静态包含类似的功能&lt;%@page pageEncoding=&quot;UTF-8&quot; %&gt; &lt;jsp:include page=&quot;info.htm&quot; /&gt; &lt;jsp:include page=&quot;info.jsp&quot; /&gt; &lt;jsp:include page=&quot;info.inc&quot; /&gt; 这一点上包含的内容和静态包含是没有区别的 动态包含传递参数param.jsp 示例：&lt;%@ page contentType=&quot;text/html&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;% String userName = &quot;xuanming&quot;; %&gt; &lt;h1&gt;动态包含并传递参数&lt;/h1&gt; &lt;jsp:include page=&quot;receive_param.jsp&quot;&gt; &lt;jsp:param name=&quot;name&quot; value=&quot;&lt;%=userName %&gt;&quot; /&gt; &lt;jsp:param name=&quot;info&quot; value=&quot;learnning &quot; /&gt; &lt;/jsp:include&gt; receive_param.jsp 示例：&lt;%@ page contentType=&quot;text/html&quot; pageEncoding=&quot;UTF-8&quot; %&gt; &lt;h1&gt;参数一：&lt;%=request.getParameter(&quot;name&quot;)%&gt;&lt;/h1&gt; &lt;h1&gt;参数二：&lt;%=request.getParameter(&quot;info&quot;)%&gt;&lt;/h1&gt; 总结 静态包含： 语法: &lt;%@include file=&quot;路径&quot; %&gt; 处理流程：先包含后一起进行处理 动态包含: 语法: &lt;jsp:include page=&quot;路径&quot; /&gt; 处理流程：如果包含的是静态页面则将只是将文件内容导入进来，如果包含的是动态文件，则将处理后的结果包含进来（先处理后包含） 以后开发尽可能用动态包含，可以避免局部变量同名冲突。","link":"/2014/10/10/javaee/jsp-servlet/jsp%E7%9A%84include%E5%8C%85%E5%90%AB%E6%8C%87%E4%BB%A4/"},{"title":"JSP基础语法--JSP的Page指令","text":"page指令 page指令在JSP开发中较为重要，使用此属性，可以定义一个JSP页面的相关属性，包括设置MIME类型、定义需要导入的包，错误页的指定等。 page指令语法：&lt;%@ page 属性=“内容” %&gt; 支持写多了page指令，没必要写在一个了，会导致太长 主要属性JSP文件编码解决乱码 通过pageEncoding=”UTF-8”,可以解决乱码问题示例&lt;%@ page pageEncoding=&quot;UTF-8&quot; &gt; 通过contentType指定编码示例&lt;%@ page contentType=&quot;text/html;charset=&quot;UTF-8&quot;&gt; 二选一即可，两个都用也不冲突，默认浏览器用contentType指定的编码示例&lt;%@ page pageEncoding=&quot;UTF-8&quot; contentType=&quot;text/html;charset=&quot;UTF-8&quot;&gt; 一般不这么用，一般 contentType只指定MIME类型，编码格式 交由pageEncoding属性去指定示例：&lt;%@ page pageEncoding=&quot;UTF-8&quot; contentType=&quot;text/html&quot; pageEncoding=&quot;UTF-8&quot;&gt; 设置MIME类型MIME指的是多路Internet媒体访问协议。相当于通过MIME类型定义出当前页面所有支持的MIME类型都在Tomcat安装目录中 /conf/web.xml文件里面定义了。 设置MIME为Word格式，可设置如下的MIME类型：示例：```jsp&lt;%@ page pageEncoding=”UTF-8” import=”java.util.Date”%&gt;&lt;%@ page contentType=”application/msword”%&gt;&lt;% long time = new Date().getTime(); String file = “attachment;filename=”+time+”.doc”; response.setHeader(“Content-Disposition”,file);%&gt;","link":"/2014/10/08/javaee/jsp-servlet/jsp%E7%9A%84page%E6%8C%87%E4%BB%A4/"},{"title":"servlet并发问题","text":"servlet运行tomcat线程模型 servlet并发的问题 线程不安全1.servlet单实例2.多线程共同访问3.线程不安全 servlet线程安全解决","link":"/2014/10/20/javaee/jsp-servlet/servlet%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98/"},{"title":"权限管理第一篇","text":"为什么需要权限管理 安全性: 误操作，人为破坏，数据泄露等 数据隔离: 不同的权限能看到及操作不同的数据 明确职责: 运营、客服等不同角色，leader和dev等不同级别","link":"/2016/12/01/javaee/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/secure-manager/"},{"title":"CRM第一篇","text":"客户管理客户管理是销售工作中最重要的部分客户的定义包括：潜在客户: 未成交，正在跟踪的客户普通客户: 已成交的客户VIP客户: 重点客户，大客户代理商： 代理商，分销商合作伙伴： 合作伙伴失效客户： 失效的客户","link":"/2017/08/03/%E4%B8%9A%E5%8A%A1%E9%A2%86%E5%9F%9F/CRM/CRM%E7%AC%AC%E4%B8%80%E7%AF%87/"},{"title":"打车业务APP规划","text":"打车业务总体解耦 项目阶段规划 SVG logo矢量图制作 OKHTTP 自定义封装 业界解耦操作 MVP重构","link":"/2017/08/03/%E4%B8%9A%E5%8A%A1%E9%A2%86%E5%9F%9F/%E6%89%93%E8%BD%A6/CallCar/"},{"title":"vsftpd在centOS安装","text":"安装vsftpd组件安装完后，有/etc/vsftpd/vsftpd.conf 文件，是vsftp的配置文件。 yum -y install vsftpd 添加一个ftp用户 useradd ftpuser这样一个用户建完，可以用这个登录，记得用普通登录不要用匿名了。登录后默认的路径为 /home/ftpuser. 给ftp用户添加密码 passwd ftpuser输入两次密码后修改密码。 防火墙开启21端口因为ftp默认的端口为21，而centos默认是没有开启的，所以要修改iptables文件 vim /etc/sysconfig/iptables在行上面有22 -j ACCEPT 下面另起一行输入跟那行差不多的，只是把22换成21，然后：wq保存。还要运行下,重启iptables service iptables restart 修改selinux 外网是可以访问上去了，可是发现没法返回目录（使用ftp的主动模式，被动模式还是无法访问），也上传不了，因为selinux作怪了。修改selinux：执行以下命令查看状态：getsebool -a | grep ftp显示———————————–beginallow_ftpd_anon_write –&gt; offallow_ftpd_full_access –&gt; offallow_ftpd_use_cifs –&gt; offallow_ftpd_use_nfs –&gt; offftp_home_dir –&gt; offftpd_connect_db –&gt; offftpd_use_passive_mode –&gt; offhttpd_enable_ftp_server –&gt; offtftp_anon_write –&gt; off显示———————————–end执行上面命令，再返回的结果看到两行都是off，代表，没有开启外网的访问 setsebool -P allow_ftpd_full_access on setsebool -P ftp_home_dir on这样应该没问题了（如果，还是不行，看看是不是用了ftp客户端工具用了passive模式访问了，如提示Entering Passive mode，就代表是passive模式，默认是不行的，因为ftp passive模式被iptables挡住了，下面会讲怎么开启，如果懒得开的话，就看看你客户端ftp是否有port模式的选项，或者把passive模式的选项去掉。如果客户端还是不行，看看客户端上的主机的电脑是否开了防火墙，关吧） 关闭匿名访问修改/etc/vsftpd/vsftpd.conf文件：anonymous_enable=YES #改为NO重启ftp服务： service vsftpd restart 开启被动模式默认是开启的，但是要指定一个端口范围，打开vsftpd.conf文件，在后面加上pasv_min_port=30000pasv_max_port=30999表示端口范围为30000~30999，这个可以随意改。改完重启一下vsftpd由于指定这段端口范围，iptables也要相应的开启这个范围，所以像上面那样打开iptables文件。也是在21上下面另起一行，更那行差不多，只是把21 改为30000:30999,然后:wq保存，重启下iptables。这样就搞定了 设置开机启动vsftpd ftp服务chkconfig vsftpd on","link":"/2016/08/05/%E4%B8%AD%E9%97%B4%E4%BB%B6/ftp/vsftpd/"},{"title":"ftp+nginx搭建分布式图片服务器","text":"传统项目的图片管理传统项目中，可以在web项目中添加一个文件夹，来存放上传的图片。例如在工程的根目录WebRoot下创建一个images文件夹。把图片存放在此文件夹中就可以直接使用在工程中引用。优点：引用方便，便于管理缺点：如果是分布式环境图片引用会出现问题。图片的下载会给服务器增加额外的压力 分布式环境的图片管理分布式环境一般都有一个专门的图片服务器存放图片。我们使用虚拟机搭建一个专门的服务器来存放图片。在此服务器上安装一个nginx来提供http服务，安装一个ftp服务器来提供图片上传服务。 安装 vsftpd 和 nginx参考前面写的blog/home/ftpuser/www ftp的跟目录设置下权限 chmod -R 775 目录名在nginx.conf配置下 location / { root /home/ftpuser/www; index index.html index.php index.htm; } 设置为开机自启动服务 java程序上传测试引入依赖 &lt;dependency&gt; &lt;groupId&gt;commons-net&lt;/groupId&gt; &lt;artifactId&gt;commons-net&lt;/artifactId&gt; &lt;version&gt;3.3&lt;/version&gt; &lt;/dependency&gt; java程序测试package com.songxm.qiuqiu.common.utils; import java.io.File; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import org.apache.commons.net.ftp.FTP; import org.apache.commons.net.ftp.FTPClient; import org.apache.commons.net.ftp.FTPFile; import org.apache.commons.net.ftp.FTPReply; public class FtpUtil { /** * Description: 向FTP服务器上传文件 * @param host FTP服务器hostname * @param port FTP服务器端口 * @param username FTP登录账号 * @param password FTP登录密码 * @param basePath FTP服务器基础目录 * @param filePath FTP服务器文件存放路径。例如分日期存放：/2015/01/01。文件的路径为basePath+filePath * @param filename 上传到FTP服务器上的文件名 * @param input 输入流 * @return 成功返回true，否则返回false */ public static boolean uploadFile(String host, int port, String username, String password, String basePath, String filePath, String filename, InputStream input) { boolean result = false; FTPClient ftp = new FTPClient(); try { int reply; ftp.connect(host, port);// 连接FTP服务器 // 如果采用默认端口，可以使用ftp.connect(host)的方式直接连接FTP服务器 ftp.login(username, password);// 登录 reply = ftp.getReplyCode(); if (!FTPReply.isPositiveCompletion(reply)) { ftp.disconnect(); return result; } //切换到上传目录 if (!ftp.changeWorkingDirectory(basePath+filePath)) { //如果目录不存在创建目录 String[] dirs = filePath.split(&quot;/&quot;); String tempPath = basePath; for (String dir : dirs) { if (null == dir || &quot;&quot;.equals(dir)) continue; tempPath += &quot;/&quot; + dir; if (!ftp.changeWorkingDirectory(tempPath)) { if (!ftp.makeDirectory(tempPath)) { return result; } else { ftp.changeWorkingDirectory(tempPath); } } } } //设置上传文件的类型为二进制类型 ftp.setFileType(FTP.BINARY_FILE_TYPE); //上传文件 if (!ftp.storeFile(filename, input)) { return result; } input.close(); ftp.logout(); result = true; } catch (IOException e) { e.printStackTrace(); } finally { if (ftp.isConnected()) { try { ftp.disconnect(); } catch (IOException ioe) { } } } return result; } /** * Description: 从FTP服务器下载文件 * @param host FTP服务器hostname * @param port FTP服务器端口 * @param username FTP登录账号 * @param password FTP登录密码 * @param remotePath FTP服务器上的相对路径 * @param fileName 要下载的文件名 * @param localPath 下载后保存到本地的路径 * @return */ public static boolean downloadFile(String host, int port, String username, String password, String remotePath, String fileName, String localPath) { boolean result = false; FTPClient ftp = new FTPClient(); try { int reply; ftp.connect(host, port); // 如果采用默认端口，可以使用ftp.connect(host)的方式直接连接FTP服务器 ftp.login(username, password);// 登录 reply = ftp.getReplyCode(); if (!FTPReply.isPositiveCompletion(reply)) { ftp.disconnect(); return result; } ftp.changeWorkingDirectory(remotePath);// 转移到FTP服务器目录 FTPFile[] fs = ftp.listFiles(); for (FTPFile ff : fs) { if (ff.getName().equals(fileName)) { File localFile = new File(localPath + &quot;/&quot; + ff.getName()); OutputStream is = new FileOutputStream(localFile); ftp.retrieveFile(ff.getName(), is); is.close(); } } ftp.logout(); result = true; } catch (IOException e) { e.printStackTrace(); } finally { if (ftp.isConnected()) { try { ftp.disconnect(); } catch (IOException ioe) { } } } return result; } public static void main(String[] args) { try { FileInputStream in=new FileInputStream(new File(&quot;/Users/sxm/Downloads/licai.png&quot;)); boolean flag = uploadFile(&quot;192.168.1.103&quot;, 21, &quot;ftpuser&quot;, &quot;ftpuser&quot;, &quot;/home/ftpuser/www/images&quot;,&quot;/2016/03/09&quot;, &quot;test.png&quot;, in); System.out.println(flag); } catch (FileNotFoundException e) { e.printStackTrace(); } } }","link":"/2016/08/06/%E4%B8%AD%E9%97%B4%E4%BB%B6/nginx/ftp+nginx%E6%90%AD%E5%BB%BA%E5%88%86%E5%B8%83%E5%BC%8F%E5%9B%BE%E7%89%87%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"title":"nginx实战应用","text":"nginx简介 Nginx (“ engine x”)是一个高性能的HTTP和反向代理服务器，也是一个IMAP/POP3/SMTP服务器。Nginx是由Igor Sysoev为俄罗斯访问量第二的Rambler.ru站点开发的，第一个公开版本0.1.0发布于2004年10月4日。其将源代码以类BSD许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。2011年6月1日, nginx1.0.4发布。 其特点是占有内存少,并发能力强,事实上nginx的并发能力确实在同类型的网页服务器中表现较好,中国大陆使用nginx网站用户有:百度、京东、新浪、网易、腾讯、淘宝等。 nginx最大特点是可以进行多模块的整合,整合其它的开发模块实现更加复杂的功能。 nginx与tomcat整合nginx反向代理功能示例 nginx与一台tomcat服务器整合示例，实现nginx代理功能 服务器ip 应用 192.168.1.110 nginx-server-01 192.168.1.101 tomcat-server-01 1)【tomcat-server-01】配置一个虚拟目录: 1.建立一个tomcat工作目录mkdir -p /usr/data/tomcat-web/ecit-web 2.将Tomcat软件下的 webapps/ROOT/WEB-INF拷贝到ecit-web此目录之中 3.编辑tomcat软件下conf/server.xml，在Host节点里添加虚拟目录&lt;content path=&quot;/&quot; docBase=&quot;/usr/data/tomcat-web/ecit-web&quot; /&gt; 4.打开浏览器输入 http://192.168.1.101:8080/ 正常访问 2)【nginx-server-01】代理配置 1.修改nginx配置文件,在location节点添加代理vim /usr/local/nginx/conf/nginx.conf 1ocation / { proxy_pass http://192.168.1.101:8080/ } 3)核心参数 proxy_pass:设置代理的服务器的路径; proxy_redirect:表示该请求是否要配置转发,这样可以避免端口与路径映射的问题; proxy_set_header Host :代理头信息,转发发送过来的HTTP头信息; proxy_set_header X-Real-IP :代理头信息,转发发送过来的客户端IP地址,如果不配置则将接收nginx服务器的IP地址; proxy_set_header X-Forwarded-For :表示该次请求是由谁发起的，一般要与proxy_set_header一起使用;location / { proxy_pass http://192.168.1.101:8080/; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Rea1-IP $remote_ addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } 检测配置是否正确：/usr/local/nginx/sbin/nginx -t 显示下面信息，表示配置无语法错误nginx : the configuration file /usr/local/nginx/conf/nginx.conf syntax is oknginx: configuration fi1e /usr/local/nginx/conf/nginx.conf test is successful重载配置文件生效：/usr/local/nginx/sbin/nginx -s reload nginx实现负载均衡 所谓的负载均衡的本质就是一个nginx将可以代理多个Tomcat服务器,形成Tomcat集群存在，每台Tomcat主机都可能称为nginx的服务主机。 服务器ip 应用 192.168.1.110 nginx-server-01 192.168.1.101 tomcat-server-01 192.168.1.102 tomcat-server-02 同理【tomcat-server-02】也配置一个web虚拟目录，正常访问 http://192.168.1.102:8080/ 1)【nginx-server-01】负载均衡配置修改nginx配置文件,在server节点上边并排添加负载服务列表 upstream appserver { server 192.168.1.101:8080; server 192.168.1.102:8080; } 或者添加权重 upstream appserver { server 192.168.1.101:8080 weight=1; server 192.168.1.102:8080 weight=2; } 还可以手动指定宕机和备机 upstream appserver { server 192.168.1.101:8080 down; server 192.168.1.102:8080; } 或 upstream appserver { server 192.168.1.101:8080 down; server 192.168.1.102:8080 backup; } 2)修改代理配置项 location / { proxy_pass http://appserver; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Rea1-IP $remote_ addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } 检测配置是否正确： /usr/local/nginx/sbin/nginx -t 重新加载配置 /usr/local/nginx/sbin/nginx -s reload nginx缓存配置 以上的nginx配置严格来讲只是做了一个中间的路由操作。 没有考虑静态资源的缓存问题，浪费网络资源。 缓存需要确定缓存模块已经添加，参考Nginx安装的文章1)【nginx-server-01】 服务器建立缓存目录:mkdir -p /usr/data/nginx/ { temp,cache } 2)【nginx-server-01】配置文件修改，有如下几项信息注意：http { include mime .types; default type application/ octet-stream; proxy_temp_path /usr/data/nginx/temp; #设置代理的临时保存目录。 proxy_cache_path /usr/data/nginx/cache levels=1:2 keys_zone=cache_one:200m inactive=1d max_size=30g; #配置所有的缓存路径，其中“cache one”就是在缓存中使用的名字，在服务器的配置上会使用到这个名字，200m:在内存中的空间是200M，inactive=1d表示1天清空一次缓存 proxy_connect_timeout 5; proxy_read_timeout 60; proxy_send_timeout 5; proxy_buffer_size 16k; #设置缓冲区大小 proxy_buffers 4 64k; proxy_busy_buffers_size 128k; #用来控制同时传输到客户端的buffer数量的 proxy_temp_file_write_size 128k; #设定缓存文件夹大小,大于这个值将从upstream服务器传输 gzip on; gzip_min_length 1k ; gzip_buffers 48k; gzip_http_version 1.1; gzip_types text/plain application/x-JavaScript text/css application/xml; gzip_disable &quot;MSIE [1-6] \\.&quot;; I } #清空缓存配置，注意必须放在最上边，当在请求的url前加/purge/时将此url的缓存清空 location ~ /purge(/.*) { # 进行清空 #安全设置，指定请求客户端的IP或IP段才可以清除URL缓存，这里为了方便测试设置为all allow 127 .0.0.1; allow 192.168.1.0/24; allow all; #指定清空缓存的区域名称cache_one(要和上边proxy_cache_path缓存配置中指定的缓存区域名称一致) #指定缓存的key规则$host$1$is_args$args，要和下边设置缓存的key一致$host$uri$is_args$args #注意$host$1$is_args$args中的$1表示当前请求的uri,$host$1$is_args$args=$host$uri$is_args$args proxy_cache_purge cache_one $host$1$is_args$args; } location / { proxy_pass http://appserver; proxy_redirect off; proxy_set_header Host $host:$server_port; proxy_cache cache_one; #表示启用缓存cache_one，上面配置的名字 proxy_cache_key $host$uri$is_args$args ; proxy_cache_valid 200 302 1h ; proxy_cache_valid 301 1d; } location ~ .*\\. (gif|jpg|png|htm|html|css|js|flv|ico|swf) (.*) { proxy_pass http://appserver; proxy_redirect off; proxy_set_header Host $host:$server_port; proxy_cache cache_one; proxy_cache_key $host$uri$is_args$args; proxy_cache_valid 200 302 1h; #对不同的HTTP状态码设置不同的缓存时间 proxy_cache_valid 301 1d; proxy_cache_valid any 1m; expires 30d; proxy_cache缓存过程：-1、客户端第一次请求url，比如请求aaa.ecit.com/index.html 2、nginx计算url的哈希值 md5(url) 即：MD5(‘ccc.test.com/index.html’)，得到b5ac8d82f6ef789fe7081ef4a43f9230 3、创建缓存目录，写入缓存数据如果缓存目录的规则设置为levels=1:2,创建目录如下：取出b5ac8d82f6ef789fe7081ef4a43f9230的最后一位0作为目录名创建目录，再取出0前边的两位23作为目录名在0目录下边创建目录，即一级目录为0，二级目录名为23，最后将代理获得的http响应数据存储在缓存数据文件中，缓存文件命名为b5ac8d82f6ef789fe7081ef4a43f9230写入0/23目录下。 4、客户端再次请求相同的url，对url进行哈希得到缓存数据文件的地址，如果找到缓存数据则直接返回给客户端不再请求web服务器。 集群session管理-五种方式比较 配置负载均衡比较简单,但是最关键的一个问题是怎么实现多台服务器之间session的共享?1)ip_hash方式upstream appserver { ip_hash; #session 具有粘滞性 server 192.168.1.101:8080 weight=1; server 192.168.1.102:8080 weight=2; } **优点:**每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。 **缺点:**这存在单点风险，倘若我已经在192.168.1.101:8080端口登录后，过段时间发现这台服务器挂了（session时间未过期），那么这时候会访问到192.168.1.102服务器，那这时候需要重新登录，因为在拿192.168.1.101服务器上的JsessionId去192.168.1.102服务器请求发现不存在。 2)session 复制 可以通过tomcat的server.xml文件进行配置，这样每个tomcat都会同步对应的session，那么此时即使某个tomcat被宕机了，也不影响服务。 具体的tomcat可以参见如下 ，http://tomcat.apache.org/tomcat-9.0-doc/cluster-howto.html&lt;Cluster className=&quot;org.apache.catalina.ha.tcp.SimpleTcpCluster&quot; channelSendOptions=&quot;8&quot;&gt; &lt;Manager className=&quot;org.apache.catalina.ha.session.DeltaManager&quot; expireSessionsOnShutdown=&quot;false&quot; notifyListenersOnReplication=&quot;true&quot;/&gt; &lt;Channel className=&quot;org.apache.catalina.tribes.group.GroupChannel&quot;&gt; &lt;Membership className=&quot;org.apache.catalina.tribes.membership.McastService&quot; address=&quot;228.0.0.4&quot; port=&quot;45564&quot; frequency=&quot;500&quot; dropTime=&quot;3000&quot;/&gt; &lt;Receiver className=&quot;org.apache.catalina.tribes.transport.nio.NioReceiver&quot; address=&quot;auto&quot; port=&quot;4000&quot; autoBind=&quot;100&quot; selectorTimeout=&quot;5000&quot; maxThreads=&quot;6&quot;/&gt; &lt;Sender className=&quot;org.apache.catalina.tribes.transport.ReplicationTransmitter&quot;&gt; &lt;Transport className=&quot;org.apache.catalina.tribes.transport.nio.PooledParallelSender&quot;/&gt; &lt;/Sender&gt; &lt;Interceptor className=&quot;org.apache.catalina.tribes.group.interceptors.TcpFailureDetector&quot;/&gt; &lt;Interceptor className=&quot;org.apache.catalina.tribes.group.interceptors.MessageDispatchInterceptor&quot;/&gt; &lt;/Channel&gt; &lt;Valve className=&quot;org.apache.catalina.ha.tcp.ReplicationValve&quot; filter=&quot;&quot;/&gt; &lt;Valve className=&quot;org.apache.catalina.ha.session.JvmRouteBinderValve&quot;/&gt; &lt;Deployer className=&quot;org.apache.catalina.ha.deploy.FarmWarDeployer&quot; tempDir=&quot;/tmp/war-temp/&quot; deployDir=&quot;/tmp/war-deploy/&quot; watchDir=&quot;/tmp/war-listen/&quot; watchEnabled=&quot;false&quot;/&gt; &lt;ClusterListener className=&quot;org.apache.catalina.ha.session.ClusterSessionListener&quot;/&gt; &lt;/Cluster&gt; 3)每台toncat配置session同步 准备tomcat与redis进行session管理的开发包commons-pool2-2.4.2.jar、jedis-2.9.0.jar、tomcat-redis-session-8.5.5.0.jar 将三个jar包拷贝到 tomcat软件下的lib目录下 修改tomcat的server.xml,追加session管理机制,假设redis服务器地址是192.168.122.183&lt;context path=&quot;/&quot; docBase= &quot;/usr/data/tomcat/ecit-web&quot;&gt; &lt;Manager className=&quot;ru.zinin.redis.session.RedisManager&quot; redisHostname=&quot;192.168.122.183&quot; redisPassword=&quot;ecit@2016&quot; redisPort=&quot;6379&quot; redisTimeout=&quot;1000&quot;/&gt; &lt;/context&gt; 同理其余的tomcat都要添加设置，至此配置完成，访问服务 4)session 共享（springboot） 对应的项目中pom文件添加&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.session&lt;/groupId&gt; &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; 在对应的application.properties中配置redis信息spring.redis.host=localhost spring.redis.port=6379 添加开启spring session支持的注解@EnableRedisHttpSession@Configuration @EnableRedisHttpSession public class RedisSessionConfig { } 添加验证的接口@Value(&quot;${server.port}&quot;) String port; @GetMapping(&quot;/session&quot;) public Object getSession(HttpServletRequest request){ Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(&quot;SessionId&quot;, request.getSession().getId()); map.put(&quot;ServerPort&quot;, &quot;服务端口号为 &quot;+port); return map; } 结果中的SessionId是一致的，却是由两个不同项目工程来提供服务。这样子，SpringSession 利用拦截器 Filter 帮我们在每个请求前进行了同步设置，达到了分布式系统中 session 共享。 5)session 共享（springmvc 版本） 首先在pom.xml文件中添加对应的jar&lt;dependency&gt; &lt;groupId&gt;org.springframework.session&lt;/groupId&gt; &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt; &lt;version&gt;1.2.1.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.8.1&lt;/version&gt; &lt;/dependency&gt; 在对应springmvc-context.xml文件中配置&lt;bean id=&quot;redisHttpSessionConfiguration&quot; class=&quot;org.springframework.session.data.redis.config.annotation.web.http.RedisHttpSessionConfiguration&quot;&gt; &lt;property name=&quot;maxInactiveIntervalInSeconds&quot; value=&quot;600&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;jedisPoolConfig&quot; class=&quot;redis.clients.jedis.JedisPoolConfig&quot;&gt; &lt;property name=&quot;maxTotal&quot; value=&quot;100&quot; /&gt; &lt;property name=&quot;maxIdle&quot; value=&quot;10&quot; /&gt; &lt;property name=&quot;testOnBorrow&quot; value=&quot;true&quot; /&gt; &lt;/bean&gt; &lt;bean id=&quot;connectionFactory&quot; class=&quot;org.springframework.data.redis.connection.jedis.JedisConnectionFactory&quot; &gt; &lt;property name=&quot;poolConfig&quot; ref=&quot;jedisPoolConfig&quot; /&gt; &lt;property name=&quot;port&quot; value=&quot;6379&quot; /&gt; &lt;property name=&quot;hostName&quot; value=&quot;192.168.1.11&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;xxx&quot; /&gt; &lt;property name=&quot;timeout&quot; value=&quot;30000&quot; &gt;&lt;/property&gt; &lt;/bean &gt; &lt;bean id=&quot;redisTemplate&quot; class=&quot;org.springframework.data.redis.core.RedisTemplate&quot; &gt; &lt;property name=&quot;connectionFactory&quot; ref=&quot;connectionFactory&quot; /&gt; &lt;property name=&quot;keySerializer&quot;&gt; &lt;bean class=&quot;org.springframework.data.redis.serializer.StringRedisSerializer&quot; /&gt; &lt;/property&gt; &lt;property name=&quot;valueSerializer&quot;&gt; &lt;bean class=&quot;org.springframework.data.redis.serializer.StringRedisSerializer&quot; /&gt; &lt;/property&gt; &lt;/bean &gt; &lt;bean id=&quot;redisUtil&quot; class=&quot;com.isea533.mybatis.service.RedisUtil&quot; &gt; &lt;property name=&quot;redisTemplate&quot; ref=&quot;redisTemplate&quot; /&gt; &lt;/bean &gt; 其次在web.xml中配置（非常重要，filter的名字必须是springSessionRepositoryFilter）&lt;filter&gt; &lt;filter-name&gt;springSessionRepositoryFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;springSessionRepositoryFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 结果中的SessionId是一致的. nginx的虚拟主机功能 虚拟主机是一种特殊的软硬件技术，它可以将网络上的每一台计算机分成多个虚拟主机，每个虚拟主机可以独立对外提供www服务，这样就可以实现一台主机对外提供多个web服务，每个虚拟主机之间是独立的，互不影响的。通过nginx可以实现虚拟主机的配置，nginx支持三种类型的虚拟主机配置，1、基于ip的虚拟主机， 2、基于域名的虚拟主机 3、基于端口的虚拟主机 基于ip的虚拟主机 Linux操作系统允许添加IP别名，IP别名就是在一块物理网卡上绑定多个IP地址。这样就能够在使用单一网卡的同一个服务器上运行多个基于IP的虚拟主机。 一个物理网卡配置多个IP1)需求一台nginx服务器绑定两个ip：192.168.1.110、192.168.1.109访问不同的ip请求不同的html目录，即：访问http://192.168.1.110 将访问“html110”目录下的html网页访问http://192.168.1.109 将访问“html109”目录下的html网页2)准备环境创建192.168.1.110虚拟机，保证本地电脑和虚拟网络通畅。在192.168.1.110上安装nginx。将原来nginx的html目录拷贝两个目录 “html110”和“html109”，为了方便测试需要修改每个目录下的index.html内容使之个性化。3)绑定多ip 方法一：使用标准的网络配置工具（比如ifconfig和route命令）添加iP别名：当前ip配置情况查看 ifconfig,并找出当前的广播地址， 在eth0网卡现在是：192.168.1.110，现在在eth0网卡再绑定一个ip：192.168.1.109 /sbin/ifconfig eth0:1 192.168.1.109 broadcast 192.168.1.255 netmask 255.255.255.0 up /sbin/route add -host 192.168.1.109 dev eth0:1 以上就完成了。 方法二将/etc/sysconfig/network-scripts/ifcfg-eth0文件复制一份，命名为ifcfg-eth0:1修改其中内容： DEVICE=eth0:1 IPADDR=192.168.1.103 其他项不用修改,重启系统 配置虚拟主机修改/usr/local/nginx/conf/nginx.conf文件，添加两个虚拟主机，如下 #user nobody; worker_processes 1; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; #配置虚拟主机192.168.1.110 server { #监听的ip和端口，配置192.168.1.110:80 listen 192.168.1.110:80; #虚拟主机名称这里配置ip地址 server_name 192.168.1.110; #所有的请求都以/开始，所有的请求都可以匹配此location location / { #使用root指令指定虚拟主机目录即网页存放目录 #比如访问http://ip/test.html将找到/usr/local/html110/test.html #比如访问http://ip/item/test.html将找到/usr/local/html110/item/test.html root /usr/local/nginx/html110; #指定欢迎页面，按从左到右顺序查找 index index.html index.htm; } } #配置虚拟主机192.168.1.109 server { listen 192.168.1.109:80; server_name 192.168.1.109; location / { root /usr/local/nginx/html109; index index.html index.htm; } } } 启动nginx测试，http://192.168.1.110, http://192.168.1.109 nginx配置文件的结构...... events { ....... } http{ ....... server{ ....... } server{ ....... } } #每个server就是一个虚拟主机。 基于域名的虚拟主机1)需求 两个域名指向同一台nginx服务器，用户访问不同的域名显示不同的网页内容。假设两个域名是aaa.ecit.com 和 bbb.ecit.com,nginx服务器使用虚拟机192.168.1.1102)准备环境 创建192.168.1.110虚拟机，保证本地电脑和虚拟网络通畅。在192.168.1.110上安装nginx。模拟的话可以修改host文件使得两个域名解析到同一个ip3)html目录创建在192.168.1.110上创建/usr/local/aaa_html，此目录为aaa.ecit.com域名访问的目录在192.168.1.110上创建/usr/local/bbb_html，此目录为bbb.ecit.com域名访问的目录 配置虚拟主机修改/usr/local/nginx/conf/nginx.conf文件，添加两个虚拟主机，如下： server { #监听的ip和端口，配置本机ip和端口 listen 192.168.1.110:80; #虚拟主机名称是aaa.ecit.com，请求域名aaa.ecit.com的url将由此server配置解析 server_name aaa.ecit.com; #所有的请求都以/开始，所有的请求都可以匹配此location location / { #使用root指令指定虚拟主机目录即网页存放目录 #比如访问http://ip/test.html将找到/usr/local/aaa_html/test.html #比如访问http://ip/item/test.html将找到/usr/local/aaa_html/item/test.html root /usr/local/aaa_html; #指定欢迎页面，按从左到右顺序查找 index index.html index.htm; } } #配置虚拟主机bbb.ecitt.com server { listen 192.168.1.110:80; server_name bbb.ecit.com; location / { root /usr/local/bbb_html; index index.html index.htm; } } 启动，测试:http://aaa.ecit.com, http://bbb.ecit.com 基于端口的虚拟主机1)需求 nginx对外提供80和8080两个端口监听服务。请求80端口则请求html80目录下的html,请求8080端口则请求html8080目录下的html2)准备环境 创建192.168.1.110虚拟机，保证本地电脑和虚拟网络通畅。在192.168.1.110上安装nginx。3)html目录创建 将原来nginx的html目录拷贝两个目录 “html80”和“html8080”，为了方便测试需要修改每个目录下的index.html内容使之个性化。 配置虚拟主机修改/usr/local/nginx/conf/nginx.conf文件，添加两个虚拟主机，如下： #user nobody; worker_processes 1; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; #配置虚拟主机 server { #监听的ip和端口，配置80 listen 80; #虚拟主机名称这里配置ip地址 server_name 192.168.1.110; #所有的请求都以/开始，所有的请求都可以匹配此location location / { #使用root指令指定虚拟主机目录即网页存放目录 #比如访问http://ip/test.html将找到/usr/local/html3/test.html #比如访问http://ip/item/test.html将找到/usr/local/html3/item/test.html root /usr/local/nginx/html80; #指定欢迎页面，按从左到右顺序查找 index index.html index.htm; } } #配置虚拟主机 server { listen 8080; server_name 192.168.1.110; location / { root /usr/local/nginx/html8080; index index.html index.htm; } } } 重启测试：http://192.168.1.110, http://192.168.1.110:8080","link":"/2016/10/06/%E4%B8%AD%E9%97%B4%E4%BB%B6/nginx/nginx%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/"},{"title":"nginx高可用(HA)","text":"nginx结构问题 所有的WEB容器的负载均衡由nginx负责,如果nginx出现了问题 ,那么所有的WEB容器均无法访问。 nginx的HA机制 nginx作为负载均衡器，所有请求都到了nginx，可见nginx处于非常重点的位置，如果nginx服务器宕机后端web服务将无法提供服务，影响严重。 为了屏蔽负载均衡服务器的宕机，需要建立一个备份机。主服务器和备份机上都运行高可用（High Availability）监控程序，通过传送诸如“I am alive”这样的信息来监控对方的运行状况。当备份机不能在一定的时间内收到这样的信息时，它就接管主服务器的服务IP并继续提供负载均衡服务；当备份管理器又从主管理器收到“I am alive”这样的信息时，它就释放服务IP地址，这样的主服务器就开始再次提供负载均衡服务。 keepalived+nginx实现主备keepalived keepalived是集群管理中保证集群高可用的一个服务软件，用来防止单点故障。类似的工具还有heartbeat、corosync、pacemaker。 但是它一般不会单独出现,而是与其它负载均衡技术(如lvs、haproxy、nginx)一起工作来达到集群的高可用。 Keepalived的作用是检测web服务器的状态，如果有一台web服务器死机，或工作出现故障，Keepalived将检测到，并将有故障的web服务器从系统中剔除，当web服务器工作正常后Keepalived自动将web服务器加入到服务器群中，这些工作全部自动完成，不需要人工干涉，需要人工做的只是修复故障的web服务器。 keepalived工作原理 keepalived是以VRRP协议为实现基础的，VRRP全称Virtual Router Redundancy Protocol，即虚拟路由冗余协议。 虚拟路由冗余协议，可以认为是实现路由器高可用的协议，即将N台提供相同功能的路由器组成一个路由器组，这个组里面有一个master和多个backup，master上面有一个对外提供服务的vip（VIP = Virtual IP Address，虚拟IP地址，该路由器所在局域网内其他机器的默认路由为该vip），master会发组播，当backup收不到VRRP包时就认为master宕掉了，这时就需要根据VRRP的优先级来选举一个backup当master。这样的话就可以保证路由器的高可用了。-keepalived主要有三个模块，分别是core、check和VRRP。core模块为keepalived的核心，负责主进程的启动、维护以及全局配置文件的加载和解析。check负责健康检查，包括常见的各种检查方式。VRRP模块是来实现VRRP协议的。 初始运行情况master 宕机情况backup 主备具体搭建配置服务器高可用环境准备 服务器名称 ip 角色 nginx-server-01 192.168.1.110 master nginx-server-02 192.168.1.99 backup tomcat-server-01 192.168.1.101 tomcat-server-02 192.168.1.102 安装keepalived 分别在主备nginx上安装keepalived 下载地址: http://www.keepalived.org/，以keepalived-l.2.24.tar.gz为例 1)解压到指定源码路径下 tar -xzvf /srv/ftp/ keepalived-l.2.24.tar.gz -c /usr/local/src cd /usr/1oca1/src/keepalived-1.2.24/ 2)需要配置keepalived的保存的输出路径: #编译配置: ./configure --prefix=/usr # 编译 make # 安装 make install 如果此时编译成功之后会自动的在“/usr/etc/”目录中出现keepalived相关的配置项，以及“/usr/sbin/”有keepalived的执行命令 配置keepalived1)修改主nginx下/usr/etc/keepalived/keepalived.conf文件 ! Configuration File for keepalived #全局配置 global_defs { notification_email { #指定keepalived在发生切换时需要发送email到的对象，一行一个 XXX@XXX.com } notification_email_from XXX@XXX.com #指定发件人 #smtp_server XXX.smtp.com #指定smtp服务器地址 #smtp_connect_timeout 30 #指定smtp连接超时时间 router_id LVS_DEVEL #运行keepalived机器的一个标识 } vrrp_instance VI_1 { state MASTER #标示状态为MASTER 备份机为BACKUP interface eth0 #设置实例绑定的网卡，机器网卡名字可用 ifconfig查看或者cat /proc/net/dev 查看 virtual_router_id 51 #同一实例下virtual_router_id必须相同 priority 100 #MASTER权重要高于BACKUP 比如BACKUP为99 advert_int 1 #MASTER与BACKUP负载均衡器之间同步检查的时间间隔，单位是秒 authentication { #设置认证 auth_type PASS #主从服务器验证方式 auth_pass 8888 } virtual_ipaddress { #设置vrip 192.168.1.100 #可以多个虚拟IP，换行即可 } } mkdir -p /etc/keepalived ;将配置文件拷贝到“/etc/keepalived” 目录下2)修改备nginx下/usr/etc/keepalived/keepalived.conf文件配置备nginx时需要注意：需要修改state为BACKUP , priority比MASTER低，virtual_router_id和master的值一致 ! Configuration File for keepalived #全局配置 global_defs { notification_email { #指定keepalived在发生切换时需要发送email到的对象，一行一个 XXX@XXX.com } notification_email_from XXX@XXX.com #指定发件人 #smtp_server XXX.smtp.com #指定smtp服务器地址 #smtp_connect_timeout 30 #指定smtp连接超时时间 router_id LVS_DEVEL #运行keepalived机器的一个标识 } vrrp_instance VI_1 { state BACKUP #标示状态为MASTER 备份机为BACKUP interface eth0 #设置实例绑定的网卡 virtual_router_id 51 #同一实例下virtual_router_id必须相同 priority 99 #MASTER权重要高于BACKUP 比如BACKUP为99 advert_int 1 #MASTER与BACKUP负载均衡器之间同步检查的时间间隔，单位是秒 authentication { #设置认证 auth_type PASS #主从服务器验证方式 auth_pass 8888 } virtual_ipaddress { #设置vrip 192.168.1.100 #可以多个虚拟IP，换行即可 } } mkdir -p /etc/keepalived ;将配置文件拷贝到“/etc/keepalived” 目录下 测试主备nginx都启动keepalived及nginx。 service keepalived start ./nginx # 查看运行状态 service keepalived status; # 查看master网卡是否有vrip /sbin/ip add show eth0 打开浏览器访问 http://192.168.1.100 ,注意是虚拟ip访问 解决nginx进程和keepalived不同时存在问题问题描述keepalived是通过检测keepalived进程是否存在判断服务器是否宕机，如果keepalived进程在但是nginx进程不在了那么keepalived是不会做主备切换，所以我们需要写个脚本来监控nginx进程是否存在，如果nginx不存在就将keepalived进程杀掉。 nginx进程检测脚本在主nginx上需要编写nginx进程检测脚本（check_nginx.sh），判断nginx进程是否存在，如果nginx不存在就将keepalived进程杀掉，check_nginx.sh内容如下： #!/bin/bash # 如果进程中没有nginx则将keepalived进程kill掉 A=`ps -C nginx --no-header |wc -l` ## 查看是否有 nginx进程 把值赋给变量A if [ $A -eq 0 ];then ## 如果没有进程值得为 零 service keepalived stop ## 则结束 keepalived 进程 fi 将check_nginx.sh拷贝至/etc/keepalived下，脚本测试：将nginx停止，将keepalived启动，执行脚本：sh /etc/keepalived/check_nginx.sh从执行可以看到自动将keepalived进程kill掉了。 修改keepalived.conf修改主nginx的keepalived.conf，添加脚本定义检测vrrp_script check_nginx 和track_script #全局配置 global_defs { notification_email { #指定keepalived在发生切换时需要发送email到的对象，一行一个 XXX@XXX.com } notification_email_from miaoruntu@itcast.cn #指定发件人 #smtp_server XXX.smtp.com #指定smtp服务器地址 #smtp_connect_timeout 30 #指定smtp连接超时时间 router_id LVS_DEVEL #运行keepalived机器的一个标识 } vrrp_script check_nginx { script &quot;/etc/keepalived/check_nginx.sh&quot; ##监控脚本 interval 2 ##时间间隔，2秒 weight 2 ##权重 } vrrp_instance VI_1 { state MASTER #标示状态为MASTER 备份机为BACKUP interface eth0 #设置实例绑定的网卡 virtual_router_id 51 #同一实例下virtual_router_id必须相同 priority 100 #MASTER权重要高于BACKUP 比如BACKUP为99 advert_int 1 #MASTER与BACKUP负载均衡器之间同步检查的时间间隔，单位是秒 authentication { #设置认证 auth_type PASS #主从服务器验证方式 auth_pass 8888 } track_script { check_nginx #监控脚本 } virtual_ipaddress { #设置vip 192.168.101.100 #可以多个虚拟IP，换行即可 } } 修改后重启keepalived 测试回到负载均衡高可用的初始状态，保证主、备上的keepalived、nginx全部启动。停止主nginx服务观察keepalived日志： tail -f /var/log/keepalived.log 可以查看keepalived进程已经不存在。可以查看eth0已经没有绑定vip","link":"/2016/10/07/%E4%B8%AD%E9%97%B4%E4%BB%B6/nginx/nginx%E7%9A%84HA%E9%AB%98%E5%8F%AF%E7%94%A8/"},{"title":"nginx在centOS安装","text":"nginx安装环境nginx是C语言开发，建议在linux上运行，本教程使用Centos6.5作为安装环境。 gcc 安装nginx需要先将官网下载的源码进行编译，编译依赖gcc环境，如果没有gcc环境，需要安装gcc：yum install gcc-c++ PCRE PCRE(Perl Compatible Regular Expressions)是一个Perl库，包括 perl 兼容的正则表达式库。nginx的http模块使用pcre来解析正则表达式，所以需要在linux上安装pcre库。 yum install -y pcre pcre-devel 注：pcre-devel是使用pcre开发的一个二次开发库。nginx也需要此库。 zlib zlib库提供了很多种压缩和解压缩的方式，nginx使用zlib对http包的内容进行gzip，所以需要在linux上安装zlib库。 yum install -y zlib zlib-devel openssl OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及SSL协议，并提供丰富的应用程序供测试或其它目的使用。 nginx不仅支持http协议，还支持https（即在ssl协议上传输http），所以需要在linux安装openssl库。 yum install -y openssl openssl-devel 编译安装将nginx-1.11.3.tar.gz拷贝至linux服务器。解压：tar -zxvf nginx-1.11.3.tar.gz -c /usr/local/srccd /usr/local/src/nginx-1.8.0下面简单介绍一些其他三方配置包 配置支持包: nginx-1.11.3.tar.gz : Nginx程序源代码; echo-nginx-module-0.59.tar.gz :信息输出模块; 安装模块示例： tar -zxvf echo-nginx-module-0.59.tar.gz -c /usr/local/src ngx_cache_purge-2.3.tar.gz :缓存清除模块; 安装模块示例： tar -zxvf ngx_cache_purge-2.3.tar.gz -c /usr/local/src nginx-upstream-fair-a18b409.tar.gz :负载均衡模块;安装模块示例： tar -zxvf nginx-upstream-fair-a18b409.tar.gz -c /usr/local/src 定义nginx编译输出目录,批量创建 mkdir -p /usr/local/nginx/{logs,conffastcgi temp,sbin,client_ body_ temp,proxy_temp,uwsgi_temp,scgi_temp} configure进入 /usr/local/src/nginx-1.11.3,准备编译 ./configure \\ --prefix=/usr/local/nginx/ \\ --sbin-path=/usr/ocal/nginx/sbin/ \\ --with-http_ ssl_ _module \\ --conf- path=/usr/local/nginx/conf/nginx.conf \\ --pid-path=/usr/local/nginx/logs/nginx.pid \\ --error-log-path=/usr/local/nginx/logs/error.log \\ --http-log-path=/usr/local/nginx/logs/access.log \\ --http-fastcgi-temp-path=/usr/local/nginx/fastcgi_temp \\ --http-client- body-temp-path=/usr/local/nginx/client_body_temp \\ --http-proxy-temp- path= /usr/local/nginx/proxy_temp \\ --http-uwsgi-temp-path=/usr/local/nginx/uwsgi_temp \\ --http-scgi-temp-path=/usr/local/nginx/scgi_temp \\ --add-module=/usr/local/src/echo-nginx-module-0.59 \\ --add-module=/usr/local/src/gnosek-nginx-upstream-fair-a18b409 \\ --add-module=/usr/local/src/ngx_cache_purge-2.3 编译安装make &amp;&amp; make install 启动nginxcd /usr/local/nginx/sbin/./nginx 注意：执行./nginx启动nginx，这里可以-c指定加载的nginx配置文件，如下： ./nginx -c /usr/local/nginx/conf/nginx.conf 如果不指定-c，nginx在启动时默认加载conf/nginx.conf文件，此文件的地址也可以在编译安装nginx时指定./configure的参数（--conf-path= 指向配置文件（nginx.conf）） 停止nginx方式1，快速停止：cd /usr/local/nginx/sbin./nginx -s stop此方式相当于先查出nginx进程id再使用kill命令强制杀掉进程。方式2，完整停止(建议使用)：cd /usr/local/nginx/sbin./nginx -s quit此方式停止步骤是待nginx进程处理任务完毕进行停止。 重启nginx方式1，先停止再启动（建议使用）：对nginx进行重启相当于先停止nginx再启动nginx，即先执行停止命令再执行启动命令。如下：./nginx -s quit./nginx方式2，重新加载配置文件：当nginx的配置文件nginx.conf修改后，要想让配置生效需要重启nginx，使用-s reload不用先停止nginx再启动nginx即可将配置信息在nginx中生效，如下：./nginx -s reload 注意关掉 iptables: service iptables stop 测试http://192.168.1.110以安装的服务器ip地址为准 开机自启动nginx编写shell脚本:wq 保存并退出 #!/bin/bash # nginx Startup script for the Nginx HTTP Server # it is v.0.0.2 version. # chkconfig: - 85 15 # description: Nginx is a high-performance web and proxy server. # It has a lot of features, but it's not for everyone. # processname: nginx # pidfile: /var/run/nginx.pid # config: /usr/local/nginx/conf/nginx.conf nginxd=/usr/local/nginx/sbin/nginx nginx_config=/usr/local/nginx/conf/nginx.conf nginx_pid=/var/run/nginx.pid RETVAL=0 prog=&quot;nginx&quot; # Source function library. . /etc/rc.d/init.d/functions # Source networking configuration. . /etc/sysconfig/network # Check that networking is up. [ ${NETWORKING} = &quot;no&quot; ] &amp;&amp; exit 0 [ -x $nginxd ] || exit 0 # Start nginx daemons functions. start() { if [ -e $nginx_pid ];then echo &quot;nginx already running....&quot; exit 1 fi echo -n $&quot;Starting $prog: &quot; daemon $nginxd -c ${nginx_config} RETVAL=$? echo [ $RETVAL = 0 ] &amp;&amp; touch /var/lock/subsys/nginx return $RETVAL } # Stop nginx daemons functions. stop() { echo -n $&quot;Stopping $prog: &quot; killproc $nginxd RETVAL=$? echo [ $RETVAL = 0 ] &amp;&amp; rm -f /var/lock/subsys/nginx /var/run/nginx.pid } # reload nginx service functions. reload() { echo -n $&quot;Reloading $prog: &quot; #kill -HUP `cat ${nginx_pid}` killproc $nginxd -HUP RETVAL=$? echo } # See how we were called. case &quot;$1&quot; in start) start ;; stop) stop ;; reload) reload ;; restart) stop start ;; status) status $prog RETVAL=$? ;; *) echo $&quot;Usage: $prog {start|stop|restart|reload|status|help}&quot; exit 1 esac exit $RETVAL 设置文件的访问权限chmod a+x /etc/init.d/nginx (a+x ==&gt; all user can execute 所有用户可执行) 加入到rc.local文件中vi /etc/rc.local加入一行 /etc/init.d/nginx start 保存并退出，下次重启会生效。 附录 nginx编译参数–prefix= 指向安装目录–sbin-path 指向（执行）程序文件（nginx）–conf-path= 指向配置文件（nginx.conf）–error-log-path= 指向错误日志目录–pid-path= 指向pid文件（nginx.pid）–lock-path= 指向lock文件（nginx.lock）（安装文件锁定，防止安装文件被别人利用，或自己误操作。）–user= 指定程序运行时的非特权用户–group= 指定程序运行时的非特权用户组–builddir= 指向编译目录–with-rtsig_module 启用rtsig模块支持（实时信号）–with-select_module 启用select模块支持（一种轮询模式,不推荐在高载环境下使用）禁用：–without-select_module–with-poll_module 启用poll模块支持（功能与select相同，与select特性相同，为一种轮询模式,不推荐在高载环境下使用）–with-file-aio 启用file aio支持（一种APL文件传输格式）–with-ipv6 启用ipv6支持–with-http_ssl_module 启用ngx_http_ssl_module支持（使支持https请求，需已安装openssl）–with-http_realip_module 启用ngx_http_realip_module支持（这个模块允许从请求标头更改客户端的IP地址值，默认为关）–with-http_addition_module 启用ngx_http_addition_module支持（作为一个输出过滤器，支持不完全缓冲，分部分响应请求）–with-http_xslt_module 启用ngx_http_xslt_module支持（过滤转换XML请求）–with-http_image_filter_module 启用ngx_http_image_filter_module支持（传输JPEG/GIF/PNG 图片的一个过滤器）（默认为不启用。gd库要用到）–with-http_geoip_module 启用ngx_http_geoip_module支持（该模块创建基于与MaxMind GeoIP二进制文件相配的客户端IP地址的ngx_http_geoip_module变量）–with-http_sub_module 启用ngx_http_sub_module支持（允许用一些其他文本替换nginx响应中的一些文本）–with-http_dav_module 启用ngx_http_dav_module支持（增加PUT,DELETE,MKCOL：创建集合,COPY和MOVE方法）默认情况下为关闭，需编译开启–with-http_flv_module 启用ngx_http_flv_module支持（提供寻求内存使用基于时间的偏移量文件）–with-http_gzip_static_module 启用ngx_http_gzip_static_module支持（在线实时压缩输出数据流）–with-http_random_index_module 启用ngx_http_random_index_module支持（从目录中随机挑选一个目录索引）–with-http_secure_link_module 启用ngx_http_secure_link_module支持（计算和检查要求所需的安全链接网址）–with-http_degradation_module 启用ngx_http_degradation_module支持（允许在内存不足的情况下返回204或444码）–with-http_stub_status_module 启用ngx_http_stub_status_module支持（获取nginx自上次启动以来的工作状态）–without-http_charset_module 禁用ngx_http_charset_module支持（重新编码web页面，但只能是一个方向–服务器端到客户端，并且只有一个字节的编码可以被重新编码）–without-http_gzip_module 禁用ngx_http_gzip_module支持（该模块同-with-http_gzip_static_module功能一样）–without-http_ssi_module 禁用ngx_http_ssi_module支持（该模块提供了一个在输入端处理处理服务器包含文件（SSI）的过滤器，目前支持SSI命令的列表是不完整的）–without-http_userid_module 禁用ngx_http_userid_module支持（该模块用来处理用来确定客户端后续请求的cookies）–without-http_access_module 禁用ngx_http_access_module支持（该模块提供了一个简单的基于主机的访问控制。允许/拒绝基于ip地址）–without-http_auth_basic_module禁用ngx_http_auth_basic_module（该模块是可以使用用户名和密码基于http基本认证方法来保护你的站点或其部分内容）–without-http_autoindex_module 禁用disable ngx_http_autoindex_module支持（该模块用于自动生成目录列表，只在ngx_http_index_module模块未找到索引文件时发出请求。）–without-http_geo_module 禁用ngx_http_geo_module支持（创建一些变量，其值依赖于客户端的IP地址）–without-http_map_module 禁用ngx_http_map_module支持（使用任意的键/值对设置配置变量）–without-http_split_clients_module 禁用ngx_http_split_clients_module支持（该模块用来基于某些条件划分用户。条件如：ip地址、报头、cookies等等）–without-http_referer_module 禁用disable ngx_http_referer_module支持（该模块用来过滤请求，拒绝报头中Referer值不正确的请求）–without-http_rewrite_module 禁用ngx_http_rewrite_module支持（该模块允许使用正则表达式改变URI，并且根据变量来转向以及选择配置。如果在server级别设置该选项，那么他们将在 location之前生效。如果在location还有更进一步的重写规则，location部分的规则依然会被执行。如果这个URI重写是因为location部分的规则造成的，那么 location部分会再次被执行作为新的URI。 这个循环会执行10次，然后Nginx会返回一个500错误。）–without-http_proxy_module 禁用ngx_http_proxy_module支持（有关代理服务器）–without-http_fastcgi_module 禁用ngx_http_fastcgi_module支持（该模块允许Nginx 与FastCGI 进程交互，并通过传递参数来控制FastCGI 进程工作。 ）FastCGI一个常驻型的公共网关接口。–without-http_uwsgi_module 禁用ngx_http_uwsgi_module支持（该模块用来医用uwsgi协议，uWSGI服务器相关）–without-http_scgi_module 禁用ngx_http_scgi_module支持（该模块用来启用SCGI协议支持，SCGI协议是CGI协议的替代。它是一种应用程序与HTTP服务接口标准。它有些像FastCGI但他的设计更容易实现。）–without-http_memcached_module 禁用ngx_http_memcached_module支持（该模块用来提供简单的缓存，以提高系统效率）-without-http_limit_zone_module 禁用ngx_http_limit_zone_module支持（该模块可以针对条件，进行会话的并发连接数控制）–without-http_limit_req_module 禁用ngx_http_limit_req_module支持（该模块允许你对于一个地址进行请求数量的限制用一个给定的session或一个特定的事件）–without-http_empty_gif_module 禁用ngx_http_empty_gif_module支持（该模块在内存中常驻了一个1*1的透明GIF图像，可以被非常快速的调用）–without-http_browser_module 禁用ngx_http_browser_module支持（该模块用来创建依赖于请求报头的值。如果浏览器为modern ，则$modern_browser等于modern_browser_value指令分配的值；如果浏览器为old，则$ancient_browser等于 ancient_browser_value指令分配的值；如果浏览器为 MSIE中的任意版本，则 $msie等于1）–without-http_upstream_ip_hash_module 禁用ngx_http_upstream_ip_hash_module支持（该模块用于简单的负载均衡）–with-http_perl_module 启用ngx_http_perl_module支持（该模块使nginx可以直接使用perl或通过ssi调用perl）–with-perl_modules_path= 设定perl模块路径–with-perl= 设定perl库文件路径–http-log-path= 设定access log路径–http-client-body-temp-path= 设定http客户端请求临时文件路径–http-proxy-temp-path= 设定http代理临时文件路径–http-fastcgi-temp-path= 设定http fastcgi临时文件路径–http-uwsgi-temp-path= 设定http uwsgi临时文件路径–http-scgi-temp-path= 设定http scgi临时文件路径-without-http 禁用http server功能–without-http-cache 禁用http cache功能–with-mail 启用POP3/IMAP4/SMTP代理模块支持–with-mail_ssl_module 启用ngx_mail_ssl_module支持–without-mail_pop3_module 禁用pop3协议（POP3即邮局协议的第3个版本,它是规定个人计算机如何连接到互联网上的邮件服务器进行收发邮件的协议。是因特网电子邮件的第一个离线协议标准,POP3协议允许用户从服务器上把邮件存储到本地主机上,同时根据客户端的操作删除或保存在邮件服务器上的邮件。POP3协议是TCP/IP协议族中的一员，主要用于支持使用客户端远程管理在服务器上的电子邮件）–without-mail_imap_module 禁用imap协议（一种邮件获取协议。它的主要作用是邮件客户端可以通过这种协议从邮件服务器上获取邮件的信息，下载邮件等。IMAP协议运行在TCP/IP协议之上，使用的端口是143。它与POP3协议的主要区别是用户可以不用把所有的邮件全部下载，可以通过客户端直接对服务器上的邮件进行操作。）–without-mail_smtp_module 禁用smtp协议（SMTP即简单邮件传输协议,它是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。SMTP协议属于TCP/IP协议族，它帮助每台计算机在发送或中转信件时找到下一个目的地。）–with-google_perftools_module 启用ngx_google_perftools_module支持（调试用，剖析程序性能瓶颈）–with-cpp_test_module 启用ngx_cpp_test_module支持–add-module= 启用外部模块支持–with-cc= 指向C编译器路径–with-cpp= 指向C预处理路径–with-cc-opt= 设置C编译器参数（PCRE库，需要指定–with-cc-opt=”-I /usr/local/include”，如果使用select()函数则需要同时增加文件描述符数量，可以通过–with-cc- opt=”-D FD_SETSIZE=2048”指定。）–with-ld-opt= 设置连接文件参数。（PCRE库，需要指定–with-ld-opt=”-L /usr/local/lib”。）–with-cpu-opt= 指定编译的CPU，可用的值为: pentium, pentiumpro, pentium3, pentium4, athlon, opteron, amd64, sparc32, sparc64, ppc64–without-pcre 禁用pcre库–with-pcre 启用pcre库–with-pcre= 指向pcre库文件目录–with-pcre-opt= 在编译时为pcre库设置附加参数–with-md5= 指向md5库文件目录（消息摘要算法第五版，用以提供消息的完整性保护）–with-md5-opt= 在编译时为md5库设置附加参数–with-md5-asm 使用md5汇编源–with-sha1= 指向sha1库目录（数字签名算法，主要用于数字签名）–with-sha1-opt= 在编译时为sha1库设置附加参数–with-sha1-asm 使用sha1汇编源–with-zlib= 指向zlib库目录–with-zlib-opt= 在编译时为zlib设置附加参数–with-zlib-asm= 为指定的CPU使用zlib汇编源进行优化，CPU类型为pentium, pentiumpro–with-libatomic 为原子内存的更新操作的实现提供一个架构–with-libatomic= 指向libatomic_ops安装目录–with-openssl= 指向openssl安装目录–with-openssl-opt 在编译时为openssl设置附加参数–with-debug 启用debug日志","link":"/2016/08/05/%E4%B8%AD%E9%97%B4%E4%BB%B6/nginx/nginx%E7%9A%84%E5%AE%89%E8%A3%85/"},{"title":"Redis第一篇 环境搭建","text":"安装运行Redis前提是在Linux系统中已经装有gcc-c++, 因为 Redis 是C语言开发的。 版本说明本教程使用redis3.0版本。3.0版本主要增加了redis集群功能。 源码下载从官网下载http://download.redis.io/releases/redis-3.0.0.tar.gz将redis-3.0.0.tar.gz拷贝到/usr/local/src下 解压源码 tar -zxvf redis-3.0.0.tar.gz -c /usr/local/src/ 进入解压后的目录进行编译 cd /usr/local/src/redis-3.0.0 &amp;&amp; make 安装到指定目录,如 /usr/local/redis cd /usr/local/src/redis-3.0.0 make PREFIX=/usr/local/redis install 拷贝配置文件到安装目录下redis.conf是redis的配置文件，redis.conf在redis源码目录。注意修改port作为redis进程的端口,port默认6379。 进入源码目录，里面有一份配置文件 redis.conf，然后将其拷贝到安装路径下 cd /usr/local/redis mkdir conf cp /usr/local/src/redis-3.0.0/redis.conf /usr/local/redis/conf 设置系统级别的内存分配策略 echo &quot;vm.overcomm1t memory一l&quot; S &gt;&gt; /etc/sysctl.conf , 然后sysctl -p使配置文件生效 # 内核参数overcommit_memory 它是 内存分配策略 # 可选值：0、1、2。 # 0， 表示内核将检查是否有足够的可用内存供应用进程使用；如果有足够的可用内存，内存申请允许；否则，内存申请失败，并把错误返回给应用进程。 # 1， 表示内核允许分配所有的物理内存，而不管当前的内存状态如何。 # 2， 表示内核允许分配超过所有物理内存和交换空间总和的内存 有三类文件需要做保存: Redis运行时的pid、 Redis相关处理日志、Redis的数据文件 mkdir -p /usr/data/redis/{run,1ogs,dbcache} 修改 redis.conf文件 vim /usr/local/redis/conf/redis.conf NO 修改项 修改值 1、 配置Redis运行端口: port 6379. 2、 配置Redis是否为后台运行: daemonize yes 3、 设置进程保存路径: pidfile /usr/data/redis/run/redis_6379.pid 4、 设置日志保存目录: logfile “/usr/data/redis/logs/redis.log” 5、 该Redis支持的数据库个数: databases 16 6、 保存数据文件目录: dir /usr/data/redis/dbcache 7、 修改密码认证登录redis-cli -h 127.0.0.1 -p 6379 -a ecit@123456 requirepass ecit@123456 redis3.0新增的redis-sentinel是redis集群管理工具可实现高可用。 Redis启动，关闭，连接前端模式启动 直接运行bin/redis-server将以前端模式启动，前端模式启动的缺点是ssh命令窗口关闭则redis-server程序结束，不推荐使用此方法。 后端模式启动修改redis.conf配置文件， daemonize yes 以后端模式启动。执行如下命令启动redis： cd /usr/local/redis/bin &amp;&amp; ./redis-server /usr/local/redis/conf/redis.conf #redis默认使用6379端口。 启动多个Redis进程方法1：启动时指定端口可在一台服务器启动多个redis进程。 cd /usr/local/redis/bin &amp;&amp; ./redis-server /usr/local/redis/conf/redis.conf --port 6380 方法2(推荐此方法)：创建多个redis目录，以端口号命名，比如：创建6379、6380两个目录，将redis的安装文件bin和conf拷贝至这两个目录。修改6379目录下的redis.conf设置端口号为6379修改6380目录下的redis.conf设置端口号为6380启动6379和6380目录下的redis-server程序： cd 6379 &amp;&amp; ./redis-server . /conf/redis.conf cd 6380 &amp;&amp; ./redis-server . /conf/redis.conf 查询当前redis的进程： ps aux | grep redis Redis 停止直接使用killall redis-server干掉所有的Redis服务。强行终止Redis进程可能会导致redis持久化数据丢失。正确停止Redis的方式应该是向Redis发送SHUTDOWN命令，方法为： cd /usr/local/redis/bin &amp;&amp; ./redis-cli shutdown Redis命令行客户端在redis的安装目录中有redis的客户端，即redis-cli（Redis Command Line Interface），它是Redis自带的基于命令行的Redis客户端。 连接redis服务器 redis-cli -h 192.168.1.11 -p 6379 向Redis服务器发送命令 pingRedis提供了PING命令来测试客户端与Redis的连接是否正常，如果连接正常会收到回复PONG set/get使用set和get可以向redis设置数据、获取数据。 set name 张三丰 get name **del** 删除指定key的内容。例如：del name **Keys** 查看当前库中所有的key值 Redis多数据库Redis实例 一个redis进程就是一个redis实例，一台服务器可以同时有多个redis实例，不同的redis实例提供不同的服务端口对外提供服务，每个redis实例之间互相影响。每个redis实例都包括自己的数据库，数据库中可以存储自己的数据。 多数据库测试 一个Redis实例可以包括多个数据库，客户端可以指定连接某个redis实例的哪个数据库，就好比一个mysql中创建多个数据库，客户端连接时指定连接哪个数据库。 一个redis实例最多可提供16个数据库，下标从0到15，客户端默认连接第0号数据库，也可以通过select选择连接哪个数据库，如下连接1号库：select 1在1号库中查询上节在0号数据库设置的数据，结果查询不到,重新选择第0号数据库(select 0)，可查询到数据如果选择一个不存在数据库则会报错(select 16):invalid DB index注意：redis不支持修改数据库的名称，只能通过select 0、select 1…选择数据库。 Redis需要注意的问题在0号数据库存储数据，在1号数据库执行清空数据命令（flushall）却把0号数据库的数据给清空了：建议：不同的应用系统要使用不同的redis实例而不是使用同一个redis实例下的不同数据库。 Redis的性能测试/usr/local/redis/bin/redis-benchmark -h 127.0.0.1 -p 6379 -c 10000 -d 10 -n 10000.此时的命令之中的具体参数含义如下:. “-h”: 要连接的Redis服务器的地址; “-p”: 要连接Redis的运行端口; -c”: 指的是模拟的客户端数量; “-d”: 每一次操作的数据长度; “-n”: 每一个用户发出的请求数量。","link":"/2016/03/02/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/redis-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"title":"Redis高可用-五种集群设计方案分析","text":"主从复制（读写分离） 主从复制的好处有2点： 1、避免redis单点故障，可以自动对数据做备份; 2、构建读写分离架构，满足读多写少的应用场景 主从架构缺点 主从设计模式的最大缺点在于:只能够做备份，而出现灾难之后无法自动恢复数据 主从架构(是其它集群解决方案的基础) 环境准备(可参看redis应用基础操作)如果要想实现主从模式的配置，首先一定要准备出三台Redis实例，分别对应的端口为:6379、6380、 6381， 其中6379运行的Redis服务为主服务，其它端口运行的是从服务。1、如果要想进行主从的模式匹配，主服务器.上不需要做出任何的变化。2、所有的从服务的配置文件( redis-6380.conf、redis-6381.conf)必须要求明确的设置出它对应的主服务器,如下操作：#slaveof &lt;masterip&gt; &lt;masterport&gt; slaveof 192.168.1.163 6379 #masterauth &lt;master-password&gt; masterauth ecit@123456 3、 启动所有的Redis数据服务:/usr/local/redis/bin/redis-server /usr/ocal/redis/conf/redis-6379.conf /usr/local/redis/bin/redis-server /usr/local/redis/conf/redis-6380.conf /usr/local/redis/bin/redis-server /usr/local/redis/conf/redis-6381.conf 4、登录6379端口的Redis服务(主服务)查看所有的副本信息:/usr/local/redis/bin/redis-cli -h 192.168.1.163 -p 6379 -a ecit@123456 info replication # 输出以下信息： # role:master # connected slaves:2. # slave0:ip=192.168.1.163,port=6380,state=online,offset=99,lag=0. # slave1:ip=192.168.1.163,port=6381,state=online,offset=99,lag=0. 5、测试 操作主节点(6379) 的数据: set name java.随后退出此客户端，随意登录6380或6381的主机: get name; 可以看出从主节点进行数据的设置，而后会自动同步到所有的从节点，两台从节点只有 only-read的权限 哨兵（sentinel）机制的集群解决方案什么是哨兵 Redis哨兵是**redis官方推荐的redis高可用(HA)**解决方案之一,它的功能： 监控( Monitoring ) , sentinel 时刻监控着redis master-slave是否正常运行; 通知( Notification ) , sentinel可以通过api来通知管理员,被监控的redis master-slave出现了问题; 自动故障转移( Automatic failover ) , 当redis master出现故障不可用状态, sentinel会开始一次故障转移,将其中一个slave提升为新的master , 将其他的slave将重新配置使用新的master同步,并使用Redis的服务器应用程序在连接时收到使用新的地址连接; 配置提供者(Configuration provider), sentinel作为在集群中的权威来源,客户端连接到sentinel来获取某个服务的当前Redis主服务器的地址和其他信息。当故障转移发生时，Sentinel 会报告新地址。 哨兵机制实现 1、启动三个模拟的主从redis服务器 /usr/local/redis/bin/redis-server /usr/ocal/redis/conf/redis-6379.conf /usr/local/redis/bin/redis-server /usr/local/redis/conf/redis-6380.conf /usr/local/redis/bin/redis-server /usr/local/redis/conf/redis-6381.conf 2、通过redis 源代码拷贝出哨兵运行程序: cp /usr/local/src/redis-3.0.0/src/redis-sentinel /usr/local/redis/bin/ 3、所有的哨兵如果要想运行一定要准备出一个配置文件: sentinel.conf,可以参考源码 /usr/local/src/redis-3.0.0/sentinel.conf模板文件 4、建立sentinel-26379.conf配置文件: 建立一个哨兵的配置文件目录: mkdir -p /usr/data/redis/{sentinel-26379,sentinel-26380,sentinel-26381} vim /usr/local/redis/conf/sentinel-26379.conf port 26379 dir /usr/data/redis/sentinel-26379 sentinel monitor mymaster 192.168.1.163 6379 2 sentinel auth-pass mymaster ecit@123456 sentinel down-after-milliseconds mymaster 30000 sentinel failover-timeout mymaster 180000 sentinel parallel-syncs mymaster 1 protected-mode no 配置哨兵监听端口: port 26379 配置哨兵的工作目录: dir /usr/data/redis/sentinel-26379 设置监控的 master: sentinel monitor mymaster 192.168.1.163 6379 2 设置的mymaster只是一个代表名称，如果你一个哨兵监控多个master，则这个名称一定要有所不同。“2”表示如果有两个哨兵认为你出现了问题，则重新选举新master替换 设置master的认证信息: sentinel auth-pass mymaster ecit@123456 设置master不活跃的时间: sentinel down-after-milliseconds mymaster 30000 选举新的master 失败时间: sentinel failover-timeout mymaster 180000 只有一个 master 同步: sentinel parallel-syncs mymaster 1 撤销Redis保护模式: protected-mode no 随后按照这样的配置分别建立sentinel-26380.conf、sentinel-26381.conf两个配置文件 #sentinel-26380.conf配置 port 26380 dir /usr/data/redis/sentinel-26380 sentinel monitor mymaster 192.168.1.163 6379 2 sentinel auth-pass mymaster ecit@123456 sentinel down-after-milliseconds mymaster 30000 sentinel failover-timeout mymaster 180000 sentinel parallel-syncs mymaster 1 protected-mode no #sentinel-26381.conf配置 port 26381 dir /usr/data/redis/sentinel-26381 sentinel monitor mymaster 192.168.1.163 6379 2 sentinel auth-pass mymaster ecit@123456 sentinel down-after-milliseconds mymaster 30000 sentinel failover-timeout mymaster 180000 sentinel parallel-syncs mymaster 1 protected-mode no 5、启动哨兵程序 /usr/local/redis/bin/redis-sentinel /usr/local/redis/conf/sentinel-26379.conf /usr/local/redis/bin/redis-sentinel /usr/local/redis/conf/sentinel-26380.conf /usr/local/redis/bin/redis-sentinel /usr/local/redis/conf/sentinel-26381.conf 通过哨兵的信息输出可以发现如下特点: “+slave”：当一个哨兵启动之后如果已经确定可以连接到了master节点，则自动追加所有slave节点， “+sentinel”:每当启动一个新的哨兵进程后会自动进行哨兵增加的信息 6、模拟宕机 直接kill掉当前监控的master主机，随后会发现有如下提示信息:. “+sdown master mymaster 192.168.1.163 6379”: 当前的master主机已经下线 “+vote-for-leader”: 进行重新的投票选举;。 ”+slave-reconf-sent slave 192.168.1.163:6381”: 从主机会自动修改redis.conf “+switch-master mymaster 192.168.1.163 6379 192.168.1.163 6380” 6380端口的redis成为了master 7、如果此时的6379的进程又重新启动成功了,那么这个时候可以考虑通过命令做一个从的设置，一定要求设置好redis-6379.conf配置文件中的masterauth属性，如果不进行此项配置则无法连接到master主机。 代码示例连接哨兵 @Test public void testSentinel() { String masterName = &quot;mymaster&quot;; String authPass = &quot;ecit@123456&quot;; JedisPoolConfig jedisPoolConfig = new JedisPoolConfig(); jedisPoolConfig.setMaxTotal(10); jedisPoolConfig.setMaxIdle(5); jedisPoolConfig.setMinIdle(5); // 哨兵信息 Set&lt;String&gt; sentinels = new HashSet&lt;&gt;(Arrays.asList(&quot;192.168.1.163:26379&quot;,&quot;192.168.1.163:26380&quot;,&quot;192.168.1.163:26381&quot;)); // 创建连接池 JedisSentinelPool pool = new JedisSentinelPool(masterName, sentinels,jedisPoolConfig,authPass); // 获取客户端 Jedis jedis = pool.getResource(); // 执行两个命令 jedis.set(&quot;name&quot;, &quot;ecit&quot;); String value = jedis.get(&quot;name&quot;); System.out.println(value); } twemproxy代理(Keepalived) + HAProxy机制集群方案 而推特网站发布了一个代理机制，可以有效的实现不同的算法，实现不同主机的分片存储，以保证负载均衡，同时可以结合keepalived组件实现twemproxy Twemproxy是一个专门为了这种nosql数据库设计的一款代理工具软件，这个工具软件最大的特征是可以实现数据的分片处理 Twemproxy ,也叫nutcraker。是一个twitter开源的一个redis和memcache快速/轻量级代理服务器; Twemproxy是一个快速的单线程代理程序,支持Memcached ASCII协议和更新的Redis协议; Twemproxy通过引入一个代理层,可以将其后端的多台redis或Memcached实例进行统一管理与分配,使应用程序只需要在Twemproxy上进行操作,而不用关心后面具体有多少个真实的Redis或Memcached存储; GITHUB地址: https://github.com/twitter/twemproxy ; twemproxy的特性 支持失败节点自动删除 可以设置重新连接该节点的时间 可以设置连接多少次之后删除该节点 支持设置HashTag 通过HashTag可以自己设定将两个key哈希到同一个实例上去 减少与redis的直接连接数 保持与redis的长连接 减少了客户端直接与服务器连接的连接数量 自动分片到后端多个redis实例上 多种hash算法: md5、crc16、 crc32、crc32a、 fnv1_64、fnv1a_64、fnv1_32、fnvla_32、 hsieh、 murmur、 jenkins 多种分片算法: ketama(一致性hash算法的一种实现)、 modula、 random 可以设置后端实例的权重 避免单点问题 可以平行部署多个代理层，通过HAProxy做负载均衡,将redis的读写分散到多个twemproxy上。 支持状态监控 可设置状态监控ip和端口 , 访问ip和端口可以得到一个json格式的状态信息串,可设置监控信息刷新间隔时间 使用pipelining处理请求和响应 连接复用,内存复用,将多个连接请求,组成reids pipelining统一向redis请求 并不是支持所有redis命令 不支持redis的事务操作 **使用SDIFF, SDIFFSTORE, SINTER, SINTERSTORE, SMOVE, SUNION and SUNIONSTORE 命令需要保证key都在同一个分片上。redis cluster codis(最好的解决方案推荐用这种)","link":"/2016/03/04/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/redis%E9%AB%98%E5%8F%AF%E7%94%A8/"},{"title":"Redis第二篇 理论应用基础操作","text":"NoSQL数据库的四大分类如下: 键值(Key-Value)存储数据库相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB、Oracle BDB、 MemcacheDB典型应用： 内容缓存，主要用于处理大量数据的高访问负载。数据模型： 一系列键值对,采用Hash表结构存储（简单、易部署）优势： 快速查询劣势： 存储的数据缺少结构化 列存储数据库相关产品：Cassandra, HBase, Riak典型应用：分布式的文件系统数据模型：以列簇式存储，将同一列数据存在一起，应对分布式存储的海量数据优势：查找速度快，可扩展性强，更容易进行分布式扩展劣势：功能相对局限 文档型数据库相关产品：CouchDB、MongoDB、SequoiaDB典型应用：Web应用（与Key-Value类似，Value是结构化的）数据模型： 采用类似JSON的形式存储优势：数据结构要求不严格劣势： 查询性能不高，而且缺乏统一的查询语法 图形(Graph)数据库相关数据库：Neo4J、InfoGrid、Infinite Graph、FlockDB典型应用：社交网络数据模型：图结构优势：利用图结构相关算法。劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。 对象存储：通过类似面向对象语言的语法操作数据库。相关产品：db4o、 Versant xml数据库：高效的存储XML数据，并支持XML的内部查询语法，比如XQuery，Xpath。相关产品：Berkeley DB XML、BaseX Redis的介绍 redis是一个nosql(not only sql不仅仅只有sql)数据库.翻译成中文叫做非关系型型数据库.关系型数据库:以二维表形式存储数据非关系型数据库: 以键值对形式存储数据(key, value形式)是一家意大利的创业公司出的,然后后来这家公司被VMware赞助. redis底层用C语句编写. redis是将数据存放到内存中,由于内容存取速度快所以redis被广泛应用在互联网项目中, redis优点:存取速度快,官方称读取速度会达到30万次每秒,写速度在10万次每秒最有,具体限制于硬件. 缺点:对持久化支持不够良好,所以redis一般不作为数据的主数据库存储,一般配合传统的关系型数据库使用. 超大规模和高并发的SNS类型的web2.0纯动态网站，暴露了很多难以克服的问题，例如： 1、High performance - 对数据库高并发读写的需求web2.0网站要根据用户个性化信息来实时生成动态页面和提供动态信息，所以基本上无法使用动态页面静态化技术，因此数据库并发负载非常高，往往要达到每秒上万次读写请求。关系数据库应付上万次SQL查询还勉强顶得住，但是应付上万次SQL写数据请求，硬盘IO就已经无法承受了。其实对于普通的BBS网站，往往也存在对高并发写请求的需求，例如网站的实时统计在线用户状态，记录热门帖子的点击次数，投票计数等，因此这是一个相当普遍的需求。 2、Huge Storage - 对海量数据的高效率存储和访问的需求类似Facebook，twitter，Friendfeed这样的SNS网站，每天用户产生海量的用户动态，以Friendfeed为例，一个月就达到了2.5亿条用户动态，对于关系数据库来说，在一张2.5亿条记录的表里面进行SQL查询，效率是极其低下乃至不可忍受的。再例如大型web网站的用户登录系统，例如腾讯，盛大，动辄数以亿计的帐号，关系数据库也很难应付。 3、High Scalability &amp;&amp; High Availability- 对数据库的高可扩展性和高可用性的需求在基于web的架构当中，数据库是最难进行横向扩展的，当一个应用系统的用户量和访问量与日俱增的时候，你的数据库却没有办法像web server和app server那样简单的通过添加更多的硬件和服务节点来扩展性能和负载能力。对于很多需要提供24小时不间断服务的网站来说，对数据库系统进行升级和扩展是非常痛苦的事情，往往需要停机维护和数据迁移。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。 redis特点 异常快速： Redis是非常快的，每秒可以执行大约110000设置操作， 81000个/海秒的读取操作。 支持丰富的数据类型： Redis支持最大多数开发人员已经知道如列表，集合，可排序集合，哈希等数据类型。 原子性操作：所有Redis的操作都是原子，从而确保当两个客户同时访问Redis服务器得到的是更新后的值（最新值）。 MultiUtility工具： Redis是一个多功能实用工具，可以在很多如：缓存，消息传递队列中使用（ Redis原生支持发布/订阅） ， 在应用程序中，如： Web应用程序会话，网站页面点击数等任何短暂的数据. Redis应用领域 分布式缓存 数据查询、短连接、新闻内容、商品内容等等 （mybatis，hibernate虽有二级缓存但性能不好，企业一般不用） 分布式session 分布式集群架构中的session分离。 聊天室的在线好友列表。 任务队列。（秒杀、抢购、12306等等） 应用排行榜 网站访问统计。 数据过期处理（可以精确到毫秒) 保存博客或者论坛的留言回复等. (像文档型text类型或者小说更倾向于 mongodb来存储) 总之是用在数据量大,并发量高的情况下 Redis支持的键值对类型： 1.字符串类型string #字符串数据操作示例： ➢设置操作数据: set KEY VALUE ; set username-ecit hello ➢查询数据:get KEY; get username-ecit ➢不覆盖设置: setnx KEY VALUE ; 此时KEY必须是不存在库里的才行，否则会设置失败返回 0. ➢设置数据有效期: setex KEY TIME VALUE ; setex 110-code 10 8789 设置验证码(8789)在10s后过期；用ttl 110-code 查看验证码失效剩余时间效果，如果过期了返回-2；persist 110-code 让该key取消有效时间，这时 ttl 110-code返回-1 ➢设置多个key : mset KEY1 VALUE1 KEY2 VALUE2 .... ; mset username-110 hello username-119 world ➢不覆盖设置多个key : msetnx KEY1 VALUE1 KEY2 VALUE2 ... ; ➢追加内容: append KEY 追加内容; append 110-code 999 返回当前字符串的长度 ➢取得数据长度: strlen KEY ; ➢删除指定数据: del key key key ; del 110-code username-1 username-99 如果现在指定的key不存在，也不会影响到程序的执行，只会删除掉存在的key值； ➢自增处理:incr KEY; ➢自增指定数据: incrby KEY 数字; ➢自减处理:decr KEY; ➢自减指定数据: decrby KEY ; 2.散列类型Hash 一般应用于将redis作为分布式缓存,存储数据库中的数据对象 #散列(Hash)类型操作示例： ➢存放hash数据: hset 对象KEY 属性KEY 内容; hset user-ecit uid 001 ➢取得hash数据: hget 对象KEY 属性KEY ; hget user-ecit uid ;hset user-ecit uname 张三丰 ➢不覆盖设置: hsetnx 对象KEY 属性KEY 内容; ➢批量设置: hmset 对象KEY 属性KEY1 内容1 属性KEY2 内容2 ... ; ➢获取对象的所有key : hmget 对象KEY 属性KEY1 属性KEY2 .. ; hmget user-ecit uid uname ➢判断某个数据是否存在: hexists 对象KEY 属性KEY ; hexists user-ecit uid ➢取得全部内容数量: hlen KEY ; hlen user-ecit 返回属性数量 ➢删除指定key信息: hdel 对象KEY 属性KEY .... ; ➢取得所有key : hkeys 对象KEY ; hkeys user-ecit ➢取得hash中所有内容: hvals 对象KEY ; hvals user-ecit ➢获得全部的key与value : hgetall 对象KEY ; hgetall user-ecit ➢数据加法: hincrby 对象KEY 数字; 3.列表类型list redis中使用的是双向循环链表来实现的list,在redis中更像栈，先进后出 ➢向左边顶部压入栈中存放数据: lpush LIST集合KEY 内容; lpush searchkeys java c c++ php c# ➢取得指定索引位置的内容: lrange 集合KEY 头部索引 尾部索引; lrange searchkeys 0 1 输出 c# php ;lrange searchkeys 0 -1 输出全部数据 ➢从右边尾部保存元素: rpush 集合KEY 内容; rpush searchkeys 1 2 3 4 5 ➢在指定元素前追加内容: linsert 集合KEY before 内容1 增加内容; linsert searchkeys before c# sql 此时sql在栈顶了 | linsert searchkeys after sql mysql 此时sql已然在栈顶，紧接着是mysql #如果此时你保存的集合内容存放有重复的数据，则以栈顶第一个数据位置为准，进行插入操作 ➢修改指定索引的内容: lset 集合KEY 索引 内容; lset searchkeys 0 ruby :修改栈顶元素，改为ruby值 ➢删除数据:lrem 集合KEY 重复个数 删除内容; LREM searchkeys 2 sql :删除重复的两个sql值 ➢保留指定key的值范围内的数据: ltrim 集合KEY 开始索引 结束索引; ltrim searchkeys 0 5 :保留栈顶向下的6个元素值 ➢从指定集合的头部删除元素,并返回删除元素: lpop 集合KEY ; lpop searchkeys :栈顶元素出栈 ➢从指定集合的底部删除元素,并返回删除元素: rpop 集合key ; rpop searchkeys:从栈底出栈 ➢将移除的元素添加到指定的集合中: rpoplpush 集合KEY 集合KEY ; rpoplpush searchkeys searchkeys :栈底元素出栈，然后压入栈顶 ➢取得元素指定索引的内容: lindex 集合KEY 索引; lindex searchkeys 1 :返回指定索引位置的元素 ➢返回集合中的元素个数: llen 集合KEY ; llen searchkeys:返回集合中的元素个数 4.集合类型set set中数据是无序的并且不允许重复，可以做集合操作交集、并集，差集 ➢向集合添加元素 : sadd 集合KEY 内容; sadd user-friend a b c d e ➢查询set集合: smembers 集合KEY ; smembers user-friend ➢删除集合元素: srem 集合KEY 内容; srem user-friend a ➢从集合中随机弹出一个元素,并删除: spop 集合KEY ; spop user-friend ➢返回两个集合的差集: sdiff 集合KEY1 集合KEY2 ; sadd user-f a b c d e sadd user-g a c e x y z sdiff user-f user-g :返回 b,d sdiff user-g user-f :返回 x,y,z ➢将差集保存到另外一个集合之中: sdiffstore 存储集合KEY 集合KEY1 集合KEY2 ; sdiffstore user-f-g user-f user-g :查看差集的结果保存 ➢交集计算: sinter 集合KEY1 集合KEY2 ; sinter user-f user-g ➢将交集保存到新的集合之中: sinterstore 存储集合集合KEY1 集合KEY2 ; sinterstore user-f-g-inter user-f user-g :查看交集的结果保存 ➢并集计算,将两个集合合并在一起: sunion 集合KEY1 集合KEY2 ; sunion user-f user-g:并集计算 ➢将并集进行存储 : sunionstore 存储集合集合KEY1 集合KEY2 ; sunionstore user-f-g-union user-f user-g: 查看并集保存结果 ➢ 从第一个key对应的set中移除并添加到另外一个集合之中: smove 集合KEY1 集合KEY2 第一个集合内容; smove user-f user-temp a ➢返回名称为key的集合个数 : scard 集合key ; scard user-f ➢测试member是否是名称为key的set的元素: sismember 集合KEY 内容; sismember user-f b ➢随机返回名称为key的一个集合的元素,但是不删除元素: srandmember 集合KEY ; srandmember user-f:随机返回一个 | srandmember user-f 3:随机返回三个集合 5.有序集合类型zset redis会根据分数自动排序,这里可以使用在学生成绩排序, 或者是手机应用商店流行软件排名等需求中 ➢追加有序集合数据: zadd 集合KEY 分数 内容; zadd user-d 1 pid-1: 假设用户查看该产品一次，记分数为1 ➢取出有序集合内容: zrange 集合KEY 0 -1 withscores ; zrange user-d 0 -1 :取出了集合中的全部数据的内容； zrange user-d 0 -1 withscores : 取出了集合中的全部数据的内容和分数 zrange user-d 0 2 withscores: 取出了集合中的前三个数据的内容和分数 ➢删除集合数据 :zrem 集合KEY 内容; zrem user-d pid-1 :删除该元素 ➢数据增长(针对于顺序增加) : zincrby 集合KEY 分数 内容; zincrby user-d 5 pid-2: 表示元素pid-2的分数涨5，分数变成了6 ➢返回集合中指定元素的索引数值: zrank 集合KEY 内容; zrank user-d pid-7 ➢反转取数据索引: zrevrank 集合KEY 内容; zrevrank user-d pid-3:反转取出数据索引位置 ➢反转后取得数据: zrevrange 集合 开始分数 结束分数 withscores ; zrevrange user-d 0 -1 :反转取出数据 ➢根据索引取得指定范围的数据: zrangebyscore 集合 开始分数 结束分数 withscores ;zrangebyscore user-d 0 9: 取出分数在0和9之间的数据 ➢取得集合中指定分数范围的数量: zcount 集合KEY 开始分数 结束分数; zcount user-d 0 9:分数0-9之间的数量 ➢取得指定集合中的元素个数: zcard 集合key ; zcard user-d ➢根据下标排序，删除指定范围中的数据: zremrangebyrank 集合KEY 索引开始 结束索引; zremrangebyrank user-d 0 2 :删除前三个数据 Redis事务处理 Redis本身支持事务处理，但是这种支持的事务处理本身是存在有设计缺陷的，而且与传统的关系型数据库事务不同。● 打开事务: multi;● 取消事务: discard; 会回滚到最初● 提交事务: exec。 Redis乐观锁 在数据库执行操作的时候，为了保证数据的一致性，即: A用户更新数据的时候B用户不能够更新。实现上分为两种:● 悲观锁:基于数据库的操作实现; SELECT * FROM member WHERE mid=1 FOR UPDATE .● 乐观锁:基于算法的实现,在数据表上追加一个锁的处理列;在Redis里面是直接支持有乐观锁的,想观察乐观锁的处理，则可以打开两个不同的redis-session来进行处理1、第一个Session 执行如下的操作: 设置一个数据: set age 30 进行该数据的监听: watch age 启用事务:Multi multi 2、第二个session对数据进行修改操作: 覆盖age数据: set age 500 取得age数据: get age 3.第一个session进行数据修改操作 修改数据: set age 60 提交事务: exec 此时由于第二个Session已经更新了原始的数据，那么就表示当第一个session对原始数据更新的时候会发现返回了“(nil)”， 意味着本次更新失败。 Redis性能监控redis性能监控，需要借助三方的组件，“redis-stat”工具实现Redis监控操作，地址: https://github.com/junegunn/redis-stat 1、为了更加清楚的发现redis-stat特点，下面建立三个Redis运行进程，需要准备出不同的redis.conf配置文件; 2、 建立redis数据的保存目录，要求可以同时保存三个Redis进程;mkdir -p /usr/data/redis/ {redis-6379,redis-6380,redis-6381 }/ {run,logs,dbcache} 3、 将之前的redis.conf 配置文件拷贝三份:cp /usr/local/redis/conf/redis.conf /usr/local/redis/conf/redis-6379.conf cp /usr/local/redis/conf/redis.conf /usr/local/redis/conf/redis-6380.conf cp /usr/local/redis/conf/redis conf /usr/local/redis/conf/redis-6381.conf 4、 编辑每一个配置文件，修改各自的内容，以redis-6379为例: 取消外网访问限制: #bind 127.0.0. 1 设置端口: port 6379 设置pid保存路径: pidfile /usr/data/redis/redis-6379/run/redis_6379.pid 设置日志文件路径: logfile “/usr/data/redis/redis-6379/logs/redis.log” 数据文件目录: dir /usr/data/redis/redis-6379/dbcache 5、 将redis-6379.conf 复制为redis-6380.conf、redis-6381.conf. cp /usr/local/redis/conf/redis-6379.conf /usr/local/redis/conf/redis-6380.conf cp /usr/local/redis/conf/redis-6379.conf /usr/local/redis/conf/redis-6381.conf 随后进入到每一个配置 文件进行6379内容的更新: vim redis-6380.conf 1,$s/6379/6380/g 同理，redis-6381.conf也要修改 6、 启动所有的Redis服务: /usr/local/redis/bin/redis-server /usr/local/redis/conf/redis-6379.conf /usr/local/redis/bin/redis-server /usr/local/redis/conf/redis-6380.conf /usr/local/redis/bin/redis-server /usr/local/redis/conf/redis-6381.conf 7、 通过GITHUB下载redis-stat开发包 如果要想使用redis-stat检测包必须下载ruby相关环境,ruby相关环境: apt-get install ruby ruby-dev rubygems; 将该工具下载到“/usr/local” 目录之中: cd /usr/local/;. 进行redis-stat 的下载: git clone htts://github.com/junegunn/redis-stat.git 8、下载下来的redis-stat 里面实际上只有一个执行命令,执行命令: /usr/local/redis-stat/bin/redis-stat; 如果要想使用这个命令则必须使用ruby进行该命令的处理: gem install /usr/local/redis-stat/bin/redis-stat; 9、启动redis-stat工具进行监听控制， /usr/local/redis-stat/bin/redis-stat 192.168.1.163:6379 192.168.1.163:6380 192.168.1.163:6381 -a ecit@123456 10、该工具还支持WEB启动查看，也就是说它内部自动提供有一个httpserver: /usr/local/redis-stat/bin/redis-stat 192.168.1.163:6379 192.168.1.163:6380 192.168.1.163:6381 -a ecit@123456 --server=80 --daemon --verbose jedis介绍 Redis不仅是使用命令来操作，现在基本上主流的语言都有客户端支持，比如java、C、C#、C++、php、Node.js、Go等。 在官方网站里列一些Java的客户端，有Jedis、Redisson、Jredis、JDBC-Redis、等其中官方推荐使用Jedis和Redisson。 在企业中用的最多的就是Jedis，下面我们就重点学习下Jedis。 Jedis同样也是托管在github上，地址：https://github.com/xetorthio/jedis 遇到的问题 由于linux防火墙默认开启，redis的服务端口6379并不在开放规则之内，所有需要将此端口开放访问或者关闭防火墙。 关闭防火墙命令：sevice iptables stop 如果是修改防火墙规则，可以修改：/etc/sysconfig/iptables文件 通过jedis连接redis单机&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; 单实例连接// 单实例连接redis @Test public void testJedisSingle() { Jedis jedis = new Jedis(&quot;192.168.101.3&quot;, 6379); jedis.set(&quot;name&quot;, &quot;bar&quot;); String name = jedis.get(&quot;name&quot;); System.out.println(name); jedis.close(); } 使用连接池连接 通过单实例连接redis不能对redis连接进行共享，可以使用连接池对redis连接进行共享，提高资源利用率，使用jedisPool连接redis服务，如下代码： @Test public void pool() { JedisPoolConfig config = new JedisPoolConfig(); //最大连接数 config.setMaxTotal(30); //最大连接空闲数 config.setMaxIdle(2); JedisPool pool = new JedisPool(config, &quot;192.168.101.3&quot;, 6379); Jedis jedis = null; try { jedis = pool.getResource(); jedis.set(&quot;name&quot;, &quot;lisi&quot;); String name = jedis.get(&quot;name&quot;); System.out.println(name); }catch(Exception ex){ ex.printStackTrace(); }finally{ if(jedis != null){ //关闭连接,会被会收回连接池 jedis.close(); } } } jedis与spring整合 配置spring配置文件applicationContext.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd &quot;&gt; &lt;!-- 连接池配置 --&gt; &lt;bean id=&quot;jedisPoolConfig&quot; class=&quot;redis.clients.jedis.JedisPoolConfig&quot;&gt; &lt;!-- 最大连接数 --&gt; &lt;property name=&quot;maxTotal&quot; value=&quot;30&quot; /&gt; &lt;!-- 最大空闲连接数 --&gt; &lt;property name=&quot;maxIdle&quot; value=&quot;10&quot; /&gt; &lt;!-- 每次释放连接的最大数目 --&gt; &lt;property name=&quot;numTestsPerEvictionRun&quot; value=&quot;1024&quot; /&gt; &lt;!-- 释放连接的扫描间隔（毫秒） --&gt; &lt;property name=&quot;timeBetweenEvictionRunsMillis&quot; value=&quot;30000&quot; /&gt; &lt;!-- 连接最小空闲时间 --&gt; &lt;property name=&quot;minEvictableIdleTimeMillis&quot; value=&quot;1800000&quot; /&gt; &lt;!-- 连接空闲多久后释放, 当空闲时间&gt;该值 且 空闲连接&gt;最大空闲连接数 时直接释放 --&gt; &lt;property name=&quot;softMinEvictableIdleTimeMillis&quot; value=&quot;10000&quot; /&gt; &lt;!-- 获取连接时的最大等待毫秒数,小于零:阻塞不确定的时间,默认-1 --&gt; &lt;property name=&quot;maxWaitMillis&quot; value=&quot;1500&quot; /&gt; &lt;!-- 在获取连接的时候检查有效性, 默认false --&gt; &lt;property name=&quot;testOnBorrow&quot; value=&quot;true&quot; /&gt; &lt;!-- 在空闲时检查有效性, 默认false --&gt; &lt;property name=&quot;testWhileIdle&quot; value=&quot;true&quot; /&gt; &lt;!-- 连接耗尽时是否阻塞, false报异常,ture阻塞直到超时, 默认true --&gt; &lt;property name=&quot;blockWhenExhausted&quot; value=&quot;false&quot; /&gt; &lt;/bean&gt; &lt;!-- redis单机 通过连接池 --&gt; &lt;!-- destroy-method=&quot;close&quot; 的意思是连接执行完，回收回到连接池，当然不需要显示执行 close方法，已经交给Spring容器来管理了--&gt; &lt;bean id=&quot;jedisPool&quot; class=&quot;redis.clients.jedis.JedisPool&quot; destroy-method=&quot;close&quot;&gt; &lt;constructor-arg name=&quot;poolConfig&quot; ref=&quot;jedisPoolConfig&quot;/&gt; &lt;constructor-arg name=&quot;host&quot; value=&quot;192.168.25.145&quot;/&gt; &lt;constructor-arg name=&quot;port&quot; value=&quot;6379&quot;/&gt; &lt;/bean&gt; &lt;/beans&gt; 整合操作示例： import org.junit.Before; import org.junit.Test; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; import redis.clients.jedis.Jedis; import redis.clients.jedis.JedisPool; public class JedisSpringTest { private ApplicationContext applicationContext; @Before public void setUp() throws Exception{ String configLocation = &quot;classpath:ApplicationContext.xml&quot;; applicationContext = new ClassPathXmlApplicationContext(configLocation); } @Test public void testJedisSpring() throws Exception{ //获取连接池 JedisPool jedisPool = (JedisPool)applicationContext.getBean(&quot;jedisPool&quot;); //获取连接 Jedis jedis = jedisPool.getResource(); //存入 jedis.set(&quot;key4&quot;, &quot;bbb&quot;); //取出 System.out.println(jedis.get(&quot;key4&quot;)); //这里没有执行close，是因为交给Spring容器管理了，Spring会执行回收的。 } }","link":"/2016/03/03/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/redis-%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/"},{"title":"kafka初次体验","text":"使用背景在我们大量使用分布式数据库、分布式计算集群的时候，是否会遇到这样一些问题我想分析一下用户行为（ pageviews），以便我能设计出更好的广告位我想对用户的搜索关键词进行统计，分析出前的流行趋势；有些数据，存数据库浪费，直接存硬盘操作效率又低；这个时候，就可以用消息系统了，尤其是分布式消息系统 定义kafka的定义:是一个分布式消息系统，由 Linkedin使用 scala编写，用作 Linkedin的活动流（ Activity Strean）和运营数据处理管道（ Pipeline）的基础，具有高水平扩展和高吞吐量。应用领域:已被多家不同类型的公司作为多种类型的数据管道和消息系统使用。如:淘宝，支付宝，百度， twitter等目前越来越多的开源分布式处理系统如 Apache flume、 Apache Storm、 Spark， elasticsearch都支持与 Kafka集成。 消息系统的对比 相关概念 kafka架构","link":"/2016/08/03/%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/kafka%E5%88%9D%E6%AC%A1%E4%BD%93%E9%AA%8C/"},{"title":"solr全文检索服务器初次了解","text":"solr是什么solr是 Apache下的一个顶级开源项目，采用java开发，它是基于 Lucene的全文搜索服务器。Solr提供了比 Lucene更为丰富的查询语言，同时实现了可配置、可扩展，并对索引、搜索性能进行了优化。 solr可以独立运行，运行在 Jetty、 Tomcat等这些 Servlet容器中，solr索引的实现方法很简单，用POST方法向Solr服务器发送一个描述 Field及其内容的xM文档，Solr根据xml文档添加、删除、更新索引。Solr搜索只需要发送 HTTP GET请求，然后对solr返回xml、json等格式的查询结果进行解析，组织页面布局。Solr不提供构建ui的功能，solr提供了一个管理界面，通过管理界面可以查询Solr的配置和运行情况 solr下载根据Windows 还是 Linux选择对应的软件http://mirror.bit.edu.cn/apache/lucene/solr/5.5.5/","link":"/2016/08/12/%E4%B8%AD%E9%97%B4%E4%BB%B6/solr/solr%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"title":"zookeeper初次体验","text":"zookeeper介绍 zookeeper典型应用场景数据发布/订阅数据发布/订阅顾名思义就是一方把数发布出来，另一方通过某种手段可以得到这些数据通常数订阅有两种方式:推模式和拉模式，推模式一般是服务器主动向客户端送信息，拉模式是客户端主动去服务器据（通常是采用定时轮询的方式)zK采用两种方式相结合发布者将数据发布到ZK集群节点上，订阅者通过一定的方法告诉服务器，我对哪个节点的好感兴趣，那服务器在这些节点的数据发生变化时，就通喀户端，客户端得到通知后可以去服务器获取数好信息 对DB的负载均衡1、首先DB在启动的时候先把自己在ZK上注册成一个时节点，ZK的节点后面我们会讲到有两种，一种是永久节点，类是时节点临时节点在服务器出现问题的时候，节点会自动的从zK上删除，那么这样ZK上的服务器列表就是最新的可用的表2、客户端在需要读写数据库的时候首先它去 Zookeeper得到所有可用的DB的连接信息（一张列表）3、客户端机选择一个与之建立连接4、当客户端发现连接不可用的时候可再次从ZK上获取可用的DB连接信息，当然也可以在刚获取的那个列表里移除掉不可用的连接后再随机选择一个DB与之连接3命名服务顾名思义，就是提供名称的服务，例据库表格ID，一般用得比较多的有两种D，种是自动增长的D，种是UUID（9291d71a－0354－4d8e－acd8－64f7393c64ae），两种D各自都有缺陷，自动增长的D局限在单库单表中使用，不能在分布式中使用，UUID可在分布式中使用但是由于ID没有规律难于理解，我们可以借用K来生成一个顺序增长的，可在集群境下使用的，命名易于理解的D4分布式协调通知口在分布式系统中，我们常需要知道某个机器是否可用，传统的开发中，可以通过ing某个主机来实现，ping得通说方是可心跳检测用的，相反是不可用的，zK中我们让所有的机其都注册个节点，我们判断个机器是否可用，我们只需要判断这个节点在 Anezk中是否存在就可以了，不需要直接去连接需要检查的机器，降低系统的复杂度 zookeeper的优势1、源代码开放2、已经被证实是高性能，易用稳定的工业级产品3、有着广泛的应用: Hadoop， Hbase， Storm，Solr zookeeper基本概念集群角色 会话会话是指客户端 keeper服务器的连接， Zookeeper中的会话 Session，客户端靠与服务器建立一个TCP的长连接来维持 Session，客户端在启动的时候首先会与服务器建立一个TCP连接，通过这个连接，客户端通过心跳检测与服务保持有效的会话，也能向ZK服务器发送请求并获得响应 数据节点Zookeeper中的节点有两类1.集群中的一台机器称为一个节点2.数据模型中的据单元 Znode，分为持久节点和时节点 Zookeeper的据模型是一棵树树的节点就是 Znode， Znode中可以保存信息我们看下图 版本 watcher事件监听器Zookeeper允许用户在指定节点上注册一些 Watcher，当数据节点发生变化的时候， Zookeeper服务器会把这个变化的通发送给感兴趣的落户端 ACL权限控制ACL是 Access Control Lists的简写， Zookeeper采用ACL第来进行权限控制，有以下权限 CREATE:创建子节点的权限READ:获取节点数据和子节点列表的权限WRITE:更新节点数据的权限DELETE:删除子节点的权限ADMIN:设置节点ACL的权限 zookeeper运行环境搭建 要求奇数台 1，3，5…环境准备 zookeeper配置文件介绍 集群配置文件1.最后把配好的zoo.cfg 拷贝到另外两台机子上2.在dataDir目录下新建myid文件，写入一个数字，该数字表示这是第几号server,该数字必须和zoo.cfg文件中的server.X中的X一一对应.3.启动 zkServer.sh start zookeeper注册和发现服务","link":"/2016/08/03/%E4%B8%AD%E9%97%B4%E4%BB%B6/zookeeper/zookeeper/"},{"title":"NFS网络文件系统","text":"NFS网络文件系统 NFS是Network File System的缩写,即网络文件系统。一种使用于分散式文件系统的协定,由Sun公司开发,于1984年向外公布。功能是通过网络让不同的机器、不同的操作系统能够彼此分享个别的数据,让应用程序在客户端通过网络访问位于服务器磁盘中的数据,是在类Unix系统间实现磁盘文件共享的一种方法。 获取nfs,安装在192.168.1.128这台服务器 : Ubuntu系统:apt-get install nfs-kernel-server CentOS系统:yum -y install rpcbind nfs-utils 1)需求要求将各个服务器项目目录作为共享目录，2)NFS参数参考 NO 参数名称 描述 1 ro 只读访问 2 rw 读写访问 3 sync 所有数据在请求时写入共享 4 async NFS在写入数据前可以相应请求 5 secure NFS通过1024以下的安全TCP/IP端口发送 6 insecure NFS通过1024以上的端口发送 7 wdelay 如果多个用户要写入NFS目录，则归组写入（默认） 8 no_wdelay 如果多个用户要写入NFS目录，则立即写入，当使用async时，无需此设置。 9 hide 在NFS共享目录中不共享其子目录 10 no_hide 共享NFS目录的子目录 11 subtree_check 如果共享/usr/bin之类的子目录时，强制NFS检查父目录的权限（默认） 12 no_subtree_check 和上面相对，不检查父目录权限 13 all_squash 共享文件的UID和GID映射匿名用户anonymous，适合公用目录。 14 no_all_squash 保留共享文件的UID和GID（默认） 15 root_squash root用户的所有请求映射成如anonymous用户一样的权限（默认） 16 no_root_squash root用户具有根目录的完全管理访问权限 17 anonuid=xxx 指定NFS服务器/etc/passwd文件中匿名用户的UID 18 anongid=xxx 指定NFS服务器/etc/passwd文件中匿名用户的GID 3)修改nfs配置文件 vim /etc/exports # 添加如下 /usr/data/tomcat/ecit-web *(rw, sync,no_root_squash, no_subtree_check) # *：表示所有的网段都可以访问，当然也可以设置成允许固定ip访问 # rw:表示可以读写操作 # sync:表示数据要进行同步 # no_root_squash:表示使用root权限具备完全的控制能力 # no_subtree_check：表示不受父目录的权限影响 4)开启服务 Centos系统：systemctl start rpcbind nfs-server Ubuntu系统: /etc/init.d/rpcbind start本质就是进行了一个RPC端口绑定 5)客户端挂载操作配置 mount -t nfs 192.168.1.128:/usr/data/tomcat/ecit-web /usr/data/tomcat/ecit-web # 远程服务器目录： 192.168.1.128:/usr/data/tomcat/ecit-web # 本地挂载目录: /usr/data/tomcat/ecit-web 测试在共享目录创建文件，看下是否同步，注意任何删除操作也都会同步执行后期要取消挂载的话，如下操作即可 unmount /usr/data/tomcat/ecit-web 补充拓展：当配置文件发生修改，重新载入配置 exportfs -ra **补充拓展:**开机启动 chkconfig nfs on chkconfig rpcbind on","link":"/2016/10/12/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%85%B6%E5%AE%83/NFS%E7%BD%91%E7%BB%9C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"title":"CSS第一篇","text":"字体样式字号和字体 单位：px(像素),em(字体尺寸) Google和火狐默认字体大小为 16px font-family 设置时：中文字体需要加英文状态下的引号，英文字体一般不需要加引号。当需要设置英文字体时，英文字体必须位于中文字体之前。如：body{font-family：“Microsoft YaHei”,”黑体”,“楷体”} —–正确body{font-family：”黑体”,“楷体”,“Microsoft YaHei”}—–错误 可以同时指定多个字体，中间以逗号隔开，表示如果浏览器不支持第一个字体，则会尝试下一个，直到找到合适的字体。 1. 现在网页中普遍使用14px+。 2. 尽量使用偶数的数字字号。ie6等老式浏览器支持奇数会有bug。 3. 各种字体之间必须使用英文状态下的逗号隔开。 4. 中文字体需要加英文状态下的引号，英文字体一般不需要加引号。当需要设置英文字体时，英文字体名必须位于中文字体名之前。 5. 如果字体名中包含空格、#、$等符号，则该字体必须加英文状态下的单引号或双引号，例如font-family: &quot;Times New Roman&quot;;。 6. 尽量使用系统默认字体，保证在任何用户的浏览器中都能正确显示。 CSS Unicode字体在 CSS 中设置字体名称，直接写中文是可以的。但是在文件编码（GB2312、UTF-8 等）不匹配时会产生乱码的错误。xp 系统不支持 类似微软雅黑的中文。 方案一： 你可以使用英文来替代。 比如 font-family:”Microsoft Yahei”。 方案二： 在 CSS 直接使用 Unicode 编码来写字体名称可以避免这些错误。使用 Unicode 写中文字体名称，浏览器是可以正确的解析的。font-family: “\\5FAE\\8F6F\\96C5\\9ED1”，表示设置字体为“微软雅黑”。 可以通过escape() 来测试属于什么字体。 字体名称 英文名称 Unicode 编码 宋体 SimSun \\5B8B\\4F53 新宋体 NSimSun \\65B0\\5B8B\\4F53 黑体 SimHei \\9ED1\\4F53 微软雅黑 Microsoft YaHei \\5FAE\\8F6F\\96C5\\9ED1 楷体_GB2312 KaiTi_GB2312 \\6977\\4F53_GB2312 隶书 LiSu \\96B6\\4E66 幼园 YouYuan \\5E7C\\5706 华文细黑 STXihei \\534E\\6587\\7EC6\\9ED1 细明体 MingLiU \\7EC6\\660E\\4F53 新细明体 PMingLiU \\65B0\\7EC6\\660E\\4F53 为了照顾不同电脑的字体安装问题，我们尽量只使用宋体和微软雅黑中文字体 字体设置字体综合设定选择器{font: font-style font-weight font-size/line-height font-family;} 注意：其中font-style和font-weight是可以选择不写的，但font-size 和font-family必须要有！ font-weight:字体粗细字体加粗除了用 b 和 strong 标签之外，可以使用CSS 来实现，但是CSS 是没有语义的。 font-weight属性用于定义字体的粗细，其可用属性值：normal、bold、bolder、lighter、100~900（100的整数倍）。 数字 400 等价于 normal，而 700 等价于 bold。 但是我们更喜欢用数字来表示。 font-style:字体风格字体倾斜除了用 i 和 em 标签之外，可以使用CSS 来实现，但是CSS 是没有语义的。 font-style属性用于定义字体风格，如设置斜体、倾斜或正常字体，其可用属性值如下： normal：默认值，浏览器会显示标准的字体样式。 italic：浏览器会显示斜体的字体样式。 oblique：浏览器会显示倾斜的字体样式。 平时我们很少给文字加斜体，反而喜欢给斜体标签（em，i）改为普通模式。 CSS选择器标签选择器（元素选择器）标签选择器是指用HTML标签名称作为选择器，按标签名称分类，为页面中某一类标签指定统一的CSS样式。其基本语法格式如下： 标签名{属性1:属性值1; 属性2:属性值2; 属性3:属性值3; } 或者 元素名{属性1:属性值1; 属性2:属性值2; 属性3:属性值3; } 标签选择器最大的优点是能快速为页面中同类型的标签统一样式，同时这也是他的缺点，不能设计差异化样式。 类选择器类选择器的写法 .类名{属性1:属性值1; 属性2:属性值2; 属性3:属性值3; } 类选择器最大的优势是可以为元素定义单独或相同的样式。将拥有这个类名的所有元素加上css样式样式显示效果跟HTML元素中的类名先后顺序没有关系,受css样式书写的上下顺序有关。各个类名中间用空格隔开。 1.长名称或词组可以使用中横线来为选择器命名。 2.不建议使用“_”下划线来命名CSS选择器。 浏览器兼容问题 (比如使用_tips的选择器命名，在IE6是无效的) 能良好区分JavaScript变量命名(JS变量命名是用“_”) ID选择器id选择器 #id名{属性1:属性值1; 属性2:属性值2; 属性3:属性值3; } 元素的id值是唯一的，只能对应于文档中某一个具体的元素。将拥有这个id名的唯一元素加上css样式 通配符选择器通配符选择器 *{属性1:属性值1; 属性2:属性值2; 属性3:属性值3; } 例如下面的代码，使用通配符选择器定义CSS样式，清除所有HTML标记的默认边距。 * { margin: 0; /* 定义外边距*/ padding: 0; /* 定义内边距*/ } 缺点：性能太低。一般情况不建议使用，或者直接不用。 伪类选择器 伪类选择器用于向某些选择器添加特殊的效果。比如给链接添加特殊效果， 比如可以选择 第1个，第n个元素。 为了和我们刚才学的类选择器相区别， 类选择器是一个点 比如 .demo {} 而我们的伪类 用 2个点 就是 冒号 比如 :link{} 链接伪类选择器 :link /* 未访问的链接 */ :visited /* 已访问的链接 */ :hover /* 鼠标移动到链接上 */ :active /* 选定的链接 */ 注意写的时候，他们的顺序尽量不要颠倒 按照 lvha 的顺序。 love hate 爱上了讨厌 记忆法 或者 lv 包包 非常 hao a { /* a是标签选择器 所有的链接 */ font-weight: 700; font-size: 16px; color: gray; } a:hover { /* :hover 是链接伪类选择器 鼠标经过 */ color: red; /* 鼠标经过的时候，由原来的 灰色 变成了红色 */ } 结构(位置)伪类选择器（CSS3) :first-child :选取属于其父元素的首个子元素的指定选择器 :last-child :选取属于其父元素的最后一个子元素的指定选择器 :nth-child(n) ： 匹配属于其父元素的第 N 个子元素，不论元素的类型 :nth-last-child(n) ：选择器匹配属于其元素的第 N 个子元素的每个元素，不论元素的类型，从最后一个子元素开始计数。n 可以是数字、关键词或公式 ​ li:first-child { /* 选择第一个孩子 */ color: pink; } li:last-child { /* 最后一个孩子 */ color: purple; } li:nth-child(4) { /* 选择第4个孩子 n 代表 第几个的意思 */ color: skyblue; } 目标伪类选择器(CSS3) :target目标伪类选择器 :选择器可用于选取当前活动的目标元素 :target { color: red; font-size: 30px; } CSS外观属性color:文本颜色color属性用于定义文本的颜色，其取值方式有如下3种： 1.预定义的颜色值，如red，green，blue等。 2.十六进制，如#FF0000，#FF6600，#29D794等。实际工作中，十六进制是最常用的定义颜色的方式。 3.RGB代码，如红色可以表示为rgb(255,0,0)或rgb(100%,0%,0%)。 需要注意的是，如果使用RGB代码的百分比颜色值，取值为0时也不能省略百分号，必须写为0%。 line-height:行间距line-height属性用于设置行间距，就是行与行之间的距离，即字符的垂直间距，一般称为行高。line-height常用的属性值单位有三种，分别为像素px，相对值em和百分比%，实际工作中使用最多的是像素px 一般情况下，行距比字号大7.8像素左右就可以了。 text-align:水平对齐方式text-align属性用于设置文本内容的水平对齐，相当于html中的align对齐属性。其可用属性值如下： left：左对齐（默认值） right：右对齐 center：居中对齐 text-indent:首行缩进text-indent属性用于设置首行文本的缩进，其属性值可为不同单位的数值、em字符宽度的倍数、或相对于浏览器窗口宽度的百分比%，允许使用负值, 建议使用em作为设置单位。 1em 就是一个字的宽度 如果是汉字的段落， 1em 就是一个汉字的宽度 letter-spacing:字间距letter-spacing属性用于定义字间距，所谓字间距就是字符与字符之间的空白。其属性值可为不同单位的数值，允许使用负值，默认为normal。 word-spacing:单词间距word-spacing属性用于定义英文单词之间的间距，对中文字符无效。和letter-spacing一样，其属性值可为不同单位的数值，允许使用负值，默认为normal。 word-spacing和letter-spacing均可对英文进行设置。不同的是letter-spacing定义的为字母之间的间距，而word-spacing定义的为英文单词之间的间距。 颜色半透明(css3)文字颜色到了CSS3我们可以采取半透明的格式了语法格式如下： color: rgba(r,g,b,a) a 是alpha 透明的意思 取值范围 0~1之间 color: rgba(0,0,0,0.3) 文字阴影(CSS3)以后我们可以给我们的文字添加阴影效果了 Shadow 影子前两项是必须写的。 后两项可以选写。text-shadow 属性向文本添加一个或多个阴影。该属性是逗号分隔的阴影列表，每个阴影有两个或三个长度值和一个可选的颜色值进行规定。省略的长度是 0。 text-shadow:水平位置 垂直位置 模糊距离 阴影颜色; 标签显示模式HTML标签一般分为块标签和行内标签两种类型，它们也称块元素和行内元素。具体如下： 块级元素(block-level)每个块元素通常都会独自占据一整行或多整行，可以对其设置宽度、高度、对齐等属性，常用于网页布局和网页结构的搭建。 常见的块元素有&lt;h1&gt;~&lt;h6&gt;、&lt;p&gt;、&lt;div&gt;、&lt;ul&gt;、&lt;ol&gt;、&lt;li&gt;等，其中&lt;div&gt;标签是最典型的块元素。 块级元素的特点： （1）总是从新行开始 （2）高度，行高、外边距以及内边距都可以控制。 （3）宽度默认是容器的100% （4）可以容纳内联元素和其他块元素。 行内元素(inline-level)行内元素（内联元素）不占有独立的区域，仅仅靠自身的字体大小和图像尺寸来支撑结构，一般不可以设置宽度、高度、对齐等属性，常用于控制页面中文本的样式。 常见的行内元素有&lt;a&gt;、&lt;strong&gt;、&lt;b&gt;、&lt;em&gt;、&lt;i&gt;、&lt;del&gt;、&lt;s&gt;、&lt;ins&gt;、&lt;u&gt;、&lt;span&gt;等，其中&lt;span&gt;标签最典型的行内元素。 行内元素的特点： （1）和相邻行内元素在一行上。 （2）高、宽无效，但水平方向的padding和margin可以设置，垂直方向的无效。 （3）默认宽度就是它本身内容的宽度。 （4）行内元素只能容纳文本或则其他行内元素。（a特殊） 只有 文字才 能组成段落 因此 p 里面不能放块级元素，同理还有这些标签h1,h2,h3,h4,h5,h6,dt，他们都是文字类块级标签，里面不能放其他块级元素。 链接里面不能再放链接。 块级元素和行内元素区别块级元素的特点： （1）总是从新行开始 （2）高度，行高、外边距以及内边距都可以控制。 （3）宽度默认是容器的100% （4）可以容纳内联元素和其他块元素。 行内元素的特点： （1）和相邻行内元素在一行上。 （2）高、宽无效，但水平方向的padding和margin可以设置，垂直方向的无效。 （3）默认宽度就是它本身内容的宽度。 （4）行内元素只能容纳文本或则其他行内元素。 行内块元素（inline-block）在行内元素中有几个特殊的标签——&lt;img /&gt;、&lt;input /&gt;、&lt;td&gt;，可以对它们设置宽高和对齐属性，有些资料可能会称它们为行内块元素。 行内块元素的特点： （1）和相邻行内元素（行内块）在一行上,但是之间会有空白缝隙。 （2）默认宽度就是它本身内容的宽度。 （3）高度，行高、外边距以及内边距都可以控制。 标签显示模式转换 display块转行内，display:inline行内转块，display:block块、行内元素转换为行内块，display：inline-block sublime快捷方式sublime可以快速提高我们代码的书写方式 1. 生成标签 直接输入标签名 按tab键即可 比如 div 然后tab 键， 就可以生成 &lt;div&gt;&lt;/div&gt; 2. 如果想要生成多个相同标签 加上 * 就可以了 比如 div*3 就可以快速生成3个div 3. 如果有父子级关系的标签，可以用 &gt; 比如 ul &gt; li就可以了 4. 如果有兄弟关系的标签，用 + 就可以了 比如 div+p 5. 如果生成带有类名或者id名字的， 直接写 .demo 或者 #two tab 键就可以了 CSS样式表引入的三种方式行内样式表（内联样式）是通过标签的style属性来设置元素的样式，其基本语法格式如下： &lt;标签名 style=&quot;属性1:属性值1; 属性2:属性值2; 属性3:属性值3;&quot;&gt; 内容 &lt;/标签名&gt; 语法中style是标签的属性，实际上任何HTML标签都拥有style属性，用来设置行内式。其中属性和值的书写规范与CSS样式规则相同，行内式只对其所在的标签及嵌套在其中的子标签起作用。示例： &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div style=&quot;color: red&quot;&gt;行内样式表&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 内部样式表（内嵌式）内嵌式是将CSS代码集中写在HTML文档的head头部标签中，并且用style标签定义，其基本语法格式如下： &lt;head&gt; &lt;style type=&quot;text/css&quot;&gt; 选择器 {属性1:属性值1; 属性2:属性值2; 属性3:属性值3;} &lt;/style&gt; &lt;/head&gt; 语法中，style标签一般位于head标签中title标签之后，也可以把他放在HTML文档的任何地方。示例： &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; div{ color: green } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;内部样式表&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 外部样式表（外链式）链入式是将所有的样式放在一个或多个以.CSS为扩展名的外部样式表文件中，通过link标签将外部样式表文件链接到HTML文档中，其基本语法格式如下： &lt;head&gt; &lt;link href=&quot;CSS文件的路径&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot; /&gt; &lt;/head&gt; 注意： link 是个单标签哦!!! 该语法中，link标签需要放在head头部标签中，并且必须指定link标签的三个属性，具体如下： href：定义所链接外部样式表文件的URL，可以是相对路径，也可以是绝对路径。 type：定义所链接文档的类型，在这里需要指定为“text/css”，表示链接的外部文件为CSS样式表。 rel：定义当前文档与被链接文档之间的关系，在这里需要指定为“stylesheet”，表示被链接的文档是一个样式表文件。 三种样式表总结 样式表 优点 缺点 使用情况 控制范围 行内样式表 书写方便，权重高 没有实现样式和结构相分离 较少 控制一个标签（少） 内嵌样式表 部分结构和样式相分离 没有彻底分离 较多 控制一个页面（中） 外部样式表 完全实现结构和样式相分离 需要引入 最多，强烈推荐 控制整个站点（多）","link":"/2015/01/01/%E5%89%8D%E7%AB%AF/css/css01/"},{"title":"CSS第二篇","text":"CSS复合选择器复合选择器是由两个或多个基础选择器，通过不同的方式组合而成的,目的是为了可以选择更准确更精细的目标元素标签。 交集选择器交集选择器由两个选择器构成，其中第一个为标签选择器，第二个为class选择器，两个选择器之间不能有空格，如h3.special。 记忆技巧： 交集选择器 是 并且的意思。 即…又…的意思 比如： p.one 选择的是： 类名为 .one 的 段落标签。 用的相对来说比较少，不太建议使用。示例： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .singer{ color: red } /*交集选择器运用，把港澳歌手加粗*/ div.singer{ font-weight: 700; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;singer&quot;&gt;刘德华&lt;/div&gt; &lt;div class=&quot;singer&quot;&gt;张学友&lt;/div&gt; &lt;p class=&quot;singer&quot;&gt;汪峰&lt;/p&gt; &lt;p class=&quot;singer&quot;&gt;王菲&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 并集选择器并集选择器（CSS选择器分组）是各个选择器通过逗号连接而成的，任何形式的选择器（包括标签选择器、class类选择器id选择器等），都可以作为并集选择器的一部分。如果某些选择器定义的样式完全相同，或部分相同，就可以利用并集选择器为它们定义相同的CSS样式。 记忆技巧： 并集选择器 和 的意思， 就是说，只要逗号隔开的，所有选择器都会执行后面样式。 比如 .one, p , #test {color: #F00;} 表示 .one 和 p 和 #test 这三个选择器都会执行颜色为红色。 通常用于集体声明。 后代选择器后代选择器又称为包含选择器，用来选择元素或元素组的后代，其写法就是把外层标签写在前面，内层标签写在后面，中间用空格分隔。当标签发生嵌套时，内层标签就成为外层标签的后代。 子孙后代都可以这么选择。 或者说，它能选择任何包含在内 的标签。示例: &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; /*后代选择器示例*/ .nav ul li{ color: red } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 导航栏的菜单全部采用红色 --&gt; &lt;div class=&quot;nav&quot;&gt; &lt;ul&gt; &lt;li&gt;首页&lt;/li&gt; &lt;li&gt;频道&lt;/li&gt; &lt;li&gt;服务&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;百度&lt;/li&gt; &lt;li&gt;新浪&lt;/li&gt; &lt;li&gt;搜狐&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 子元素选择器子元素选择器只能选择作为某元素子元素的元素。其写法就是把父级标签写在前面，子级标签写在后面，中间跟一个 &gt; 进行连接，注意，符号左右两侧各保留一个空格。白话： 这里的子 指的是 亲儿子 不包含孙子 重孙子之类。 比如： .demo &gt; h3 {color: red;} 说明 h3 一定是demo 亲儿子。 demo 元素包含着h3。 示例: &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; /*后代选择器全部黑色显示 */ .nav li { color: black; } /* 子元素选择器 一级菜单变为红色显示 */ .nav &gt; li { color: red; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 导航栏的菜单全部采用红色 --&gt; &lt;div class=&quot;head&quot;&gt; &lt;ul class=&quot;nav&quot;&gt; &lt;li&gt; 一级菜单 &lt;ul&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; 一级菜单 &lt;ul&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; 一级菜单 &lt;ul&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 综合使用示例需求： 在不修改以下代码的前提下，完成以下任务： 1. 链接 登录 的颜色为红色。 2. 主导航栏里面的文字颜色为绿色。 3. 主导航栏和侧导航栏里面文字都是16像素并且是微软雅黑。 4. 一级菜单显示改为天蓝色。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; /*后代选择器使用*/ .site-r a { color: red; } /*后代选择器使用*/ .nav ul li a { color: green; } /*并集元素选择器使用*/ .nav,sitenav{ /*font-size: 16px; font-family: microsoft yahei;*/ font: 16px microsoft yahei; } /*子元素选择器使用*/ .nav &gt; ul &gt; li &gt; a { color: skyblue; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;nav&quot;&gt; &lt;!-- 主导航栏 --&gt; &lt;ul&gt; &lt;li&gt; &lt;a href=&quot;&quot;&gt;公司首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt; &lt;a href=&quot;&quot;&gt;公司简介&lt;/a&gt;&lt;/li&gt; &lt;li&gt; &lt;a href=&quot;&quot;&gt;公司产品&lt;/a&gt;&lt;/li&gt; &lt;li&gt; &lt;a href=&quot;&quot;&gt;联系我们&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;公司邮箱&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;公司电话&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;sitenav&quot;&gt; &lt;!-- 侧导航栏 --&gt; &lt;div class=&quot;site-l&quot;&gt;左侧侧导航栏&lt;/div&gt; &lt;div class=&quot;site-r&quot;&gt;&lt;a href=&quot;#&quot;&gt;登录&lt;/a&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 属性选择器 **选择器 **示例 **含义 E[attr]**** 存在attr属性即可 E[attr=val]**** 属性值完全等于val E[attr*=val]**** 属性值里包含val字符并且在“任意”位置 E[attr^=val]**** 属性值里包含val字符并且在“开始”位置 E[attr$=val]**** 属性值里包含val字符并且在“结束”位置 /* 获取到 拥有 该属性的元素 */ li[type] { border: 1px solid gray; } /* 获取 属性等于某个值的 元素 属性值 可以使用 引号进行包裹 */ li[type=&quot;vegetable&quot;] { background-color: green; } /* 使用空格分隔的 多个属性 其中有某个属性即可获取 */ li[type~=&quot;hot&quot;] { font-size: 40px; } /* 获取以某个属性开头的语法 */ li[color^='green'] { background-color: orange; } /* 获取以某个值 结尾的属性 */ li[type$='t']{ color: hotpink; font-weight: 900; } /* 获取 属性中 拥有某个值的 元素 */ li[type*=ea] { font-size: 100px; } /* 如果属性的值 只有very 也能够获取 用来获取 多个属性 并且 使用-连接 */ li[price|='very'] { background-color: darkred; } &lt;ul&gt; &lt;li type='fruit' color='green'&gt;西瓜&lt;/li&gt; &lt;li type='vegetable' color='greenyellow'&gt;西兰花&lt;/li&gt; &lt;li type='meat'&gt;牛肉&lt;/li&gt; &lt;li type='meat hot'&gt;猪肉&lt;/li&gt; &lt;li type='drink hot'&gt;可乐&lt;/li&gt; &lt;li type='drink hot'&gt;雪碧&lt;/li&gt; &lt;li price='very-cheap'&gt;红酒&lt;/li&gt; &lt;li price='very'&gt;白酒&lt;/li&gt; &lt;/ul&gt; 伪元素选择器（CSS3) E::first-letter文本的第一个单词或字（如中文、日文、韩文等） E::first-line 文本第一行； E::selection 可改变选中文本的样式； p::first-letter { font-size: 20px; color: hotpink; } /* 首行特殊样式 */ p::first-line { color: skyblue; } p::selection { /* font-size: 50px; */ color: orange; } 示例： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; p::first-letter{ color: red; font: 50px microsoft yahei; } p::first-line{ color: green } p::selection{ color: pink } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt; 李敖（1935年4月25日－2018年3月18日），男，字敖之，出生于黑龙江省哈尔滨市，思想家，自由主义大师，国学大师，中国近代史学者，时事批评家，台湾作家，历史学家，诗人；台湾省无党派人士，曾任台湾“立法委员”，2008年任满，宣布退出台湾省政坛。因其文笔犀利、批判色彩浓厚，嬉笑怒骂皆成文章，所以自诩为“中国白话文第一人”。 &lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 4、E::before和E::after 在E元素内部的开始位置和结束位创建一个元素，该元素为行内元素，且必须要结合content属性使用。 div::befor { content:&quot;开始&quot;; } div::after { content:&quot;结束&quot;; } 示例： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; div::before{ /*before 和 after在盒子div 的内部前面插入或者是内部后面插入*/ content: &quot;俺在&quot;; } div::after{ content: &quot;度假&quot;; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;杭州&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; E:after、E:before 在旧版本里是伪元素，CSS3的规范里“:”用来表示伪类，“::”用来表示伪元素，但是在高版本浏览器下E:after、E:before会被自动识别为E::after、E::before，这样做的目的是用来做兼容处理。 E:after、E:before后面的练习中会反复用到，目前只需要有个大致了解 “:” 与 “::” 区别在于区分伪类和伪元素 CSS背景(backgroud)CSS 可以添加背景颜色和背景图片，以及来进行图片设置。 background-color 背景颜色 background-image 背景图片地址 background-repeat 是否平铺 background-position 背景位置 background-attachment 背景固定还是滚动 背景的合写（复合属性） background:背景颜色 背景图片地址 背景平铺 背景滚动 背景位置 背景图片(image)语法： background-image : none | url (url) 参数：none : 无背景图（默认的）url : 使用绝对或相对地址指定背景图像background-image 属性允许指定一个图片展示在背景中（只有CSS3才可以多背景）可以和 background-color 连用。 如果图片不重复地话，图片覆盖不到地地方都会被背景色填充。 如果有背景图片平铺，则会覆盖背景颜色。 小技巧： 我们提倡 背景图片后面的地址，url不要加引号。 背景平铺(repeat)语法： background-repeat : repeat | no-repeat | repeat-x | repeat-y 参数：repeat : 背景图像在纵向和横向上平铺（默认的）no-repeat : 背景图像不平铺repeat-x : 背景图像在横向上平铺repeat-y : 背景图像在纵向平铺设置背景图片时，默认把图片在水平和垂直方向平铺以铺满整个元素。repeat-x : 背景图像在横向上平铺 背景位置(position)语法： background-position : length || length background-position : position || position 参数：length : 百分数 | 由浮点数字和单位标识符组成的长度值。请参阅长度单位position : top | center | bottom | left | center | right 说明：设置或检索对象的背景图像位置。必须先指定background-image属性。默认值为：(0% 0%)。如果只指定了一个值，该值将用于横坐标。纵坐标将默认为50%。第二个值将用于纵坐标。 注意： position 后面是x坐标和y坐标。 可以使用方位名词或者 精确单位。 如果和精确单位和方位名字混合使用，则必须是x坐标在前，y坐标后面。比如 background-position: 15px top; 则 15px 一定是 x坐标 top是 y坐标。 实际工作用的最多的，就是背景图片居中对齐了。 背景附着(attachment)语法： background-attachment : scroll | fixed 参数：scroll : 背景图像是随对象内容滚动fixed : 背景图像固定 说明：设置或检索背景图像是随对象内容滚动还是固定的。 背景简写background属性的值的书写顺序官方并没有强制标准的。为了可读性，建议大家如下写：background:背景颜色 背景图片地址 背景平铺 背景滚动 背景位置 background: transparent url(image.jpg) repeat-y scroll 50% 0 ; 背景透明(CSS3)CSS3支持背景半透明的写法语法格式是: background: rgba(0,0,0,0.3); 最后一个参数是alpha 透明度 取值范围 0~1之间 注意： 背景半透明是指盒子背景半透明， 盒子里面的内容不收影响。同样， 可以给 文字和边框透明 都是 rgba 的格式来写。 color:rgba(0,0,0,0.3); border: 1px solid rgba(0,0,0,0.3); 背景缩放(CSS3)通过background-size设置背景图片的尺寸，就像我们设置img的尺寸一样，在移动Web开发中做屏幕适配应用非常广泛。 其参数设置如下：a) 可以设置长度单位(px)或百分比（设置百分比时，参照盒子的宽高）b) 设置为cover时，会自动调整缩放比例，保证图片始终填充满背景区域，如有溢出部分则会被隐藏。c) 设置为contain会自动调整缩放比例，保证图片始终完整显示在背景区域。 background-image: url('images/gyt.jpg'); background-size: 300px 100px; /* background-size: contain; */ /* background-size: cover; */ 多背景(CSS3)以逗号分隔可以设置多背景，可用于自适应布局 background-image: url('images/gyt.jpg'),url('images/robot.png'); 综合运用案例&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; body{ background: url(king.jpg) no-repeat right top #000; text-align:center; } a{ width: 200px; height: 50px; /* background-color: orange;*/ display: inline-block; text-align: center; line-height: 50px; text-decoration: none; color: #FFF; font-size: 22px; } a:hover{ background: url(h.png) no-repeat; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=&quot;#&quot;&gt;专区说明&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;申请资格&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;兑换奖励&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;下载游戏&lt;/a&gt; &lt;/body&gt; &lt;/html&gt;","link":"/2015/01/02/%E5%89%8D%E7%AB%AF/css/css02/"},{"title":"CSS第三篇","text":"CSS三大特性层叠性所谓层叠性是指多种CSS样式的叠加。 是浏览器处理冲突的一个能力,如果一个属性通过两个选择器设置到同一个元素上，那么这个时候一个属性就会将另一个属性层叠掉 比如先给某个标签指定了内部文字颜色为红色，接着又指定了颜色为蓝色，此时出现一个标签指定了相同样式不同值的情况，这就是样式冲突。 一般情况下，如果出现样式冲突，则会按照CSS书写的顺序，以最后的样式为准。 继承性所谓继承性是指书写CSS样式表时，子标签会继承父标签的某些样式，如文本颜色和字号。想要设置一个可继承的属性，只需将它应用于父元素即可。 恰当地使用继承可以简化代码，降低CSS样式的复杂性。子元素可以继承父元素的样式（text-，font-，line-这些元素开头的都可以继承，以及color属性）。 并不是所有的CSS属性都可以继承，例如，下面的属性就不具有继承性，边框，外边距，内边距，背景，定位，元素高属性。 优先级定义CSS样式时，经常出现两个或更多规则应用在同一元素上，这时就会出现优先级的问题。在考虑权重时，初学者还需要注意一些特殊的情况，具体如下： 继承样式的权重为0。即在嵌套结构中，不管父元素样式的权重多大，被子元素继承时，他的权重都为0，也就是说子元素定义的样式会覆盖继承来的样式。 行内样式优先。应用style属性的元素，其行内样式的权重非常高，可以理解为远大于100。总之，他拥有比上面提高的选择器都大的优先级。 权重相同时，CSS遵循就近原则。也就是说靠近元素的样式具有最大的优先级，或者说排在最后的样式优先级最大。 CSS定义了一个!important命令，该命令被赋予最大的优先级。也就是说不管权重如何以及样式位置的远近，!important都具有最大优先级。 CSS特殊性（Specificity）关于CSS权重，我们需要一套计算公式来去计算，这个就是 CSS Specificity，我们称为CSS 特性或称非凡性，它是一个衡量CSS值优先级的一个标准 具体规范入如下： specificity用一个四位的数 字串(CSS2是三位)来表示，更像四个级别，值从左到右，左面的最大，一级大于一级，数位之间没有进制，级别之间不可超越。 继承或者* 的贡献值 0,0,0,0 每个元素（标签）贡献值为 0,0,0,1 每个类，伪类贡献值为 0,0,1,0 每个ID贡献值为 0,1,0,0 每个行内样式贡献值 1,0,0,0 每个!important贡献值 ∞ 无穷大 比如的例子： div ul li ------&gt; 0,0,0,3 .nav ul li ------&gt; 0,0,1,2 a:hover -----—&gt; 0,0,1,1 .nav a ------&gt; 0,0,1,1 #nav p -----&gt; 0,1,0,1 注意： 数位之间没有进制 比如说： 0,0,0,5 + 0,0,0,5 =0,0,0,10 而不是 0,0, 1, 0， 所以不会存在10个div能赶上一个类选择器的情况。 总结优先级： 1. 使用了 !important声明的规则。 2. 内嵌在 HTML 元素的 style属性里面的声明。 3. 使用了 ID 选择器的规则。 4. 使用了类选择器、属性选择器、伪元素和伪类选择器的规则。 5. 使用了元素选择器的规则。 6. 只包含一个通用选择器的规则。 总结：权重是优先级的算法，层叠是优先级的表现 权重叠加示例： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; ul li { /* ul权重 0，0，0，1； li权重 0，0，0，1； 叠加 0，0，0，2 ，所以最终显示颜色skyblue */ color: skyblue; } li{ /*权重 0,0,0,1 */ color: red; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;nav&gt; &lt;ul&gt; &lt;li&gt;首页&lt;/li&gt; &lt;li&gt;新闻&lt;/li&gt; &lt;li&gt;服务&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;/body&gt; &lt;/html&gt; 效果：","link":"/2015/01/03/%E5%89%8D%E7%AB%AF/css/css03/"},{"title":"CSS第四篇","text":"CSS盒模型及应用其实，CSS就三个大模块： 盒子模型 、 浮动 、 定位，其余的都是细节。所谓盒子模型就是把HTML页面中的元素看作是一个矩形的盒子，也就是一个盛装内容的容器。每个矩形都由元素的内容、内边距（padding）、边框（border）和外边距（margin）组成。 看透网页布局的本质看透网页布局的本质： 把网页元素比如文字图片等等，放入盒子里面，然后利用CSS摆放盒子的过程，就是网页布局。CSS 其实没有太多逻辑可言 ， 类似我们小时候玩的积木,我们可以自由的，随意的摆放出我们想要的效果。 盒子模型（Box Model）所有的文档元素（标签）都会生成一个矩形框，我们成为元素框（element box），它描述了一个文档元素再网页布局汇总所占的位置大小。因此，每个盒子除了有自己大小和位置外，还影响着其他盒子的大小和位置。 盒子边框（border）边框就是那层皮。 橘子皮。。柚子皮。。橙子皮。。。语法： border : border-width || border-style || border-color 边框属性—设置边框样式（border-style）边框样式用于定义页面中边框的风格，常用属性值如下： none：没有边框即忽略所有边框的宽度（默认值） solid：边框为单实线(最为常用的) dashed：边框为虚线 dotted：边框为点线 double：边框为双实线 表格的细线边框示例表格边框发现很粗 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; table{ border: 1px solid red; widows: 700px; height: 300px; } td{ border: 1px solid red; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;table cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;&gt; &lt;tr&gt; &lt;td&gt;123456&lt;/td&gt; &lt;td&gt;123456&lt;/td&gt; &lt;td&gt;123456&lt;/td&gt; &lt;td&gt;123456&lt;/td&gt; &lt;td&gt;123456&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;123456&lt;/td&gt; &lt;td&gt;123456&lt;/td&gt; &lt;td&gt;123456&lt;/td&gt; &lt;td&gt;123456&lt;/td&gt; &lt;td&gt;123456&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;123456&lt;/td&gt; &lt;td&gt;123456&lt;/td&gt; &lt;td&gt;123456&lt;/td&gt; &lt;td&gt;123456&lt;/td&gt; &lt;td&gt;123456&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;123456&lt;/td&gt; &lt;td&gt;123456&lt;/td&gt; &lt;td&gt;123456&lt;/td&gt; &lt;td&gt;123456&lt;/td&gt; &lt;td&gt;123456&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;123456&lt;/td&gt; &lt;td&gt;123456&lt;/td&gt; &lt;td&gt;123456&lt;/td&gt; &lt;td&gt;123456&lt;/td&gt; &lt;td&gt;123456&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; 效果发现边框是2px。 解决：table{ border-collapse:collapse; }border-collapse:collapse; 表示边框合并在一起。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; table{ border: 1px solid red; widows: 700px; height: 300px; border-collapse: collapse; /*合并相邻边框*/ } td{ border: 1px solid red; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;table cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;&gt; &lt;tr&gt; &lt;td&gt;123456&lt;/td&gt; &lt;td&gt;123456&lt;/td&gt; &lt;td&gt;123456&lt;/td&gt; &lt;td&gt;123456&lt;/td&gt; &lt;td&gt;123456&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;123456&lt;/td&gt; &lt;td&gt;123456&lt;/td&gt; &lt;td&gt;123456&lt;/td&gt; &lt;td&gt;123456&lt;/td&gt; &lt;td&gt;123456&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;123456&lt;/td&gt; &lt;td&gt;123456&lt;/td&gt; &lt;td&gt;123456&lt;/td&gt; &lt;td&gt;123456&lt;/td&gt; &lt;td&gt;123456&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;123456&lt;/td&gt; &lt;td&gt;123456&lt;/td&gt; &lt;td&gt;123456&lt;/td&gt; &lt;td&gt;123456&lt;/td&gt; &lt;td&gt;123456&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;123456&lt;/td&gt; &lt;td&gt;123456&lt;/td&gt; &lt;td&gt;123456&lt;/td&gt; &lt;td&gt;123456&lt;/td&gt; &lt;td&gt;123456&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; 效果 合并相邻边框 盒子边框总结表 设置内容 样式属性 常用属性值 上边框 border-top-style:样式; border-top-width:宽度;border-top-color:颜色;border-top:宽度 样式 颜色; 下边框 border-bottom-style:样式;border- bottom-width:宽度;border- bottom-color:颜色;border-bottom:宽度 样式 颜色; 左边框 border-left-style:样式; border-left-width:宽度;border-left-color:颜色;border-left:宽度 样式 颜色; 右边框 border-right-style:样式;border-right-width:宽度;border-right-color:颜色;border-right:宽度 样式 颜色; 样式综合设置 border-style:上边 [右边 下边 左边]; none无（默认）、solid单实线、dashed虚线、dotted点线、double双实线 宽度综合设置 border-width:上边 [右边 下边 左边]; 像素值 颜色综合设置 border-color:上边 [右边 下边 左边]; 颜色值、#十六进制、rgb(r,g,b)、rgb(r%,g%,b%) 边框综合设置 border:四边宽度 四边样式 四边颜色; 圆角边框(CSS3)从此以后，我们的世界不只有矩形。语法格式： Border-radius: 水平半径/垂直半径； 一般我们垂直半径都是省略的默认和水平半径一样。 border-radius: 左上角 右上角 右下角 左下角; 示例 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; div{ width: 100px; height: 100px; border: 1px solid red; border-collapse: collapse; } div:first-child{ border-radius: 20px; 表示 左上，右上，右下，左下 均是20px } div:nth-child(2){ border-radius: 50%; /*取宽度和高度的一半，则变成了圆*/ } div:nth-child(3){ border-radius: 10px 40px; 表示 左上，右下均是10px，右上，左下 均是40px } div:nth-child(4){ border-radius: 10px 40px 80px; 表示 左上是10px，右上，左下 均是40px， 右下是80px } div:nth-child(5){ border-radius: 50%; /*取宽度和高度的一半，则变成了圆*/ height: 50px; /*行高变为一半，把圆压扁成胶囊形状了*/ } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; 效果： 内边距（padding）padding属性用于设置内边距。 是指 边框与内容之间的距离。 padding-top:上内边距padding-right:右内边距padding-bottom:下内边距padding-left:左内边距 注意： 后面跟几个数值表示的意思是不一样的。 值的个数 表达意思 1个值 padding：上下左右边距 比如padding: 3px; 表示上下左右都是3像素 2个值 padding: 上下边距 左右边距 比如 padding: 3px 5px; 表示 上下3像素 左右 5像素 3个值 padding：上边距 左右边距 下边距 比如 padding: 3px 5px 10px; 表示 上是3像素 左右是5像素 下是10像素 4个值 padding:上内边距 右内边距 下内边距 左内边距 比如: padding: 3px 5px 10px 15px; 表示 上3px 右是5px 下 10px 左15px 顺时针 内边距运用–新浪导航栏示例&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;style&gt; body{ margin: 0 auto; padding: 0; } nav { height: 41px; background-color: #FCFCFC; border-top: 3px solid #FF8500; /* 上边框 */ border-bottom: 1px solid #EDEEF0; /* 下边框 */ } nav a { font-size: 14px; color: #4C4C4C; text-decoration: none; /* 取消下划线 */ padding: 0 15px; /* 上下是0 左右是 15 */ height: 41px; line-height: 41px; /* 行高等于高度可以文字垂直居中 */ /* 因为链接是行内元素么有大小 所以需要转换 行内块 */ display: inline-block; } nav a:hover { /* 链接伪类选择器 鼠标经过a链接的时候 */ background-color: #eee; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;nav&gt; &lt;a href=&quot;#&quot;&gt;首页&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;手机新浪网&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;网站导航&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;三个字&lt;/a&gt; &lt;/nav&gt; &lt;/body&gt; &lt;/html&gt; 效果： 外边距（margin）margin属性用于设置外边距。 设置外边距会在元素之间创建“空白”， 这段空白通常不能放置其他内容。margin-top:上外边距margin-right:右外边距margin-bottom:下外边距margin-left:左外边距 margin:上外边距 右外边距 下外边距 左外边 取值顺序跟内边距相同。 外边距实现盒子居中可以让一个盒子实现水平居中，需要满足一下两个条件： 必须是块级元素。 盒子必须指定了宽度（width） 然后就给左右的外边距都设置为auto，就可使块级元素水平居中。 实际工作中常用这种方式进行网页布局，示例代码如下： .header{ width:960px; margin:0 auto;} 插入图片和背景图片控制&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div { width: 300px; height: 100px; border: 1px solid pink; text-align: center; /* 文字居中水平 */ margin: 10px auto; /* 盒子水平居中 左右margin 改为 auto 就阔以了 */ } section { width: 400px; height: 400px; border: 1px solid #000; } section img { width: 200px;/* 插入图片更改大小 width 和 height */ height: 210px; margin-top: 30px; /* 插入图片更改位置 可以用margin 或padding 盒模型 */ margin-left: 50px; /* 插入当图片也是一个盒子 */ } aside { width: 400px; height: 400px; border: 1px solid purple; background: #fff url(images/sun.jpg) no-repeat; background-size: 200px 210px; /* 背景图片更改大小只能用 background-size */ background-position: 30px 50px; /* 背景图片更该位置 我用 background-position */ } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; 1. 文字水平居中 和 盒子水平居中 &lt;div&gt;文字水平居中&lt;/div&gt; 2. 插入图片和背景图片 &lt;section&gt; &lt;img src=&quot;images/sun.jpg&quot; height=&quot;691&quot; width=&quot;721&quot; alt=&quot;&quot;&gt;123 &lt;/section&gt; &lt;aside&gt; 123123123 &lt;/aside&gt; 3. 一般情况下，背景图片适合做一些小图标使用 产品展示之类的就用插入图片 &lt;/body&gt; &lt;/html&gt; 清除元素的默认内外边距为了更方便地控制网页中的元素，制作网页时，可使用如下代码清除元素的默认内外边距： * { padding:0; /* 清除内边距 */ margin:0; /* 清除外边距 */ } 注意： 行内元素是只有左右内外边距的，是没有上下内外边距的。 外边距合并使用margin定义块元素的垂直外边距时，可能会出现外边距的合并。 相邻块元素垂直外边距的合并当上下相邻的两个块元素相遇时，如果上面的元素有下外边距margin-bottom，下面的元素有上外边距margin-top，则他们之间的垂直间距不是margin-bottom与margin-top之和，而是两者中的较大者。这种现象被称为相邻块元素垂直外边距的合并（也称外边距塌陷）。 解决方案： 避免就好了。 嵌套块元素垂直外边距的合并对于两个嵌套关系的块元素，如果父元素没有上内边距及边框，则父元素的上外边距会与子元素的上外边距发生合并，合并后的外边距为两者中的较大者，即使父元素的上外边距为0，也会发生合并。 问题现象示例： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;style&gt; #father{ background-color: pink; width: 200px; height: 200px; margin-top: 100px; } #son{ background-color:blue; width: 50px; height: 50px; margin-top: 20px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;father&quot;&gt; &lt;div id=&quot;son&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 解决方案： 可以为父元素定义1像素的上边框或上内边距。 可以为父元素添加overflow:hidden。示例：&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;style&gt; #father{ background-color: pink; width: 200px; height: 200px; margin-top: 100px; border: 1px solid pink; /*解决嵌套块元素外边距合并问题，父元素加一个 1px边框 或内边距1px*/ /*padding: 1px;*/ /*overflow: hidden; /*BFC机制也可以解决*/ } #son{ background-color:blue; width: 50px; height: 50px; margin-top: 20px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;father&quot;&gt; &lt;div id=&quot;son&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; content宽度和高度 使用宽度属性width和高度属性height可以对盒子的大小进行控制。width和height的属性值可以为不同单位的数值或相对于父元素的百分比%，实际工作中最常用的是像素值。大多数浏览器，如Firefox、IE6及以上版本都采用了W3C规范，符合CSS规范的盒子模型的总宽度和总高度的计算原则是：外盒尺寸计算(元素空间尺寸) 外盒尺寸计算(元素空间尺寸) 盒子的总高度=content height + 上下内边距之和（pading）+ 上下边框宽度之和(border) + 上下外边距之和(margin) 盒子的总宽度=content width + 左右内边距之和(pading) + 左右边框宽度之和(border) + 左右外边距之和(margin) 实际计算只计算内盒尺寸(元素大小) 排除外边距 盒子的总高度=content height + 上下内边距之和（pading）+ 上下边框宽度之和(border) 盒子的总宽度=content width + 左右内边距之和(pading) + 左右边框宽度之和(border) 注意： 宽度属性width和高度属性height仅适用于块级元素，对行内元素无效（ img 标签和 input除外）。 计算盒子模型的总高度时，还应考虑上下两个盒子垂直外边距合并的情况。 如果一个盒子没有给定宽度/高度或者是继承了父亲的宽度/高度，则padding不会影响本盒子大小。示例：&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; div { height: 30px; border: 1px solid red; padding-left: 20px; /* 因为这个盒子没有宽度 所以padding 不会影响盒子的宽度 */ padding-top: 10px; /* width: 100%; */ } nav { width: 300px; height: 40px; border: 1px solid pink; } p { /* 因为p没有指定宽度 则会默认和父亲一样宽 块级元素 */ height: 20px; background-color: hotpink; padding-left: 30px; /* 此时padding 也不会影响盒子的宽度 */ } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;奔跑吧，兄弟&lt;/div&gt; &lt;nav&gt; &lt;p&gt;摔跤吧，爸爸&lt;/p&gt; &lt;/nav&gt; &lt;/body&gt; &lt;/html&gt; 综合例子运用&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;style&gt; * { /* 清空默认的内外边距 几乎是我们写css 必须要写的 */ margin: 0; padding: 0; } ul { list-style: none; /* 取消列表自带的小点 默认的列表样式 */ } .searchPic { width: 238px; height: 294px; border: 1px solid #D9E0EE; border-top: 3px solid #FF8400; /* 这句话要放到 border 的下面 */ margin: 100px; } .searchPic h3 { height: 35px; line-height: 35px; /* 让行高等于高度 ，可以让文字垂直居中 */ border-bottom: 1px solid #D9E0EE; font-size: 16px; font-weight: normal; /* 让粗体不变粗 */ padding-left: 12px; /* 因为这个h3我么没有给宽度 继承的父亲的宽度 padding就不会撑开盒子了 */ } .searchPic img { margin: 7px 0 0 8px; /* 上 右 下 左 */ } .searchPic ul li a { font-size: 12px; color: #666; text-decoration: none; /* 取消下划线 */ } .searchPic ul { margin-left: 8px; } .searchPic ul li{ padding-left: 10px; height: 26px; line-height: 26px; background: url(images/square.png) no-repeat left center; /* 背景设置 */ } .searchPic ul li a:hover { text-decoration: underline; /* 添加下划线 */ color: #ff8400; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;searchPic&quot;&gt; &lt;h3&gt;搜索趣图&lt;/h3&gt; &lt;img src=&quot;images/happy.gif&quot; height=&quot;160&quot; width=&quot;218&quot; alt=&quot;&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;GIF：小胖墩游泳被卡 被救后一脸无辜&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;GIF：小胖墩游泳被卡 被救后一脸无辜&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;GIF：小胖墩游泳被卡 被救后一脸无辜&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 盒子模型布局稳定性学习盒子模型，最大的困惑就是， 分不清内外边距的使用，什么情况下使用内边距，什么情况下使用外边距？答案是： 其实他们大部分情况下是可以混用的。 就是说，你用内边距也可以，用外边距也可以。 你觉得哪个方便，就用哪个。但是，总有一个最好用的吧，我们根据稳定性来分，建议如下： 按照 优先使用 宽度 （width） 其次 使用内边距（padding） 再次 外边距（margin）。 width &gt; padding &gt; margin 原因： margin 会有外边距合并 还有 ie6下面margin 加倍的bug（讨厌）所以最后使用。 padding 会影响盒子大小， 需要进行加减计算（麻烦） 其次使用。 width 没有问题（嗨皮）我们经常使用宽度剩余法 高度剩余法来做。 CSS3盒模型CSS3中可以通过box-sizing 来指定盒模型，即可指定为content-box、border-box，这样我们计算盒子大小的方式就发生了改变。 可以分成两种情况： 1、box-sizing: border-box 盒子大小为 width 2、box-sizing: content-box 盒子大小为 width + padding + border 注：上面的标注的width指的是CSS属性里设置的width: length，content的值是会自动调整的。 div { width: 100px; height: 100px; background: skyblue; margin: 0 auto; border: 1px solid gray; /* 默认的设置 如果我们添加了 border属性 该容器的大小会发生改变 因为他要优先保证内部的内容所占区域 不变 */ /* box-sizing 如果不设置 默认的值 就是 content-box: 优先保证内容的大小 对盒子进行缩放; border-box: 让 盒子 优先保证自己所占区域的大小,对内容进行压缩; */ box-sizing: border-box; } 盒子阴影语法格式： box-shadow:水平阴影位置 垂直阴影位置 模糊距离(模糊程度) 阴影尺寸(影子大小) 阴影颜色 内/外阴影； 前两个属性是必须写的。其余的可以省略。 外阴影 (outset) 但是不能写 默认 想要内阴影 inset img { border:10px solid orange; box-shadow:3px 3px 5px 4px rgba(0,0,0,1); } 盒子阴影综合运用–水晶图片&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;style&gt; div { width: 249px; height: 249px; line-height: 249px; background-color: pink; margin: 100px; background: url(images/shui.jpg) 0 0 no-repeat; font-size: 30px; text-align: center; color: rgba(255, 255, 255, 0.7);/* 颜色半透明 */ border-radius: 50%; /* 变成一个圆 圆角 */ box-shadow: 5px 5px 10px 16px rgba(255,255,255, 0.4) inset, 7px 6px 9px rgba(0,0,0,0.3);/* 内阴影 */ } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; 水晶图片 &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 素材效果","link":"/2015/01/04/%E5%89%8D%E7%AB%AF/css/css04/"},{"title":"CSS第五篇","text":"浮动及应用普通流(normal flow)这个单词很多人翻译为 文档流 ， 字面翻译 普通流 或者标准流都可以。前面我们说过，网页布局的核心，就是用CSS来摆放盒子位置。如何把盒子摆放到合适的位置？CSS的定位机制有3种：普通流（标准流）、浮动和定位。html语言当中另外一个相当重要的概念———-标准流！或者普通流。普通流实际上就是一个网页内标签元素正常从上到下，从左到右排列顺序的意思，比如块级元素会独占一行，行内元素会按顺序依次前后排列；按照这种大前提的布局排列之下绝对不会出现例外的情况叫做普通流布局。 浮动(float) 浮动最早是用来控制图片，以便达到其他元素（特别是文字）实现“环绕”图片的效果。示例-文字环绕效果： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;style&gt; div { width: 500px; height: 330px; border: 1px solid hotpink; margin: 0 auto; /* 让盒子居中对齐 */ } img { float: right; /* 开始的时候 ，浮动是用来做文字环绕效果 */ } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; 李敖（1935年4月25日－2018年3月18日），男，字敖之，出生于黑龙江省哈尔滨市，思想家，自由主义大师，国学大师，中国近代史学者，时事批评家，台湾作家，历史学家，诗人；台湾省无党派人士，曾任台湾“立法委员”， &lt;img src=&quot;la.png&quot; height=&quot;220&quot; width=&quot;171&quot; alt=&quot;&quot;&gt; 2008年任满，宣布退出台湾省政坛。因其文笔犀利、批判色彩浓厚，嬉笑怒骂皆成文章，所以自诩为“中国白话文第一人”。 “以玩世来醒世，用骂世而救世”，有《北京法源寺》、《阳痿美国》、《李敖有话说》、《红色11》等100多本著作，前后共有九十六本被禁，创下历史纪录，被西方传媒追捧为“中国近代最杰出的批评家”。《李敖大全集》是他大部分著作的合集，共80册，凡3000万字。2005年9月访问大陆，在北大、清华、复旦三所顶尖高校发表了名为“金刚怒目、菩萨低眉、尼姑思凡”的系列演讲。 &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 效果： 后来，我们发现浮动有个很有意思的事情：就是让任何盒子可以一行排列。之前把块级元素转换为行内块元素 就可以放一行上 有宽度高度 但是 元素之间有空隙 不方便处理 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;style&gt; div { width: 200px; height: 200px; background-color: pink; display: inline-block; /*转换为行内块元素 就可以放一行上 有宽度高度 但是 元素之间有空隙 不方便处理*/ } div:nth-child(2) { background-color: hotpink; } div:last-child { background-color: deeppink; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 问题展示： 用浮动就可以令块级元素一行显示，且无间隙 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;style&gt; div { width: 200px; height: 200px; background-color: pink; /*display: inline-block; */ /*转换为行内块元素 就可以放一行上 有宽度高度 但是 元素之间有空隙 不方便处理*/ float: left; } div:nth-child(2) { background-color: hotpink; } div:last-child { background-color: deeppink; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 示例完美效果： 什么是浮动？元素的浮动是指设置了浮动属性的元素会脱离标准普通流的控制，移动到其父元素中指定位置的过程。在CSS中，通过float属性来定义浮动，其基本语法格式如下： 选择器{float:属性值;} 属性值 描述 left 元素向左浮动 right 元素向右浮动 none 元素不浮动（默认值） 浮动详细内幕特性 浮动首先创建包含块的概念（包裹）。就是说， 浮动的元素总是找理它最近的父级元素对齐。但是不会超出内边距的范围。 浮动的元素排列位置，跟上一个元素（块级）有关系。如果上一个元素有浮动，则A元素顶部会和上一个元素的顶部对齐；如果上一个元素是标准流，则A元素的顶部会和上一个元素的底部对齐。 由2可以推断出，一个父盒子里面的子盒子，如果其中一个子级有浮动的，则其他子级都需要浮动。这样才能一行对齐显示。 浮动脱离标准流，不占位置，会影响标准流。浮动只有左右浮动。 元素添加浮动后，元素会具有行内块元素的特性。元素的大小完全取决于定义的大小或者默认的内容多少 示例 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;style&gt; div { height: 200px; background-color: pink; float: left; /* 块级元素添加浮动之后，具有行内块的特性 */ } span { background-color: purple; height: 100px; float: left;/* 行内元素添加浮动之后，具有行内块的特性 */ } /* 行内块特性 可以一行放多个 有宽度和高度 盒子的大小是有内容决定的 */ &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;三大傻大闹宝莱坞&lt;/div&gt; &lt;div&gt;三大傻大闹宝莱坞&lt;/div&gt; &lt;span&gt;额的个神啊&lt;/span&gt; &lt;span&gt;额的个神啊&lt;/span&gt; &lt;/body&gt; &lt;/html&gt; 浮动根据元素书写的位置来显示相应的浮动。 总结： 浮动 —&gt; 浮漏特浮： 加了浮动的元素盒子是浮起来的，漂浮在其他的标准流盒子上面。漏： 加了浮动的盒子，不占位置的，它浮起来了，它原来的位置漏 给了标准流的盒子。特： 特别注意，这是特殊的使用，有很多的不好处，使用要谨慎。 清除浮动我们前面说过，浮动本质是用来做一些文字混排效果的，但是被我们拿来做布局用，则会有很多的问题出现， 但是，你不能说浮动不好由于浮动元素不再占用原文档流的位置，所以它会对后面的元素排版产生影响，为了解决这些问题，此时就需要在该元素中清除浮动。如果浮动一开始就是一个美丽的错误，那么请用正确的方法挽救它。 清除浮动本质清除浮动主要为了解决父级元素因为子级浮动引起内部高度为0 的问题。 清除浮动的方法其实本质叫做闭合浮动更好一些, 记住，清除浮动就是把浮动的盒子圈到里面，让父盒子闭合出口和入口不让他们出来影响其他元素。 在CSS中，clear属性用于清除浮动，其基本语法格式如下： 选择器{clear:属性值;} 属性值 描述 left 不允许左侧有浮动元素（清除左侧浮动的影响） right 不允许右侧有浮动元素（清除右侧浮动的影响） both 同时清除左右两侧浮动的影响 额外标签法是W3C推荐的做法是通过在浮动元素末尾添加一个空的标签例如 &lt;div style=”clear:both”&gt;&lt;/div&gt;，或则其他标签br等亦可。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;style&gt; .box1 { /* height: 200px; 很多情况下，我们父级盒子，不方便给高度 考虑孩子高度会变 */ width: 600px; /*height: 200px;*/ background-color: pink; } .box2 { width: 600px; height: 240px; background-color: purple; } .son1 { /* son1 和 son2 是标准流，会撑开盒子 */ width: 150px; height: 100px; background-color: skyblue; float: left; } .son2 { width: 300px; height: 100px; background-color: hotpink; float: left; } /* 如果son1 和son2 都浮动了， 浮动元素不占有位置， 父亲没有高度 此时 底下盒子就会跑上来 */ .clear { clear: both; /* 清除浮动的影响 */ } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;box1&quot;&gt; &lt;div class=&quot;son1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;son2&quot;&gt;&lt;/div&gt; &lt;!-- 在浮动盒子的后面添加一个空盒子 --&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 优点： 通俗易懂，书写方便 缺点： 添加许多无意义的标签，结构化较差。 我只能说，w3c你推荐的方法我不接受，你不值得拥有。。。 父级添加overflow属性方法可以通过触发BFC的方式，可以实现清除浮动效果。（BFC后面讲解） 可以给父级添加： overflow为 hidden|auto|scroll 都可以实现。 优点： 代码简洁 缺点： 内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;style&gt; .box1 { /* height: 200px; 很多情况下，我们父级盒子，不方便给高度 考虑孩子高度会变 */ width: 600px; background-color: pink; overflow: hidden; /* 触发BFC BFC可以清除浮动 这是解决方案 BFC我们后面讲解 */ } .box2 { width: 600px; height: 240px; background-color: purple; } .son1 { /* son1 和 son2 是标准流，会撑开盒子 */ width: 150px; height: 100px; background-color: skyblue; float: left; } .son2 { width: 300px; height: 100px; background-color: hotpink; float: left; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;box1&quot;&gt; &lt;div class=&quot;son1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;son2&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 使用after伪元素清除浮动使用方法： .clearfix:after { content: &quot;.&quot;; display: block; height: 0; clear: both; visibility: hidden; } .clearfix {*zoom: 1;} /* IE6、7 专有 */ 优点： 符合闭合浮动思想 结构语义化正确 缺点： 由于IE6-7不支持:after，使用 zoom:1触发 hasLayout。 代表网站： 百度、淘宝网、网易等 注意： content:”.” 里面尽量跟一个小点，或者其他，尽量不要为空，否则再firefox 7.0前的版本会有生成空格。示例用法： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;style&gt; .box1 { /* height: 200px; 很多情况下，我们父级盒子，不方便给高度 考虑孩子高度会变 */ width: 600px; background-color: pink; } .box2 { width: 600px; height: 240px; background-color: purple; } .son1 { /* son1 和 son2 是标准流，会撑开盒子 */ width: 150px; height: 100px; background-color: skyblue; float: left; } .son2 { width: 300px; height: 100px; background-color: hotpink; float: left; } /* p:after { content: &quot;456&quot;; } */ /* 伪元素产生出的是 行内元素 在整个父元素后面内容 转成块元素 高度为0 隐藏掉点 清除浮动*/ .clearfix:after { content: &quot;.&quot;; /* 内容为小点， 尽量加不要空， 否则旧版本浏览器有空隙 */ display: block; /* 转换为块级元素 */ height: 0; /* 高度为0 */ visibility: hidden; /* 隐藏盒子 */ clear: both; /* 清除浮动 */ } .clearfix { /* ie6.7浏览器的处理方式 */ *zoom: 1; /* * 代表ie6.7能识别的特殊符号 带有这个*的属性 只有ie6.7才执行 zoom 就是ie6.7 清除浮动的方法 */ } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;123&lt;/p&gt; &lt;div class=&quot;box1 clearfix&quot;&gt; &lt;div class=&quot;son1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;son2&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 使用before和after双伪元素清除浮动(强烈推荐)使用方法： .clearfix:before,.clearfix:after { content:&quot;.&quot;; display:table; } .clearfix:after { clear:both; } .clearfix { *zoom:1; } 优点： 代码更简洁 缺点： 由于IE6-7不支持:after，使用 zoom:1触发 hasLayout。 代表网站： 小米、腾讯等 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;style&gt; .box1 { /* height: 200px; 很多情况下，我们父级盒子，不方便给高度 考虑孩子高度会变 */ width: 600px; background-color: pink; } .box2 { width: 600px; height: 240px; background-color: purple; } .son1 { /* son1 和 son2 是标准流，会撑开盒子 */ width: 150px; height: 100px; background-color: skyblue; float: left; } .son2 { width: 300px; height: 100px; background-color: hotpink; float: left; } .clearfix:before, .clearfix:after { content: &quot;&quot;; display: table; } .clearfix:after { clear: both; } .clearfix { *zoom: 1; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;box1 clearfix&quot;&gt; &lt;div class=&quot;son1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;son2&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 版心和布局流程 阅读报纸时容易发现，虽然报纸中的内容很多，但是经过合理地排版，版面依然清晰、易读。同样，在制作网页时，要想使页面结构清晰、有条理，也需要对网页进行“排版”。“版心”是指网页中主体内容所在的区域。一般在浏览器窗口中水平居中显示，常见的宽度值为960px、980px、1000px、1200px等。 布局流程为了提高网页制作的效率，布局时通常需要遵守一定的布局流程，具体如下： 1、确定页面的版心（可视区）。 2、分析页面中的行模块，以及每个行模块中的列模块。 3、制作HTML页面，CSS文件。 4、CSS初始化，然后开始运用盒子模型的原理，通过DIV+CSS布局来控制网页的各个模块。 一列固定宽度且居中&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;style&gt; * { margin: 0; padding: 0; /* 清除内外边距 css 第一讲句话 */ } /* 相同的样式，我们会想到 并集选择器 */ .top, .banner, .main, .footer { width: 960px; text-align: center; /* 文字居中对齐 */ margin: 0 auto; /* 可以让盒子居中对齐 只要保证 左右auto就阔以了 */ margin-bottom: 10px; border: 1px dashed #ccc; } .top { height: 80px; background-color: #EEE; } .banner { height: 120px; background-color: #EEE; } .main { height: 500px; background-color: #EEE; } .footer { height: 150px; background-color: #EEE; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;top&quot;&gt;top&lt;/div&gt; &lt;div class=&quot;banner&quot;&gt;banner&lt;/div&gt; &lt;div class=&quot;main&quot;&gt;main&lt;/div&gt; &lt;div class=&quot;footer&quot;&gt;footer&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 最普通的，最为常用的结构 两列左窄右宽型&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;style&gt; * { margin: 0; padding: 0; } .top, /* 并集选择器给相同样式集体声明 */ .banner, .main, .footer { width: 960px; margin: 0 auto; border: 1px dashed #ccc; text-align: center; background-color: #eee; margin-bottom: 8px; } .top { height: 80px; } .banner { height: 150px; } .main { height: 500px; } .left { width: 360px; height: 500px; background-color: #eee; float: left; } .right { width: 592px; height: 500px; background-color: #eee; float: right; } .footer { height: 120px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;top&quot;&gt;top&lt;/div&gt; &lt;div class=&quot;banner&quot;&gt;banner&lt;/div&gt; &lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;footer&quot;&gt;footer&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 比如小米 小米官网 通栏平均分布型&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;style&gt; * { margin: 0; padding: 0; } ul { list-style: none; /* 取消列表的默认样式小点 */ } .top { height: 60px; background-color: #000; } .banner { width: 960px; height: 400px; background-color: skyblue; margin: 20px auto; border-radius: 15px; } .main { width: 960px; margin: 0 auto; height: 200px; } .main ul li { width: 240px; height: 200px; background-color: pink; float: left; /* 浮动的目的让多个块级li 一行显示 而且米有缝隙呦 */ } .main ul li:nth-child(even) { /* even 偶数 个 odd 奇数 */ background-color: purple; } .footer { height: 100px; background-color: #000; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;top&quot;&gt;top&lt;/div&gt; &lt;div class=&quot;banner&quot;&gt;banner&lt;/div&gt; &lt;div class=&quot;main&quot;&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;main&quot;&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;footer&quot;&gt;footer&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 比如锤子 锤子官网","link":"/2015/01/05/%E5%89%8D%E7%AB%AF/css/css05/"},{"title":"CSS第六篇","text":"CSS定位及应用","link":"/2015/01/06/%E5%89%8D%E7%AB%AF/css/css06/"},{"title":"HTML重拾第一篇","text":"URL协议协议规定格式: scheme://host.domain:port/path/filenamescheme:定义因特网服务的类型常见的就是httphost:定义域主机（http的默认主机是www）domain:定义因特网域名比如:w3school.com.cnport定义端口号（网页默认端口:80）path:网页所在服务器上的路径filename:文件名称 工具介绍sublime轻量级 有很多好用的插件 webstorm重量级 太过智能","link":"/2018/03/17/%E5%89%8D%E7%AB%AF/html/html%E7%AC%AC%E4%B8%80%E7%AF%87/"},{"title":"后台模板","text":"AdminLTE AdminLTE是一款建 立在bootstrap利jquery之上的开源的模板主题工具，它提供了一系列响应的、可重复使用的组件，并内置了多个模板页面;同时自适应多种屏幕分辨率，兼容PC和移动端。通过AdminLTE，我们可以快速的创建一个响应式的Html5网站。AdminLTE框架在网页架构与设计上，有很大的辅助作用，尤其是前端架构设计师，用好AdminLTE不但美观，而且可以免去写很大CSS与JS的工作量。 AdminLTE源代码: https://github.com/ColorlibHQ/AdminLTE AdminLTE依赖于两个框架Bootstrap3与JQuery1.11+ AdminLTE布局与皮肤 布局.wrapper 包住了body下的所有代码.main-header 里是网站的logo和导航栏的代码.main-sidebar里是用户面板和侧边栏菜单的代码.content-wrapper里是页面的页面和内容区域的代码.main-footer里是页脚的代码.control-sidebar里是页面右侧侧边栏区域的代码， 布局选项fixed:固定layout-boxed:盒子布局layout-top-nav: 顶部隐藏sidebar-collapse: 侧边栏隐藏sidebar-mini: 侧边栏隐藏时有小图标 皮肤skin-blue: 蓝色skin-black:黑色skin-purple:紫色skin-yellow:黄色skin-red:红色skin-green: 绿色 汉化版地址：https://github.com/itheima2017/adminlte2-itheima","link":"/2017/12/01/%E5%89%8D%E7%AB%AF/html/%E5%90%8E%E5%8F%B0%E6%A8%A1%E6%9D%BF/"},{"title":"reactjs-共享单车练手项目001","text":"共享单车项目整体架构","link":"/2018/09/15/%E5%89%8D%E7%AB%AF/reactjs/reactjs-sharebike001/"},{"title":"react基础","text":"react了解 react是一个用户界面的库 react安装create-react-app是开始构建一个全新单页应用的最好方式 npm install -g create-react-app create-react-app my-react-app cd my-react-app npm start npm info react //查看当前react版本信息 react组件 组件的首字母一定是大写字母 react组件的第一种定义是函数 ,理解props组件传值 import React from 'react'; import ReactDOM from 'react-dom'; let Message = ({msg})=&gt;{ return &lt;h1&gt;{msg}&lt;/h1&gt; } ReactDOM.render( &lt;Message msg=&quot;hello world&quot;/&gt;, document.querySelector('#root') ); import React from 'react'; import ReactDOM from 'react-dom'; let Message = (props)=&gt;{ return &lt;h1&gt;&lt;span&gt;{props.id} &lt;/span&gt;{props.msg}&lt;/h1&gt; } ReactDOM.render( &lt;Message msg=&quot;hello world&quot; id=&quot;1&quot;/&gt;, document.querySelector('#root') ); 组件的第二种定义方式：通过类来声明组件，类需要继承自Component import React,{Component} from 'react'; import ReactDOM from 'react-dom'; class Clock extends Component{ constructor(){ super(); this.state={time:new Date().toLocaleString()}; } componentDidMount(){ window.setInterval(()=&gt;{ this.setState({time:new Date().toLocaleString()});},1000);//setState有两个作用 1.改变state状态;2.状态的改变会自动调用render进行重新渲染 } render(){ return &lt;h1&gt;{this.state.time}&lt;/h1&gt; } } ReactDOM.render( &lt;Clock /&gt;, document.querySelector('#root') ); react组件属性props 默认属性值 import React, {Component} from 'react'; import ReactDOM from 'react-dom'; class Person extends Component { constructor() { super(); this.state = {happy: true} } static defaultProps = { name: '未填', age: '未知' } handleClick = ()=&gt; { this.setState({happy:!this.state.happy}) } render() { let heart = this.state.happy ? &quot;开心&quot; : &quot;难过&quot;; return &lt;div&gt; &lt;p&gt;姓名:{this.props.name}&lt;/p&gt; &lt;p&gt;年龄:{this.props.age}&lt;/p&gt; &lt;p&gt;心情:{heart}&lt;/p&gt; &lt;button onClick={this.handleClick}&gt;改变心情&lt;/button&gt; &lt;/div&gt; } } ReactDOM.render( &lt;Person /&gt;, document.querySelector('#root') );","link":"/2018/07/13/%E5%89%8D%E7%AB%AF/reactjs/react%E5%9F%BA%E7%A1%80/"},{"title":"Jsoup解析器","text":"简介 jsoup 是一款Java的HTML解析器， 可直接解析某个URL地址、HTML文本内容。 它提供了一 套非常省力的API,可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数 使用介绍 导入依赖&lt;dependency&gt; &lt;groupId&gt;org.jsoup&lt;/groupId&gt; &lt;artifactId&gt;jsoup&lt;/artifactId&gt; &lt;version&gt;1.11.2&lt;/version&gt; &lt;/dependency&gt; 1.Jsoup :工具类，可以解析html或xml文档，返回Document. parse(File in, string charsetName) :解析xm1或html文件的。 parse(String html) :解析xml或html字符串 parse(URL url, int timeoutMillis) :通过网络路径获取指定的html或xml的文档对象 2.Document :文档对象。代表内存中的dom树 getElementById(String id) :根据id属性值获取唯一的element对象 getElementsByTag(String tagName) :根据标签名称获取元素对象集合 getElementsByAttribute(String key) :根据属性名称获取元素对象集合 getElementsByAttributeValue(String key, String value) :根据对应的属性名和属性值获取元素对象集合 3.Elements :元素Element对象的集合。可以当做ArrayList&lt;Element&gt;来使用 4.Element :元素对象 1.获取子元素对象 getElementById(String id) :根据id属性值获取唯一-的element对象 getElementsByTag(String tagName) :根据标签名称获取元素对象集合 getElementsByAttribute(String key) : 根据属性名称获取元素对象集合 getElementsByAttributeValue(String key, string value) :根据对应的属性名和属性值获取元素对象集合 2.获取属性值 String attr(String key) :根据属性名称获取属性值 3.获取文本内容 String text():获取文本内容 String html() :获取标签体的所有内容(包括字标签的字符串内容) 5.Node:节点对象 是Document和Element的父类 快捷查询方式 1.selector: 选择器 使用的方法: Elements select(String cssQuery) 语法:参考selector类中定义的语法 2.XPath : XPath即为XML路径语言，它是-种用来确定XML (标准通用标记语言的子集)文档中某部分位置的语言*使用Jsoup的xpath需要额外导入jar包。 查询w3cshoo]参考手册，使用xpath的语法完成查询","link":"/2015/02/03/%E5%89%8D%E7%AB%AF/xml/jsoup%E8%A7%A3%E6%9E%90%E5%99%A8/"},{"title":"XML认识","text":"XML概念概念：Extensible Markup Language 可扩展标记语言 可扩展标签都是自定义的。 如：&lt;user&gt; &lt;student&gt; 功能 软件的配置文件 在网络中数据传输 XML与HTML的区别 xml标签都是自定义的，html标签是预定义。 xml的语法严格，html语法松散 xml是存储数据的，html是展示数据 XML语法基本语法 xml文档的后缀名 .xml xml第一行必须定义为文档声明 xml文档中有且仅有一个根标签 属性值必须使用引号(单双都可)引起来 标签必须正确关闭 xml标签名称区分大小写 快速入门&lt;?xml version='1.0' encoding='utf-8' ?&gt; &lt;users&gt; &lt;user id='1'&gt; &lt;name&gt;李寻欢&lt;/name&gt; &lt;age&gt;22&lt;/age&gt; &lt;skill&gt;小李飞刀&lt;/skill&gt; &lt;/user&gt; &lt;user id='2'&gt; &lt;name&gt;萧峰&lt;/name&gt; &lt;age&gt;23&lt;/age&gt; &lt;skill&gt;降龙十八掌&lt;/skill&gt; &lt;/user&gt; &lt;/users&gt; 组成部分1.文档声明 1. 格式：&lt;?xml 属性列表 ?&gt; 2. 属性列表： * version：版本号，必须的属性 * encoding：编码方式。告知解析引擎当前文档使用的字符集，默认值：ISO-8859-1 * standalone：是否独立 * 取值： * yes：不依赖其他文件 * no：依赖其他文件 2.指令(了解)：结合css的 &lt;?xml-stylesheet type=&quot;text/css&quot; href=&quot;a.css&quot; ?&gt; 示例: name{ color: red } skill{ color: yellow; } &lt;?xml version='1.0' encoding='utf-8' ?&gt; &lt;?xml-stylesheet type=&quot;text/css&quot; href=&quot;test.css&quot; ?&gt; &lt;users&gt; &lt;user&gt; &lt;name&gt;李寻欢&lt;/name&gt; &lt;age&gt;22&lt;/age&gt; &lt;skill&gt;小李飞刀&lt;/skill&gt; &lt;/user&gt; &lt;user&gt; &lt;name&gt;萧峰&lt;/name&gt; &lt;age&gt;23&lt;/age&gt; &lt;skill&gt;降龙十八掌&lt;/skill&gt; &lt;compare&gt; &lt;![CDATA[ if (age&lt;=22){ }else{ } ]]&gt; &lt;/compare&gt; &lt;/user&gt; &lt;/users&gt; 3.标签：标签名称自定义的 规则： 名称可以包含字母、数字以及其他的字符 名称不能以数字或者标点符号开始 名称不能以字母 xml（或者 XML、Xml 等等）开始 名称不能包含空格 4.属性：id属性值唯一 5.文本： CDATA区：在该区域中的数据会被原样展示格式： &lt;![CDATA[ 数据 ]]&gt; 示例: &lt;?xml version='1.0' encoding='utf-8' ?&gt; &lt;users&gt; &lt;user&gt; &lt;name&gt;李寻欢&lt;/name&gt; &lt;age&gt;22&lt;/age&gt; &lt;skill&gt;小李飞刀&lt;/skill&gt; &lt;/user&gt; &lt;user&gt; &lt;name&gt;萧峰&lt;/name&gt; &lt;age&gt;23&lt;/age&gt; &lt;skill&gt;降龙十八掌&lt;/skill&gt; &lt;compare&gt; &lt;![CDATA[ if (age&lt;=22){ }else{ } ]]&gt; &lt;/compare&gt; &lt;/user&gt; &lt;/users&gt; 约束规定xml文档的书写规则 作为框架的使用者(程序员)： 能够在xml中引入约束文档 能够简单的读懂约束文档分类： DTD:一种简单的约束技术 Schema:一种复杂的约束技术 DTD引入dtd文档到xml文档中 1）内部dtd：将约束规则定义在xml文档中(很少用) 2）外部dtd：将约束的规则定义在外部的dtd文件中 2.1） 本地：&lt;!DOCTYPE 根标签名 SYSTEM &quot;dtd文件的位置&quot;&gt; 2.2）网络：&lt;!DOCTYPE 根标签名 PUBLIC &quot;dtd文件名字&quot; &quot;dtd文件的位置URL&quot;&gt; 示例内部dtd： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE students [ &lt;!ELEMENT students (student*) &gt; &lt;!ELEMENT student (name,age,sex)&gt; &lt;!ELEMENT name (#PCDATA)&gt; &lt;!ELEMENT age (#PCDATA)&gt; &lt;!ELEMENT sex (#PCDATA)&gt; &lt;!ATTLIST student number ID #REQUIRED&gt; ]&gt; &lt;students&gt; &lt;student number=&quot;ecit_0001&quot;&gt; &lt;name&gt;tom&lt;/name&gt; &lt;age&gt;18&lt;/age&gt; &lt;sex&gt;male&lt;/sex&gt; &lt;/student&gt; &lt;/students&gt; 示例外部dtd 本地引入student.dtd &lt;!ELEMENT students (student*) &gt; &lt;!ELEMENT student (name,age,sex)&gt; &lt;!ELEMENT name (#PCDATA)&gt; &lt;!ELEMENT age (#PCDATA)&gt; &lt;!ELEMENT sex (#PCDATA)&gt; &lt;!ATTLIST student number ID #REQUIRED&gt; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE students SYSTEM &quot;student.dtd&quot;&gt; &lt;students&gt; &lt;student number=&quot;ecit_0001&quot;&gt; &lt;name&gt;tom&lt;/name&gt; &lt;age&gt;18&lt;/age&gt; &lt;sex&gt;male&lt;/sex&gt; &lt;/student&gt; &lt;/students&gt; Schema 引入： 1.填写xml文档的根元素 2.引入xsi前缀. xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; 3.引入xsd文件命名空间. xsi:schemaLocation=&quot;http://www.itcast.cn/xml student.xsd&quot; 4.为每一个xsd约束声明一个前缀,作为标识 xmlns=&quot;http://www.itcast.cn/xml&quot; 示例 &lt;students xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://www.ecit.cn/xml&quot; xsi:schemaLocation=&quot;http://www.ecit.cn/xml student.xsd&quot;&gt; XML解析xml常见的解析器: 1.JAXP : sun公司提供的解析器,支持dom和sax两种思想 2.DOM4J :-款非常优秀的解析器 3.Jsoup: jsoup 是一款Java的HTML解析器， 可直接解析某个URL地址、HTML文本内容。 它提供了一 套非常省力的API,可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。 4.PULL : Android操作系统内置的解析器，sax方式的。","link":"/2015/02/01/%E5%89%8D%E7%AB%AF/xml/xml01/"},{"title":"","text":"","link":"/2020/06/29/%E5%89%8D%E7%AB%AF/%E5%89%8D%E5%8F%B0%E6%B8%B2%E6%9F%93%E6%A8%A1%E6%9D%BF/freemarker/"},{"title":"","text":"","link":"/2020/06/29/%E5%89%8D%E7%AB%AF/%E5%89%8D%E5%8F%B0%E6%B8%B2%E6%9F%93%E6%A8%A1%E6%9D%BF/thymeleaf/"},{"title":"前端项目构建工具--webpack","text":"webpack解决什么问题的 webpack 是前端的一个项目构建工具，它是基于 Node.js 开发出来的一个前端工具.( webpack官网) 借助于webpack这个前端自动化构建工具，可以完美实现资源的合并、打包、压缩、混淆等诸多功能. 使用Webpack， 是基于整个项目进行构建的；使用Gulp， 是基于task任务的； 在网页中会引用哪些常见的静态资源？ JS .js .jsx .coffee .ts（TypeScript 类 C# 语言） CSS .css .less .sass .scss Images .jpg .png .gif .bmp .svg 字体文件（Fonts） .svg .ttf .eot .woff .woff2 模板文件 .ejs .jade .vue【这是在webpack中定义组件的方式，推荐这么用】 网页中引入的静态资源多了以后有什么问题？ 1.网页加载速度慢， 因为 我们要发起很多的二次请求； 2.要处理错综复杂的依赖关系 解决上述两个问题常用手段 1.合并、压缩、精灵图、图片的Base64编码 2.可以使用之前学过的requireJS、也可以使用webpack可以解决各个包之间的复杂依赖关系 webpack安装的两种方式 运行 npm i webpack -g 全局安装webpack，这样就能在全局使用webpack的命令 在项目根目录中运行 npm i webpack --save-dev 安装到项目依赖中 初步使用webpack打包构建列表隔行变色案例 创建工程目录 mkdir webpack-learn &amp;&amp; cd webpack-learn &amp;&amp; mkdir {src,dist} &amp;&amp; cd src &amp;&amp; mkdir {js,css,images} 在项目根目录webpack-learn下 ，运行 npm init -y 初始化项目，使用npm管理项目中的依赖包 先安装cnpm命令 npm i cnpm -g,然后使用 cnpm命令安装 jquery库 cnpm i jquery --save,安装完项目根目录下会有一个node_modules目录，里面存放了三方库 在src目录下创建首页 index.html 和项目js入口文件 main.js 并书写各行变色的代码逻辑：&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;../dist/bundle.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;张三&lt;/li&gt; &lt;li&gt;丽思&lt;/li&gt; &lt;li&gt;王五&lt;/li&gt; &lt;li&gt;古丽&lt;/li&gt; &lt;li&gt;李四&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt; // 1. 导入 Jquery // import *** from *** 是ES6中导入模块的方式 // 由于 ES6的代码，太高级了，浏览器解析不了，所以，这一行执行会报错 import $ from 'jquery' $(function () { $('li:odd').css('backgroundColor', 'yellow') $('li:even').css('backgroundColor', function () { return '#' + 'FF00FF' }) }) 因为浏览器不认识import这种高级的JS语法，需要使用webpack进行处理，webpack默认会把这种高级的语法转换为低级的浏览器能识别的语法,运行webpack 入口文件路径 输出文件路径对main.js进行处理：webpack src/js/main.js dist/bundle.js 3.0+版本 webpack src/js/main.js -o dist/bundle.js --mode=none 4.0+版本 查看效果： 使用webpack的配置文件简化打包时候的命令 在项目根目录中创建webpack.config.js 由于运行webpack命令的时候，webpack需要指定入口文件和输出文件的路径，所以，我们需要在webpack.config.js中配置这两个路径：// 导入处理路径的模块 var path = require('path'); // 导出一个配置对象，将来webpack在启动的时候，会默认来查找webpack.config.js，并读取这个文件中导出的配置对象，来进行打包处理 module.exports = { entry: path.resolve(__dirname, 'src/js/main.js'), // 项目入口文件 output: { // 配置输出选项 path: path.resolve(__dirname, 'dist'), // 配置输出的路径 filename: 'bundle.js' // 配置输出的文件名 }, mode:'none' //4.0+版本要加, 3.0+版本可以不加 } 这样每次只需在 工程下输入 webpack 就可以完成打包js的任务 实现webpack的实时打包构建-webpack-dev-server 1.由于每次重新修改代码之后，都需要手动运行webpack打包的命令，比较麻烦，所以使用webpack-dev-server来实现代码实时打包编译，当修改代码之后，会自动进行打包构建。 2.运行cnpm i webpack-dev-server --save-dev安装到开发依赖；运行cnpm i webpack --save-dev安装到项目本地；如果webpack版本是4.0+，则需要运行 cnpm i webpack-cli --save-dev安装到项目本地 3.安装完成之后，在命令行直接运行webpack-dev-server来进行打包，发现报错，此时需要借助于package.json文件中的指令，来进行运行webpack-dev-server命令，在scripts节点下新增&quot;dev&quot;: &quot;webpack-dev-server&quot;指令，发现可以进行实时打包，但是dist目录下并没有生成bundle.js文件，这是因为webpack-dev-server将打包好的文件放在了内存中 把bundle.js放在内存中的好处是：由于需要实时打包编译，所以放在内存中速度会非常快 npm run dev 运行启动，这个时候访问webpack-dev-server启动的http://localhost:8080/网站，发现是一个文件夹的面板，需要点击到src目录下，才能打开我们的index首页，此时引用不到bundle.js文件，需要修改index.html中script的src属性为:&lt;script src=&quot;../bundle.js&quot;&gt;&lt;/script&gt; 为了能在访问http://localhost:8080/的时候直接访问到index首页，可以使用--contentBase src指令来修改dev指令，指定启动的根目录：&quot;dev&quot;: &quot;webpack-dev-server&quot;, &quot;dev1&quot;: &quot;webpack-dev-server --contentBase src&quot;, &quot;dev2&quot;: &quot;webpack-dev-server --open --port 3000 --contentBase src --hot&quot; //推荐这个配置，启动 npm run dev2 同时修改index页面中script的src属性为&lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt; 使用html-webpack-plugin插件配置启动页面 由于使用--contentBase指令的过程比较繁琐，需要指定启动的目录，同时还需要修改index.html中script标签的src属性，所以推荐使用html-webpack-plugin插件配置启动页面. 1.运行cnpm i html-webpack-plugin --save-dev安装到开发依赖 2.修改webpack.config.js配置文件如下： // 导入处理路径的模块 var path = require('path'); // 导入自动生成HTMl文件的插件 var htmlWebpackPlugin = require('html-webpack-plugin'); // 导出一个配置对象，将来webpack在启动的时候，会默认来查找webpack.config.js，并读取这个文件中导出的配置对象，来进行打包处理 module.exports = { entry: path.resolve(__dirname, 'src/js/main.js'), // 项目入口文件 output: { // 配置输出选项 path: path.resolve(__dirname, 'dist'), // 配置输出的路径 filename: 'bundle.js' // 配置输出的文件名 }, mode:'none', //4.0+版本要加, 3.0+版本可以不加 plugins:[ // 添加plugins节点配置插件 new htmlWebpackPlugin({ template:path.resolve(__dirname, 'src/index.html'),//模板路径 filename:'index.html'//自动生成的HTML文件的名称 }) ] } 3.修改package.json中script节点中的dev指令如下： &quot;dev&quot;: &quot;webpack-dev-server&quot; 4.将index.html中script标签注释掉，因为html-webpack-plugin插件会自动把bundle.js注入到index.html页面中！ 运行 npm run dev 查看效果。 实现自动打开浏览器、热更新和配置浏览器的默认端口号方式一 修改package.json的script节点如下，其中--open表示自动打开浏览器，--port 4321表示打开的端口号为4321，--hot表示启用浏览器热更新：&quot;dev&quot;: &quot;webpack-dev-server --hot --port 4321 --open&quot; 方式二(不推荐) 修改webpack.config.js文件，新增devServer节点如下devServer: { // 这是配置 dev-server 命令参数的第二种形式，相对来说，这种方式麻烦一些 // --open --port 3000 --contentBase src --hot open: true, // 自动打开浏览器 port: 3000, // 设置启动时候的运行端口 contentBase: 'src', // 指定托管的根目录 hot: true // 启用热更新 的 第1步 }, 在头部引入webpack模块：// 启用热更新的 第2步 const webpack = require('webpack') 在plugins节点下新增：new webpack.HotModuleReplacementPlugin() 最终 webpack.config.js修改为：// 导入处理路径的模块 var path = require('path'); // 导入自动生成HTMl文件的插件 // 只要是插件，都一定要 放到 plugins 节点中去 // 这个插件的两个作用： // 1. 自动在内存中根据指定页面生成一个内存的页面 // 2. 自动，把打包好的 bundle.js 追加到页面中去 var htmlWebpackPlugin = require('html-webpack-plugin'); // 启用热更新的 第2步 const webpack = require('webpack') // 导出一个配置对象，将来webpack在启动的时候，会默认来查找webpack.config.js，并读取这个文件中导出的配置对象，来进行打包处理 module.exports = { entry: path.resolve(__dirname, 'src/js/main.js'), // 项目入口文件 output: { // 配置输出选项 path: path.resolve(__dirname, 'dist'), // 配置输出的路径 filename: 'bundle.js' // 配置输出的文件名 }, mode:'none', //4.0+版本要加, 3.0+版本可以不加 devServer: { // 这是配置 dev-server 命令参数的第二种形式，相对来说，这种方式麻烦一些 // --open --port 3000 --contentBase src --hot open: true, // 自动打开浏览器 port: 3000, // 设置启动时候的运行端口 contentBase: 'src', // 指定托管的根目录 hot: true // 启用热更新 的 第1步 }, plugins:[ // 添加plugins节点配置插件 new webpack.HotModuleReplacementPlugin(), // new 一个热更新的 模块对象， 这是 启用热更新的第 3 步 new htmlWebpackPlugin({ template:path.resolve(__dirname, 'src/index.html'),//模板路径 filename:'index.html'//自动生成的HTML文件的名称 }) ] } 使用webpack打包css文件,less文件,sass文件 在项目css目录下新建 index.css ,index.less,index.scss index.css示例：li{ list-style: none; } index.less示例：ul{ padding: 0; margin: 0; } index.scss示例：html, body{ margin: 0; padding: 0; li{ font-size: 12px; line-height: 30px; } } 在main.js导入示例：// 使用 import 语法，导入 CSS样式表 import '../css/index.css' import '../css/index.less' import '../css/index.scss' // 注意： webpack, 默认只能打包处理 JS 类型的文件，无法处理 其它的非 JS 类型的文件； // 如果要处理 非JS类型的文件，我们需要手动安装一些 合适 第三方 loader 加载器； // 1. 如果想要打包处理 css 文件，需要安装 cnpm i style-loader css-loader -D // 2. 打开 webpack.config.js 这个配置文件，在 里面，新增一个 配置节点，叫做 module, 它是一个对象；在 这个 module 对象身上，有个 rules 属性，这个 rules 属性是个 数组；这个数组中，存放了，所有第三方文件的 匹配和 处理规则； // 注意： webpack 处理第三方文件类型的过程： // 1. 发现这个 要处理的文件不是JS文件，然后就去 配置文件中，查找有没有对应的第三方 loader 规则 // 2. 如果能找到对应的规则， 就会调用 对应的 loader 处理 这种文件类型； // 3. 在调用loader 的时候，是从后往前调用的； // 4. 当最后的一个 loader 调用完毕，会把 处理的结果，直接交给 webpack 进行 打包合并，最终输出到 bundle.js 中去 运行cnpm i style-loader css-loader --save-dev ；运行cnpm i less-loader less -D ；运行cnpm i sass-loader node-sass --save-dev，然后分别修改webpack.config.jsmodule: { // 这个节点，用于配置 所有 第三方模块 加载器 rules: [ // 所有第三方模块的 匹配规则 { test: /\\.css$/, use: ['style-loader', 'css-loader'] }, // 配置处理 .css 文件的第三方loader 规则 { test: /\\.less$/, use: ['style-loader', 'css-loader', 'less-loader'] }, //配置处理 .less 文件的第三方 loader 规则 { test: /\\.scss$/, use: ['style-loader', 'css-loader', 'sass-loader'] }, // 配置处理 .scss 文件的 第三方 loader 规则 ] } 最终完整的 webpack.config.js如下：// 导入处理路径的模块 var path = require('path'); // 导入自动生成HTMl文件的插件 // 只要是插件，都一定要 放到 plugins 节点中去 // 这个插件的两个作用： // 1. 自动在内存中根据指定页面生成一个内存的页面 // 2. 自动，把打包好的 bundle.js 追加到页面中去 var htmlWebpackPlugin = require('html-webpack-plugin'); // 启用热更新的 第2步 const webpack = require('webpack') // 导出一个配置对象，将来webpack在启动的时候，会默认来查找webpack.config.js，并读取这个文件中导出的配置对象，来进行打包处理 module.exports = { entry: path.resolve(__dirname, 'src/js/main.js'), // 项目入口文件 output: { // 配置输出选项 path: path.resolve(__dirname, 'dist'), // 配置输出的路径 filename: 'bundle.js' // 配置输出的文件名 }, mode:'none', //4.0+版本要加, 3.0+版本可以不加 devServer: { // 这是配置 dev-server 命令参数的第二种形式，相对来说，这种方式麻烦一些 // --open --port 3000 --contentBase src --hot open: true, // 自动打开浏览器 port: 3000, // 设置启动时候的运行端口 contentBase: 'src', // 指定托管的根目录 hot: true // 启用热更新 的 第1步 }, plugins:[ // 添加plugins节点配置插件 new webpack.HotModuleReplacementPlugin(), // new 一个热更新的 模块对象， 这是 启用热更新的第 3 步 new htmlWebpackPlugin({ template:path.resolve(__dirname, 'src/index.html'),//模板路径 filename:'index.html'//自动生成的HTML文件的名称 }) ], module: { // 这个节点，用于配置 所有 第三方模块 加载器 rules: [ // 所有第三方模块的 匹配规则 { test: /\\.css$/, use: ['style-loader', 'css-loader'] }, // 配置处理 .css 文件的第三方loader 规则 { test: /\\.less$/, use: ['style-loader', 'css-loader', 'less-loader'] }, //配置处理 .less 文件的第三方 loader 规则 { test: /\\.scss$/, use: ['style-loader', 'css-loader', 'sass-loader'] }, // 配置处理 .scss 文件的 第三方 loader 规则 ] } } 使用webpack处理css中的路径 1.运行cnpm i url-loader file-loader --save-dev 2.在webpack.config.js中添加处理url路径的loader模块：{ test: /\\.(png|jpg|gif)$/, use: 'url-loader' } 3.可以通过limit指定进行base64编码的图片大小；只有小于指定字节（byte）的图片才会进行base64编码：{ test: /\\.(jpg|png|gif|bmp|jpeg)$/, use: 'url-loader?limit=7631&amp;name=[hash:8]-[name].[ext]' }, // 处理 图片路径的 loader // limit 给定的值，是图片的大小，单位是 byte， 如果我们引用的 图片，大于或等于给定的 limit值，则不会被转为base64格式的字符串， 如果 图片小于给定的 limit 值，则会被转为 base64的字符串 { test: /\\.(ttf|eot|svg|woff|woff2)$/, use: 'url-loader' }, // 处理 字体文件的 loader 使用babel处理高级JS语法 1.运行cnpm i babel-core babel-loader babel-plugin-transform-runtime -D安装babel的相关loader包 2.运行cnpm i babel-preset-env babel-preset-stage-0 -D安装babel转换的语法 3.在webpack.config.js中添加相关loader模块，其中需要注意的是，一定要把node_modules文件夹添加到排除项：{ test: /\\.js$/, use: 'babel-loader', exclude: /node_modules/ } 4.在项目根目录中添加.babelrc文件，并修改这个配置文件如下：{ &quot;presets&quot;:[&quot;env&quot;, &quot;stage-0&quot;], &quot;plugins&quot;:[&quot;transform-runtime&quot;] } 注意事项：详解babel升级到7.X采坑总结 项目提示没找到@babel/core，需要把babel-core卸载掉，从新安装@babel/corenpm un babel-core npm i -D @babel/core 在webpack中配置.vue组件页面的解析 1.运行cnpm i vue -S将vue安装为运行依赖； 2.运行cnpm i vue-loader vue-template-compiler -D将解析转换vue的包安装为开发依赖； 3.运行cnpm i style-loader css-loader -D将解析转换CSS的包安装为开发依赖，因为.vue文件中会写CSS样式； 4.在webpack.config.js中，添加如下module规则：module: { rules: [ { test: /\\.css$/, use: ['style-loader', 'css-loader'] }, { test: /\\.vue$/, use: 'vue-loader' }// 处理 .vue 文件的 loader ] } 5.在main.js入口文件：导入vue组件(关键要注意的几点) 导入指令，但此时导入的的是runtime-only方式，还需要额外解析import Vue from 'vue' // 回顾 包的查找规则： // 1. 找 项目根目录中有没有 node_modules 的文件夹 // 2. 在 node_modules 中 根据包名，找对应的 vue 文件夹 // 3. 在 vue 文件夹中，找 一个叫做 package.json 的包配置文件 // 4. 在 package.json 文件中，查找 一个 main 属性【main属性指定了这个包在被加载时候，的入口文件】,npm安装完vue默认在node_modules/vue/package.json 的&quot;main&quot;:为 &quot;dist/vue.runtime.common.js&quot;, // 也就是要注意：在 webpack 中， 使用 import Vue from 'vue' 导入的 Vue 构造函数，功能不完整，只提供了 runtime-only 的方式，并没有提供 像网页中那样的使用方式；import Vue from '../../node_modules/vue/dist/vue.js' var app = new Vue({ el: '#app', data:{ msg:'123' } }); 主要修改 webpack.config.jsresolve: { alias: { // 修改 Vue 被导入时候的包的路径,对结尾vue的进行解析 &quot;vue$&quot;: &quot;vue/dist/vue.js&quot; } } 在 index.html添加模板与之挂载,就完成了&lt;div id=&quot;app&quot;&gt; &lt;h2&gt;{{msg}}&lt;h2&gt; &lt;/div&gt; 6.自定义组件使用 main.js修改import Vue from 'vue' var login = { template: '&lt;h1&gt;这是login组件，是使用网页中形式创建出来的组件&lt;/h1&gt;' } var app = new Vue({ el: '#app', data:{ msg:'自强不息' }, components: { login } }); index.html使用自定义组件&lt;div id=&quot;app&quot;&gt; &lt;h2&gt;{{msg}}&lt;h2&gt; &lt;login&gt;&lt;/login&gt; &lt;/div&gt; 7.使用抽离组件为 .vue 再使用 在src下新建 login.vue，组件有三部分组成: template script style&lt;template&gt; &lt;div&gt; &lt;h1&gt;这是登录组件，使用 .vue 文件定义出来的&lt;/h1&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; &lt;/script&gt; &lt;style&gt; &lt;/style&gt; 在main.js入口文件导入组件并渲染import Vue from 'vue' import login from '../login.vue' var app = new Vue({ el: '#app', data:{ msg:'自强不息' }, render: function (createElements) { // 在 webpack 中，如果想要通过 vue， 把一个组件放到页面中去展示，vm 实例中的 render 函数可以实现 return createElements(login) } //等同于这个简写 render: c =&gt; c(login) }); 如果vue-loader版本是 15.0+，还需要额外安装插件 cnpm i vue-loader-plugin -S，并在webpack.config.js中配置插件// vue-loader在 15.0+版本需要额外启用插件 const VueLoaderPlugin = require('vue-loader/lib/plugin') //添加plugins节点配置插件 new VueLoaderPlugin() 在login.vue，使用export default 使用data属性和 methods&lt;template&gt; &lt;div&gt; &lt;h1&gt;这是登录组件，使用 .vue 文件定义出来的 --- {{msg}}&lt;/h1&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { // 注意：组件中的 data 必须是 function return { msg: &quot;功勋卓著&quot; }; }, methods: { show() { console.log(&quot;调用了 login.vue 中的 show 方法&quot;); } } }; &lt;/script&gt; &lt;style&gt; &lt;/style&gt; export default 和 export区别 在 ES6 中，使用 export default 和 export 向外暴露成员： 注意： export default 向外暴露的成员，可以使用任意的变量来接收 注意： 在一个模块中，export default 只允许向外暴露1次 注意： 在一个模块中，可以同时使用 export default 和 export 向外暴露成员 注意： 使用 export 向外暴露的成员，只能使用 { } 的形式来接收，这种形式，叫做按需导出 注意： export 可以向外暴露多个成员， 同时，如果某些成员，我们在 import 的时候，不需要，则可以 不在 {} 中定义 注意： 使用 export 导出的成员，必须严格按照 导出时候的名称，来使用 {} 按需接收； 注意： 使用 export 导出的成员，如果 就想 换个名称来接收，可以使用 as 来起别名； 新建test.jsvar info = { name: '薛岳', age: 20 } export default info export var title = '长沙保卫战' export var content = '天炉战法' 在main.js导入模块标识使用import infomation, { title as titleAlia, content } from './test.js' console.log(infomation) console.log(titleAlia + ' --- ' + content) ES6中语法使用总结 1.使用 export default 和 export 导出模块中的成员; 对应ES5中的 module.exports 和 export 2.使用 import ** from ** 和 import '路径' 还有 import {a, b} from '模块标识' 导入其他模块 3.使用箭头函数：(a, b)=&gt; { return a-b; } 在vue组件页面中，集成vue-router路由模块 安装vue-router组件 cnpm i vue-router -S 在src新建 App.vue,GoodsList.vue,Account.vue App.vue&lt;template&gt; &lt;div&gt; &lt;h1&gt;这是 App 组件&lt;/h1&gt; &lt;router-link to=&quot;/account&quot;&gt;Account&lt;/router-link&gt; &lt;router-link to=&quot;/goodslist&quot;&gt;Goodslist&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; &lt;/script&gt; &lt;style&gt; &lt;/style&gt; GoodsList.vue&lt;template&gt; &lt;div&gt; &lt;h1&gt;这是 GoodsList 组件&lt;/h1&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; &lt;/script&gt; &lt;style&gt; &lt;/style&gt; Account.vue&lt;template&gt; &lt;div&gt; &lt;h1&gt;这是 Account 组件&lt;/h1&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; &lt;/script&gt; &lt;style&gt; &lt;/style&gt; main.js导入，配置路由import Vue from 'vue' // 1. 导入 vue-router 包 import VueRouter from 'vue-router' // 2. 手动安装 VueRouter Vue.use(VueRouter) // 导入 app 组件 import app from './App.vue' // 导入 Account 组件 import account from './Account.vue' import goodslist from './GoodsList.vue' // 3. 创建路由对象 var router = new VueRouter({ routes: [ // account goodslist { path: '/account', component: account }, { path: '/goodslist', component: goodslist } ] }) var vm = new Vue({ el: '#app', render: c =&gt; c(app), // render 会把 el 指定的容器中，所有的内容都清空覆盖，所以 不要 把 路由的 router-view 和 router-link 直接写到 el 所控制的元素中 router // 4. 将路由对象挂载到 vm 上 }) // 注意： App 这个组件，是通过 VM 实例的 render 函数，渲染出来的， render 函数如果要渲染 组件， 渲染出来的组件，只能放到 el: '#app' 所指定的 元素中； // Account 和 GoodsList 组件， 是通过 路由匹配监听到的，所以， 这两个组件，只能展示到 属于 路由的 &lt;router-view&gt;&lt;/router-view&gt; 中去； 添加子路由嵌套路由 在src下新建 login.vue&lt;template&gt; &lt;div&gt; &lt;h3&gt;这是Account的登录子组件&lt;/h3&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; &lt;/script&gt; &lt;style scoped&gt;&lt;!--scoped属性修改的样式只针对本组件--&gt; div { color: red; } &lt;/style&gt; 修改Account.vue&lt;template&gt; &lt;div&gt; &lt;h1&gt;这是 Account 组件&lt;/h1&gt; &lt;router-link to=&quot;/account/login&quot;&gt;登录&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; &lt;/script&gt; &lt;style lang=&quot;scss&quot; scoped&gt; /* 普通的 style 标签只支持 普通的 样式，如果想要启用 scss 或 less ，需要为 style 元素，设置 lang 属性 */ // 只要 咱们的 style 标签， 是在 .vue 组件中定义的，那么，推荐都为 style 开启 scoped 属性 body { div { font-style: italic; } } &lt;/style&gt; 修改main.jsimport Vue from 'vue' // 1. 导入 vue-router 包 import VueRouter from 'vue-router' // 2. 手动安装 VueRouter Vue.use(VueRouter) // 导入 app 组件 import app from './App.vue' // 导入 Account 组件 import account from './Account.vue' import goodslist from './GoodsList.vue' // 3. 创建路由对象 var router = new VueRouter({ routes: [ // account goodslist { path: '/account', component: account, children: [ { path: 'login', component: login } ] }, { path: '/goodslist', component: goodslist } ] }) var vm = new Vue({ el: '#app', render: c =&gt; c(app), // render 会把 el 指定的容器中，所有的内容都清空覆盖，所以 不要 把 路由的 router-view 和 router-link 直接写到 el 所控制的元素中 router // 4. 将路由对象挂载到 vm 上 }) // 注意： App 这个组件，是通过 VM 实例的 render 函数，渲染出来的， render 函数如果要渲染 组件， 渲染出来的组件，只能放到 el: '#app' 所指定的 元素中； // Account 和 GoodsList 组件， 是通过 路由匹配监听到的，所以， 这两个组件，只能展示到 属于 路由的 &lt;router-view&gt;&lt;/router-view&gt; 中去； 抽离路由信息 新建router.js,把main.js中路由创建信息抽离出来```jsimport VueRouter from ‘vue-router’// 导入 Account 组件import account from ‘./Account.vue’import goodslist from ‘./GoodsList.vue’ // 导入Account的子组件import login from ‘./login.vue’// 3. 创建路由对象var router = new VueRouter({ routes: [ { path: ‘/account’, component: account, children: [ { path: ‘login’, component: login } ] }, { path: ‘/goodslist’, component: goodslist } ]})// 把路由对象暴露出去export default router - main.js最后修改 ```js import Vue from 'vue' // 1. 导入 vue-router 包 import VueRouter from 'vue-router' // 2. 手动安装 VueRouter Vue.use(VueRouter) // 导入 app 组件 import app from './App.vue' // 导入 自定义路由模块 import router from './router.js' var vm = new Vue({ el: '#app', render: c =&gt; c(app), // render 会把 el 指定的容器中，所有的内容都清空覆盖，所以 不要 把 路由的 router-view 和 router-link 直接写到 el 所控制的元素中 router // 4. 将路由对象挂载到 vm 上 }) // 注意： App 这个组件，是通过 VM 实例的 render 函数，渲染出来的， render 函数如果要渲染 组件， 渲染出来的组件，只能放到 el: '#app' 所指定的 元素中； // Account 和 GoodsList 组件， 是通过 路由匹配监听到的，所以， 这两个组件，只能展示到 属于 路由的 &lt;router-view&gt;&lt;/router-view&gt; 中去； 使用 饿了么的 移动端MintUI组件 Mint UI 包含丰富的 CSS 和 JS 组件，能够满足日常的移动端开发需要。通过它，可以快速构建出风格统一的页面，提升开发效率。 考虑到移动端的性能门槛，Mint UI 采用 CSS3 处理各种动效，避免浏览器进行不必要的重绘和重排，从而使用户获得流畅顺滑的体验。 依托 Vue.js 高效的组件化方案，Mint UI 做到了轻量化。即使全部引入，压缩后的文件体积也仅有 ~30kb (JS + CSS) gzip。 地址：http://mint-ui.github.io/，文档：http://mint-ui.github.io/docs/#/zh-cn2/ 安装// 安装 # Vue 1.x npm install mint-ui@1 -S # Vue 2.0 npm install mint-ui -S 引入// 引入全部组件 import Vue from 'vue'; import Mint from 'mint-ui'; import 'mint-ui/lib/style.css';//导入样式 Vue.use(Mint); // 按需引入部分组件 import { Cell, Checklist } from 'mint-ui'; Vue.component(Cell.name, Cell); Vue.component(Checklist.name, Checklist); 在页面组件种直接使用&lt;mt-button type=&quot;primary&quot; size=&quot;large&quot;&gt;primary&lt;/mt-button&gt;","link":"/2018/03/05/%E5%89%8D%E7%AB%AF/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/webpack/"},{"title":"MySQL第一篇--入门篇","text":"MySQL MySQL:开源免费的数据库，小型的数据库，已经被Oracle收购了。MySQL6.x 版本也开始收费。后来Sun公司收购了MySQL，而Sun公司又被Oracle收购 数据库基本概念 数据库的英文单词:DataBase,简称DB 用于存储和管理数据的仓库。 数据库的特点： 持久化存储数据的。其实数据库就是一个文件系统 方便存储和管理数据 使用了统一的方式操作数据库–SQL MySQL数据库软件 产品 sqlserver –&gt;微软 收费 Mysql –&gt;Oracle收购 免费 Oracle–&gt;Oracle 收费 DB2–&gt;IBM 份额很少 mysql数据类型 SQLSQL基本概念 Structured Query Language：结构化查询语言 其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为“方言”。 SQL分类-- DDL(Data Definition Language)数据定义语言 用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等 -- DML(Data Manipulation Language)数据操作语言 用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等 -- DQL(Data Query Language)数据查询语言 用来查询数据库中表的记录(数据)。关键字：select, where 等 --DCL(Data Control Language)数据控制语言(了解) 用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等 DDL 操作数据库表操作数据库CRUD 1.C(Create):创建 -- 创建数据库： create database 数据库名称; -- 创建数据库，判断不存在，再创建： create database if not exists 数据库名称; -- 创建数据库，并指定字符集 create database 数据库名称 character set 字符集名; 2.R(Retrieve)：查询 -- 查询所有数据库的名称: show databases; -- 查询某个数据库的字符集:查询某个数据库的创建语句 show create database 数据库名称; 3.U(Update):修改 -- 修改数据库的字符集 alter database 数据库名称 character set 字符集名称; 4.D(Delete):删除 -- 删除数据库 drop database 数据库名称; -- 判断数据库存在，存在再删除 drop database if exists 数据库名称; 5.使用数据库 -- 查询当前正在使用的数据库名称 select database(); -- 使用数据库 use 数据库名称; 操作表CRUD 1.C(Create):创建 语法： create table 表名( 列名1 数据类型1, 列名2 数据类型2, .... 列名n 数据类型n ); -- 注意：最后一列，不需要加逗号（,） -- 数据库类型： -- 1. int：整数类型 age int, -- 2. double:小数类型 score double(5,2) -- 3. date:日期，只包含年月日，yyyy-MM-dd -- 4. datetime:日期，包含年月日时分秒 yyyy-MM-dd HH:mm:ss -- 5. timestamp:时间错类型 包含年月日时分秒 yyyy-MM-dd HH:mm:ss -- 如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值 -- 6. varchar：字符串 name varchar(20):--姓名最大20个字符 -- zhangsan 8个字符 张三 2个字符 --创建表 create table student( id int, name varchar(32), age int , score double(4,1), birthday date, insert_time timestamp ); --复制表： create table 表名 like 被复制的表名; 2.R(Retrieve)：查询 -- 查询某个数据库中所有的表名称 show tables; -- 查询表结构 desc 表名; 3.U(Update):修改 -- 1. 修改表名 alter table 表名 rename to 新的表名; -- 2. 修改表的字符集 alter table 表名 character set 字符集名称; -- 3. 添加一列 alter table 表名 add 列名 数据类型; -- 4. 修改列名称 类型 alter table 表名 change 列名 新列别 新数据类型; alter table 表名 modify 列名 新数据类型; -- 5. 删除列 alter table 表名 drop 列名; 4.D(Delete):删除 drop table 表名; drop table if exists 表名 ; DML 增删改表中数据1.添加数据, 语法 insert into 表名(列名1,列名2,...列名n) values(值1,值2,...值n); -- 注意： -- 1. 列名和值要一一对应。 -- 2. 如果表名后，不定义列名，则默认给所有列添加值 insert into 表名 values(值1,值2,...值n); -- 3. 除了数字类型，其他类型需要使用引号(单双都可以)引起来 1.1蠕虫复制将一张已经存在的表中的数据复制到另一张表中，语法格式: -- 将表名2中的所有的列复制到表名1中 INSERT INTO 表名1 SELECT * FROM 表名2; -- 只复制部分列 INSERT INTO 表名1(列1，列2) SELECT 列1,列2 FROM 表名2; -- 创建 student2 表，student2 结构和 student 表结构一样 create table student2 like student; -- 将 student 表中的数据添加到 student2 表中 insert into student2 select * from student; -- 如果只想复制 student 表中 name,age 字段数据到 student2 表中，两张表都写出相应的列名 insert into student2 (name,age) select name,age from student; 2.删除数据,语法： delete from 表名 [where 条件] -- 注意： -- 1. 如果不加条件，则删除表中所有记录。 -- 2. 如果要删除所有记录 delete from 表名; -- 不推荐使用。有多少条记录就会执行多少次删除操作 TRUNCATE TABLE 表名; -- 推荐使用，效率更高 先删除表，然后再创建一张一样的表。 3.修改数据,语法: update 表名 set 列名1 = 值1, 列名2 = 值2,... [where 条件]; -- 注意： -- 1. 如果不加任何条件，则会将表中所有记录全部修改。 DQL 查询表中的记录1.语法：select 字段列表 from 表名列表 where 条件列表 group by 分组字段 having 分组之后的条件 order by 排序 limit 分页限定 1.1单列排序，只按某一个字段进行排序，单列排序。 -- 查询所有数据,使用年龄降序排序 select * from student order by age desc; 1.2组合排序,同时对多个字段进行排序，如果第 1 个字段相等，则按第 2 个字段排序，依次类推。 -- 查询所有数据,在年龄降序排序的基础上，如果年龄相同再以数学成绩升序排序 select * from student order by age desc, math asc; 2.基础查询-- 1. 多个字段的查询 select 字段名1，字段名2... from 表名； --注意： -- 如果查询所有字段，则可以使用*来替代字段列表。 -- 2. 去除重复： distinct -- 3. 计算列 -- 一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算） ifnull(表达式1,表达式2)：null参与的运算，计算结果都为null -- 表达式1：哪个字段需要判断是否为null；表达式2：如果该字段为null后的替换值。 -- 4. 起别名： as：as也可以省略 3.条件查询-- 1. where子句后跟条件 -- 2. 运算符 &gt; 、&lt; 、&lt;= 、&gt;= 、= 、&lt;&gt; BETWEEN...AND IN( 集合) LIKE：模糊查询 -- 占位符： _:单个任意字符 %：多个任意字符 IS NULL and 或 &amp;&amp; or 或 || not 或 ! -- 查询年龄大于20岁 SELECT * FROM student WHERE age &gt; 20; SELECT * FROM student WHERE age &gt;= 20; -- 查询年龄等于20岁 SELECT * FROM student WHERE age = 20; -- 查询年龄不等于20岁 SELECT * FROM student WHERE age != 20; SELECT * FROM student WHERE age &lt;&gt; 20; -- 查询年龄大于等于20 小于等于30 SELECT * FROM student WHERE age &gt;= 20 &amp;&amp; age &lt;=30; SELECT * FROM student WHERE age &gt;= 20 AND age &lt;=30; SELECT * FROM student WHERE age BETWEEN 20 AND 30; -- 查询年龄22岁，18岁，25岁的信息 SELECT * FROM student WHERE age = 22 OR age = 18 OR age = 25 SELECT * FROM student WHERE age IN (22,18,25); -- 查询英语成绩为null SELECT * FROM student WHERE english = NULL; -- 不对的。null值不能使用 = （!=） 判断 SELECT * FROM student WHERE english IS NULL; -- 查询英语成绩不为null SELECT * FROM student WHERE english IS NOT NULL; -- 查询姓马的有哪些？ like SELECT * FROM student WHERE NAME LIKE '马%'; -- 查询姓名第二个字是化的人 SELECT * FROM student WHERE NAME LIKE &quot;_化%&quot;; -- 查询姓名是3个字的人 SELECT * FROM student WHERE NAME LIKE '___'; -- 查询姓名中包含德的人 SELECT * FROM student WHERE NAME LIKE '%德%'; 4.聚合函数 之前我们做的查询都是横向查询，它们都是根据条件一行一行的进行判断，而使用聚合函数查询是纵向查询， 它是对一列的值进行计算，然后返回一个结果值。聚合函数会忽略空值 NULL。 SQL中的聚合函数 作用 max(列名) 求这一列的最大值 min(列名) 求这一列的最小值 avg(列名) 求这一列的平均值 count(列名) 统计这一列有多少条记录 sum(列名) 对这一列求总和 -- 查询学生总数 select count(id) as 总人数 from student; select count(*) as 总人数 from student; -- 我们发现对于 NULL 的记录不会统计，建议如果统计个数则不要使用有可能为 null 的列，但如果需要把 NULL 也统计进去,就需要 ifnull转换 IFNULL(列名，默认值)如果列名不为空，返回这列的值。如果为NULL,则返回默认值。 select count(ifnull(id,0)) from student; -- 查询年龄大于 20 的总数 select count(*) from student where age&gt;20; -- 查询数学成绩总分 select sum(math) 总分 from student; -- 查询数学成绩平均分 select avg(math) 平均分 from student; -- 查询数学成绩最高分 select max(math) 最高分 from student; -- 查询数学成绩最低分 select min(math) 最低分 from student; 5.分组分组查询是指使用GROUP BY语句对查询信息进行分组，相同数据作为一组，GROUP BY将分组字段结果中相同内容作为一组，并且返回每组的第一条数据，所以单独分组没什么用处。分组的目的就是为了统计，一般分组会跟聚合函数一起使用。注意:当我们使用某个字段分组,在查询的时候也需要将这个字段查询出来,否则看不到数据属于哪组的. -- 按性别进行分组，求男生和女生数学的平均分 select sex, avg(math) from student group by sex; -- 查询男生和女生各多少人 select sex,count(*) from student group by sex ; where vs having 子句 作用 where子句 1.对查询结果进行分组前，将不符合where条件的行去掉，即在分组之前过滤数据，即先过滤再分组。2. where 后面不可以使用聚合函数 having子句 1. having子句的作用是筛选满足条件的组，即在分组之后过滤数据，即先分组再过滤。2.having后面可以使用聚合函数 6分页 limit-- LIMIT 语法格式: LIMIT offset,length; -- offset: 起始行数，从0开始计数，如果省略，默认就是0;length: 返回的行数 -- 查询学生表中数据，从第 3 条开始显示，显示 6 条。 select * from student limit 2,6; DCL(Data Control Language) 我们现在默认使用的都是 root 用户，超级管理员，拥有全部的权限。但是，一个公司里面的数据库服务器上面,可能同时运行着很多个项目的数据库。所以，我们应该可以根据不同的项目建立不同的用户，分配不同的权限来管 理和维护数据库。 注:mysqld 是 MySQL 的主程序，服务器端。mysql 是 MySQL 的命令行工具，客户端。 创建账户-- CREATE USER '用户名'@'主机名' IDENTIFIED BY '密码'; 注:创建的用户名都在 mysql 数据库中的 user 表中可以查看到，密码经过了加密。 -- '主机名' 指定该用户在哪个主机上可以登陆，如果是本地用户可用 localhost，如果想让该用户可以 从任意远程主机登陆，可以使用通配符% -- 创建 user1 用户，只能在 localhost 这个服务器登录 mysql 服务器，密码为 123 create user 'user1'@'localhost' identified by '123'; -- 创建 user2 用户可以在任何电脑上登录 mysql 服务器，密码为 123 create user 'user2'@'%' identified by '123'; 给用户授权 用户创建之后，没什么权限!需要给用户授权-- GRANT 权限 1, 权限 2... ON 数据库名.表名 TO '用户名'@'主机名'; -- 权限 授予用户的权限，如 CREATE、ALTER、SELECT、INSERT、UPDATE 等。如果要授 予所有的权限则使用 ALL -- 给 user1 用户分配对 test 这个数据库操作的权限:创建表，修改表，插入记录，更新记录，查询 grant create,alter,insert,update,select on test.* to 'user1'@'%'; -- 给 user2 用户分配所有权限，对所有数据库的所有表 grant all on *.* to 'user2'@'%'; 撤销授权-- REVOKE 权限 1, 权限 2... ON 数据库.表名 from '用户名'@'主机 名'; -- 撤销 user1 用户对 test 数据库所有表的操作的权限 revoke all on test.* from 'user1'@'%'; 查看权限-- SHOW GRANTS FOR '用户名'@'主机名'; 注:usage 是指连接(登陆)权限，建立一个用户，就会自动授予其 usage 权限(默认授予)。 -- 查看 user1 用户的权限 show grants for 'user1'@'%' 删除用户-- DROP USER '用户名'@'主机名'; -- 删除 user2 drop user 'user2'@'%'; 修改管理员密码-- 注意:需要在未登陆 MySQL 的情况下操作，新密码不需要加上引号。 mysqladmin -uroot -p password 新密码 修改普通用户密码set password for '用户名'@'主机名' = password('新密码'); -- 注意:需要在登陆 MySQL 的情况下操作，新密码要加单引号。 数据库的备份和还原 备份的应用场景在服务器进行数据传输、数据存储和数据交换，就有可能产生数据故障。比如发生意外停机或存储介质损坏。这时，如果没有采取数据备份和数据恢复手段与措施，就会导致数据的丢失，造成的损失是无法弥补与估量的。# mysqldump -u用户名 -p密码数据库 &gt;文件的路径 mysqldump -uroot -proot shop &gt; /usr/data/mysql/shop.sql 还原数据库，需要登录后才可以操作# USE 数据库; # SOURCE导入文件的路径; use shop; source /usr/data/mysql/shop.sql 数据库表的约束约束的作用: 对表中的数据进行限制，保证数据的正确性、有效性和完整性。一个表如果添加了约束，不正确的数据将无法插入到表中。约束在创建表的时候添加比较合适。 约束种类: 约束名 约束关键字 作用 说明 主键 primary key 用来唯一标识数据库中的每一条记录 通常不用业务字段作为主键，单独给每张表设计一个id的字段，把id作为主键。主键是给数据库和程序使用的，不是给最终的客户使用的。所以主键有没有含义没有关系，只要不重复，非空就行 唯一 unique 表中某一列不能出现重复的值 多个null值，不是重复的值 非空 not null 某一列不能为null。 定义表结构时，可以指定默认值 外键 foreign key 主表中主键列，在从表中外键列 检查约束 check注: mysql 不支持 主键示例:-- 创建表结构时未指定主键，后边添加主键 alter table student add primary key(id); -- 删除 student 表的主键 alter table student drop primary key; -- 指定起始值为 1000 ,默认是1. create table student ( id int primary key auto_increment, name varchar(20) ) auto_increment = 1000; -- 创建好以后修改自增的起始值 alter table student auto_increment = 2000; -- DELETE:删除所有的记录之后，自增长没有影响。 -- TRUNCATE:删除以后，自增长又重新开始。 唯一约束示例：-- 创建学生表 st7, 包含字段(id, idcard),idcard 这一列设置唯一约束,不能出现相同身份号的学生 create table st7 ( id int, idcard varchar(20) unique ) 非空约束示例：-- 创建表学生表 st8, 包含字段(id,name,gender)其中 name 不能为 NULL create table st8 ( id int, name varchar(20) not null, gender char(1) ) -- 创建一个学生表 st9，包含字段(id,name,address)， 地址默认值是广州 create table st9 ( id int, name varchar(20), address varchar(20) default '广州' ) 外键约束:-- 创建从表employee并添加外键约束emp_depid_fk create table employee( id int primary key auto_increment, name varchar(20), age int, dep_id int, -- 外键对应主表的主键 constraint emp_depid_fk foreign key (dep_id) references department(id) -- 创建外键约束 ) --删除employee表的emp_depid_fk 外键 alter table employee drop foreign key emp_depid_fk; --在employee表情存在的情况下添加外键 alter table employee add constraint emp_depid_fk foreign key (dep_id) references department (id) ; 级联操作：在修改和删除主表的主键时，同时更新或删除副表的外键值，称为级联操作 级联操作语法 描述 ON UPDATE CASCADE 级联更新，只能是创建表的时候创建级联关系。更新主表中的主键，从表中的外键列也自动同步更新 ON DELETE CASCADE 级联删除 -- 删除 employee 表，重新创建 employee 表，添加级联更新和级联删除 drop table employee; create table employee( id int primary key auto_increment, name varchar(20), age int, dep_id int, -- 外键对应主表的主键 constraint emp_depid_fk foreign key (dep_id) references department(id) on update cascade on delete cascade -- 创建外键约束 ) -- 再次添加数据到员工表和部门表 INSERT INTO employee (NAME, age, dep_id) VALUES ('张三', 20, 1); INSERT INTO employee (NAME, age, dep_id) VALUES ('李四', 21, 1); INSERT INTO employee (NAME, age, dep_id) VALUES ('王五', 20, 1); INSERT INTO employee (NAME, age, dep_id) VALUES ('老王', 20, 2); INSERT INTO employee (NAME, age, dep_id) VALUES ('大王', 22, 2); INSERT INTO employee (NAME, age, dep_id) VALUES ('小王', 18, 2); -- 删除部门表?能不能直接删除? drop table department; -- 把部门表中id等于1的部门改成id等于10 update department set id=10 where id=1; select * from employee; select * from department; -- 删除部门号是 2 的部门 delete from department where id=2; 表与表之间的关系表关系的概念 现实生活中，实体与实体之间肯定是有关系的，比如:老公和老婆，部门和员工，老师和学生等。那么我们 在设计表的时候，就应该体现出表与表之间的这种关系! 表与表之间的三种关系 表关系 例子 图片 一对多: 最常用的关系 部门和员工 多对多: 学生选课表 和 学生表， 一门课程可以有多个学生选择，一个学生选择多门课程 一对一: 在实际的开发中应用不多.因为一对一可以创建成一张表。员工表 简历表， 公民表 护照表 数据库设计-范式 好的数据库设计对数据的存储性能和后期的程序开发，都会产生重要的影响。建立科学的，规范的数据库就需 要满足一些规则来优化数据的设计和存储，这些规则就称为范式。 三大范式: 目前关系数据库有六种范式:第一范式(1NF)、第二范式(2NF)、第三范式(3NF)、巴斯-科德范式(BCNF)、 第四范式(4NF)和第五范式(5NF，又称完美范式)。 满足最低要求的范式是第一范式(1NF)。在第一范式的基础上进一步满足更多规范要求的称为第二范式(2NF，) 其余范式以次类推。一般说来，数据库只需满足第三范式(3NF)就行了。 1NF 数据库表的每一列都是不可分割的原子数据项，不能是集合、数组等非原子数据项。即表中的某个列有多个值 时，必须拆分为不同的列。简而言之，第一范式每一列不可再拆分，称为原子性。 2NF 在满足第一范式的前提下，表中的每一个字段都完全依赖于主键。 所谓完全依赖是指不能存在仅依赖主键一部分的列。简而言之，第二范式就是在第一范式的基础上所有列完全依赖于主键列。当存在一个复合主键包含多个主键列的时候，才会发生不符合第二范式的情况。比如有一个主键有 两个列，不能存在这样的属性，它只依赖于其中一个列，这就是不符合第二范式。 第二范式的特点: 一张表只描述一件事情。 表中的每一列都完全依赖于主键 3NF: 在满足第二范式的前提下，表中的每一列都直接依赖于主键，而不是通过其它的列来间接依赖于主键。简而言之，第三范式就是所有列不依赖于其它非主键列，也就是在满足 2NF 的基础上，任何非主列不得传递 依赖于主键。所谓传递依赖，指的是如果存在”A → B → C”的决定关系，则 C 传递依赖于 A。因此，满足第三范 式的数据库表应该不存在如下依赖关系:主键列 → 非主键列 x → 非主键列 y 表连接查询 如果一条 SQL 语句查询多张表，因为查询结果在多张不同的表中。每张表取 1 列或多列。这就涉及多表查询了 多表查询分类 内连接 显示内连接 隐式内连接 外连接 左外连接 右外连接 笛卡尔积现象 左表的每条数据和右表的每条数据组合,这种效果成为笛卡尔乘积，示例：-- 需求:查询所有的员工和所有的部门 select * from emp,dept; 如何清除笛卡尔积现象的影响 我们发现不是所有的数据组合都是有用的，只有员工表.dept_id = 部门表.id 的数据才是有用的。所以需要 通过条件过滤掉没用的数据。示例：-- 查询员工和部门的名字 select emp.`name`, dept.`name` from emp,dept where emp.`dept_id` = dept.`id`; 内连接查询 用左边表的记录去匹配右边表的记录，如果符合条件的则显示。如:从表.外键=主表.主键隐式内连接: 看不到 JOIN 关键字，条件使用 WHERE 指定 select * from emp,dept where emp.`dept_id` = dept.`id`; 显式内连接 显示内连接:使用 INNER JOIN … ON 语句, 可以省略 INNER-- SELECT 字段名 FROM 左表 [INNER] JOIN 右表 ON 条件 select * from emp e inner join dept d on e.`dept_id` = d.`id`; 外连接查询左外连接 用左边表的记录去匹配右边表的记录，如果符合条件的则显示;否则，显示 NULL 可以理解为:在内连接的基础上保证左表的数据全部显示(左表是部门，右表员工) 使用 LEFT OUTER JOIN … ON，OUTER 可以省略-- 使用左外连接查询 select * from dept d left join emp e on d.`id` = e.`dept_id`; 右外连接 用右边表的记录去匹配左边表的记录，如果符合条件的则显示;否则，显示 NULL,可以理解为:在内连接的基础上保证右表的数据全部显示 右外连接:使用 RIGHT OUTER JOIN … ON，OUTER 可以省略 -- 使用右外连接查询 select * from dept right join emp on dept.`id` = emp.`dept_id`; 总结连接分类: 内链接 表1 inner join 表2 on 关联条件 做连接查询的时候一定要写上关联条件 inner 可以省略 外连接 左外连接 表1 left outer join 表2 on 关联条件 做连接查询的时候一定要写上关联条件 outer 可以省略 右外连接 表1 right outer join 表2 on 关联条件 做连接查询的时候一定要写上关联条件 outer 可以省略 左外连接(左连接)和右外连接(右连接)的区别: 左连接以左面的表为准和右边的表比较，和左表相等的不相等都会显示出来，右表符合条件的显示, 不符合条件的不显示右连接恰恰相反，以上左连接和右连接也可以加入 outer 关键字，但一般不建议这种写法 子查询 一个查询的结果做为另一个查询的条件 有查询的嵌套，内部的查询称为子查询 子查询要使用括号 子查询的结果是一个值的时候-子查询结果只要是单行单列，肯定在 WHERE 后面作为条件，父查询使用:比较运算符，如:&gt; 、&lt;、&lt;&gt;、=等 -- 使用子查询 select * from emp where dept_id = (select id from dept where name='市场部'); -- 根据最高工资到员工表查询到对应的员工信息 select * from emp where salary = (select max(salary) from emp); -- 到员工表查询小于平均的员工信息 select * from emp where salary &lt; (select avg(salary) from emp); 子查询结果是多行单列的时候 子查询结果是单例多行，结果集类似于一个数组，父查询使用 IN 运算符-- 查询工资大于 5000 的员工，来自于哪些部门的名字 select name from dept where id in (select dept_id from emp where salary &gt; 5000); -- 查询开发部与财务部所有的员工信息 select * from emp where dept_id in (select id from dept where name in('开发部','财务 部')); 子查询的结果是多行多列 子查询结果只要是多列，肯定在 FROM 后面作为表,子查询作为表需要取别名，否则这张表没有名称则无法访问表中的字段-- 查询所有的部门信息，与上面的虚拟表中的信息组合，找出所有部门 id 等于的 dept_id select * from dept d, (select * from emp where join_date &gt;='2011-1-1') e where d.`id`= e.dept_id ; -- 也可以使用表连接 select * from emp inner join dept on emp.`dept_id` = dept.`id` where join_date &gt;='2011-1-1'; select * from emp inner join dept on emp.`dept_id` = dept.`id` and join_date &gt;='2011-1-1'; 事务事务的基本介绍 如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。 操作:```sql 开启事务： start transaction; 回滚：rollback; 提交：commit;``` MySQL数据库中事务默认自动提交 事务提交的两种方式： 自动提交：mysql就是自动提交的一条DML(增删改)语句会自动提交一次事务。 手动提交：Oracle 数据库默认是手动提交事务需要先开启事务，再提交 修改事务的默认提交方式： 查看事务的默认提交方式：SELECT @@autocommit; 1 代表自动提交 0 代表手动提交 修改默认提交方式： set @@autocommit = 0; 事务的四大特征： 1.原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败。 整个事务中的所有操作，必须作为一个单元全部完成(或全部取消)。 undo log 名为回滚日志，是实现原子性的关键，当事务回滚时能够撤销所有已经成功执行的 sql 语句，他需要 记录你要回滚的相应日志信息。  例如: (1)当你 delete 一条数据的时候，就需要记录这条数据的信息，回滚的时候，insert 这条旧数据 (2)当你 update 一条数据的时候，就需要记录之前的旧值，回滚的时候，根据旧值执行 update 操作 (3)当年 insert 一条数据的时候，就需要这条记录的主键，回滚的时候，根据主键执行 delete 操作 undo log 记录了这些回滚需要的信息，当事务执行失败或调用了 rollback，导致事务需要回滚，便可以利用 undo log 中的信息将数据回滚到修改之前的样子。 2.持久性：当事务提交或回滚后，数据库会持久化的保存数据。 在事务完成以后，该事务对数据库所作的更改将持久地保存在数据库之中，并不会被回滚。 事务的持久性是利用 Innodb 的 redo log。 3.隔离性：多个事务之间。相互独立。 一个事务不会影响其他事务的运行。 事务的隔离性是利用的是锁和 MVCC 机制。 至于 MVCC,即多版本并发控制(Multi Version Concurrency Control),一个行记录数据有多个版本对快照数据，这些快 照数据在 undo log 中。 如果一个事务读取的行正在做 DELELE 或者 UPDATE 操作，读取操作不会等行上的锁释放，而是读取该行的快照 版本。 由于 MVCC 机制在可重复读(Repeateable Read)和读已提交(Read Commited)的 MVCC 表现形式不同，就不赘述了。 但是有一点说明一下，在事务隔离级别为读已提交(Read Commited)时，一个事务能够读到另一个事务已经提交的数 据，是不满足隔离性的。但是当事务隔离级别为可重复读(Repeateable Read)中，是满足隔离性的。 4.一致性：事务操作前后，数据总量不变 在事务开始之前与结束之后，数据库都保持一致状态。 从数据库层面，数据库通过原子性、隔离性、持久性来保证一致性。也就是说 ACID 四大特性之中，C(一致性) 是目的，A(原子性)、I(隔离性)、D(持久性)是手段，是为了保证一致性，数据库提供的手段。数据库必须要实现 AID 三大特性，才有可能实现一致性。例如，原子性无法保证，显然一致性也无法保证。 但是，如果你在事务里故意写出违反约束的代码，一致性还是无法保证的。例如，你在转账的例子中，你的代 码里故意不给 B 账户加钱，那一致性还是无法保证。因此，还必须从应用层角度考虑。从应用层面，通过代码判断 数据库数据是否有效，然后决定回滚还是提交数据! 事务的隔离级别（了解） 概念：多个事务之间隔离的，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题。 存在问题： 1.脏读：一个事务，读取到另一个事务中没有提交的数据 2.不可重复读(虚读)：在同一个事务中，两次读取到的数据不一样。 3.幻读：一个事务按照相同的条件重新读取以前检索过的数据时，却发现了其他事务插入的新数据。幻读和不可重复读有些相似之处 ，但是不可重复读的重点是修改，幻读的重点在于新增或者删除 隔离级别： 1.read uncommitted：读未提交 允许一个事务可以看到其他事务未提交的修改。产生的问题：脏读、不可重复读、幻读 2.read committed：读已提交 （Oracle）允许一个事务只能看到其他事务已经提交的修改，未提交的修改是不可见的。产生的问题：不可重复读、幻读 3.repeatable read：可重复读 （MySQL默认）确保如果在一个事务中执行两次相同的 SELECT 语句，都能得到相同的结果，不管其他事务是否提交这些修改 4.serializable：串行化可以解决所有的问题 注意：隔离级别从小到大安全性越来越高，但是效率越来越低 数据库查询隔离级别：SELECT @@global.tx_isolation; 数据库设置隔离级别： set global transaction isolation level 级别字符串;演示： set global transaction isolation level read uncommitted; start transaction; 关于事务的回滚需要注意:只能回滚 insert、delete 和 update 语句，不能回滚 select(回滚 select 没有任何意义)，对 于 create、drop、alter 这些无法回滚. 事务只对 DML 有效果。 注意:rollback，或者 commit 后事务就结束了 隔离级别与一致性问题的关系 当多个客户端并发地访问同一个表时，可能出现下面的一致性问题:- 更新丢失:两个并行操作，后进行的操作覆盖掉了先进行操作的操作结果，被称作更新丢失。 - 脏读(Dirty Read):一个事务在提交之前，在事务过程中修改的数据，被其他事务读取到了。 - 不可重复读(Non-repeatable Read):一个事务在提交之前，在事务过程中读取以前的数据却发现数据发生了改 变。 - 幻读(Phantom Read):一个事务按照相同的条件重新读取以前检索过的数据时，却发现了其他事务插入的新数 据。 通用的解决思路是更新丢失通过应用程序完全避免。而其他的问题点则通过调整数据库事务隔离级别来解决。事务 的隔离机制的实现手段之一就是利用锁。 隔离级别与一致性问题的关系 分布式事务传统项目中用一个 mysql 数据库，mysql 数据库当中 innoDB 引擎是支持 ACID 事务特性的，能够满足我们的事务要求，但现在分布式项目中，我们会有多个微服务处理不同业务这些微服务都是独立的进程，数据库也都是相互独立，但是事务可能要横跨这些微服务， 比如订单功能， 如果我支付订单成功在订单微服务中我需要改变订单状态， 在库存微服务中需要减对应的库存， 在积分微服务中得加对应积分， 这是一个整体的事务，这种事务就是分布式事务 CAP 定理和 Base 理论CAP 定理是由加州大学伯克利分校 Eric Brewer 教授提出来的，他指出 WEB 服务无法同时满足以下三个属 性 - 一致性(Consistency): 客户端知道一系列的操作都会同时发生(生效) - 可用性(Availability): 每个操作都必须以可预期的响应结束 - 分区容错性(Partitiontolerance): 即使出现单个组件无法可用,操作依然可以完成 在分布式系统中，我们往往追求的是可用性，它的重要程序比一致性要高，那么如何实现高可用性呢?那就是 另外一个理论 BASE 理论，它是用来对 CAP 定理进行进一步扩充的。BASE 理论指的是 - BasicallyAvailable(基本可用):分布式系统在出现故障时，允许损失部分可用功能，保证核心功能可用。 - Soft state(软状态):允许系统中存在中间状态，这个状态不影响系统可用性，这里指的是 CAP 中的不一致。 - Eventually consistent(最终一致性):指经过一段时间后，所有节点数据都将会达到一致 BASE 理论是对 CAP 中的一致性和可用性进行一个权衡的结果，理论的核心思想就是:我们无法做到强一致， 但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性(Eventual consistency)。 2PC 二阶段分步提交其核心思想是将分布式事务拆分成本地事务进行处理 - 白话 各个服务在处理数据过程中，会进行预备提交操作，预备操作可以反映出各个节点是否都能够提交，预备操作 如果成功的话，那么事务协调器会执行每个数据库的 commit 操作。如果在预提交过程当中有一个节点不能够 提交，事务协调器会执行每个数据库的 roll back 操作 -官腔 事务管理器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交。事务协调器要求每 个数据库提交数据，或者回滚数据。 -实现的思路 消息生产方，需要额外建一个消息表，并记录消息发送状态。消息表和业务数据要在一个事务里提交，也就是说他们要在一个数据库里面。然后消息会经过 MQ 发送到消息的消费方。如果消息发送失败，会进行重试发送。 消息消费方，需要处理这个消息，并完成自己的业务逻辑。此时如果本地事务处理成功，表明已经处理成功了， 如果处理失败，那么就会重试执行。如果是业务上面的失败，可以给生产方发送一个业务补偿消息，通知生产方进 行回滚等操作。 生产方和消费方定时扫描本地消息表，把还没处理完成的消息或者失败的消息再发送一遍。如果有靠谱的自动 对账补账逻辑，这种方案还是非常实用的。这种方案遵循 BASE 理论，采用的是最终一致性。 TCC (Try Confirm Cancel)- Try 阶段:尝试执行，完成所有业务检查(一致性)，预留必需业务资源(准隔离性)。 - Confirm 阶段:确认真正执行业务，不作任何业务检查，只使用 try 阶段预留的业务资源，Confirm 操作满足 幂等性。要求具备幂等设计，Confirm 失败后需要进行重试。默认只要 Try 成功，Confirm 一定成功。 - Cancel 阶段:取消执行，释放 Try 阶段预留的业务资源，Cancel 操作满足幂等性。Cancel 阶段的异常和 Confirm 阶段异常处理方案基本上一致。 - 举个简单的例子:如果你用 100 元买了一瓶水， Try 阶段:你需要向你的钱包检查是否够 100 元并锁住这 100 元，水也是一样的。如果有一个失败，则进行 Cancel(释放这 100 元和这一瓶水)，如果 Cancel 失败不论什么 失败都进行重试 Cancel，所以需要保持幂等。如果都成功，则进行 Confirm，确认这 100 元被扣，和这一瓶 水被卖，如果 Confirm 失败无论什么失败则重试(会依靠活动日志进行重试)。 数据库锁和并发策略数据库锁的分类- MyIsam 实现了表锁。表锁可以针对数据库表加锁，在锁的灵活性上不如行锁。表锁分为两种锁:读锁与写锁。 - InnoDB 存储引擎实现了行锁与表锁(意向锁)。行锁可以以行为单位对数据集进行锁定。行锁也分为两种锁: 共享锁与排他锁。InnoDB 对于 Update、Delete、insert 语句会自动给涉及的数据集隐式的加上排他锁。对于 select 语句 InnoDB 不会加任何锁 - 共享锁:允许一个事务读取一行，阻止其他事务获得相同数据集的排他锁。但允许其他事务获取共享锁。 显示加锁 select * from table where ... lock in share mode - 排他锁:允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享与排他锁。但是可以对获 取了排他锁的数据集进行单纯的查询访问。 显示加锁 sql select * from table where ... for update - innoDB 的行锁的实现方式是基于索引项的。这意味着即使你尝试获取不同行的排他锁，若使用了相同的索引 键，也可能会造成锁冲突。 行级锁```text行级锁是一种排他锁，防止其他事务修改此行;行锁的特点是开销大，加锁慢;会出现死锁;锁定粒度最小，发生 锁冲突的概率最低，并发度也最高在使用以下语句时，Oracle 会自动应用行级锁: INSERT、UPDATE、DELETE、SELECT „ FOR UPDATE [OF columns] [WAIT n | NOWAIT]; SELECT „ FOR UPDATE 语句允许用户一次锁定多条记录进行更新 使用 COMMIT 或 ROLLBACK 语句释放锁。但是使用行级锁也不是绝对的，如果在执行一个 SQL 语句时 MySQL 不能确定要扫描的范围，InnoDB 表同样会锁全表– 这个就是 select 锁表的一种，不明确主键。增删改查都可能会导致锁全表。SELECT * FROM products WHERE name=’Mouse’ FOR UPDATE;总之InnoDB 的行锁，只是在 WHERE 的主键是有效的，非主键的 WHERE 都会锁 全表的。``` 表级锁 表锁的特点是开销小，加锁快;不会出现死锁;锁定粒度大，发生锁冲突的概率最高，并发度最低 表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分 MySQL 引擎支持。最常使用的 MYISAM 与 INNODB 都支持表级锁定。 页级锁 页级锁是 MySQL 中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。BDB 支持页级锁 数据库的并发策略 乐观锁 乐观锁认为一个用户读数据的时候，别人不会去写自己所读的数据;悲观锁就刚好相反，觉得自 己读数据库 的时候，别人可能刚好在写自己刚读的数据，其实就是持一种比较保守的态度;时间 戳就是不加锁，通过时间戳 来控制并发出现的问题。 解决方案为:时间戳就是在数据库表中单独加一列时间戳，比如“TimeStamp”，每次读出来的时候，把该字 段 也读出来，当写回去的时候，把该字段加 1，提交之前 ，跟数据库的该字段比较一次，如果比数 据库的值大的话， 就允许保存，否则不允许保存，这种处理方法虽然不使用数据库系统提供的锁 机制，但是这种方法可以大大提高 数据库处理的并发量， Select max(nub) ,version from biao Update biao set nub=nub+1,version=vsersion+1 where id=id and version =version 悲观锁 悲观锁就是在读取数据的时候，为了不让别人修改自己读取的数据，就会先对自己读取的数据加 锁，只有自 己把数据读完了，才允许别人修改那部分数据，或者反过来说，就是自己修改某条数 据的时候，不允许别人读取 该数据，只有等自己的整个事务提交了，才释放自己加上的锁，才允 许其他用户访问那部分数据。 悲观锁所说的加“锁”，其实分为几种锁，分别是:排它锁(写锁)和共享锁(读锁) 解决方案为 sql 语句后边加上 for update 例子:select id,nam from biao for update 锁表问题```text 锁表发生在 insert、update 、delete 中 锁表的原理是数据库使用独占式锁机制，当执行 insert、update 和 delete 的语句时，对表进行锁住，直到发生commite 或者回滚或者退出数据库用户 锁表的原因 : 当多个连接(数据库连接)同时对一个表的数据进行更新操作，那么速度将会越来越慢，持续一段时间后将出现数据表被锁的现象，从而影响到其它的查询及更新。 A 程序执行了对 tableA 的 insert ，并还未 commite 时，B 程序也对 tableA 进行 insert 则此时会发生资源正忙的异常就是锁表。 锁表常发生于并发而不是并行(并行时，一个线程操作数据库时，另一个线程是不能操作数据库的，cpu和 i/o 分配原则) 减少锁表的概率 减少 insert 、update 、delete 语句执行到 commite 之间的时间。具体点批量执行改为单个执行、优化 sql 自身的非执行速度 如果异常对事物进行回滚```","link":"/2013/10/27/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL%E7%AC%AC%E4%B8%80%E7%AF%87--%E5%85%A5%E9%97%A8%E7%AF%87/"},{"title":"MySQL数据库表优化和插入优化","text":"数据库表结构优化一个好的数据库设计方案对于数据库的性能往往会起到事半功倍的效果。需要考虑数据冗余、查询和更新的速度、字段的数据类型是否合理等多方面的内容。 将字段很多的表分解成多个表对于字段较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。 增加中间表对于需要经常联合查询的表，可以建立中间表以提高查询效率。通过建立中间表，将需要通过联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询。 增加冗余字段设计数据表时应尽量遵循范式理论的规约，尽可能的减少冗余字段，让数据库设计看起来精致、优雅。但是，合理的加入冗余字段可以提高查询速度。表的规范化程度越高，表和表之间的关系越多，需要连接查询的情况也就越多，性能也就越差。注意：冗余字段的值在一个表中修改了，就要想办法在其他表中更新，否则就会导致数据不一致的问题。 插入数据的优化插入数据时，影响插入速度的主要是索引、唯一性校验、一次插入的数据条数等。插入数据的优化，不同的存储引擎优化手段不一样，在MySQL中常用的存储引擎有，MyISAM和InnoDB，两者的区别 MyISAM禁用索引对于非空表，插入记录时，MySQL会根据表的索引对插入的记录建立索引。如果插入大量数据，建立索引会降低插入数据速度。为了解决这个问题，可以在批量插入数据之前禁用索引，数据插入完成后再开启索引。禁用索引的语句：ALTER TABLE table_name DISABLE KEYS开启索引语句：ALTER TABLE table_name ENABLE KEYS对于空表批量插入数据，则不需要进行操作，因为MyISAM引擎的表是在导入数据后才建立索引。 禁用唯一性检查唯一性校验会降低插入记录的速度，可以在插入记录之前禁用唯一性检查，插入数据完成后再开启。禁用唯一性检查的语句：SET UNIQUE_CHECKS = 0;开启唯一性检查的语句：SET UNIQUE_CHECKS = 1; 批量插入数据插入数据时，可以使用一条INSERT语句插入一条数据，也可以插入多条数据。 使用LOAD DATA INFILE当需要批量导入数据时，使用LOAD DATA INFILE语句比INSERT语句插入速度快很多 InnoDB禁用唯一性检查用法和MyISAM一样。 禁用外键检查插入数据之前执行禁止对外键的检查，数据插入完成后再恢复，可以提供插入速度。禁用：SET foreign_key_checks = 0;开启：SET foreign_key_checks = 1; 禁止自动提交插入数据之前执行禁止事务的自动提交，数据插入完成后再恢复，可以提供插入速度。禁用：SET autocommit = 0;开启：SET autocommit = 1;","link":"/2016/12/27/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E4%BC%98%E5%8C%96%E5%92%8C%E6%8F%92%E5%85%A5%E4%BC%98%E5%8C%96/"},{"title":"MySQL第三篇--性能优化篇","text":"优化服务器硬件服务器的硬件性能直接决定着MySQL数据库的性能，硬件的性能瓶颈，直接决定MySQL数据库的运行速度和效率。 需要从以下几个方面考虑： 1、 配置较大的内存。足够大的内存，是提高MySQL数据库性能的方法之一。内存的IO比硬盘快的多，可以增加系统的缓冲区容量，使数据在内存停留的时间更长，以减少磁盘的IO。 2、 配置高速磁盘，比如SSD。 3、 合理分配磁盘IO，把磁盘IO分散到多个设备上，以减少资源的竞争，提高并行操作能力。 4、 配置多核处理器，MySQL是多线程的数据库，多处理器可以提高同时执行多个线程的能力。 优化MySQL的参数 通过优化MySQL的参数可以提高资源利用率，从而达到提高MySQL服务器性能的目的。MySQL的配置参数都在my.conf或者my.ini文件的[mysqld]组中，常用的参数如下： MYSQL连接优化 很多开发人员都会遇见”MySQL: ERROR 1040: Too many connections”的异常情况，造成这种情况的一种原因是访问量过高，MySQL服务器抗不住，这个时候就要考虑增加从服务器分散读压力；另一种原因就是MySQL配置文件中max_connections值过小。show variables like '%max_connections%'; show global status like 'Max_used_connections'; show status; 优化原则方面1、适度优化，切忌过度优化 2、先优化最大瓶颈，事半功倍 3、依据数据而不是凭空猜测 4、性能优化是持久战，道高一尺魔高一丈 5、深入理解业务 ├── 性能监控 │ ├── sql执行计划explain │ ├── 系统级性能 │ └── 数据库服务器日志 └── 数据库层面 ├── 索引 │ ├── 原则 │ ├── 目标 │ └── 常用优化 ├── 集群 │ ├── 中间件 │ │ ├── MaxScale │ │ └── MySQL-Proxy │ ├── 主从复制 │ └── 读写分离 ├── 表结构 ├── 架构优化 │ └── 拆分 ├── 硬件配置 └── 数据库参数 ├── IO相关参数 ├── 引擎 ├── 内存分配 ├── 并发控制 └── 系统资源 准备工作慢查询日志show variables like 'slow_query_log'; -- 查看慢 SQL 日志是否启用(on 表示启用): show variables like 'long_query_time'; -- 查看执行慢于多少秒的 SQL 会记录到日志文件中 show variables like '%query%'; -- 可以使用模糊搜索，查看所有含有 query 的变量信息 修改慢查询相关配置文件参数常用的参数详解: --是否开启慢查询日志 off表示未开启，on表示开启，可以用1，0代替 slow_query_log=1 --指定保存路径及文件名，默认为数据文件目录， slow_query_log_file=&quot;xx_mysql_slow.log&quot; -- 时间、主机信息、执行信息、执行时间、执行内容 --指定多少秒返回查询的结果为慢查询 long_query_time=1 --记录所有没有使用到索引的查询语句 log_queries_not_using_indexes=1 --记录那些由于查找了多于 1000 次而引发的慢查询 min_examined_row_limit=1000 --记录那些慢的 optimize table，analyze table 和 alter table 语句 log_slow_admin_statements=1 --记录由 Slave 所产生的慢查询 log_slow_slave_statements=1 命令行方式修改慢查询配置--命令行修改配置方式不需要不重启即可生效，但重启之后会自动失效。 set global slow_query_log=1; set global slow_query_log_file='local_mysql_slow.log'; set global long_query_time=1; set global log_queries_not_using_indexes=1; set global min_examined_row_limit=1000; set global log_slow_admin_statements=1; set global log_slow_slave_statements=1; 慢查询日志的基本格式/usr/local/mysql/bin/mysqld, Version: 5.7.15 (MySQL Community Server (GPL)). started with: Tcp port: 3306 Unix socket: /tmp/mysql.sock Time Id Command Argument #Time:2019-03-20T07:42:59.665041Z User@Host:root [root]localhost [127.0.0.1] Id:5 Query time:0.023937 Lock time:0.000000 Rows sent:1000 Rows examined:1000 use coursel; SET timestamp=1553067779; SELECT FROM person LIMIT 0,1000; 查询缓存-- QueryCache 会缓存select 查询，安装时默认是开启的，但是如果对表进行INSERT,UPDATE, DELETE, TRUNCATE, ALTER TABLE, DROP TABLE, or DROP DATABASE 等操作 时，之前的缓存会无效并且删除。这样一定程度上也会影响我们数据库的性能。所以对一些频繁的变动表的情况开启缓存是不明智的。还有一种情况我们测试数据库性能的时候也要关闭缓存，避免缓存对我们测试数据的影响。 show VARIABLES like '%cache%'; -- query_cache_type=OFF 表明未开启缓存 set global query_cache_type=1; --如果配置文件中为关闭缓存的话，不能通过该命令开启缓存 show global status like '%Qcache%' -- 查看到缓存命中值 Qcache_hits -- 我们还可以通过 sql_no_cache 关键字在 sql 语句中直接禁用缓存，在开启缓存 的情况下我们对 sql 语句做一些改动 select sql_no_cache count(*) from 表名; -- 不缓存 select sql_cache count(*) from 表名; -- 缓存(也可以不加，默认缓存开启状态跟当前配置有关) MySQL 查询不建议使用缓存，因为查询缓存失效在实际业务场景中可能会非常频繁，假如你对一个表更新的话，这个表上的所有的查询缓存都会被清空。对于不经常更新的数据来说，使用缓存还是可以的。 所以，一般在大多数情况下我们都是不推荐去使用查询缓存的。MySQL 8.0 版本后删除了缓存的功能，官方也是认 为该功能在实际的应用场景比较少，所以干脆直接删掉了 存储过程方式准备测试数据 创建三张表 -- 用户表 CREATE TABLE `person` ( `id` bigint(20) unsigned NOT NULL, `fname` varchar(100) NOT NULL, `lname` varchar(100) NOT NULL, `age` tinyint(3) unsigned NOT NULL, `sex` tinyint(1) unsigned NOT NULL, PRIMARY KEY (`id`) ) ENGINE=INNODB DEFAULT CHARSET=utf8; -- 用户部门表 CREATE TABLE `department` ( `id` bigint(20) unsigned NOT NULL, `department` varchar(100) NOT NULL, PRIMARY KEY (`id`) ) ENGINE=INNODB DEFAULT CHARSET=utf8; -- 用户住址表 CREATE TABLE `address` ( `id` bigint(20) unsigned NOT NULL, `address` varchar(100) NOT NULL, PRIMARY KEY (`id`) ) ENGINE=INNODB DEFAULT CHARSET=utf8; 创建存储过程，用于批量添加测试数据 -- 创建存储过程，用于批量添加测试数据 delimiter $$ drop procedure if exists generate; CREATE DEFINER=`root`@`localhost` PROCEDURE `generate`(IN num INT) BEGIN DECLARE chars VARCHAR(100) DEFAULT 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'; DECLARE fname VARCHAR(10) DEFAULT ''; DECLARE lname VARCHAR(25) DEFAULT ''; DECLARE id int UNSIGNED; DECLARE len int; set id=1; DELETE from person; WHILE id &lt;= num DO set len = FLOOR(1 + RAND()*10); set fname = ''; WHILE len &gt; 0 DO SET fname = CONCAT(fname,substring(chars,FLOOR(1 + RAND()*62),1)); SET len = len - 1; END WHILE; set len = FLOOR(1+RAND()*25); set lname = ''; WHILE len &gt; 0 DO SET lname = CONCAT(lname,SUBSTR(chars,FLOOR(1 + RAND()*62),1)); SET len = len - 1; END WHILE; INSERT into person VALUES (id,fname,lname, FLOOR(RAND()*100), FLOOR(RAND()*2)); set id = id + 1; END WHILE; END $$ delimiter $$ drop procedure if exists genDepAdd; CREATE DEFINER=`root`@`localhost` PROCEDURE `genDepAdd`(IN num INT) BEGIN DECLARE chars VARCHAR(100) DEFAULT '行政技术研发财务人事开发公关推广营销咨询客服 运营测试'; DECLARE chars2 VARCHAR(100) DEFAULT '北京上海青岛重庆成都安徽福建浙江杭州深圳温 州内蒙古天津河北西安三期'; DECLARE depart VARCHAR(10) DEFAULT ''; DECLARE address VARCHAR(25) DEFAULT ''; DECLARE id int UNSIGNED; DECLARE len int; set id=1; WHILE id &lt;= num DO set len = FLOOR(2 + RAND()*2); set depart = ''; WHILE len &gt; 0 DO SET depart = CONCAT(depart,substring(chars,FLOOR(1 + RAND()*26),1)); SET len = len - 1; END WHILE; set depart=CONCAT(depart,'部'); set len = FLOOR(6+RAND()*18); set address = ''; WHILE len &gt; 0 DO SET address = CONCAT(address,SUBSTR(chars2,FLOOR(1 + RAND()*33),1)); SET len = len - 1; END WHILE; INSERT into department VALUES (id,depart); INSERT into address VALUES (id,address); set id = id + 1; END WHILE; END $$ 为了提高速度，可以暂停事务。测试添加 100 万随机数据，大概 600s 左右时间。此时如果隔离级别是可重复读的话,在存储过程执行过程中未提交前，不能实时读到数据 如果隔离级别是读未提交的话，则可以实时读到数据 -- 停掉事务 set autocommit = 0; -- 调用存储过程 call generate(1000000); call genDepAdd(1000000); -- 重启事务 set autocommit = 1; -- 输出结果时间： set autocommit = 0 &gt; OK &gt; Time: 0s -- 调用存储过程 call generate(1000000) &gt; OK &gt; Time: 631s call genDepAdd(1000000) &gt; OK &gt; Time: 642s -- 重启事务 set autocommit = 1 &gt; OK &gt; Time: 0s 常用工具分析工具 Mysqldumpslow mysqldumpslow -r -s c -a -t 3 &quot;/usr/local/mysql/data/local_mysql_slow.log&quot; 得到的一些关键信息 Count: 4(执行了多少次) Time=375.01s(每次执行的时间) (1500s)(一共执行了多少时间) Lock=0.00s (0s)(等待锁的时间) Rows=10200.3(每次返回的记录数) (40801)(总共返回的记录数) mysqlsla 通过 slow log，我们可以找到服务器的瓶颈。通过 binary log，我们可以恢复数据。Mysqlsla 可以处理其中的任意日志。 参考:https://yq.aliyun.com/articles/59260 pt-query-digest pt-query-digest 是用于分析 mysql 慢查询的一个工具，它可以分析 binlog、General log、slowlog，也可以通过 SHOWPROCESSLIST 或者通过 tcpdump 抓取的 MySQL 协议 数据来进行分析。可以把分析结果输出到文件中，分析过程是先对查询语句的条件进行参数化，然后对参数化以后的查询进行分组统计，统计出各查询的执行时间、次数、占比等， 可以借助分析结果找出问题进行优化。 参考:https://blog.csdn.net/seteor/article/details/24017913 EXPLAIN执行计划 用法 1.EXPLAIN SELECT ...... 经常使用的方式，查看 sql 的执行计划 2.EXPLAIN EXTENDED SELECT ...... 将执行计划&quot;反编译&quot;成 SELECT 语句，运行 SHOW WARNINGS ，可得到被 MySQL 优化器优化后的查询语句。 3.EXPLAIN PARTITIONS SELECT ...... 用于分区表的 EXPLAIN 生成 QEP 的信息，用来查看索引是否正在被使用，并且输出 其使用的索引的信息。 字段 说明 Id 查询中执行 select 子句或操作表的顺序,id相同执行顺序由上至下。如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行 Select_type 所使用的 SELECT 查询类型，包括以下常见类型:SIMPLE、 PRIMARY、SUBQUERY、UNION、DERIVED、UNION RESULT、DEPENDENT、 UNCACHEABLE table 所使用的的数据表的名字 type 表示 MySQL 在表中找到所需行的方式，又称“访问类型”。取值按优劣排序 为 NULL&gt;system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL,一般来说，得保证查询至 少达到 range 级别，最好能达到 ref Possible_keys 可能使用哪个索引在表中找到记录 key 实际使用的索引,若没有使用索引，显示为 NULL Key_len 索引中使用的字节数 ref 显示索引的哪一列被使用了 rows 估算的找到所需的记录所需要读取的行数 filtered 通过条件过滤出的行数的百分比估计值 extra 包含不适合在其他列中显示但十分重要的额外信息 select_type 所使用的 SELECT 查询类型，包括以下常见类型: a. SIMPLE:表示为简单的 SELECT，查询中不包含子查询或者 UNION b. PRIMARY:查询中若包含任何复杂的子部分，最外层查询则被标记为 PRIMARY c. SUBQUERY:在 SELECT 或 WHERE 列表中包含了子查询，该子查询被标记为SUBQUERY d. UNION:表连接中的第二个或后面的 select 语句，若第二个 SELECT 出现在 UNION之后，则被标记为 UNION。 e. DERIVED:DERIVED(衍生)用来表示包含在 from 子句中的子查询的 select。若UNION 包含在 FROM 子句的子查询中，外层 SELECT 将被标记为 DERIVED。mysql 会递归执行并将结果放到一个临时表中。服务器内部称为&quot;派生表&quot;，因为该临时表是从子查询 中派生出来的 f.UNION RESULT:从 UNION 表获取结果的 SELECT 被标记为 UNION RESULT g.DEPENDENT:意味着 select 依赖于外层查询中发现的数据。 h.UNCACHEABLE:意味着 select 中的某些特性阻止结果被缓存于一个 item_cache中。 type a.ALL:Full Table Scan 全表扫描，MySQL 将遍历全表以找到匹配的行。 b.index:Full Index Scan 全索引扫描，index 与 ALL 区别为 index 类型只遍历索引树 c. range:索引范围扫描，对索引的扫描开始于某一点，返回匹配值域的行。显而易见的索引范围扫描是带有 between 或者 where 子句里带有&lt;, &gt;查询。当 mysql 使用索引 去查找一系列值时，例如 IN()和 OR 列表，也会显示 range(范围扫描),当然性能上面是 有差异的。 d. ref_or_null:该联接类型如同 ref,但是添加了 MySQL 可以专门搜索包含 NULL 值的 行。 e. index_merge:该联接类型表示使用了索引合并优化方法 f. unique_subquery:该类型替换了下面形式的 IN 子查询的 ref: value IN (SELECT primary_key FROM single_table WHERE some_expr) 。unique_subquery 是一个索引查 找函数,可以完全替换子查询,效率更高。 g. index_subquery:该联接类型类似于 unique_subquery。可以替换 IN 子查询,但只 适合下列形式的子查询中的非唯一索引: value IN (SELECT key_column FROM single_table WHERE some_expr) h.ref:就是连接程序无法根据键值只取得一条记录，使用索引的最左前缀或者索引不 是 primary key 或 unique 索引的情况。当根据键值只查询到少数几条匹配的记录时，这 就是一个不错的连接类型。 i.eq_ref:类似 ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有 一条记录匹配，简单来说，就是多表连接中使用 primary key 或者 unique key 作为关联 条件. j.const、system:当 MySQL 对查询某部分进行优化，并转换为一个常量时，使用这 些类型访问。如将主键置于 where 列表中，MySQL 就能将该查询转换为一个常量。 注:system 是 const 类型的特例，当查询的表只有一行的情况下，使用 system k.NULL:MySQL 在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。 possible_keys 指出 MySQL 能使用哪个索引在表中找到记录，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用 extra 包含不适合在其他列中显示但十分重要的额外信息，提供了与关联操作有关的信息，没有则什么都不写。 a.Using index:该值表示相应的 select 操作中使用了覆盖索引(Covering Index)。 MySQL 可以利用索引返回 select 列表中的字段，而不必根据索引再次读取数据文件包含 所有满足查询需要的数据的索引称为覆盖索引(Covering Index)。注意:如果要使用覆 盖索引，一定要注意 select 列表中只取出需要的列，不可 select *，因为如果将所有字段 一起做索引会导致索引文件过大，查询性能下降。 b.Using where:表示 mysql 服务器将在存储引擎检索行后再进行过滤。许多 where 条件里涉及索引中的列，当(并且如果)它读取索引时，就能被存储引擎检验，因此不是所有带 where 字句的查询都会显示 &quot;Using where&quot;。有时&quot;Using where&quot;的出现就是一个暗 示:查询可受益与不同的索引。 c.Using temporary:表示 MySQL 需要使用临时表来存储结果集，常见于排序和分组 查询。这个值表示使用了内部临时(基于内存的)表。一个查询可能用到多个临时表。有很 多原因都会导致 MySQL 在执行查询期间创 建临时表。两个常见的原因是在来自不同表的 上使用了 DISTINCT,或者使用了不同的 ORDER BY 和 GROUP BY 列。可以强制指定一个 临时表使用基于磁盘的 MyISAM 存储引擎。这样做的原因主要有两个:1)内部 临时表占用 的空间超过 min(tmp_table_size，max_heap_table_size)系统变量的限制;2)使用了 TEXT/BLOB 列。 d. Using filesort:MySQL 中无法利用索引完成的排序操作称为“文件排序” e. Using join buffer:改值强调了在获取连接条件时没有使用索引，并且需要连接缓冲区来存储中间结果。如果出现了这个值，那应该注意，根据查询的具体情况可能需要添 加索引来改进能。 f. Impossible where:这个值强调了 where 语句会导致没有符合条件的行。 h. Select tables optimized away:这个值意味着仅通过使用索引，优化器可能仅从聚合函数结果中返回一行. I. Index merges:当 MySQL 决定要在一个给定的表上使用超过一个索引的时候，就会出现以下格式中的一个，详细说明使用的索引以及合并的类型。 Using sort_union(...) Using union(...) Using intersect(...) EXPLAIN 不考虑各种 Cache • EXPLAIN 不能显示 MySQL 在执行查询时所作的优化工作 • 部分统计信息是估算的，并非精确值 • EXPALIN 只能解释 SELECT 操作，其他操作要重写为 SELECT 后查看执行计划。 • EXPLAIN不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响 情况 Profiling的使用要想优化一条 Query，就须要清楚这条 Query 的性能瓶颈到底在哪里，是消耗的 CPU计算太多，还是需要的 IO 操作太多?要想能够清楚地了解这些信息，可以通过 Query Profiler 功能得到。 Query Profiler 是 MYSQL 自带的一种 query 诊断分析工具，通过它可以分析出一条 SQL 语句的性能瓶颈在什么地方。通常我们是使用的 explain,以及 slow query log 都无法 做到精确分析， 但是 Query Profiler 却可以定位出一条 SQL 语句执行的各种资源消耗情况， 比如 CPU，IO 等，以及该 SQL 执行所耗费的时间等 用法 (1)通过执行“set profiling”命令，可以开启关闭 QueryProfiler 功能 mysql&gt; SET global profiling=on; (2)查看相关变量 show VARIABLES like '%profiling%'; (3)设置保存数量默认 15 条，最大值为 100 mysql&gt; set profiling_history_size=100; (4)在开启 Query Profiler 功能之后，MySQL 就会自动记录所有执行的 Query 的 profile 信息，下面执行 n 条 Query 作为测试 select * from person limit 10000,100; (5)获取当前系统中保存的多个 Query 的 profile 的概要信息 mysql&gt; show profiles; (6)可以根据概要信息中的 Query_ID 来获取某个 Query 在执行过程中详细的 profile 信息。例如查看 cpu 和 io 的详细信息 show profiles; show profile cpu,block io for query 103; show profile ALL for query 103; ALL :显示所有信息 BLOCK IO :块设备 IO 输入输出次数 CONTEXT SWITCHES:上下文切换相关开销 CPU:用户和系统的 CPU 使用情况 IPC:显示发送和接收消息的相关消耗 MEMORY:内存消耗情况(该版本 is not currently implemented) PAGE FAULTS:显示主要和次要页面故障相关的开销 SOURCE:显示和 Source_function,Source_file,Source_line 相关的开销信息 |SWAPS:显示交换次数相关的开销 注意:profiling 被应用在每一个会话中，当前会话关闭后，profiling 统计的信息将丢失 last_query_cost查上一个查询的代价，而且它是 io_cost 和 cpu_cost 的开销总和，它通常也是我们评 价一个查询的执行效率的一个常用指标。last_query_cost 对于简单的查询可以精确的得到 计算，但于包含子查询或 union 的复杂查询值是 0。 show status like 'last_query_cost'; timestampdiff 查看执行时间这种方法有一点要注意，就是三条 sql 语句要尽量连一起执行，不然误差太大，根本不准。 set @d=now(); select id from person where lname='x8RJWmQX'; select timestampdiff(second,@d,now()); navicat客户端工具都自带sql执行时间显示功能 数据库连接进程列表show processlist; 建表时优化列选择原则1:字段类型优先级 整型 &gt; date,time &gt; char,varchar &gt; blob 2: 够用就行,不要慷慨 (如 smallint,varchar(N)) 原因:列的字段越大，建立索引时所需要的空间也就越大，这样一页中所能存储的索引节点的数量也就越少也 越少，在遍历时所需要的 IO 次数也就越多，索引的性能也就越差。 3: 尽量避免用 NULL() 原因:索引 NULL 列需要额外的空间来保存，所以要占用更多的空间进行比较和计算时要对 NULL 值做特别 的处理 4:对于非负型的数据 (如自增 ID,整型 IP) 来说,要优先使用无符号整型来存储 原因:无符号相对于有符号可以多出一倍的存储空间 SIGNED INT -2147483648~2147483647 UNSIGNED INT 0~4294967295 VARCHAR(N) 中的 N 代表的是字符数，而不是字节数，使用 UTF8 存储 255 个汉字 Varchar(255)=765 个字节。过大的长度会消耗更多的内存。 5:避免使用 TEXT,BLOB 数据类型，最常见的 TEXT 类型可以存储 64k 的数据 6:同财务相关的金额类数据必须使用 decimal 类型非精准浮点:float,double 精准浮点:decimal Decimal 类型为精准浮点数，在计算时不会丢失精度 占用空间由定义的宽度决定，每 4 个字节可以存储 9 位数字，并且小数点要占用一个字节可用于存储比 bigint 更大的整型数据 主键的选择:主键用来区分,查找,和关联数据,非常重要. 1.在 myisam 中,字符串索引会被压缩,用字符串做主键性能不如整型 2.用递增的值,不要用离散的值,离散值会导致文件在磁盘的位置有间隔,浪费空间且不易连续读取 3.不要使用 UUID,MD5,HASH,字符串列作为主键(无法保证数据的顺序增长) 反范式设计表反范式的目的--减少表的关联查询 常用办法: 冗余字段和冗余表 冗余字段: 表中某字段存储另一表的统计信息 冗余表: 表中统计或汇总其他表的信息,又称汇总表 本质 1:空间换时间 2:大任务分成小任务,分散执行 将字段很多的表分解成多个表对于字段较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。 因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。 举例:商品表和商品描述表就是把描述字段拆分成一个单独的表 增加中间表 Note不是多对多的中间表对于需要经常联合查询的表，可以建立中间表以提高查询效率。 通过建立中间表，将需要通过联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询。 举例: 增加冗余字段设计数据表时应尽量遵循范式理论的规约，尽可能的减少冗余字段，让数据库设计看起来精致、优雅。但是，合理的加入冗余字段可以提高查询速度。 表的规范化程度越高，表和表之间的关系越多，需要连接查询的情况也就越多，性能也就越差。 注意: 冗余字段的值在一个表中修改了，就要想办法在其他表中更新，否则就会导致数据不一致的问题。 举例:商品表里增加类目名称 测试性能定位高性能不是指”绝对性能”强悍,而是指业务能发挥出硬件的最大水平.性能强的服务器并非”设计”而来,而是不断改进,提升短板.测试,就是量化找出短板的过程. 测试指标 只有会测试,能把数据量化,才能进一步改进优化 1:吞吐量:单位时间内的事务处理数,单位 tps(每秒事务数) 2:响应时间:语句平均响应时间,一般截取某段时间内,95%范围内的平均时间 3:并发性:线程同时执行 4:可扩展性:资源增加,性能也能正比增加 发现系统运行缓慢，如何定位和分析查询慢的 sql 语句 1.开启 mysql 慢日志查询 定位查询较慢的 sql 语句 (200ms 500ms ) 2.使用 EXPLAIN 关键字可以让你知道 MySQL 是如何处理你的 SQL 语句的。这可以帮你分析你的查询语句或是表 结构的性能瓶颈。EXPLAIN 的查询结果还会告诉你你的索引主键被如何利用的，你的数据表是如何被搜索和排序 的......等等，等等 3.代码中 可以使用 AOP 的操作 对每个持久层的 service 方法 打印执行时间，将所有执行时间较长的 sql 语句进行 预警 测试工具mysqlslapmysqlslap --options --concurrency 代表并发数量，多个可以用逗号隔开，concurrency=10,50,100, 并发连接线程数分别是 10、50、 100 个并发。 --engines 代表要测试的引擎，可以有多个，用分隔符隔开。 --iterations 代表要运行这些测试多少次。 --auto-generate-sql 代表用系统自己生成的 SQL 脚本来测试。 --auto-generate-sql-load-type 代表要测试的是读还是写还是两者混合的(read,write,update,mixed) --number-of-queries 代表总共要运行多少次查询。每个客户运行的查询数量可以用查询总数/并发数来计算。 --debug-info 代表要额外输出 CPU 以及内存的相关信息。 mysqlslap -h 192.168.1.201 -uroot --auto-generate-sql --concurrency 20 --iterations 1 --create-schema=big_data --query='select * from dict limit 1' 测试工具sysbench测试 CPU 性能 测试 IO 性能 测试事务性能 - 查看 mysql 的进程状态 mysql -h 5 2 2 1 1 192.168.177.128 -u root -e 'show processlist\\G'|grep State:|sort|uniq -c|sort -rn State: Sending data State: statistics State: NULL State: Updating State: update 以下几种状态要注意: convertingHEAPtoMyISAM 查询结果太大时,把结果放在磁盘 create tmp table 创建临时表(如 group 时储存中间结果) Copying to tmp table on disk 把内存临时表复制到磁盘 locked 被其他查询锁住 logging slow query 记录慢查询 - 什么情况下产生临时表? 1: group by 的列和 order by 的列不同时, 2 表边查时,取 A 表的内容,group/order by 另外表的列 2: distinct 和 order by 一起使用时 3: 开启了 SQL_SMALL_RESULT 选项 - 什么情况下临时表写到磁盘上? 1:取出的列含有 text/blob 类型时 ---内存表储存不了 text/blob 类型 2:在 group by 或 distinct 的列中存在&gt;512 字节的 string 列 3:select 中含有&gt;512 字节的 string 列,同时又使用了 union 或 union all 语句 - 什么情况下 converting HEAP to MyISAM 1: sql 有问题,取出的结果或中间结果过大,内存临时表放不下 2: 服务器配置的临时表内存参数过小. tmp_table_size max_heap_table_size","link":"/2016/12/28/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL%E7%AC%AC%E4%B8%89%E7%AF%87--%E4%BC%98%E5%8C%96%E7%AF%87/"},{"title":"MySQL5.6的查询优化","text":"优化定义1. 合理安排资源、调整系统参数使MySQL运行更快、更节省资源。 2. 优化是多方面的，包括查询、更新、服务器等。 3. 原则：减少系统瓶颈，减少资源占用，增加系统的反应速度。 select * from tb_student A where A.age='18' and A.name=' 张三 '; 结合上面的说明，我们分析下这个语句的执行流程: - 先检查该语句是否有权限，如果没有权限，直接返回错误信息，如果有权限，在 MySQL8.0 版本以前，会先查询缓存，以这条 sql 语句为 key 在内存中查询是否有结果，如果有直接缓存，如果没有，执行下一步。 - 通过分析器进行词法分析，提取 sql 语句的关键元素，比如提取上面这个语句是查询 select，提取需要查 询的表名为 tb_student,需要查询所有的列，查询条件是这个表的 id='1'。然后判断这个 sql 语句是否有语法错误，比如关键词是否正确等等，如果检查没问题就执行下一步。 - 接下来就是优化器进行确定执行方案，上面的 sql 语句，可以有两种执行方案: - 先查询学生表中姓名为“张三”的学生，然后判断是否年龄是 18。 - 先找出学生中年龄 18 岁的学生，然后再查询姓名为“张三”的学生。 那么优化器根据自己的优化算法进行选择执行效率最好的一个方案(优化器认为，有时候不一定最好)。 那么确认了执行计划后就准备开始执行了。 - 进行权限校验，如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，返回引擎的执行结果 updatetb_studentAsetA.age='19'whereA.name=' 张三 '; 我们来给张三修改下年龄。其实这条语句也基本上会沿着上一个查询的流程走，只不过执行更新的时候肯定要记录 日志啦，这就会引入日志模块了，MySQL 自带的日志模块式 binlog(归档日志)，所有的存储引擎都可以使用，我们常用的 InnoDB 引擎还自带了一个日志模块 redo log(重做日志)，我们就以 InnoDB 模式下来探讨这个语句的 执行流程。流程如下: - 先查询到张三这一条数据，如果有缓存，也是会用到缓存。 - 然后拿到查询的数据，把 age 改为 19 - 然后调用引擎 API 接口，写入这一行数据。InnoDB 引擎把数据保存在内存中，同时记录 redo log，此时 redo log进入 prepare(预提交)状态，然后告诉执行器，执行完成了，随时可以提交。 - 执行器收到通知后记录 binlog，然后调用引擎接口，提交 redo log 为 commit(提交)状态 MySQL 主要分为 Server 层和引擎层，Server 层主要包括连接器、查询缓存、分析器、优化器、执行器，同 时还有一个日志模块(binlog)，这个日志模块所有执行引擎都可以共用,redolog 只有 InnoDB 有。 - 引擎层是插件式的，目前主要包括，MyISAM,InnoDB,Memory 等。 - SQL 等执行过程分为两类，一类对于查询等过程如下:权限校验---》查询缓存---》分析器---》优化器---》权 限校验---》执行器---》引擎 - 对于更新等语句执行流程如下:分析器----》权限校验----》执行器---》引擎---redo log prepare---》binlog---》redo log commit redo log理解Mysql 是先把磁盘上的数据加载到内存中，在内存中对数据进行修改，再刷回磁盘上。为了避免此时突然宕 机，内存中的数据就会丢失。事务提交前直接把数据写入磁盘啊。但是直接写入磁盘又会出现新的问题-----只修改 一个页面里的一个字节，就要将整个页面刷入磁盘，太浪费资源了。毕竟一个页面 16kb 大小，你只改其中一点点 东西，就要将 16kb 的内容刷入磁盘。毕竟一个事务里的 SQL 可能牵涉到多个数据页的修改，而这些数据页可能 不是相邻的，也就是属于随机 IO。显然操作随机IO，速度会比较慢。于是，决定采用 redo log 解决上面的问题。 当做数据修改的时候，不仅在内存中操作，还会在 redo log 中记录这次操作。当事务提交的时候，会将 redo log 日 志进行刷盘(redo log 一部分在内存中，一部分在磁盘上)。当数据库宕机重启的时候，会将 redo log 中的内容恢复 到数据库中，再根据 undo log 和 binlog 内容决定回滚数据还是提交数据。 - 采用 redo log 的好处 其实好处就是将 redo log 进行刷盘比对数据页刷盘效率高，具体表现如下 redo log 体积小，毕竟只记录了哪一页修改了啥，因此体积小，刷盘快。 redo log 是一直往末尾进行追加，属于顺序IO。效率显然比随机IO来的快。 - 使用 redo log 怎么保证的 crashsafe 最开始 MySQL 并没与 InnoDB 引擎( InnoDB 引擎是其他公司以插件形式插入 MySQL 的) ，MySQL 自带的 引擎是 MyISAM 该引擎只有用来归档 binlog 日志， redo log 是 InnoDB 引擎特有的，因此只有 InnoDB 引擎具有 crash-safe 的能力(crash-safe 的能力即使数据库发生异常重启，之前提交的记录都不会丢失)。 - InnoDB 引擎就是通 过 redo log 两阶段提交的方式+Mysql 事务处理机制来支持事务的。 通过 redo log 预提交—&gt; bin log 入库—&gt; redo log 提交来保证 crashsafe。但是 redo log 处于预提交状态，binglog 也已经写完了，这个时候发生了异常重启会怎么样呢?这个就要依赖于 MySQL 的处理机制了，MySQL 的处理过程 如下: - 判断redolog是否完整，如果判断是完整的，就立即提交。 - 如果 redo log 只是预提交但不是 commit 状态，这个时候就会去判断 binlog 是否完整，如果完整就提交 redo log, 不完整就回滚事务【undo log】。这样就解决了数据一致性的问题。 数据库的性能参数使用SHOW STATUS语句查看MySQL数据库的性能参数 SHOW STATUS LIKE ‘value‘常用的参数： Slow_queries 慢查询次数 Com_(CRUD) 操作的次数 Uptime 上线时间慢查询查看状态示例:统计CRUD次数show status like 'Com_delete'; show status like 'Com_select'; show status like 'Com_insert'; 统计上线时间show status like 'Uptime' 输出 Uptime 6960661 //表示这么多秒之前上线的 查询优化Explain在MySQL中可以使用EXPLAIN查看SQL执行计划，用法：EXPLAIN SELECT * FROM tb_item 结果说明idSELECT识别符。这是SELECT查询序列号。这个不重要 select_type有以下几种值： SIMPLE 表示简单查询，其中不包含连接查询和子查询 PRIMARY 表示主查询，或者是最外面的查询语句 UNION 表示连接查询的第2个或后面的查询语句。 DEPENDENT UNION UNION中的第二个或后面的SELECT语句，取决于外面的查询。 UNION RESULT 连接查询的结果。 SUBQUERY子查询中的第1个SELECT语句 DEPENDENT SUBQUERY 子查询中的第1个SELECT语句，取决于外面的查询。 DERIVED SELECT(FROM 子句的子查询)。 table表示查询的表 type表示表的连接类型。以下的连接类型的顺序是从最佳类型到最差类型： 1、system表仅有一行，这是const类型的特列，平时不会出现，这个也可以忽略不计。 2、const数据表最多只有一个匹配行，因为只匹配一行数据，所以很快，常用于PRIMARY KEY或者UNIQUE索引的查询，可理解为const是最优化的 3、eq_ref (多出现在唯一索引或者主键)mysql手册是这样说的:”对于每个来自于前面的表的行组合，从该表中读取一行。这可能是最好的联接类型，除了const类型。它用在一个索引的所有部分被联接使用并且索引是UNIQUE或PRIMARY KEY”。eq_ref可以用于使用=比较带索引的列 4、ref (多出现在普通索引情况下)查询条件索引既不是UNIQUE也不是PRIMARY KEY的情况。ref可用于=或&lt;或&gt;操作符的带索引的列。 5、 ref_or_null该联接类型如同ref，但是添加了MySQL可以专门搜索包含NULL值的行。在解决子查询中经常使用该联接类型的优化。上面这五种情况都是很理想的索引使用情况。 6、index_merge （多出现在联合索引）该联接类型表示使用了索引合并优化方法。在这种情况下，key列包含了使用的索引的清单，key_len包含了使用的索引的最长的关键元素。 7、unique_subquery该类型替换了下面形式的IN子查询的ref: value IN (SELECT primary_key FROM single_table WHERE some_expr) unique_subquery是一个索引查找函数,可以完全替换子查询,效率更高。 8、index_subquery该联接类型类似于unique_subquery。可以替换IN子查询,但只适合下列形式的子查询中的非唯一索引: value IN (SELECT key_column FROM single_table WHERE some_expr) 9、range只检索给定范围的行,使用一个索引来选择行 10、index该联接类型与ALL相同,除了只有索引树被扫描。这通常比ALL快,因为索引文件通常比数据文件小。 11 ALL对于每个来自于先前的表的行组合,进行完整的表扫描。（性能最差） possible_keys表示可用的索引有哪些 key 实际用到的索引显示MySQL实际决定使用的键(索引)。如果没有选择索引,键是NULL。可以强制使用索引或者忽略索引 key_len显示MySQL决定使用的键长度。如果键是NULL,则长度为NULL。注意：key_len是确定了MySQL将实际使用的索引长度。 ref显示使用哪个列或常数与key一起从表中选择行。 rows显示MySQL认为它执行查询时必须检查的行数。 Extra该列包含MySQL解决查询的详细信息• Distinct:MySQL发现第1个匹配行后,停止为当前的行组合搜索更多的行。• Not exists:MySQL能够对查询进行LEFT JOIN优化,发现1个匹配LEFT JOIN标准的行后,不再为前面的的行组合在该表内检查更多的行。• range checked for each record (index map: #):MySQL没有发现好的可以使用的索引,但发现如果来自前面的表的列值已知,可能部分索引可以使用。• Using filesort:MySQL需要额外的一次传递,以找出如何按排序顺序检索行。• Using index:从只使用索引树中的信息而不需要进一步搜索读取实际的行来检索表中的列信息。• Using temporary:为了解决查询,MySQL需要创建一个临时表来容纳结果。• Using where:WHERE 子句用于限制哪一个行匹配下一个表或发送到客户。• Using sort_union(…), Using union(…), Using intersect(…):这些函数说明如何为index_merge联接类型合并索引扫描。• Using index for group-by:类似于访问表的Using index方式,Using index for group-by表示MySQL发现了一个索引,可以用来查 询GROUP BY或DISTINCT查询的所有列,而不要额外搜索硬盘访问实际的表。 使用索引注意的地方索引可以提供查询的速度，但并不是使用了带有索引的字段查询都会生效，有些情况下是不生效的，需要注意！ 使用LIKE关键字的查询在使用LIKE关键字进行查询的查询语句中，如果匹配字符串的第一个字符为“%”，索引不起作用。只有“%”不在第一个位置，索引才会生效。 使用联合索引的查询MySQL可以为多个字段创建索引，一个索引可以包括16个字段。对于联合索引，只有查询条件中使用了这些字段中第一个字段时，索引才会生效。 使用OR关键字的查询查询语句的查询条件中只有OR关键字，且OR前后的两个条件中的列都是索引时，索引才会生效，否则，索引不生效 子查询优化MySQL从4.1版本开始支持子查询，使用子查询进行SELECT语句嵌套查询，可以一次完成很多逻辑上需要多个步骤才能完成的SQL操作。子查询虽然很灵活，但是执行效率并不高。执行子查询时，MYSQL需要创建临时表，查询完毕后再删除这些临时表，所以，子查询的速度会受到一定的影响。优化：可以使用连接查询（JOIN）代替子查询，连接查询时不需要建立临时表，其速度比子查询快 总结SELECT 语句务必指明字段名称(避免直接使用 select * ) SQL 语句要避免造成索引失效的写法 SQL 语句中 IN 包含的值不应过多 当只需要一条数据的时候，使用 limit 1 如果排序字段没有用到索引，就尽量少排序 如果限制条件中其他字段没有索引，尽量少用 or 尽量用 union all 代替 union,union all 不过滤 效率提高,如非必须,请用 union all因为 union 去重的代价非常高, 放在程序里去重 避免在 where 子句中对字段进行 null 值判断 不建议使用%前缀模糊查询 避免在 where 子句中对字段进行表达式操作 Join 优化 能用 inner join 就不用 left join right join，如必须使用 一定要已小表为驱动 limit 及翻页优化 limit offset,N, 当 offset 非常大时, 效率极低, 原因是 mysql 并不是跳过 offset 行,然后单取 N 行, 而是取 offset+N 行,返回放弃前 offset 行,返回 N 行. 效率较低,当 offset 越大时,效率越低 优化办法: 1: 从业务上去解决 办法: 不允许翻过 100 页 以百度为例,一般翻页到 70 页左右. 1:不用 offset,用条件查询. 3: 非要物理删除,还要用 offset 精确查询,还不限制用户分页,怎么办? 分析: 优化思路是 不查,少查,查索引,少取. 我们现在必须要查,则只查索引,不查数据,得到 id. 再用 id 去查具体条目. 这种技巧就是延迟索引. 索引优化策略 1. 选择唯一性索引 2. 唯一性索引的值是唯一的，可以更快速的通过该索引来确定某条记录。 3. 为经常需要排序、分组和联合操作的字段建立索引: 4. 为常作为查询条件的字段建立索引。 5. 限制索引的数目: 越多的索引，会使更新表变得很浪费时间。 6. 尽量使用数据量少的索引 7. 如果索引的值很长，那么查询的速度会受到影响。 8. 尽量使用前缀来索引 9. 如果索引字段的值很长，最好使用值的前缀来索引。 10. 删除不再使用或者很少使用的索引 11. 最左前缀匹配原则，非常重要的原则。 12. 尽量选择区分度高的列作为索引 13. 区分度的公式是表示字段不重复的比例 14. 索引列不能参与计算，保持列“干净”:带函数的查询不参与索引。 15. 尽量的扩展索引，不要新建索引。 应尽量避免在 where 子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行 全表扫描。如: select id from t where substring(name,1,3)=’abc’ –name 以 abc 开头的 id select id from t where datediff(day,createdate,’2005-11-30′)=0 –’2005-11-30′生成 的 id 应改为: select id from t where name like ‘abc%’ select id from t where createdate&gt;=’2005-11-30′ and createdate&lt;’2005-12-1′ 用 exists 代替 in 很多时候用 exists 代替 in 是一个好的选择: select num from a where num in(select num from b) 用下面的语句替换: select num from a where exists(select 1 from b where num=a.num) 大临时表使用 select into 代替 create table 在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度;如果数据量不大，为了缓和系统表的资 源，应先 create table，然后 insert 临时表先 truncate table，然后 drop table 如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定 避免在 where 子句中对字段进行 null 值判断 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索 引而进行全表扫描。如: select id from t where num is null 可以在 num 上设置默认值 0，确保表中 num 列没有 null 值，然后这样查询: select id from t where num=0 在 Mysql5.7 版本中该条建议已经不用考虑了，因为 null 判断也能使用索引了。 尽可能减少 Join 语句中 Nested Loop 的循环总次数 最有效的办法是让驱动表的结果集尽可能地小，“永远用小结果集驱动大结果集”。 比如，当两个表(表 A 和表 B)Join 时，如果表 A 通过 WHERE 条件过滤后有 10 条 记录，而表 B 有 20 条记录。如果选择表 A 作为驱动表，也就是被驱动表的结果集为 20， 那么我们通过 Join 条件对被驱动表(表 B)的比较过滤就会进行 10 次。反之，如果选择 表 B 作为驱动表，则须要进行 20 次对表 A 的比较过滤。 其目的正是基于上面两点的考虑，只有让被驱动表的 Join 条件字段被索引了，才能保 证循环中每次查询都能够消耗较少的资源，这也正是内层循环的实际优化方法 分页优化方法一 select * from person limit 999900,100; -- 慢了，大概需要 0.4 秒多 select * from person where id&gt;999900 limit 100;-- 这样就非常快，0.001s 左右，因为使用了 id 索引，但这样用有前提，id 是连续的，中间的数据不能删，否则 id 为 999900 的并不是第 999900 个记录。 分页技术优化方法二 如果必须用 limit offset 查询，就用延迟关联 select id from person limit 999900 ,100; 这样只查询 id 列，实现了索引覆盖，就会很快 select p.* from person p inner join (select id from person limit 999900 ,100) as tmp on p.id=tmp.id; 通过内连接再获取分页后每条记录的详细信息 优化更须要优化的Query 这个问题须要从对整个系统的影响来考虑。哪个 Query 的优化能给系统整体带来更大的收益，就更须要优化。一般来说，高并发低消耗的影响 &gt; 低并发高消耗 假设有一个 Query 每小时执行 10000 次，每次需要 20 个 IO，而另外一个 Query 每 小时执行 10 次，每次需要 20000 个 IO。 (1)通过 IO 消耗来分析 两个 Query 每小时所消耗的 IO 总数目是一样的，都是 200000 IO/小时 假设优化第一个 Query，从 20 个 IO 降低到 18 个 IO，也就是降低了 2 个 IO，则节 省了 2×10000 = 20000 (IO/小时) 而如果希望通过优化第二个 Query 达到相同的效果，必须要让每个 Query 减少 20000 / 10 = 2000 IO 可以看出第一个 Query 节省 2 个 IO 即可达到第二个 Query 节省 2000 个 IO 相同的 效果 (2)通过 CPU 消耗来分析 原理和上面一样，只要让第一个 Query 节省一小块资源，就可以让整个系统节省出一 大块资源，尤其是在排序、分组这些对 CPU 消耗比较多的操作中更加明显 (3)从对整个系统的影响来分析 一个频繁执行的高并发 Query 的危险性比一个低并发的 Query 要大很多，当一个低 并发的 Query 执行计划有误时，所带来的影响只是该 Query 请求者的体验会变差，对整 体系统的影响并不会特别突出，但是，如果一个高并发的 Query 执行计划有误，它带来的 后果很可能就是灾难性的。 让 InnoDB 使用全部内存 innodb_buffer_pool_size 参数指定了 InnoDB 可以使用的内存总量 建议设置为物理内存的 80%，因为要给操作系统留有空间。 如果你的内存是 32GB，可以设置为大约 25GB innodb_buffer_pool_size = 25600M 注意: (1)如果值小于 1GB，说明真的应该升级服务器了 (2)如果内存特别大，例如 200gb，就不必给操作系统留 20% 了，因为 OS 用不 了 40gb。 让 InnoDB 多实例 innodb_buffer_pool_size 的 值 大 于 1G 时 ， innodb_buffer_pool_instances 会 把 InnoDB 的缓存池划分成多个实例。 多个缓冲池的好处: 多个线程同时访问缓冲池时可能会遇到瓶颈，而多个缓冲池则可以最小化这个冲突 官方建议的 buffer 数量:每个 buffer pool 实例至少要 1G 例如内存为 32GB，innodb_buffer_pool_size 为 25GB，那么合适的方案就是 25600M / 24 = 1.06GB innodb_buffer_pool_instances = 24 加大 max_length_for_sort_data 参数的设置 在 MySQL 中，排序算法分为两种，一是只加载排序字段到内存，排序完成后再到表 中取其他字段，二是加载所有需要的字段到内存，显然第二种节省了 IO 操作，所以更快。 决定使用哪种算法是通过参数 max_length_for_sort_data 来决定的，当所有返回字段的最 大长度小于这个参数值时，MySQL 就会选择第二种算法，反之使用第一种。所以，如果 有充足的内存让 MySQL 存放须要返回的非排序字段，就可以加大这个参数的值来让 MySQL 选择第二种排序算法。 当内存不是很充裕时，不能简单地通过强行加大上面的参数来强迫 MySQL 去使用高 效算法，否则可能会造成 MySQL 不得不将数据分成很多段，然后进行排序，这样可能会 得不偿失，此时就须要去掉不必要的返回字段，让返回结果长度适应 max_length_for_sort_data 参数的限制。 增大 sort_buffer_size 参数设置 增大 sort_buffer_size 并不是为了让 MySQL 选择第二种排序算法，而是为了让MySQL 尽量减少在排序过程中对须要排序的数据进行分段，因为分段会造成 MySQL 不得 不使用临时表来进行交换排序 案例 发现网站页面打开非常慢，对处理过程简单记录了一下。 找问题 首先登录服务器使用 top 查看当前进程信息，发现排名第一的是 mysql，占用 cpu达到了 100% 以上，这就明确了是 mysql 的问题。 登录 mysql，使用 show processlist 查看下当前执行状态，发现了大量 LOCK 操作， 也有多个 Copying to tmp table 的操作，说明有 sql 出现了问题，操作过于复杂，对临 时表使用频繁，把其他操作阻塞了 解决思路 找到了问题后，把处理方向确定为检查和修改配置、sql 优化。 临时表 既然涉及了到了临时表，就先查看下目前临时表的信息 查看临时表的使用状态 show global status like 'created_tmp%'; 发现 created_tmp_disk_tables 值过高，需要增加此值。 再看一下现在临时表的大小 show variables like '%tmp_table_size%'; 在现在值的基础上增加一些，重新设置临时表大小 线程缓存数 看当前线程情况 show global status like 'Thread%'; 发现 threads_created 的值过大，表明 MySQL 服务器一直在创建线程 查看当前值 show variables like 'thread_cache_size'; 此参数需要调高 打开表数量 查看打开表的情况 show global status like 'open%tables%'; 发现 opened_tables 数量过大，说明 table_cache 的值可能太小。 查看当前值 show variables like 'table_cache'; 此参数需要调高 最大连接数 查看当前允许的最大连接数 show variables like 'max_connections'; 查看服务器连接数的峰值 show global status like 'Max_used_connections'; 峰值还没到最大限制，不需要修改 join buffer 和 sort buffer 查看现有值 SELECT @@sort_buffer_size; SELECT @@join_buffer_size; 是默认值，需要修改 修改配置 确定了要修改的参数后，修改 my.cnf ，例如 table_cache = 64 sort_buffer_size = 8M join_buffer_size = 4M thread_cache_size = 300 thread_concurrency = 8 tmp_table_size = 246M sql 优化 从 show processlist 结果集中找出主要的复杂语句，对其进行 explain 和 profile 分析，进行索引优化，把复杂的 sql 根据业务拆分为多个小的 sql 主从复制、读写分离、高可用 HA主从复制 MySQL 主从复制是指数据可以从一个 MySQL 数据库服务器主节点复制到一个或多 个从节点。MySQL 默认采用异步复制方式，这样从节点不用一直访问主服务器来更新自 己的数据，数据的更新可以在远程连接上进行，从节点可以复制主数据库中的所有数据库 或者特定的数据库，或者特定的表。 读写分离 可以把写操作放在 master，读取操作放在 slave，减轻单一数据库的操作压力 高可用 HA 随着系统中业务访问量的增大，如果是单机部署数据库，就会导致 I/O 访问频率过高。 有了主从复制，增加多个数据存储节点，将负载分布在多个从节点上，降低单机磁盘 I/O 访问的频率，提高单个机器的 I/O 性能 基本原理```textmaster 记录下自己的操作日志，授权从服务器可以读取操作日志，slave 会开启两个线程。IO 线程负责连接 master 连接成功后，睡眠并等待 master 产生新的事件，有新的就保存到 自己的中继日志中，中继日志通常位于操作系统的缓存中，所以开销很小sql 进程负责执行中继日志中的 sql 操作，这样 slave 的内容就和 master 的一致了 具体执行 主库 db 的更新事件(update、insert、delete)被写到 binlog 从库发起连接，连接到主库 主库创建一个 binlog dump thread 线程，把 binlog 的内容发送到从库 从库启动之后，创建一个 I/O 线程，读取主库传过来的 binlog 内容并写入到 relaylog。 还会创建一个 SQL 线程，从 relay log 里面读取内容，从 Exec_Master_Log_Pos位置开始执行读取到的更新事件，将更新内容写入到 slave 的 db。``` 配置方式```shell前提条件停止对 master 数据库的操作，把 master 中的数据库全部导入到 slave，使两边数据 库完全一致。 配置 master 修改 master 的配置文件，使用二进制日志，指定 server-id，重启服务。目的是让各自都有了自己的唯一标示，并以二进制文件格式进行交流。Centos 中路径为 /etc/my.cnf。[mysqld]Log_bin=mysql-bin //[必须]启用二进制日志server-id=10//[必须]服务器唯一 ID，默认是 1，一般取 IP 最后一段配置完成后需要重启 mysqlserver 才能生效。 systemctl restart mysqld 创建授权用户登陆主服务器 mysql 命令行，创建一个用于从服务器复制的用户。mysql -uroot -pmysql&gt;grant replication slave on . to ‘root‘@’%’ identified by ‘123456’;“.“表示对所有库的所有操作，“%”表示所有客户端都可能连，也可用具体客户端 IP 代替，如 192.168.33.11，加强安全。 记录 master 状态信息查看二进制日志文件名，及最新位置。让 slave 知道用哪个用户信息访问 master，知道读取哪个日志文件，及从哪儿开始读。 mysql&gt;show master status;其中 file、position 字段需要记录下值，mysql-bin.000001 是用于主从复制的文件名，437 是日志文件内的最新位置 配置 slave 修改配置文件 my.cnf，使用二进制日志，指定 server-id，重新启动服务。[mysqld] Log_bin=mysql-binServer_id=11 将 slave 指向 master登陆从服务器 mysql 命令行，使用之前创建的用户和 master 的日志文件及其位置。slave 中使用被授权用户信息及日志文件信息，进行指向 master。这时已经建立了和 master的联系，明确了从哪儿读取日志文件。mysql&gt;change master to master_host=’192.168.33.10’,master_user=’root’,master_password=’123456’,master_log_file=’mysql-bin.00 0001’,master_log_pos=437;//注意不要断开，“437”无单引号 启动 slave执行启动 slave 的命令，开始主从复制 mysql&gt;start slave;4. 查看 slave 状态mysql&gt; show slave status\\G;结果中有两个重要数据项: Slave_IO_Running: Yes IO 线程状态，必须 YES Slave_SQL_Running: Yes SQL 线程状态，必须 YES常见的问题是 SQL 线程没有正常工作 Slave_SQL_Running: No 通常是两边的数据库不是完全对应的，需要确保 master 上的库及到目前为止的最新记录都复制到 slave 上了。 验证测试当 IO 线程和 SQL 线程都正常后，到 master 中随意测试下插入、修改、删除操作，同时到 slave 中检查。master 执行以下命令:Create database mastertest; Use mastertest;CREATE TABLE test (id bigint(20) unsigned NOT NULL AUTO_INCREMENT, name varchar(100) NOT NULL,PRIMARY KEY (id)) ENGINE=InnoDB DEFAULT CHARSET=utf8;Insert into test(name) values(‘1test’);Insert into test(name) values(‘2test’);Insert into test(name) values(‘3test’); slave 下验证show databases;Use mastertest;Show tables;Select * from test; ### 使用MysqlUtilities快速搭建主从复制 ```text Mysql Utilities 是一个 Mysql 的工具箱(基于 python )，里面有不少好用的小工具，其中的 mysqlreplicate 命令，可以让我们通过一个命令就能快速配置好主从复制环境。 Mysql Utilities 下载地址 http://dev.mysql.com/downloads/utilities/1.5.html Mysql Utilities 文档 http://dev.mysql.com/doc/mysql-utilities/1.6/en/utils-overview.html 用法: mysqlreplicate \\ --master=root:111111@192.168.31.168:3306 \\ --slave=root:111111@192.168.31.101:3306 \\ --rpl-user=replutil:111111 --master 指定主库的连接信息 --slave 指定从库的连接信息 --rpl-user 指定用于复制的用户信息，这个用户需要提前在 master 上创建好，例如: grant ALL PRIVILEGES on *.* to replutil@&quot;192.168.31.101&quot; Identified by &quot;111111&quot;; 注意，创建用户时，其中的从库 IP 要明确，不要用 '%'。 可以看到，总共只需要两步: (1)master 上创建用于复制的用户 (2)执行 mysqlreplicate 命令 几秒钟就完成了主从配置 下载解压 Mysql Utilities，进入解压后的目录，执行编译安装命令 python ./setup.py build python ./setup.py install 执行完成后，就可以使用其中的工具命令了 读写分离中间件 MaxScale配置好了 Mysql 的主从复制结构后，我们希望实现读写分离，把读操作分散到从服务器中，并且对多个从服务器能实现负载均衡。读写分离和负载均衡是 Mysql 集群的基 础需求，MaxScale 就可以帮着我们方便的实现这些功能 MaxScale 的基础构成 MaxScale 是 Mysql 的兄弟公司 MariaDB 开发的，现在已经发展得非常成熟。 MaxScale 是插件式结构，允许用户开发适合自己的插件。 MaxScale 目前提供的插件功能分为 5 类 1.)认证插件 提供了登录认证功能，MaxScale 会读取并缓存数据库中 user 表中的信息，当有连 接进来时，先从缓存信息中进行验证，如果没有此用户，会从后端数据库中更新信息，再 次进行验证 2.)协议插件 包括客户端连接协议，和连接数据库的协议。 3.)路由插件 决定如何把客户端的请求转发给后端数据库服务器，读写分离和负载均衡的功能就是 由这个模块实现的。 4.)监控插件 对各个数据库服务器进行监控，例如发现某个数据库服务器响应很慢，那么就不向其 转发请求了。 5.)日志和过滤插件 提供简单的数据库防火墙功能，可以对 SQL 进行过滤和容错。 安装 MaxScale 最好在另一台服务器上安装，如果资源不足，可以和某个 Mysql 放在一起。 MaxScale 的下载地址，最新版本 2.3.4，实例中使用的是 1.4.5: https://downloads.mariadb.com/files/MaxScale 根据自己的服务器选择合适的安装包，以 centos 7 为例安装步骤如下: yum install libaio.x86_64 libaio-devel.x86_64 novacom-server.x86_64 libedit -y wget https://downloads.mariadb.com/MaxScale/1.4.5/centos/7/x86_64/maxscale-1.4.5-1.centos.7.x8 6_64.rpm rpm -ivh maxscale-1.4.5-1.centos.7.x86_64.rpm 配置 MaxScale 在开始配置之前，需要在 master 中为 MaxScale 创建两个用户，用于监控模块和 路由模块: 创建监控用户 create user 'maxmon'@'%' identified by '123456'; grant replication slave,replication client on *.* to 'maxmon'@'%'; 创建路由用户 create user 'maxrou'@'%' identified by '123456'; grant select on mysql.* to 'maxrou'@'%'; flush privileges; 用户创建完成后，开始配置 vi /etc/maxscale.cnf 找到 [server1] 部分，修改其中的 address 和 port，指向 master 的 IP 和端口 复制 2 次 [server1] 的整块儿内容，改为 [server2] 与 [server3]，同样修改其中的 address 和 port，分别指向 slave1 和 slave2 找到 [MySQL Monitor] 部分，修改 servers 为 server1,server2,server3，修改 user 和 passwd 为之前创建的监控用户的信息(maxmon,123456) 找到 [Read-Write Service] 部分，修改 servers 为 server1,server2,server3，修改 user 和 passwd 为之前创建的路由用户的信息(maxrou,123456) 由于我们使用了 [Read-Write Service]，需要删除另一个服务 [Read-Only Service]， 删除其整块儿内容即可，底部还有一个[Read-Only Client]也需要删除。 配置完成，保存并退出编辑器。 启动 MaxScale 执行启动命令 maxscale --config=/etc/maxscale.cnf 查看 MaxScale 的响应端口是否已经就绪 netstat -ntelp 4006 是 Read-Write Listener 使用的端口，用于连接 MaxScale 6603 是 MaxAdmin Listener 使用的端口，用于 MaxScale 管理器 登录 MaxScale 管理器，查看一下数据库连接状态，默认的用户名和密码是 admin/mariadb maxadmin --user=admin --password=mariadb MaxScale&gt; list servers 可以看到，MaxScale 已经连接到了 master 和 slave 测试 先在 master 上创建一个测试用户 create user 'rtest'@'%' identified by '111111'; grant ALL PRIVILEGES on *.* to 'rtest'@'%'; 使用 Mysql 客户端到连接 MaxScale mysql -urtest -p'111111' -h'192.168.33.11' -P4006 执行查看数据库服务器名的操作来知道当前实际所在的数据库 Select @@hostname; start transaction; Select @@hostname; roolback; Select @@hostname; 开启事务后，就自动路由到了 master，普通的查询操作，是在 slave 上 读写分离中间件 MySQL-Proxy可参考:https://www.cnblogs.com/luckcs/articles/2543607.html MySQLProxy 是 MySQL 官方提供的一个数据库代理层产品，和 MySQLServer 一样， 相同是一个基于 GPL 开源协议的开源产品。可用来监视、分析或者传输他们之间的通讯信 息，具备的功能主要有连接路由、Query 分析、Query 过滤和修改、负载均衡以及主要的 HA 机制等。 实际上 MySQLProxy 本身并不具有上述全部的这些功能，而是提供了实现上述功能的 基础。要实现这些功能，还须要通过我们自行编写 LUA 脚本来实现。 MySQLProxy 实际上是在 client 请求与 MySQLServer 之间建立了一个连接池。全部 client 请求都是发向 MySQLProxy，然后经由 MySQLProxy 进行对应的分析。推断出是读 操作还是写操作，分发至对应的 MySQLServer 上。对于多节点 Slave 集群，也能够起做 到负载均衡的效果。 数据库切分(Sharding) 当数据量达到一定程度时，我们处于性能考虑就需要将我们存放在同一个数据库中的 垂直切分```text数据分散存放到多个数据库(主机)上面，以达到分散单台设备负载的效果。数据的切分 同一时候还能够提高系统的总体可用性，由于单台设备 Crash 之后。仅仅有总体数据的某 部分不可用，而不是全部的数据。数据的切分(Sharding)依据其切分规则的类型，能够分为垂直切分、水平切分、联 合切分模式。 数据的垂直切分简介一种是依照不同的表(或者 Schema)来切分到不同的数据库(主机)之上，这样的 切能够称之为数据的垂直(纵向)切分。垂直切分的最大特点就是规则简单，实施也更为方便，尤其适合各业务之间的耦合度 非常低。相互影响非常小，业务逻辑非常清晰的系统。在这样的系统中，能够非常容易做 到将不同业务模块所使用的表分拆到不同的数据库中。依据不同的表来进行拆分。对应用 程序的影响也更小，拆分规则也会比较简单清晰。一个架构设计较好的应用系统。其总体功能肯定是由非常多个功能模块所组成的。而 每一个功能模块所须要的数据对应到数据库中就是一个或者多个表。而在架构设计中，各 个功能模块相互之间的交互点越统一越少，系统的耦合度就越低，系统各个模块的维护性 以及扩展性也就越好。这样的系统实现数据的垂直切分也就越容易，不同功能模块的数据 存放于不同的数据库主机中，能够非常容易就避免掉跨数据库的 Join 存在。当然很多情况下系统的耦合度没有那么低，我们就必须依据实际的应用场景进行评估 权衡。决定是迁就应用程序将须要 Join 的表的相关某快都存放在同一个数据库中，还是让应用程序做很多其它的事情，也就是程序全然通过模块接口取得不同数据库中的数据，然后在程序中完毕 Join 操作。 - 案例分析 ```text 系统功能能够基本分为四个功能模块:用户，群组消息，相册以及事件。分别对应为 例如以下这些表: 1. 用户模块表:user,user_profile,user_group,user_photo_album 2. 群组讨论表:groups,group_message,group_message_content,top_message 3. 相册相关表:photo,photo_album,photo_album_relation,photo_comment 4. 事件信息表:event 初略一看，没有哪一个模块能够脱离其它模块独立存在，模块与模块之间都存在着关 系。莫非无法切分? 当然不是，我们再略微深入分析一下，能够发现，尽管各个模块所使用的表之间都有关联，可是关联关系还算比较清晰，也比较简单。 ◆群组讨论模块和用户模块之间主要存在通过用户或者是群组关系来进行关联。一般关联的时候都会是通过用户的 id 或者 nick_name 以及 group 的 id 来进行关联。通过模块 之间的接口实现不会带来太多麻烦。 ◆相册模块仅仅与用户模块存在通过用户的关联。这两个模块之间的关联基本就有通 过用户 id 关联的内容。简单清晰，接口明白; ◆ 事件模块与各个模块可能都有关联，可是都仅仅关注其各个模块中对象的ID信息， 相同能够做到非常容易分拆。 所以。我们第一步能够将数据库依照功能模块相关的表进行一次垂直拆分。每一个模 块所涉及的表单独到一个数据库中，模块与模块之间的表关联都在应用系统端通过藉口来 处理。例如以下图所看到的 通过这样的垂直切分之后。之前仅仅能通过一个数据库来提供的服务。就被分拆成四 个数据库来提供服务，服务能力自然是添加几倍了。 垂直切分的长处 ◆ 数据库的拆分简单明了，拆分规则明白; ◆ 应用程序模块清晰明白，整合容易。 ◆ 数据维护方便易行，容易定位。 垂直切分的缺点 ◆ 部分表关联无法在数据库级别完毕。须要在程序中完毕。 ◆ 对于访问极其频繁且数据量超大的表仍然存在性能平静，不一定能满足要求。 ◆ 事务处理相对更为复杂; ◆ 切分达到一定程度之后，扩展性会遇到限制; ◆ 过读切分可能会带来系统过渡复杂而难以维护 数据的水平切分 依据表中的数据的逻辑关系，将同一个表中的数据依照某种条件拆分到多台数据库 (主机)上面，这样的切分称之为数据的水平(横向)切分。一般来说，简单的水平切分 主要是将某个访问极其平庸的表再依照某个字段的某种规则来分散到多个表之中。每一个 表中包括一部分数据。 水平切分于垂直切分相比。相对来说略微复杂一些。由于要将同一个表中的不同数据 拆分到不同的数据库中，对于应用程序来说，拆分规则本身就较依据表名来拆分更为复杂， 后期的数据维护也会更为复杂一些。 如依据某个数字类型字段基于特定数目取模，某个时间类型字段的范围，或者是某个 字符类型字段的 hash 值。假设整个系统中大部分核心表都能够通过某个字段来进行关联。 那这个字段自然是一个进行水平分区的上上之选了。 一般来说，像如今互联网非常火爆的 Web2.0 类型的站点。基本上大部分数据都能够 通过会员用户信息关联上，可能非常多核心表都非常适合通过会员 ID 来进行数据的水平 切分。切分之后基本上不会出现各个库之间的交互。 案例分析```text全部数据都是和用户关联的。那么我们就能够依据用户来进行水平拆分，将不同用户 的数据切分到不同的数据库中。当然，唯一有点差别的是用户模块中的 groups 表和用户 没有直接关系。所以 groups 不能依据用户来进行水平拆分。对于这样的特殊情况下的表， 我们全然能够独立出来。单独放在一个独立的数据库中所以，对于我们的演示样例数据库来说，大部分的表都能够依据用户 ID 来进行水平 的切分。不同用户相关的数据进行切分之后存放在不同的数据库中。如将全部用户 ID 通 过 5 取模然后分别存放于五个不同的数据库中。每一个和用户 ID 关联上的表都能够这样切分。这样，基本上每一个用户相关的数据。 都在同一个数据库中，即使是须要关联，也能够非常简单的关联上。我们能够通过下图来更为直观的展示水平切分相关信息: 水平切分的长处◆ 表关联基本能够在数据库端全部完毕;◆ 不会存在某些超大型数据量和高负载的表遇到瓶颈的问题;◆ 应用程序端总体架构修改相对较少;◆ 事务处理相对简单;◆ 仅仅要切分规则能够定义好。基本上较难遇到扩展性限制;水平切分的缺点◆ 切分规则相对更为复杂，非常难抽象出一个能够满足整个数据库的切分规则;◆ 后期数据的维护难度有所添加，人为手工定位数据更困难;◆ 应用系统各模块耦合度较高，可能会对后面数据的迁移拆分造成一定的困难。 - 联合切分 ```text 当我们某个(或者某些)表的数据量和访问量特别的大，通过垂直切分将其放在独立 的设备上后仍然无法满足性能要求，这时候我们就必须将垂直切分和水平切分相结合。先 垂直切分，然后再水平切分，才能解决这样的超大型表的性能问题。 每一个应用系统的负载都是一步一步增长上来的，在开始遇到性能瓶颈的时候，大多 数架构师和 DBA 都会选择先进行数据的垂直拆分，由于这样的成本最小。最符合这个时 期所追求的最大投入产出比。然而随着业务的不断扩张，系统负载的持续增长，在系统稳 定一段时期之后，经过了垂直拆分之后的数据库集群可能又再一次不堪重负，遇到了性能 瓶颈。这时候我们就必须要通过数据的水平切分的优势，来解决这里所遇到的问题。并且， 我们全然不必在使用数据水平切分的时候，推倒之前进行数据垂直切分的成果，而是在其 基础上利用水平切分的优势来避开垂直切分的弊端。而水平拆分的弊端(规则难以统一) 也已经被之前的垂直切分解决掉了，让水平拆分能够进行的得心应手 案例分析```text假设在最开始。我们进行了数据的垂直切分，然而随着业务的不断增长，数据库系统遇到了瓶颈，我们选择重构数据库集群的架构。怎样重构?我们选择了在垂直切分的基础 上再进行水平拆分。在经历过垂直拆分后的各个数据库集群中的每一个都仅仅有一个功能 模块。而每一个功能模块中的全部表基本上都会与某个字段进行关联。如用户模块全部都 能够通过用户 ID 进行切分，群组讨论模块则都通过群组 ID 来切分。相册模块则依据相册ID 来进切分。最后的事件通知信息表考虑到数据的时限性(仅仅会访问近期某个事件段的 信息)，则考虑按时间来切分实际上，在非常多大型的应用系统中，垂直切分和水平切这两种数据的切分方法基本 上都是并存的。并且经常在不断的交替进行，以不断的添加系统的扩展能力。我们在应对 不同的应用场景的时候，也须要充分考虑到这两种切分方法各自的局限，以及各自的优势。 在不同的时期(负载压力)使用不同的结合方式。 联合切分的长处◆ 能够充分利用垂直切分和水平切分各自的优势而避免各自的缺陷◆ 让系统扩展性得到最大化提升。联合切分的缺点◆ 数据库系统架构比较复杂。维护难度更大。◆ 应用程序架构也相对更复杂; ### 数据切分及整合方案 ```text 我们已经非常清晰了通过数据库的数据切分能够极大的提高系统的扩展性，可是数据 库中的数据在经过垂直和(或)水平切分被存放在不同的数据库主机之后，应用系统面临 的最大问题就是怎样来让这些数据源得到较好的整合。 数据的整合非常难依靠数据库本身来达到这个效果，尽管 MySQL 存在 Federated 存 储引擎，能够解决部分相似的问题。可是在实际应用场景中却非常难较好的运用。那我们 该怎样来整合这些分散在各个 MySQL 主机上面的数据源呢? 总的来说，存在两种解决思路: 1. 在每一个应用程序模块中配置管理自己须要的一个(或者多个)数据源。直接访问 各个数据库，在模块内完毕数据的整合; 2. 通过中间代理层来统一管理全部的数据源。后端数据库集群对前端应用程序透明; 可能 90%以上的人在面对上面这两种解决思路的时候都会倾向于选择第二种，尤其是 系统不断变得庞大复杂的时候，尽管短期内须要付出的成本可能会相对更大一些，可是对 整个系统的扩展性来说，是非常有帮助的。所以，对于第一种解决思路我这里就不准备过 多的分析，以下我重点分析一下在另外一种解决思路中的一些解决方式. 自行开发中间代理层 通过自行开发中间代理层能够最大程度的应对自身应用的特点，最大化的定制非常多个性化需求，在面对变化的时候也能够灵活的应对。当然，选择自行开发享受让个性化定制最大化的乐趣的同一时候，自然也须要投入很多其它的成本来进行前期研发以及后期的 持续升级改进工作，并且本身的技术门槛可能也比简单的 Web 应用要更高一些。 1.11.4.2. 利用 MySQLProxy 实现数据切分及整合 基于 MySQLProxy 自行编写 LUA 脚本实现数据切分相关代理功能。 利用 Amoeba 实现数据切分及整合 Amoeba 是一个基于 Java 开发的，专注于解决分布式数据库数据源整合 Proxy 程序 的开源框架，基于 GPL3 开源协议。眼下 Amoeba 已经具有 Query 路由、Query 过滤、 读写分离、负载均衡以及 HA 机制等相关内容。 Amoeba 主要解决的以下几个问题: 1. 数据切分后复杂数据源整合; 2. 提供数据切分规则并降低数据切分规则给数据库带来的影响。 3. 降低数据库与 client 的连接数。 4. 读写分离路由; 我们能够看出，Amoeba 所做的事情，正好就是我们通过数据切分来提升数据库的扩 展性所须要的。 Amoeba 并非一个代理层的 Proxy 程序，而是一个开发数据库代理层 Proxy 程序的开 发框架，眼下基于 Amoeba 所开发的 Proxy 程序有 AmoebaForMySQL 和 AmoebaForAladin 两个。 AmoebaForMySQL 主要是专门针对 MySQL 数据库的解决方式，前端应用程序请求 的协议以及后端连接的数据源数据库都必须是 MySQL。对于 client 的不论什么应用程序 来说，AmoebaForMySQL 和一个 MySQL 数据库没有什么差别。不论什么使用 MySQL 协议的 client 请求，都能够被 AmoebaForMySQL 解析并进行对应的处理。 AmoebaForAladin 则是一个适用更为广泛，功能更为强大的 Proxy 程序。 他能够同一时候连接不同数据库的数据源为前端应用程序提供服务，可是仅仅接受符 合 MySQL 协议的 client 应用程序请求。也就是说，仅仅要前端应用程序通过 MySQL 协议 连接上来之后，AmoebaForAladin 会自己主动分析 Query 语句，依据 Query 语句中所请 求的数据来自己主动识别出该所 Query 的数据源是在什么类型数据库的哪一个物理主机 上面. 咋一看，两者好像全然一样。细看之后才会发现两者主要的差别仅在于通过 MySQLProtocalAdapter 处理之后。依据分析结果推断出数据源数据库。然后选择特定的 JDBC 驱动和对应协议连接后端数据库。 事实上通过上面两个架构图大家可能也已经发现了 Amoeba 的特点了，他仅仅仅仅是 一个开发框架。我们除了选择他已经提供的 ForMySQL 和 ForAladin 这两款产品之外。还 能够基于自身的需求进行对应的二次开发。得到更适应我们自己应用特点的 Proxy 程序。 当对于使用 MySQL 数据库来说。不论是 AmoebaForMySQL 还是 AmoebaForAladin 都能够非常好的使用。当然，考虑到不论什么一个系统越是复杂，其性能肯定就会有一定的损失，维护成本自然也会相对更高一些。所以，对于仅仅须要使用 MySQL 数据库的时 候，我还是建议使用 AmoebaForMySQL。 AmoebaForMySQL 的使用非常简单，全部的配置文件都是标准的 XML 文件，总共同 拥有四个配置文件。分别为: ◆amoeba.xml:主配置文件，配置全部数据源以及 Amoeba 自身的參数设置。 ◆rule.xml:配置全部 Query 路由规则的信息。 ◆functionMap.xml:配置用于解析 Query 中的函数所对应的 Java 实现类; ◆ rullFunctionMap.xml:配置路由规则中须要使用到的特定函数的实现类; 假设您的规则不是太复杂，基本上仅须要使用到上面四个配置文件里的前面两个就可 完毕全部工作。Proxy 程序经常使用的功能如读写分离。负载均衡等配置都在 amoeba.xml 中进行。此外。Amoeba 已经支持了实现数据的垂直切分和水平切分的自己主动路由。路 由规则能够在 rule.xml 进行设置。 眼下 Amoeba 少有欠缺的主要就是其在线管理功能以及对事务的支持了，以前在与相 关开发人员的沟通过程中提出过相关的建议，希望能够提供一个能够进行在线维护管理的 命令行管理工具，方便在线维护使用，得到的反馈是管理专门的管理模块已经纳入开发日 程了。另外在事务支持方面临时还是 Amoeba 无法做到的，即使 client 应用在提交给 Amoeba 的请求是包括事务信息的，Amoeba 也会忽略事务相关信息。当然，在经过不断 完好之后，我相信事务支持肯定是 Amoeba 重点考虑添加的 feature。 关于 Amoeba 更为具体的用法读者朋友能够通过 Amoeba 开发人员博客 (http://amoeba.sf.net)上面提供的使用手冊获取，这里就不再细述了 利用 HiveDB 实现数据切分及整合 和前面的 MySQLProxy 以及 Amoeba 一样，HiveDB 相同是一个基于 Java 针对 MySQL 数据库的提供数据切分及整合的开源框架，仅仅是眼下的 HiveDB 仅仅支持数据的水平切 分。 主要解决大数据量下数据库的扩展性及数据的高性能访问问题，同一时候支持数据的 冗余及主要的 HA 机制。 HiveDB 的实现机制与 MySQLProxy 和 Amoeba 有一定的差异，他并非借助 MySQL 的 Replication 功能来实现数据的冗余，而是自行实现了数据冗余机制，而其底层主要是 基于 HibernateShards 来实现的数据切分工作。 在 HiveDB 中，通过用户自己定义的各种 Partitionkeys(事实上就是制定数据切分规 则)，将数据分散到多个 MySQLServer 中。在访问的时候。在执行 Query 请求的时候。 会自己主动分析过滤条件，并行从多个 MySQLServer 中读取数据，并合并结果集返回给 client 应用程序。 单纯从功能方面来讲，HiveDB 可能并不如 MySQLProxy 和 Amoeba 那样强大，可是 其数据切分的思路与前面二者并无本质差异。此外，HiveDB 并不仅仅仅仅是一个开源爱 好者所共享的内容，而是存在商业公司支持的开源项目。 以下是 HiveDB 官方站点上面一章图片，描写叙述了 HiveDB 怎样来组织数据的基本 信息，尽管不能具体的表现出太多架构方面的信息，可是也基本能够展示出其在数据切分 方面独特的一面了。 mycat 数据整合```text参见:http://www.songwie.com/articlelist/11其它实现数据切分及整合的解决方式 除了上面介绍的几个数据切分及整合的总体解决方式之外，还存在非常多其它相同提供了数据切分与整合的解决方式。如基于 MySQLProxy 的基础上做了进一步扩展的 HSCALE，通过 Rails 构建的 SpockProxy。以及基于 Pathon 的 Pyshards 等等。无论大家选择使用哪一种解决方式，总体设计思路基本上都不应该会有什么变化。那 就是通过数据的垂直和水平切分，增强数据库的总体服务能力，让应用系统的总体扩展能 力尽可能的提升，扩展方式尽可能的便捷。 仅仅要我们通过中间层 Proxy 应用程序较好的攻克了数据切分和数据源整合问题。那 么数据库的线性扩展能力将非常容易做到像我们的应用程序一样方便。仅仅须要通过加入 便宜的 PCServerserver，就可以线性添加数据库集群的总体服务能力，让数据库不再轻易 成为应用系统的性能瓶颈。数据切分与整合可能存在的问题 在实施数据切分方案之前，有些可能存在的问题我们还是须要做一些分析的。 一般来说，我们可能遇到的问题主要会有以下几点:◆ 引入分布式事务的问题。◆ 跨节点 Join 的问题;◆ 跨节点合并排序分页问题。 引入分布式事务的问题一旦数据进行切分被分别存放在多个 MySQLServer 中之后，无论我们的切分规则设计的多么的完美(实际上并不存在完美的切分规则)，都可能造成之前的某些事务所涉及 到的数据已经不在同一个 MySQLServer 中了。在这样的场景下，假设我们的应用程序仍然依照老的解决方式，那么势必须要引入分 布式事务来解决。分布式事务本身对于系统资源的消耗就是非常大的，性能本身也并非太 高，并且引入分布式事务本身在异常处理方面就会带来较多比较难控制的因素。首先须要考虑的一件事情就是:是否数据库是唯一一个能够解决事务的地方呢?事实 上并非这样的，我们全然能够结合数据库以及应用程序两者来共同解决。各个数据库解决 自己身上的事务，然后通过应用程序来控制多个数据库上面的事务。将一个跨多个数据库 的分布式事务分拆成多个仅处于单个数据库上面的小事务，并通过应用程序来总控各个小 事务。 当然，这样作的要求就是我们的俄应用程序必须要有足够的健壮性。当然也会给应用 程序带来一些技术难度。跨节点 Join 的问题上面介绍了可能引入分布式事务的问题，如今我们再看看须要跨节点 Join 的问题。数据切分之后可能会造成有些老的 Join 语句无法继续使用。由于 Join 使用的数据源 可能被切分到多个 MySQLServer 中了。怎么办?这个问题从 MySQL 数据库角度来看，假设非得在数据库端来直接解决的话， 恐怕仅仅能通过 MySQL 一种特殊的存储引擎 Federated 来攻克了。Federated 存储引擎 是 MySQL 解决相似于 Oracle 的 DBLink 之类问题的解决方式。和 OracleDBLink 的主要差别在于 Federated 会保存一份远端表结构的定义信息在本 地。咋一看，Federated 确实是解决跨节点 Join 非常好的解决方式。可是我们还应该清晰 一点，那就似乎假设远端的表结构发生了变更，本地的表定义信息是不会跟着发生对应变 化的。假设在更新远端表结构的时候并没有更新本地的 Federated 表定义信息。就非常可 能造成 Query 执行出错，无法得到正确的结果。对待这类问题，我还是推荐通过应用程序来进行处理，先在驱动表所在的 MySQLServer 中取出对应的驱动结果集。然后依据驱动结果集再到被驱动表所在的 MySQLServer 中取出对应的数据。可能非常多读者朋友会觉得这样做对性能会产生一定的 影响，是的，确实是会对性能有一定的负面影响，可是除了此法，基本上没有太多其它更 好的解决的方法了。并且，由于数据库通过较好的扩展之后，每台 MySQLServer 的负载就能够得到较好 的控制。单纯针对单条 Query 来说，其响应时间可能比不切分之前要提高一些，所以性能 方面所带来的负面影响也并非太大。更何况。相似于这样的须要跨节点 Join 的需求也并非太多。相对于总体性能而言，可能也仅仅是非常小一部分而已。所以为了总体性能的考虑， 偶尔牺牲那么一点点。事实上是值得的。毕竟系统优化本身就是存在非常多取舍和平衡的 过程。 跨节点合并排序分页问题一旦进行了数据的水平切分之后，可能就并不仅仅仅仅有跨节点 Join 无法正常执行， 有些排序分页的 Query 语句的数据源可能也会被切分到多个节点。这样造成的直接后果就 是这些排序分页 Query 无法继续正常执行。事实上这和跨节点 Join 是一个道理。数据源 存在于多个节点上，要通过一个 Query 来解决，就和跨节点 Join 是一样的操作。相同 Federated 也能够部分解决。当然存在的风险也一样。还是相同的问题，怎么办?我相同仍然继续建议通过应用程序来解决。怎样解决?解决的思路大体上和跨节点 Join 的解决相似，可是有一点和跨节点 Join 不太一样。Join 非常多时候都有一个驱动与被驱动的关系。所以 Join 本身涉及到的多个表 之间的数据读取一般都会存在一个顺序关系。可是排序分页就不太一样了，排序分页的数 据源基本上能够说是一个表(或者一个结果集)。本身并不存在一个顺序关系，所以在从 多个数据源取数据的过程是全然能够并行的。这样排序分页数据的取数效率我们能够做的比跨库 Join 更高。所以带来的性能损失相 对的要更小，在有些情况下可能比在原来未进行数据切分的数据库中效率更高了。 小结当然，不论是跨节点 Join 还是跨节点排序分页。都会使我们的应用 server 消耗很多 其它的资源，尤其是内存资源，由于我们在读取访问以及合并结果集的这个过程须要比原 来处理很多其它的数据。事实上全然不是这样，首先应用程序由于其特殊性。能够非常容易做到非常好的扩展 性，可是数据库就不一样。必须借助非常多其它的方式才干做到扩展。并且在这个扩展过 程中，非常难避免带来有些原来在集中式数据库中能够解决但被切分开成一个数据库集群 之后就成为一个难题的情况。要想让系统总体得到最大限度的扩展，我们仅仅能让应用程序做很多其它的事情来解 决数据库集群无法较好解决的问题","link":"/2016/12/26/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/mysql%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/"},{"title":"数据库第二篇--索引、视图、过程、触发器、事件","text":"索引 案例 拼音 偏旁部首 简介 在MySQL中，索引（index）也叫做“键（key）”，它是存储引擎用于快速找到记录的一种数据结构。 索引对于良好的性能非常关键，尤其是当表中的数据量越来越大时，索引对性能的影响就愈发重要。 索引优化应该是对查询性能优化最有效的手段。 -- CREATE INDEX indexName ON mytable(username); Create Index index_dept_dname on dept(dname); Drop Index index_dept_dname on dept; 索引的分类 常规索引 常规索引，也叫普通索引（index或key），它可以常规地提高查询效率。一张数据表中可以有多个常规索引。常规索引是使用最普遍的索引类型，如果没有明确指明索引的类型，我们所说的索引都是指常规索引。 主键索引 主键索引（Primary Key），也简称主键。它可以提高查询效率，并提供唯一性约束。一张表中只能有一个主键。被标志为自动增长的字段一定是主键，但主键不一定是自动增长。一般把主键定义在无意义的字段上（如：编号），主键的数据类型最好是数值。 唯一索引 唯一索引（Unique Key），可以提高查询效率，并提供唯一性约束。一张表中可以有多个唯一索引。 外键索引 外键索引（Foreign Key），简称外键，它可以提高查询效率，外键会自动和对应的其他表的主键关联。外键的主要作用是保证记录的一致性和完整性。 索引是数据库中一块独立的空间，专门存储索引值的一刻B-树 我们可以通过B树快速的定位到要查找的数据 尽量不要对重复列添加索引 性别 优点 索引可以让MySQL快速地查找到我们所需要的数据，但这并不是索引的唯一作用。 索引大大减少了MySQL服务器需要扫描的数据量。 索引可以帮助服务器避免排序和临时表。 索引可以将随机I/O变为顺序I/O。 缺点 影响数据库的增删改速度 视图 简介 MySQL 视图（View）是一种虚拟存在的表，同真实表一样，视图也由列和行构成，但视图并不实际存在于数据库中。 行和列的数据来自于定义视图的查询中所使用的表，并且还是在使用视图时动态生成的。 优点 定制用户数据，聚焦特定的数据 简化数据操作 提高数据的安全性 共享所需数据 更改数据格式 重用 SQL 语句 创建 查看 -- CREATE VIEW &lt;视图名&gt; AS &lt;SELECT语句&gt; -- &lt;视图名&gt;：指定视图的名称。该名称在数据库中必须是唯一的，不能与其他表或视图同名。 -- &lt;SELECT语句&gt;：指定创建视图的 SELECT 语句，可用于查询多个基础表或源视图。 CREATE VIEW v_swordsman AS ( SELECT tid, NAME FROM teacher ) UNION ALL ( SELECT sid, NAME FROM student ); SELECT * FROM v_swordsman -- DESCRIBE 视图名； DESCRIBE v_swordsman -- SHOW CREATE VIEW 视图名; SHOW CREATE VIEW v_swordsman -- ALTER VIEW &lt;视图名&gt; AS &lt;SELECT语句&gt; -- &lt;视图名&gt;：指定视图的名称。该名称在数据库中必须是唯一的，不能与其他表或视图同名。 -- &lt;SELECT 语句&gt;：指定创建视图的 SELECT 语句，可用于查询多个基础表或源视图。 --DROP VIEW IF EXISTS &lt;视图名1&gt; [ , &lt;视图名2&gt; …] 存储过程少使用游标。sql 是个集合语言，对于集合运算具有较高性能。而 cursors 是过程运算。比如 对一个 100 万行 的数据进行查询。游标需要读表 100 万次，而不使用游标则只需要少量几次 读取。 当一个大型系统在建立时，会发现，很多的 SQL 操作是有重叠的，个别计算是相同的，比如:业务 系统中，计算一张工单的计算方式。当遇到这些情况时，我们运用存储过程就是一个非常棒的优化啦。 创建调用删除 --删除存储过程 drop procedure if exists p_hello_world; --创建存储过程 create procedure p_hello_world() begin select sysdate(); end; -- 调用存储过程 call p_hello_world(); --删除存储过程 drop procedure if exists p_hello_world; --创建存储过程 create procedure p_hello_world(in v_empno int) begin select * from emp e where e.empno = v_empno; end; -- 调用存储过程 call p_hello_world(7788); 变量定义与赋值 --删除存储过程 drop procedure if exists p_hello_world; --创建存储过程 create procedure p_hello_world() begin declare v_number int; declare v_varchar varchar(32); set v_number = 1; set v_varchar = 'hello world'; select v_number; select v_varchar; end; -- 调用存储过程 call p_hello_world(); 选择语句 --删除存储过程 drop procedure if exists p_hello_world; --创建存储过程 create procedure p_hello_world(in v_id int) begin if (v_id &gt; 0) then select '&gt; 0'; elseif (v_id = 0) then select '= 0'; else select '&lt; 0'; end if; end; -- 调用存储过程 call p_hello_world(-9); 循环语句 drop procedure if exists p_while_do; create procedure p_while_do() begin declare i int; set i = 1; while i &lt;= 10 do select concat('index : ', i); set i = i + 1; end while; end; call p_while_do(); drop procedure if exists p_for_loop; create procedure p_for_loop() begin declare i int; set i = 1; loop_example : loop select concat('index -&gt; ', i); set i = i + 1; if i &gt; 10 then leave loop_example; end if; end loop; end; call p_for_loop(); 静态游标 --删除存储过程 drop procedure if exists p_hello_world; --创建存储过程 create procedure p_hello_world() begin declare empno integer; declare ename varchar(256); declare result varchar(4000) default ''; declare cursor_emp cursor for select e.empno,e.ename from emp e; declare continue handler for SQLSTATE '02000' set empno = null; open cursor_emp; fetch cursor_emp into empno, ename; while (empno is not null ) do set result = concat(result, 'empno:', empno, ',ename:', ename, ';'); fetch cursor_emp into empno, ename; end while; close cursor_emp; select result; end -- 调用存储过程 call p_hello_world(); 触发器简介 触发器与数据表关系密切，主要用于保护表中的数据。 特别是当有多个表具有一定的相互联系的时候，触发器能够让不同的表保持数据的一致性。 在 MySQL 中，只有执行 INSERT、UPDATE 和 DELETE 操作时才能激活触发器 优缺点 优点： 触发器的执行是自动的，当对触发器相关表的数据做出相应的修改后立即执行。 触发器可以实施比 FOREIGN KEY 约束、CHECK 约束更为复杂的检查和操作。 触发器可以实现表数据的级联更改，在一定程度上保证了数据的完整性。 缺点： 使用触发器实现的业务逻辑在出现问题时很难进行定位，特别是涉及到多个触发器的情况下，会使后期维护变得困难。 大量使用触发器容易导致代码结构被打乱，增加了程序的复杂性， 如果需要变动的数据量较大时，触发器的执行效率会非常低。 类型 INSERT 触发器 在 INSERT 语句执行之前或之后响应的触发器。 在 INSERT 触发器代码内，可引用一个名为 NEW（不区分大小写）的虚拟表来访问被插入的行。 在 UPDATE 触发器代码内，可引用一个名为 NEW（不区分大小写）的虚拟表来访问更新的值。 update触发器 在 UPDATE 触发器代码内，可引用一个名为 NEW（不区分大小写）的虚拟表来访问更新的值。 在 UPDATE 触发器代码内，可引用一个名为 OLD（不区分大小写）的虚拟表来访问 UPDATE 语句执行前的值。 在 BEFORE UPDATE 触发器中，NEW 中的值可能也被更新，即允许更改将要用于 UPDATE 语句中的值。 OLD 中的值全部是只读的，不能被更新。 Delete触发器 在 DELETE 触发器代码内，可以引用一个名为 OLD（不区分大小写）的虚拟表来访问被删除的行。 OLD 中的值全部是只读的，不能被更新。 对于事务性表，如果触发程序失败，以及由此导致的整个语句失败，那么该语句所执行的所有更改将回滚； 对于非事务性表，则不能执行此类回滚，即使语句失败，失败之前所做的任何更改依然有效。 使用 语法 CREATE TRIGGER &lt;触发器名&gt; &lt; BEFORE | AFTER &gt; &lt;INSERT | UPDATE | DELETE &gt; ON &lt;表名&gt; FOR EACH Row &lt;触发器主体&gt; 1) 触发器名 触发器的名称，触发器在当前数据库中必须具有唯一的名称。如果要在某个特定数据库中创建，名称前面应该加上数据库的名称。 2) INSERT | UPDATE | DELETE 触发事件，用于指定激活触发器的语句的种类。 注意：三种触发器的执行时间如下。 INSERT：将新行插入表时激活触发器。例如，INSERT的BEFORE触发器不仅能被INSERT 语句激活，也能被LOAD DATA 语句激活。 DELETE： 从表中删除某一行数据时激活触发器，例如 DELETE 和 REPLACE 语句。 UPDATE：更改表中某一行数据时激活触发器，例如 UPDATE 语句。 3) BEFORE | AFTER BEFORE 和 AFTER，触发器被触发的时刻，表示触发器是在激活它的语句之前或之后触发。 若希望验证新数据是否满足条件，则使用 BEFORE 选项； 若希望在激活触发器的语句执行之后完成几个或更多的改变，则通常使用 AFTER 选项。 4) 表名 与触发器相关联的表名，此表必须是永久性表，不能将触发器与临时表或视图关联起来。 在该表上触发事件发生时才会激活触发器。同一个表不能拥有两个具有相同触发时刻和事件的触发器。 5) 触发器主体 触发器动作主体，包含触发器激活时将要执行的 MySQL 语句。如果要执行多个语句，可使用 BEGIN…END 复合语句结构。 6) FOR EACH ROW 一般是指行级触发，对于受触发事件影响的每一行都要激活触发器的动作。 创建 BEFORE 触发器 -- 创建 ,每次将新增的薪资记录到一个局部变量中 CREATE TRIGGER tr_salsum BEFORE INSERT ON emp FOR EACH ROW SET @sum=@sum+NEW.sal; -- 创建完成后 可以在设计表对应的触发器处看到 -- 查看触发器的作用 SET @sum=0; INSERT INTO `emp` VALUES ('9999', 'MILLER', 'CLERK', '7782', '1982-01-23', '1300', null, '10'); select @sum; 创建 AFTER 触发器 -- 首先创建一张相同的表 create table dept_copy as select * from dept; -- 向Dept插入数据的时候，也会向复制表中插入数据 CREATE TRIGGER tr_chinaloc AFTER INSERT ON dept FOR EACH ROW INSERT INTO dept_copy VALUES (NEW.deptno,NEW.dname,concat('china-',NEW.loc)); -- 测试 insert into dept values(88,'shop','shanghai'); 查看 在 MySQL 中，若需要查看数据库中已有的触发器，则可以使用 SHOW TRIGGERS 语句 -- 简单模式 SHOW TRIGGERS; -- 指定触发器 SELECT * FROM information_schema.triggers WHERE trigger_name= 'tr_chinaloc'; 修改删除 修改触发器可以通过删除原触发器，再以相同的名称创建新的触发器。 删除一个表的同时，也会自动删除该表上的触发器。 触发器不能更新或覆盖，为了修改一个触发器，必须先删除它，再重新创建。 -- DROP TRIGGER [ IF EXISTS ] [数据库名] &lt;触发器名&gt; DROP TRIGGER IF EXISTS tr_chinaloc; 事件简介 事件（event）是MySQL在相应的时刻调用的过程式数据库对象。一个事件可调用一次，也可周期性的启动，它由一个特定的线程来管理的，也就是所谓的“事件调度器”。 事件取代了原先只能由操作系统的计划任务来执行的工作 MySQL的事件调度器可以精确到每秒钟执行一个任务， 操作系统的计划任务（如：Linux下的CRON或Windows下的任务计划）只能精确到每分钟执行一次。 开启事件 查看是否开启 -- 是否开启 show variables like '%event_scheduler%'; -- 如果是关闭的（临时开启） set global event_scheduler = on; --如果是关闭的（长久开启） --修改my.ini中[mysqld]数据 C:\\ProgramData\\MySQL\\MySQL Server 8.0 event_scheduler=ON 创建事件 一条create event语句创建一个事件。 每个事件由两个主要部分组成 第一部分是事件调度（eventschedule，表示事件何时启动以及按什么频率启动; 第二部分是事件动作（event action），这是事件启动时执行的代码 一个事件可以是活动（打开）的或停止（关闭）的 活动意味着事件调度器检查事件动作是否必须调用 停止意味着事件的声明存储在目录中，但调度器不会检查它是否应该调用。 语法 CREATE [DEFINER = { user | CURRENT_USER }] EVENT [IF NOT EXISTS] event_name ON SCHEDULE schedule [ON COMPLETION [NOT] PRESERVE] [ENABLE | DISABLE | DISABLE ON SLAVE] [COMMENT 'comment'] DO event_body; schedule: AT timestamp [+ INTERVAL interval] ... | EVERY interval [STARTS timestamp [+ INTERVAL interval] ...] [ENDS timestamp [+ INTERVAL interval] ...] interval: quantity {YEAR | QUARTER | MONTH | DAY | HOUR | MINUTE | WEEK | SECOND | YEAR_MONTH | DAY_HOUR | DAY_MINUTE | DAY_SECOND | HOUR_MINUTE | HOUR_SECOND | MINUTE_SECOND} #DEFINER：定义事件执行的时候检查权限的用户。 #event_name：表示事件名称 #SCHEDULE：表示触发点 AT timestamp一般用于只执行一次。 EVERY interval一般用于周期性执行，可以设定开始时间和结束时间。 #ON COMPLETION PRESERVE：表示任务执行之后仍保留 #ON COMPLETION NOT PRESERVE：表示任务执行完成后不保留 #ENABLE|DISABLE：表示设置启用或者禁止这个事件。 #COMMENT：添加注释 案例 -- 立即启动事件 create event event_now on schedule at now() do insert into events_list values('event_now', now()); -- 5秒钟后自动清空表 CREATE EVENT IF NOT EXISTS event_truncate_dept_copy ON SCHEDULE AT CURRENT_TIMESTAMP + INTERVAL 5 SECOND DO TRUNCATE TABLE dept_copy; -- 每秒钟启动事件 CREATE event event_SECOND ON SCHEDULE EVERY 1 SECOND DO INSERT INTO event_test VALUES(1); -- 每分钟启动事件 create event event_minute on schedule every 1 minute do insert into events_list values('event_now', now()); --5天后开启每天定时3秒向表test2中插入数据，一个月后停止执行 CREATE EVENT IF NOT EXISTS event_truncate_test3 ON SCHEDULE EVERY 3 SECOND STARTS CURRENT_TIMESTAMP + INTERVAL 5 day ENDS CURRENT_TIMESTAMP + INTERVAL 1 month ON COMPLETION PRESERVE DO INSERT INTO test2(department,time_v) VALUES('1',NOW()); -- 每秒钟调用存储过程 CREATE DEFINER=`root`@`localhost` EVENT `eventUpdateStatus` ON SCHEDULE EVERY 1 SECOND STARTS '2017-11-21 00:12:44' ON COMPLETION PRESERVE ENABLE DO call updateStatus() 启用禁用 alter event event_name disable; alter event event_name enable; 删除 drop event [if exists] event_name","link":"/2013/10/27/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%AC%E4%BA%8C%E7%AF%87--%E7%B4%A2%E5%BC%95%E3%80%81%E8%A7%86%E5%9B%BE%E3%80%81%E8%BF%87%E7%A8%8B%E3%80%81%E8%A7%A6%E5%8F%91%E5%99%A8%E3%80%81%E4%BA%8B%E4%BB%B6/"},{"title":"H2数据库","text":"H2数据库H2介绍 h2是个开源的纯Java编写的轻星级数据库,是一个用Java开发的嵌入式数据库,只有一个jar文件,可以直接嵌入到应用项目中。h2最大的用途在于可以同应用程序打包在一起发布,这样可以非常方便地存储少量结构化数据,它的另一个用途是用于单元测试。启动速度快,而且可以关闭持久化功能,每一个用例执行完随即还原到初始状态。h2的第三个用处是作为缓存,作为 NOSQL的一个补充 产品优势 纯Java编写,不受平台的限制; 只有一个jar文件,适合作为嵌入式数据库使用; h2提供了—个十分方便的web控制台用于操作和管理数据库内容; 功能完整,支持标准SQL和DB。麻雀虽小五脏俱全; 支持内嵌模式、服务器模式和集群。 下载安装地址:http://www.h2database.com/html/download.html H2运行模式 内嵌模式 内嵌模式下,应用和数据库同在一个JVM中,通过JDBC进行连接。可持久化,但同时只能一个客户端连接。内嵌模式性能会比较好 服务器模式 使用服务器模式和内嵌模式一样,只不过它可以跑在另一个进程里。 混合模式 第一个应用以内嵌模式启动它,对于后面的应用来说它是服务器模式跑着的","link":"/2016/11/10/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/H2%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"title":"jmeter-第一篇","text":"jmeter介绍Apache Jmeter是Apache组织开发的基于JAVA的压力测试工具。Jmeter可用于对服务器，网络或对象模拟巨大的负载，来自不同压力类别下测试他们的强度和分析整体性能。另外，jmeter能够对应用程序做功能/回归测试，通过创建带有断言的脚本来验证你的程序返回了你期望的结果。为了最大限度的灵活性，jmeter允许使用正则表达式创建断言。 jmeter的特点 能够对HTTP和FTP服务器进行压力和性能测试，也可以对任何数据库进行同样的测试(通过JDBC) 完全的可移植性和100%纯JAVA。 完全多线程框架允许通过多个线程并发取样和 通过单独的线程组对不同的功能同时取样。 各种负载统计表和可链接的计时器可供选择。 数据分析和可视化插件提供了很好的可扩展性以及个性化。 具有提供动态输入到测试的功能。 jmeter下载与安装 前置条件:安装好JDK jmeter下载地址:(http://jmeter.apache.org/download_jmeter.cgi) 一般启动:解压，bin目录里的jmeter.bat即可启动 服务器模式启动:jmeter-server.bat.允许在远程节点上以服务器模式运行jmeter,并通过jmeter gui来控制。 jmeter工作原理 jmeter目录结构 bin目录是可执行文件，jmeter.bat启动，里面可以设置jvm参数 根据经验，heap最多设置为物理内存的一半，默认设置为512M。如果heap超过物理内存的一半，可能运行jmeter会慢，甚至出现内存溢出 jmeter的log在jmeter.log中查看 jmeter.properties文件中有一个属性log_level.JMeter 可以设置改变日志详细度。默认是info,可改为debug","link":"/2017/06/01/%E6%B5%8B%E8%AF%95/jmeter/jmeter-%E7%AC%AC%E4%B8%80%E7%AF%87/"},{"title":"SSO单点登录+shiro--多个子系统认证授权的解决方案","text":"单点登录-SSO (英文全称Single Sign On、单点登录)。 SSO是在多个应用系统中,用户只需要登录一次就可以访问所有相互信任的应用系统。 如京东的购物车系统(https://cart.jd.com/),搜索系统(https://search.jd.com/),商品系统(https://item.jd.com/42443306375.html) 等 它包括可以将这次主要的登录映射到其他应用中用于同一个用户的登录的机制。它是目前比较流行的企业业务整合的解决方案之一。 注意区别三方登录，它们之间不一样:三方登录指的是某系统，使用其他系统的用户，实现本系统登录的方式。如，在京东中使用微信登录。解决信息孤岛和用户不对等的实现方案。","link":"/2017/12/20/framework/security/shiro/SSO%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95+shiro/"},{"title":"spring-security第一篇","text":"SpringSecurity核心功能 认证（你是谁） 授权(你能干什么) 攻击防护(防止伪造身份) 内容简介 SpringSecurity基本原理 实现用户名 + 密码认证 实现手机号 + 短信认证 SpringSecurity基本原理图示： 实现用户名 + 密码认证实现手机号 + 短信认证实战架构分层介绍 RESTful API 使用URL描述资源 使用HTTP方法描述行为，使用HTTP状态码来表示不同结果 使用json交互数据 RESTful API只是一种风格，不是强制的标准","link":"/2016/12/15/framework/security/spring-security/spring-security%E7%AC%AC%E4%B8%80%E7%AF%87/"},{"title":"Apache的commons-dbutils","text":"Apache的DBUtils介绍 Apache的commons-dbutils不是框架,它和Spring的JdbcTemplate很像，也是对Jdbc的简单封装,都只是工具类。 commons-dbutils是Apache组织提供的一个开源的JDBC工具类库，它是对JDBC的简单封装，学习成本极低，并且使用dbutils能极大简化jdbc编码的工作量, 同时也不会影响程序的性能。因此dbutils成为很多不喜欢hibernate的公司的首选。 commons-dbutils工具类的API介绍: org.apache.commons.dbutils.QueryRunner: SQL执行的主要类 org.apache.commons.dbutils.ResultSetHandler: 对结果集封装 org.apache.commons.dbutils.DbUtils: 涉及到数据库连接的获取关闭的工具 DbUtils 提供如关闭连接、装载JDBC驱动程序等常规工作的工具类，里面的所有方法都是静态的。主要方法如下： public static void close(…) throws java.sql.SQLException： DbUtils类提供了三个重载的关闭方法。这些方法检查所提供的参数是不是NULL，如果不是的话，它们就关闭Connection、Statement和ResultSet。 **public static void closeQuietly(…):**这一类方法不仅能在Connection、Statement和ResultSet为NULL情况下避免关闭，还能隐藏一些在程序中抛出的SQLException。 public static void commitAndCloseQuietly(Connection conn)： 用来提交连接，然后关闭连接，并且在关闭连接时不抛出SQL异常。 public static boolean loadDriver(java.lang.String driverClassName)：这一方装载并注册JDBC驱动程序，如果成功就返回true。使用该方法，你不需要捕捉这个异常ClassNotFoundException。 QueryRunner 该类简单化了SQL查询，它与ResultSetHandler组合在一起使用可以完成大部分的数据库操作，能够大大减少编码量。 QueryRunner类提供了两个构造方法：默认的构造方法需要一个 javax.sql.DataSource 来作参数的构造方法 查询操作public Object query(Connection conn, String sql, ResultSetHandler rsh, Object… params)public Object query(String sql, ResultSetHandler rsh, Object… params) 更新操作public int update(Connection conn, String sql, Object… params)public int update(String sql, Object… params) ResultSetHandler 该接口用于处理 java.sql.ResultSet，将数据按要求转换为另一种形式。 ResultSetHandler 接口提供了一个单独的方法：Object handle (java.sql.ResultSet rs)。 ArrayHandler：把结果集中的第一行数据转成对象数组。 ArrayListHandler：把结果集中的每一行数据都转成一个对象数组，再存放到List中。 BeanHandler：将结果集中的第一行数据封装到一个对应的JavaBean实例中。 BeanListHandler：将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里 ColumnListHandler：将结果集中某一列的数据存放到List中。 MapHandler：将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值。 MapListHandler：将结果集中的每一行数据都封装到一个Map里，然后再存放到List **KeyedHandler(name)**：将结果集中的每一行数据都封装到一个Map里(List&lt;Map&gt;)，再把这些map再存到一个map里，其key为指定的key。 commons-dbutils综合使用添加依赖jar&lt;dependency&gt; &lt;groupId&gt;commons-dbutils&lt;/groupId&gt; &lt;artifactId&gt;commons-dbutils&lt;/artifactId&gt; &lt;version&gt;1.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.6&lt;/version&gt; &lt;/dependency&gt; QueryRunner的CUD操作示例：// 事务控制 @Test public void testTransfer() throws SQLException { double money = 100; String outAccount = &quot;aaa&quot;; String inAccount = &quot;bbb&quot;; String sql1 = &quot;update account set money = money - ? where name= ?&quot;; String sql2 = &quot;update account set money = money + ? where name= ?&quot;; // QueryRunner queryRunner = new QueryRunner(JDBCUtils.getDataSource()); // 默认每条sql 一个单独事务 QueryRunner queryRunner = new QueryRunner();// 不要传递连接池 --- 手动事务管理 Connection conn = JdbcUtils.getConnection(); conn.setAutoCommit(false); try { queryRunner.update(conn, sql1, money, outAccount); // int d = 1 / 0; 模拟异常回滚 queryRunner.update(conn, sql2, money, inAccount); System.out.println(&quot;事务提交！&quot;); DbUtils.commitAndCloseQuietly(conn); } catch (Exception e) { System.out.println(&quot;事务回滚！&quot;); DbUtils.rollbackAndCloseQuietly(conn); e.printStackTrace(); } } @Test public void testDelete() throws SQLException { Connection conn = JdbcUtils.getConnection(); QueryRunner queryRunner = new QueryRunner(); String sql = &quot;delete from users where id = ?&quot;; queryRunner.update(conn,sql, 3); } @Test public void testUpdate() throws SQLException { Connection conn = JdbcUtils.getConnection(); QueryRunner queryRunner = new QueryRunner(); String sql = &quot;update users set password = ? where username = ?&quot;; Object[] param = { &quot;nihao&quot;, &quot;小明&quot; }; queryRunner.update(conn,sql, param); } @Test public void testInsert() throws SQLException { Connection conn = JdbcUtils.getConnection(); // 第一步 创建QueryRunner对象 QueryRunner queryRunner = new QueryRunner(); // 第二步 准备方法参数 String sql = &quot;insert into users values(null,?,?,?)&quot;; Object[] param = { &quot;张三&quot;, &quot;qwe&quot;, &quot;zhangsan@qq.com&quot; }; // 第三步 调用 query / update queryRunner.update(conn,sql, param); } QueryRunner的查询操作示例// ScalarHandler 通过保存只有一行一列 结果数据 ---- 分组函数 @Test public void demo9() throws SQLException { QueryRunner queryRunner = new QueryRunner(JdbcUtils.getDataSource()); String sql = &quot;select count(*) from account&quot;; long count = (Long) queryRunner.query(sql, new ScalarHandler(1)); System.out.println(count); } // KeyedHandler 将结果集每一行数据 保存map , 将map保存另一个map ， key 指定列 @Test public void demo8() throws SQLException { QueryRunner queryRunner = new QueryRunner(JdbcUtils.getDataSource()); String sql = &quot;select * from account&quot;; Map&lt;Object, Map&lt;String, Object&gt;&gt; map = (Map&lt;Object, Map&lt;String, Object&gt;&gt;) queryRunner.query(sql, new KeyedHandler(&quot;id&quot;)); System.out.println(map); } // MapListHandler 将结果集每一行数据 保存map中，key列名 value数据 ---- 在讲map对象保存List集合 @Test public void demo7() throws SQLException { QueryRunner queryRunner = new QueryRunner(JdbcUtils.getDataSource()); String sql = &quot;select * from account&quot;; List&lt;Map&lt;String, Object&gt;&gt; list = queryRunner.query(sql, new MapListHandler()); for (Map&lt;String, Object&gt; map : list) { System.out.println(map); } } // MapHander 将结果集第一行数据 封装Map集合，key是列名 value第一行数据 @Test public void demo6() throws SQLException { QueryRunner queryRunner = new QueryRunner(JdbcUtils.getDataSource()); String sql = &quot;select * from account&quot;; Map&lt;String, Object&gt; map = queryRunner.query(sql, new MapHandler()); System.out.println(map); } // ColumnListHandler 作用获得结果集的某一列 @Test public void demo5() throws SQLException { QueryRunner queryRunner = new QueryRunner(JdbcUtils.getDataSource()); String sql = &quot;select * from account&quot;; // 因为每列类型 都不一样 // List&lt;Object&gt; list = queryRunner.query(sql, // new ColumnListHandler(&quot;name&quot;)); List&lt;Object&gt; list = (List&lt;Object&gt;) queryRunner.query(sql, new ColumnListHandler(2)); System.out.println(list); } // BeanListHander 结果集每一条数据 ---JavaBean对象 再保存list集合 @Test public void demo4() throws SQLException { QueryRunner queryRunner = new QueryRunner(JdbcUtils.getDataSource()); String sql = &quot;select * from account&quot;; List&lt;Account&gt; accounts = queryRunner.query(sql, new BeanListHandler&lt;Account&gt;(Account.class)); for (Account account : accounts) { System.out.println(account.getId()); System.out.println(account.getName()); System.out.println(account.getMoney()); System.out.println(&quot;----------------&quot;); } } // BeanHandler 将结果集第一行数据 封装 JavaBean对象中 @Test public void demo3() throws SQLException { QueryRunner queryRunner = new QueryRunner(JdbcUtils.getDataSource()); String sql = &quot;select * from account&quot;; // 传入 Account.class 为了在方法中 通过反射构造Account对象 // 使用BeanHandler 注意事项 ：表列名 与 类中属性名称一致 Account account = queryRunner.query(sql, new BeanHandler&lt;Account&gt;( Account.class)); System.out.println(account.getId()); System.out.println(account.getName()); System.out.println(account.getMoney()); } // ArrayListHandler 结果集每一行数据保存Object[] ----- List @Test public void demo2() throws SQLException { QueryRunner queryRunner = new QueryRunner(JdbcUtils.getDataSource()); String sql = &quot;select * from account&quot;; List&lt;Object[]&gt; list = queryRunner.query(sql, new ArrayListHandler()); for (Object[] objects : list) { System.out.println(Arrays.toString(objects)); } } // ArrayHandler 将结果集 第一行数据 存入Object[] @Test public void demo1() throws SQLException { // 使用DBUtils QueryRunner queryRunner = new QueryRunner(JdbcUtils.getDataSource()); String sql = &quot;select * from account&quot;; // 数组每一个元素，第一行数据每一列 Object[] values = queryRunner.query(sql, new ArrayHandler()); System.out.println(Arrays.toString(values)); } KeyedHandler存储结构","link":"/2013/11/01/framework/%E6%8C%81%E4%B9%85%E5%B1%82%E6%A1%86%E6%9E%B6/DB-Utils/DBUtils/"},{"title":"Apache的DBUtils预热篇--自定义类似的框架","text":"JDBC元数据API（编写JDBC框架基础） 数据库元数据(MetaData)：数据库存储结构定义信息 （库、表、列 定义信息）学习元数据API 获得 数据库、表、列定义信息元数据－DataBaseMetaData对象 **getURL()**：返回一个String类对象，代表数据库的URL。 getUserName()：返回连接当前数据库管理系统的用户名。 getDriverName()：返回驱动驱动程序的名称。 getPrimaryKeys(String catalog, String schema, String table)：返回指定表主键的结果集 @Test public void testDatabaseMetaData() throws Exception{ Connection connection = JdbcUtils.getConnection(); DatabaseMetaData databaseMetaData = connection.getMetaData(); System.out.println(databaseMetaData.getURL()); System.out.println(databaseMetaData.getUserName()); System.out.println(databaseMetaData.getDriverName()); ResultSet resultSet = databaseMetaData.getPrimaryKeys(null,null,&quot;user&quot;); while (resultSet.next()){ System.out.println(resultSet.getString(1)); //数据库 System.out.println(resultSet.getString(2)); System.out.println(resultSet.getString(3)); // 第三列 是表名 System.out.println(resultSet.getString(&quot;TABLE_NAME&quot;)); System.out.println(resultSet.getString(4)); // 获取主键 } } 元数据－ParameterMetaData getParameterCount() :获得指定参数的个数 getParameterType(int param):获得指定参数的sql类型 注意 jdbc.url一定要加上如下属性，否则可能会报错: Parameter metadata not available for the given statement&amp;generateSimpleParameterMetadata=true @Test public void testParameterMetaData() throws SQLException { Connection conn = JdbcUtils.getConnection(); String sql = &quot;select * from users where id = ? and nick_name=?&quot;; PreparedStatement stmt = conn.prepareStatement(sql); // 通过ParameterMetaData 获得 ？ 相关信息 ParameterMetaData parameterMetaData = stmt.getParameterMetaData(); // 获得个数 int count = parameterMetaData.getParameterCount(); System.out.println(count); for (int i = 1; i &lt;= count; i++) { // 该方法并不是所有数据库都支持 --- MySQL不支持（所有返回类型都是varchar） int type = parameterMetaData.getParameterType(i); System.out.println(type); System.out.println(parameterMetaData.getParameterTypeName(i)); } } 元数据－ResultSetMetaData **getColumnCount():**返回resultset对象的列数 getColumnName(int column): 获得指定列的名称 **getColumnTypeName(int column):**获得指定列的类型 @Test public void testResultSetMetaData() throws SQLException { Connection conn = JdbcUtils.getConnection(); String sql = &quot;select * from user&quot;; PreparedStatement stmt = conn.prepareStatement(sql); ResultSet rs = stmt.executeQuery(); // 获得结果集元数据 ResultSetMetaData resultSetMetaData = rs.getMetaData(); int count = resultSetMetaData.getColumnCount(); // 打印table 第一行 for (int i = 1; i &lt;= count; i++) { System.out.print(resultSetMetaData.getColumnName(i) + &quot;\\t&quot;); } System.out.println(); // 打印每列类型 for (int i = 1; i &lt;= count; i++) { System.out.print(resultSetMetaData.getColumnTypeName(i) + &quot;\\t&quot;); } System.out.println(); // 打印table数据 while (rs.next()) { for (int i = 1; i &lt;= count; i++) { System.out.print(rs.getObject(i) + &quot;\\t&quot;); } System.out.println(); } } 自定义JDBC框架业务背景： 系统中所有实体对象都涉及到基本的CRUD操作：所有实体的CUD操作代码基本相同，仅仅发送给数据库的SQL语句不同而已，因此可以把CUD操作的所有相同代码抽取到工具类的一个update方法中，并定义参数接收变化的SQL语句。 实体的R操作，除SQL语句不同之外，根据操作的实体不同，对ResultSet的映射也各不相同，因此可义一个query方法，除以参数形式接收变化的SQL语句外，可以使用策略模式由qurey方法的调用者决定如何把ResultSet中的数据映射到实体对象中。 提炼单例的Connectionimport java.io.IOException; import java.io.InputStream; import java.sql.*; import java.util.*; public final class JdbcUtils { private static String URL; private static String USERNAME; private static String PASSWORD; private static String DRIVER; private JdbcUtils() { } static { try (InputStream is = JdbcUtils.class.getClassLoader().getResourceAsStream(&quot;db.properties&quot;)) {//db.properties放在项目的resources目录下 Properties props = new Properties(); props.load(is); DRIVER = props.getProperty(&quot;jdbc.driver&quot;); URL = props.getProperty(&quot;jdbc.url&quot;); USERNAME = props.getProperty(&quot;jdbc.username&quot;); PASSWORD = props.getProperty(&quot;jdbc.password&quot;); Class.forName(DRIVER); } catch (ClassNotFoundException | IOException e) { throw new ExceptionInInitializerError(e); } } public static Connection getConnection() { try { return DriverManager.getConnection(URL, USERNAME, PASSWORD); } catch (SQLException e) { throw new RuntimeException(&quot;获取数据库连接失败&quot;, e); } } public static void free(ResultSet rs, Statement st, Connection conn) { try { if (rs != null) rs.close(); } catch (SQLException e) { e.printStackTrace(); } finally { try { if (st != null) st.close(); } catch (SQLException e) { e.printStackTrace(); } finally { if (conn != null) try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } } } } 自定义JDBC框架-把CUD抽象成一个update操作 import java.sql.Connection; import java.sql.ParameterMetaData; import java.sql.PreparedStatement; import java.sql.SQLException; /** * 自定义JDBC框架 */ public class JDBCFramework { /** * 封装 insert update delete方法为一个方法update * @param sql 预编译需要SQL * @param args 根据SQL中? 准备参数 */ public static void update(String sql, Object... args) { Connection conn = null; PreparedStatement stmt = null; try { conn = JdbcUtils.getConnection(); stmt = conn.prepareStatement(sql); // 设置参数 --- 根据？设置参数 ParameterMetaData parameterMetaData = stmt.getParameterMetaData(); int count = parameterMetaData.getParameterCount(); for (int i = 1; i &lt;= count; i++) { stmt.setObject(i, args[i - 1]); } stmt.executeUpdate(); } catch (SQLException e) { e.printStackTrace(); } finally { JdbcUtils.free(null,stmt, conn); } } } 自定义JDBC框架-把R抽象成一个query操作 import java.sql.ResultSet; public interface MyResultSetHandler&lt;T&gt; { // 将rs中数据封装对象 public T handle(ResultSet rs); } import java.beans.BeanInfo; import java.beans.Introspector; import java.beans.PropertyDescriptor; import java.lang.reflect.Method; import java.sql.ResultSet; import java.sql.ResultSetMetaData; /** * 通用handler，处理将所有rs第一行数据 转换指定 JavaBean对象 * @param &lt;T&gt; */ public class MyBeanHandler&lt;T&gt; implements MyResultSetHandler&lt;T&gt; { private Class&lt;T&gt; domainClass; public MyBeanHandler(Class&lt;T&gt; domainClass) { this.domainClass = domainClass; } @Override public T handle(ResultSet rs) { try { ResultSetMetaData resultSetMetaData = rs.getMetaData();// 结果集元数据 int count = resultSetMetaData.getColumnCount(); BeanInfo beanInfo = Introspector.getBeanInfo(domainClass); PropertyDescriptor[] descriptors = beanInfo .getPropertyDescriptors(); if (rs.next()) { T t = domainClass.newInstance(); for (int i = 1; i &lt;= count; i++) { String columnName = resultSetMetaData.getColumnName(i); // 获得列名 --- 需要去查找匹配属性 for (PropertyDescriptor propertyDescriptor : descriptors) { if (columnName.equalsIgnoreCase(propertyDescriptor.getName())) { // 列名 存在 同名属性 ---- 列值 存到属性里 Method writeMethod = propertyDescriptor .getWriteMethod(); // setName setMoney writeMethod.invoke(t, rs.getObject(columnName)); } } } return t; } } catch (Exception e) { e.printStackTrace(); } return null; } } import java.sql.*; /** * 自定义JDBC框架 */ public class JDBCFramework { /** * 通用select方法 */ public static &lt;T&gt; T query(String sql, MyResultSetHandler&lt;T&gt; handler, Object... args) { T obj = null; Connection conn = null; PreparedStatement stmt = null; ResultSet rs = null; try { conn = JdbcUtils.getConnection(); stmt = conn.prepareStatement(sql); // 设置参数 ParameterMetaData parameterMetaData = stmt.getParameterMetaData(); int count = parameterMetaData.getParameterCount(); for (int i = 1; i &lt;= count; i++) { stmt.setObject(i, args[i - 1]); } rs = stmt.executeQuery(); obj = handler.handle(rs); } catch (SQLException e) { e.printStackTrace(); } finally { JdbcUtils.free(rs, stmt, conn); } return obj; } } 测试单条记录@Test public void testResultSetMetaData() throws SQLException { System.out.println(JDBCFramework.query(&quot;select * from user where id = 123&quot;,new MyBeanHandler(User.class))); } 测试多条记录@Test public void testResultSetMetaData() throws SQLException { JDBCFramework.query(&quot;select * from user&quot;, new MyResultSetHandler&lt;List&lt;User&gt;&gt;() { @Override public List&lt;User&gt; handle(ResultSet rs) throws SQLException { List&lt;User&gt; list = new ArrayList&lt;User&gt;(); User u; while (rs.next()) { u = new User(); u.setId(rs.getLong(&quot;id&quot;)); u.setNick_Name(rs.getString(&quot;nick_name&quot;)); u.setUSER_ICON(rs.getString(&quot;user_icon&quot;)); list.add(u); } return list; } }).forEach(u-&gt; System.out.println(u)); }","link":"/2013/11/01/framework/%E6%8C%81%E4%B9%85%E5%B1%82%E6%A1%86%E6%9E%B6/DB-Utils/%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84JDBC%E5%B0%81%E8%A3%85%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"title":"mybatis框架-全注解开发","text":"mybatis注解开发mybatis 的常用注解说明@Insert:实现新增 @Update:实现更新 @Delete:实现删除 @Select:实现查询 @Result:实现结果集封装 @Results:可以与@Result 一起使用，封装多个结果集 @ResultMap:实现引用@Results 定义的封装 @One:实现一对一结果集封装 @Many:实现一对多结果集封装 @SelectProvider: 实现动态SQL映射 @CacheNamespace:实现注解二级缓存的使用 使用mybatis注解实现基本CRUD 编写 SqlMapConfig 配置文件&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; &lt;!--加载属性文件--&gt; &lt;properties resource=&quot;db.properties&quot;&gt;&lt;/properties&gt; &lt;typeAliases&gt; &lt;package name=&quot;com.ecit.domain&quot;&gt;&lt;/package&gt; &lt;/typeAliases&gt; &lt;!-- 配置 mybatis 的环境 --&gt; &lt;environments default=&quot;mysql&quot;&gt; &lt;!-- 配置 mysql 的环境 --&gt; &lt;environment id=&quot;mysql&quot;&gt; &lt;!-- 配置事务的类型 --&gt; &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt; &lt;!-- 配置连接数据库的信息:用的是数据源(连接池) --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver}&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 告知 mybatis 映射配置的位置 --&gt; &lt;mappers&gt; &lt;package name=&quot;com.ecit.dao&quot;&gt;&lt;/package&gt; &lt;/mappers&gt; &lt;/configuration&gt; 删除之前接口层的xml文件 编写IUserDao接口注解```javapackage com.ecit.dao;import com.ecit.domain.User;import org.apache.ibatis.annotations.;import java.util.List;/* 用户的持久层接口 /public interface IUserDao { /* 查询所有数据 @return / @Select(“select * from user”) @Results(id = “userMap”, value = { @Result(id = true, column = “id”, property = “id”), @Result(column = “username”, property = “username”), @Result(column = “sex”, property = “sex”), @Result(column = “address”, property = “address”), @Result(column = “birthday”, property = “birthday”) }) List findAll(); /* 根据用户ID获取单条数据 @param userId @return / @Select(“select * from user where id = #{uid} “) @ResultMap(“userMap”) User findById(Integer userId); /* 保存一条数据 @param user @return / @Insert(“insert into user(username,sex,birthday,address)values(#{username},#{sex},#{birthday},#{address} )”) @SelectKey(keyColumn=”id”,keyProperty=”id”,resultType=Integer.class,before = false, statement = { “select last_insert_id()” }) int saveUser(User user); /* 更新一条数据 @param user @return / @Update(“update user set username=#{username},address=#{address},sex=#{sex},birthday=#{birthday} where id =#{id} “) int updateUser(User user); /* 删除一条数据 @param userId @return / @Delete(“delete from user where id = #{uid} “) int deleteUser(Integer userId); /* 查询统计数据 @return / @Select(“select count() from user “) int findTotal(); /** 模糊查询 @param name @return / @Select(“select * from user where username like #{username} “) List findByName(String name); /* 等同上面的模糊查询 */ @Select(“select * from user where username like ‘%${value}%’ “) List findByName(String name);}就完成了注解的CRUD，可以在测试类直接测试 ```java package com.ecit.dao; import com.ecit.domain.User; import org.junit.Test; import java.util.Date; import java.util.List; public class IUserDaoTest extends BaseTest { @Test public void findAll() throws Exception { userDao.findAll().stream().forEach(item-&gt; System.out.println(item)); } @Test public void findAll2() throws Exception { List&lt;User&gt; list1 = userDao.findAll(); System.out.println(list1); session.close(); session = factory.openSession(); userDao = session.getMapper(IUserDao.class); List&lt;User&gt; list5 = userDao.findAll(); System.out.println(list5); } @Test public void findById() throws Exception { User user1 = userDao.findById(48); System.out.println(user1); } @Test public void saveUser() throws Exception{ User user = new User(); user.setUsername(&quot;杨过&quot;); user.setAddress(&quot;古墓派&quot;); user.setBirthday(new Date()); user.setSex(&quot;男&quot;); int res = userDao.saveUser(user); System.out.println(res); } @Test public void updateUser() throws Exception{ User user = new User(); user.setId(48); user.setUsername(&quot;杨过&quot;); user.setAddress(&quot;古墓派&quot;); user.setBirthday(new Date()); user.setSex(&quot;男&quot;); int res = userDao.updateUser(user); System.out.println(res); } @Test public void deleteUser() throws Exception{ int res = userDao.deleteUser(49); System.out.println(res); } @Test public void findTotal() throws Exception{ int res = userDao.findTotal(); System.out.println(res); } @Test public void findByName() throws Exception{ List&lt;User&gt; list = userDao.findByName(&quot;%王%&quot;); System.out.println(list); } } 注解实现批量插入数据 @Insert(&quot;&lt;script&gt;&quot;+ &quot;insert into user(username,sex,birthday,address) values &quot; + &quot;&lt;foreach collection='list' index='index' item='user' separator=','&gt; &quot; + &quot;(#{user.username},#{user.sex},#{user.birthday},#{user.address} ) &lt;/foreach&gt;&quot; + &quot;&lt;/script&gt;&quot;) @SelectKey(keyColumn=&quot;id&quot;,keyProperty=&quot;id&quot;,resultType=Integer.class,before = false, statement = { &quot;select last_insert_id()&quot; }) int batchSaveUser(@Param(&quot;list&quot;) List&lt;User&gt; list); @Test public void batchSaveUser() throws Exception{ List&lt;User&gt; list = new ArrayList&lt;&gt;(); for (int i=101;i&lt;=200;i++) { User user = new User(); user.setUsername(&quot;杨过&quot; + i); user.setAddress(&quot;古墓派&quot; + i); user.setBirthday(new Date()); user.setSex(&quot;男&quot;); list.add(user); } int res = userDao.batchSaveUser(list); //批量插入100条 System.out.println(res); } 使用注解实现复杂关系映射开发-多表查询 实现复杂关系映射之前我们可以在映射文件中通过配置&lt;resultMap&gt;来实现，在使用注解开发时我们需要借 助@Results 注解，@Result 注解，@One 注解，@Many 注解。 复杂关系映射的注解说明@Results 注解代替的是标签&lt;resultMap&gt;,该注解中可以使用单个@Result 注解， 也可以使用@Result 集合@Results({@Result()，@Result()}) 或@Results(@Result()) @Resutl 注解 代替了 &lt;id&gt;标签和&lt;result&gt;标签 @Result 中 属性介绍: id 是否是主键字段 column 数据库的列名 property 需要装配的属性名 one 需要使用的@One 注解(@Result(one=@One)())) many 需要使用的@Many 注解(@Result(many=@many)())) @One 注解(一对一) 代替了&lt;assocation&gt;标签，是多表查询的关键，在注解中用来指定子查询返回单一对象。 @One 注解属性介绍: select 指定用来多表查询的 sqlmapper fetchType 会覆盖全局的配置参数 lazyLoadingEnabled。。 使用格式: @Result(column=&quot; &quot;,property=&quot;&quot;,one=@One(select=&quot;&quot;)) @Many 注解(多对一)代替了&lt;Collection&gt;标签,是是多表查询的关键，在注解中用来指定子查询返回对象集合。 注意:聚集元素用来处理“一对多”的关系。需要指定映射的 Java 实体类的属性，属性的 javaType(一般为 ArrayList)但是注解中可以不定义; 使用格式: @Result(property=&quot;&quot;,column=&quot;&quot;,many=@Many(select=&quot;&quot;)) 使用注解实现一对一复杂关系映射及延迟加载 需求:加载账户信息时并且加载该账户的用户信息，根据情况可实现延迟加载。(注解方式实现) Account 实体类下添加User对象import lombok.Data; import java.io.Serializable; @Data public class Account implements Serializable { private Integer id; private Integer uid; private Double money; //从表实体应该包含一个主表实体的对象引用 private User user; } 添加账户的持久层接口并使用注解配置 /** * 查询所有账户，采用延迟加载的方式查询账户的所属用户 * @return */ @Select(&quot;select * from account&quot;) @Results(id=&quot;accountMap&quot;, value= { @Result(id=true,column=&quot;id&quot;,property=&quot;id&quot;), @Result(column=&quot;uid&quot;,property=&quot;uid&quot;), @Result(column=&quot;money&quot;,property=&quot;money&quot;), @Result(column=&quot;uid&quot;, property=&quot;user&quot;, one=@One(select=&quot;com.ecit.dao.IUserDao.findById&quot;,fetchType= FetchType.LAZY) ) }) List&lt;Account&gt; findAll(); 检查用户的持久层接口用到的查询并使用注解配置```javapackage com.ecit.dao;import com.ecit.domain.User;import org.apache.ibatis.annotations.;import java.util.List;/* 用户的持久层接口 /public interface IUserDao { /* 根据用户ID获取单条数据 @param userId @return */ @Select(“select * from user where id = #{uid} “) @ResultMap(“userMap”) User findById(Integer userId);}``` 测试一对一关联及延迟加载 @Test public void findAll() throws Exception { accountDao.findAll(); } @Test public void findAll2() throws Exception { accountDao.findAll().stream().forEach(item-&gt; System.out.println(item)); //按需加载效果 } 使用注解实现一对多复杂关系映射 需求: 查询用户信息时，也要查询他的账户列表。使用注解方式实现。 分析:一个用户具有多个账户信息，所以形成了用户(User)与账户(Account)之间的一对多关系。 用户实体User添加Account集合import java.io.Serializable; import java.util.Date; import java.util.List; @Data public class User implements Serializable { private Integer id; private String username; private String address; private String sex; private Date birthday; private List&lt;Account&gt; accounts; } 编写用户的持久层接口并使用注解配置public interface IUserDao { /** * 查询所有用户 * @return */ @Select(&quot;select * from user&quot;) @Results(id=&quot;userMap&quot;, value= { @Result(id=true,column=&quot;id&quot;,property=&quot;id&quot;), @Result(column=&quot;username&quot;,property=&quot;username&quot;), @Result(column=&quot;sex&quot;,property=&quot;sex&quot;), @Result(column=&quot;address&quot;,property=&quot;address&quot;), @Result(column=&quot;birthday&quot;,property=&quot;birthday&quot;), @Result(column=&quot;id&quot;,property=&quot;accounts&quot;, many=@Many(select=&quot;com.ecit.dao.IAccountDao.findByUid&quot;, fetchType= FetchType.LAZY)) }) List&lt;User&gt; findAll(); } 检查IAccountDao对应用到的查询public interface IAccountDao { @Select(&quot;select * from account where uid = #{uid} &quot;) List&lt;Account&gt; findByUid(Integer userId); } 添加测试方法 @Test public void findAll0() throws Exception { userDao.findAll(); } @Test public void findAll() throws Exception { userDao.findAll().stream().forEach(item-&gt; System.out.println(item)); } mybatis 基于注解的二级缓存 在SqlMapConfig中开启二级缓存支持 &lt;settings&gt; &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; &lt;/settings&gt; @CacheNamespace(blocking=true)//mybatis 基于注解方式实现配置二级缓存 public interface IUserDao {} ehcache二级缓存 mybatis的特长是SQL操作，缓存数据管理不是其特长，为了提高缓存的性能，myBatis允许使用第三方缓存产品。ehcache就是其中的一种。 在映射文件的mapper中的&lt;cache/&gt;中通过type指定缓存机制为Ehcache缓存。默认为myBatis内置的二级缓存org.apache.ibatis.cache.impl.PerpetualCache. 导入依赖库 &lt;dependency&gt; &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt; &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt; &lt;version&gt;1.2.1&lt;/version&gt; &lt;/dependency&gt; 在classpath下配置ehcache.xml&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:noNamespaceSchemaLocation=&quot;http://ehcache.org/ehcache.xsd&quot;&gt; &lt;diskStore path=&quot;java.io.tmpdir&quot;/&gt; &lt;defaultCache maxElementsInMemory=&quot;10000&quot; eternal=&quot;false&quot; timeToIdleSeconds=&quot;120&quot; timeToLiveSeconds=&quot;120&quot; maxElementsOnDisk=&quot;10000000&quot; diskExpiryThreadIntervalSeconds=&quot;120&quot; memoryStoreEvictionPolicy=&quot;LRU&quot;&gt; &lt;persistence strategy=&quot;localTempSwap&quot;/&gt; &lt;/defaultCache&gt; &lt;/ehcache&gt; SqlMapConfig.xml开启二级缓存开关 &lt;settings&gt; &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; &lt;/settings&gt; dao接口映射文件配置实现类```javapackage com.ecit.dao;import com.ecit.domain.User;import org.apache.ibatis.annotations.CacheNamespace;import org.apache.ibatis.annotations.Options;import org.apache.ibatis.annotations.Select;import org.mybatis.caches.ehcache.EhcacheCache;/** 用户的持久层接口 */@CacheNamespace(implementation = EhcacheCache.class) //配置ehcache实现类public interface IUserDao { @Select(value = “select * from user where id = #{id}” ) @Options(useCache = true) //该语句启用二级缓存 User findUserById(int uid);}``` 测试 @Test public void findUserById() throws Exception { User user1 = userDao.findUserById(48); System.out.println(user1); session.close(); session = factory.openSession(); userDao = session.getMapper(IUserDao.class); User user2 = userDao.findUserById(48); System.out.println(user2); System.out.println(System.getProperty(&quot;java.io.tmpdir&quot;)); } //注意查看 com.ecit.dao.IUserDao - Cache Hit Ratio [com.ecit.dao.IUserDao]: 0.5，说明生效了 ehcache.xml配置参数 **name:**缓存名字 maxElementsInMemory：在内存中最多存放的对象 **eternal:**是否永久存活 **timeToldleSeconds:**设定允许对象处于空闲状态的最长时间，以秒为单位。仅当eternal=false对象不是永久有效时使用，可选属性。当对象自从最近一次被访问后，若处于空闲状态的时间超过了timeToldleSeconds 设定的值，这个对象就会过期。当对象过期，EHCache 就会将它从缓存中清除。设置值为0， 则对象可以无限期地处于空闲状态。 timeToLiveSeconds: 设定对象允许存在于缓存中的最长时间，以秒为单位。当对象自从被存放到缓存后，若处于缓存中的时间超过了timeToliveSeconds设定的值，这个对象就会过期。当对象过期，EHCache 就会将它从缓存中清除。设置值为0，则对象可以无限期地存在于缓存中。注意，只有timeToLiveSeconds大于等于timeToldleSeconds，才有意义。 maxEntriesLocalDisk：当内存中对象数量达到maxElementsInMemory时，Ehcache将会对象写到磁盘中。 **overflowToDisk:**内存不足时，是否启用磁盘缓存。 **diskSpoolBufferSizeMB:**这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。 maxElementsOnDisk: 指定硬盘缓存区可以存放缓存对象的最多个数。 **diskPersistent:**是否在VM重启时存储硬盘的缓存数据。默认值是false。 **diskExpiryThreadIntervalSeconds:**磁盘失效线程运行时间间隔，默认是120秒。 **clearOnFlush:**内存数量最大时是否清除。 statistics：是否收集统计信息。如果需要监控缓存使用情况，应该打开这个选项。默认为关闭（统计会影响性能）。设置 statistics=”true”开启统计。 memoryStoreEvictionPolicy: 如果内存缓存区超过限制，选择移向硬盘缓存区中的对象时使用的策略。支持三种策略: FIFO: First In First Out, 先进先出 LFU: Less Frequently Used,最少使用 LRU: Least Recently Used,最近最少使用 &lt;persistence strategy=”localTempSwap”/&gt;:表示当内存缓存对象达到了上限，会将溢出的对象写到硬盘临时目录缓存中。 ehcache个性化设置可以单独到一个mapper接口中 一个项目中可以有多个mapper, ，不同的mapper有不同的缓存区域。对于不同缓存区域也可进行专门针对于当前区域的个性化设置,可通过指定不同mapper的&lt;cache&gt;属性值来设置。&lt;cache&gt;属性值的优先级高于ehcache.xml中的属性值。```javaimport com.ecit.domain.User;import org.apache.ibatis.annotations.CacheNamespace;import org.apache.ibatis.annotations.Options;import org.apache.ibatis.annotations.Property;import org.apache.ibatis.annotations.Select;import org.mybatis.caches.ehcache.EhcacheCache;/** 用户的持久层接口 */@CacheNamespace(implementation = EhcacheCache.class, properties = { @Property(name = “maxElementsInMemory”, value = “100”), @Property(name = “eternal”, value = “false”), @Property(name = “timeToIdleSeconds”, value = “180”), @Property(name = “timeToLiveSeconds”, value = “180”), @Property(name = “maxElementsOnDisk”, value = “1000”), @Property(name = “diskExpiryThreadIntervalSeconds”, value = “180”), @Property(name = “memoryStoreEvictionPolicy”, value = “LRU”), })public interface IUserDao { @Select(value = “select * from user where id = #{id}”) @Options(useCache = true) User findUserById(int uid);}``` mybatis分页插件pagehelper分页插件实现原理 项目添加依赖 &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.0.3&lt;/version&gt; &lt;/dependency&gt; 需要在SqlMapConfig.xml中配置插件&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; &lt;!-- 配置分页插件 --&gt; &lt;plugins&gt; &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt; &lt;!-- 设置数据库类型 Oracle,Mysql,MariaDB,SQLite,Hsqldb,PostgreSQL六种数据库--&gt; &lt;!--&lt;property name=&quot;dialect&quot; value=&quot;mysql&quot;/&gt; 4.0版本以上不需要配置--&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/configuration&gt; 具体使用在查询的sql语句执行之前，添加一行代码：PageHelper.startPage(1, 10);第一个参数是page，要显示第几页。第二个参数是rows，每页显示的记录数第三步：取查询结果的总数量。创建一个PageInfo类的对象，从对象中取分页信息 测试 @Test public void findAll0() throws Exception { PageHelper.startPage(2,10); List&lt;User&gt; list = userDao.findAll(); System.out.println(&quot;list---&gt;&quot; + list); PageInfo&lt;User&gt; pageInfo = new PageInfo&lt;&gt;(list); System.out.println(&quot;共有总:&quot; + pageInfo.getTotal()); System.out.println(&quot;当前列表数据:&quot; + pageInfo.getList()); System.out.println(&quot;当前页码:&quot; + pageInfo.getPageNum()); System.out.println(&quot;每页条数:&quot; + pageInfo.getPageSize()); System.out.println(&quot;前一页:&quot; + pageInfo.getPrePage()); System.out.println(&quot;后一页:&quot; + pageInfo.getNextPage()); System.out.println(&quot;第一条数据&quot; + list.get(0)); } // 输出结果: // 共有总:108 // 当前列表数据:Page{count=true, pageNum=2, pageSize=10, startRow=10, endRow=20, total=108, pages=11, reasonable=false, pageSizeZero=false} // 当前页码:2 // 每页条数:10 // 前一页:1 // 后一页:3 // 第一条数据User(id=55, username=杨过4, address=古墓派4, sex=男, birthday=Fri Jun 19 03:39:43 CST 2020, accounts=[])","link":"/2013/11/05/framework/%E6%8C%81%E4%B9%85%E5%B1%82%E6%A1%86%E6%9E%B6/mybatis/mybatis%E5%85%A8%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/"},{"title":"分布式ID生成","text":"snowflake算法–分布式ID生成器 由于我们的数据库在生产环境中要分片部署(MyCat),所以我们不能使用数据库本 身的自增功能来产生主键值，只能由程序来生成唯一的主键值。我们采用的是开源的 twitter( 非官方中文惯称:推特.是国外的一个网站，是一个社交网络及微博客服务) 的 snowflake (雪花)算法。 默认情况下41bit的时间戳可以支持该算法使用到2082年，10bit的工作机器id可以 支持1024台机器，序列号支持1毫秒产生4096个自增序列id . SnowFlake的优点是，整 体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞(由数据中心ID和机器ID 作区分)，并且效率较高，经测试，SnowFlake每秒能够产生26万ID左右","link":"/2017/06/01/framework/%E7%BB%83%E4%B9%A0%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%A4%BE%E4%BA%A4%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8FID%E7%94%9F%E6%88%90/"},{"title":"SSM大众点评项目","text":"功能介绍 前后端分离架构 启动reactjs项目如果是windows系统，请将’./package.json’ 里面的的 ‘NODE_ENV=dev’全部修改为 ‘set NODE_ENV=dev’ 运行程序npm install npm run mock(windows环境下在后台进程形式启动 start /b npm run mock) npm start 另外，所有的后端接口地址，都可以在’./mock/server.js’中查看 APP系统架构","link":"/2017/09/01/framework/%E7%BB%83%E4%B9%A0%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95/SSM%E5%A4%A7%E4%BC%97%E7%82%B9%E8%AF%84/SSM%E5%A4%A7%E4%BC%97%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE/"},{"title":"mybatis框架","text":"框架什么是框架 框架(Framework) 是整个或部分系统的可重用设计，表现为一组抽象构件及构件实例间交互的方法;另一种定义认为，框架是可被应用开发者定制的应用骨架。前者是从应用方面而后者是从目的方面给出的定义。简而言之，框架其实就是某种应用的半成品，就是一组组件，供你选用完成你自己的系统。简单说就是使用别人搭好的舞台，你来做表演。而且，框架一般是成熟的，不断升级的软件。框架要解决的问题 框架要解决的最重要的一个问题是技术整合的问题，框架一般处在低层应用平台(如J2EE)和高层业务逻辑之间的中间层。mybatis框架 mybatis框架是一种解决数据的持久化问题的框架，mybatis本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation迁移到了google code,并且改名为mybatis。2013年11月迁移到Github。概述 mybatis是一个优秀的基于java的持久层框架，它内部封装了jdbc,使开发者只需要关注sq|语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。 mybatis通过xml或注解的方式将要执行的各种statement配置起来,并通过java对象和statement中sqI的动态参数进行映射生成最终执行的sq|语句，最后由mybatis框架执行sql并将结果映射为java对象并返回。 采用ORM思想解决了实体和数据库映射的问题，对jdbc进行了封装，屏蔽了jdbc api底层访问细节，使我们不用与jdbc api打交道，就可以完成对数据库的持久化操作。 mybatis架构 总结1、 mybatis的配置文件有2类 a）mybatisconfig.xml，，配置文件的名称不是固定的，配置了全局的参数的配置，全局只能有一个配置文件 b） Mapper.xml配置多个 statemement，也就是多个sql，整个 mybatis框架中可以有多个 Mappe.xml配置文件。2、通过 mybatis配置文件得到 Sqlsessionfactory(有Spring容器跟无Spring容器获取的方法)3、通过 Sqlsessionfactory得到 Sqlsession，，得到 Sqlsession就可以操作数据了。4、 Sqlsession通过底层的 Executor（执行器），执行器有2类实现 a）基本实现 b）带有缓存功能的实现5、 Mappedstatement是通过 Mapper.xml中定义 statement生成的对象6、参数输入，无需手动判断参数类型和参数下标位置 a） Hashmap，KV格式的数据类型 b）Java的基本数据类型 c）POO，java的对象7、结果集输出，自动将查询的结果集映射为java对象（Poo） a） Hashmap，Kv格式的数据类型 b）Java的基本数据类型 c）POJO，java的对象 mybatis快速搭建XML方式的快速搭建 创建简单maven工程，引入依赖 &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;/dependency&gt; 编写domain实体对象和dao接口package com.ecit.domain; import java.io.Serializable; public class User implements Serializable{ private Long id; private String username; private Integer age; public Long getId() { return id; } public void setId(Long id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } } package com.ecit.dao; import com.ecit.domain.User; import java.util.List; public interface IUserDao { /** * 查询所有用户 */ List&lt;User&gt; findAll(); } 编写持久层接口的映射文件IUserDao.xml,在resources资源目录下创建和dao接口一样的目录结构，将xml文件放到下面&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;com.ecit.dao.IUserDao&quot;&gt; &lt;!--查询所有用户--&gt; &lt;select id=&quot;findAll&quot; resultType=&quot;com.ecit.domain.User&quot;&gt; SELECT * from user &lt;/select&gt; &lt;/mapper&gt; 编写SqlMapConfig.xml配置文件&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; &lt;!-- 配置 mybatis 的环境 --&gt; &lt;environments default=&quot;mysql&quot;&gt; &lt;!-- 配置 mysql 的环境 --&gt; &lt;environment id=&quot;mysql&quot;&gt; &lt;!-- 配置事务的类型 --&gt; &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt; &lt;!-- 配置连接数据库的信息:用的是数据源(连接池) --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/testDB?charset=utf8mb4&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8&amp;amp;useSSL=false&amp;amp;serverTimezone=Asia/Shanghai&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 告知 mybatis 映射配置的位置 --&gt; &lt;mappers&gt; &lt;mapper resource=&quot;com/ecit/dao/IUserDao.xml&quot;/&gt; &lt;/mappers&gt; &lt;/configuration&gt; 测试public class DemoTest { public static void main(String[] args) throws Exception{ //1.读取配置文件 InputStream in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); //2.创建 SqlSessionFactory 的构建者对象 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); //3.使用构建者创建工厂对象SqlSessionFactory SqlSessionFactory factory = builder.build(in); //4.使用 SqlSessionFactory 生产 SqlSession 对象 SqlSession session = factory.openSession(); //5.使用 SqlSession 创建 dao 接口的代理对象 IUserDao userDao = session.getMapper(IUserDao.class); //6.使用代理对象执行查询所有方法 List&lt;User&gt; users = userDao.findAll(); for (User user : users) { System.out.println(user); } //7.释放资源 session.close(); in.close(); } } 总结环境搭建的注意事项: 第一:创建IUserDao. xml和IUserDao. java时名称是为了和我们之前的知识保持一致。在Mybatis中它把持久层的操作接口名称和映射文件也叫做: Mapper所以: IUserDao 和IUserMapper是一样的 第二: mybatis的映射配置文件位置必须和dao接口的包结构相同 第三:映射配置文件的mapper标签namespace属性的取值必须是dao接口的全限定类名 第四:映射配置文件的操作配置(select) ，id属 性的取值必须是dao接口的方法名 基于注解方式改写上面的例子 修改 SqlMapConfig.xml &lt;!-- 告知 mybatis 映射配置的位置 --&gt; &lt;mappers&gt; &lt;mapper class=&quot;com.ecit.dao.IUserDao&quot;/&gt; &lt;/mappers&gt; 在持久层接口中添加注解package com.ecit.dao; import com.ecit.domain.User; import org.apache.ibatis.annotations.Select; import java.util.List; public interface IUserDao { /** * 查询所有用户 */ @Select(&quot;select * from user&quot;) List&lt;User&gt; findAll(); } 在使用基于注解的 Mybatis 配置时，移除 xml 的映射配置(IUserDao.xml)。 mybatis的CRUD(基于XML方式)package com.ecit.dao; import com.ecit.domain.User; import java.util.List; public interface IUserDao { /** * 查询所有用户 */ List&lt;User&gt; findAll(); /** * 查询用户总数 */ int findTotal(); /** * 根据UID查找用户 */ User findUserById(Long id); /** * 模糊查询 */ List&lt;User&gt; findUserByName(String name); /** * 删除用户 */ int deleteById(Long id); /** * 增加用户 */ void insert(User user); /** * 修改用户信息 */ int updateByName(User user); } &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;com.ecit.dao.IUserDao&quot;&gt; &lt;!--查询所有用户--&gt; &lt;select id=&quot;findAll&quot; resultType=&quot;com.ecit.domain.User&quot;&gt; SELECT * from user &lt;/select&gt; &lt;!--聚合查询--&gt; &lt;select id=&quot;findTotal&quot; resultType=&quot;int&quot;&gt; SELECT count(*) from user &lt;/select&gt; &lt;!--查询具体的用户信息--&gt; &lt;select id=&quot;findUserById&quot; parameterType=&quot;long&quot; resultType=&quot;com.ecit.domain.User&quot;&gt; SELECT * from user WHERE id = #{uid} &lt;/select&gt; &lt;!--模糊查询--&gt; &lt;select id=&quot;findUserByName&quot; resultType=&quot;com.ecit.domain.User&quot;&gt; SELECT * from user WHERE username like #{name} &lt;/select&gt; &lt;!-- 根据名称模糊查询2 这个相当于SQL拼接，上面的相当于预编译SQL--&gt; &lt;!-- &lt;select id=&quot;findByName&quot; parameterType=&quot;string&quot; resultType=&quot;ccom.ecit.domain.User&quot;&gt; select * from user where username like '%${value}%' &lt;/select&gt; --&gt; &lt;!--新增用户--&gt; &lt;insert id=&quot;insert&quot; parameterType=&quot;com.ecit.domain.User&quot; &gt; &lt;!-- 配置保存时获取插入的 id --&gt; &lt;selectKey keyColumn=&quot;id&quot; keyProperty=&quot;id&quot; order=&quot;AFTER&quot; resultType=&quot;long&quot;&gt; SELECT last_insert_id(); &lt;/selectKey&gt; insert into user(username,age) values(#{username},#{age}) &lt;/insert&gt; &lt;!--删除用户--&gt; &lt;delete id=&quot;deleteById&quot; parameterType=&quot;long&quot;&gt; DELETE FROM user WHERE id = #{uid} &lt;/delete&gt; &lt;!--修改用户信息--&gt; &lt;update id=&quot;updateByName&quot; parameterType=&quot;com.ecit.domain.User&quot;&gt; update user set username=#{username},age=#{age} WHERE id = #{id} &lt;/update&gt; &lt;/mapper&gt; 测试数据: import com.ecit.domain.User; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import org.junit.After; import org.junit.Before; import org.junit.Test; import java.io.InputStream; import java.util.List; public class IUserDaoTest { SqlSession session; InputStream in; IUserDao userDao; @Before public void setUp() throws Exception { //1.读取配置文件 in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); //2.创建 SqlSessionFactory 的构建者对象 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); //3.使用构建者创建工厂对象SqlSessionFactory SqlSessionFactory factory = builder.build(in); //4.使用 SqlSessionFactory 生产 SqlSession 对象 session = factory.openSession(); //5.使用 SqlSession 创建 dao 接口的代理对象 userDao = session.getMapper(IUserDao.class); } @After public void tearDown() throws Exception { session.commit(); //7.释放资源 session.close(); in.close(); } @Test public void findAll() throws Exception { List&lt;User&gt; list = userDao.findAll(); System.out.println(&quot;全部用户信息:&quot; +list.toString()); } @Test public void findTotal() throws Exception { int total = userDao.findTotal(); System.out.println(&quot;目前有&quot; + total +&quot;条用户数据&quot;); } @Test public void findUserById() throws Exception { User user = userDao.findUserById(2L); System.out.println(&quot;id是2的用户:&quot; + user); } //通过SqlSession操作数据库 //第一个参数:映射文件中statement的id,等于=namespace+&quot;. &quot;+statement的id //第二个参数:指定和映射文件中所匹配的parameterType类型的参数 //sqlSession. selectOne结果是与映射文件中所匹的resultType类型的对象 @Test public void findUserById2() throws Exception { User user = session.selectOne(&quot;com.ecit.dao.IUserDao.findUserById&quot;,2L); System.out.println(&quot;id2是2的用户:&quot; + user); } @Test public void deleteById() throws Exception { int res = userDao.deleteById(8L); System.out.println(&quot;删除结果:&quot; + res); } // 通过SqlSession操作数据库，删除数据 @Test public void deleteById2() throws Exception { int res = session.delete(&quot;com.ecit.dao.IUserDao.deleteById&quot;,10L); System.out.println(&quot;删除结果:&quot; + res); } @Test public void insert() throws Exception { User user = new User(&quot;王其&quot;, 22); userDao.insert(user); System.out.println(&quot;新增的用户的id:&quot; + user.getId()); } @Test public void findUserByName() throws Exception { List&lt;User&gt; list = userDao.findUserByName(&quot;%王%&quot;); System.out.println(&quot;姓王的用户:&quot; + list); } @Test public void updateByName() throws Exception { User user = new User(&quot;李琦&quot;, 22); user.setId(2L); int res = userDao.updateByName(user); System.out.println(&quot;更新结果:&quot; + res); } } 注意上面模糊查询#{}与${}的区别#{}表示一个占位符号 通过#{}可以实现 preparedStatement 向占位符中设置值，自动进行 java 类型和 jdbc 类型转换， #{}可以有效防止 sql 注入。 #{}可以接收简单类型值或 pojo 属性值。 如果 parameterType 传输单个简单类 型值，#{}括号中可以是 value 或其它名称。 ${}表示拼接 sql 串 通过${}可以将parameterType 传入的内容拼接在sql中且不进行jdbc类型转换， ${}可以接收简 单类型值或 pojo 属性值，如果 parameterType 传输单个简单类型值，${}括号中只能是 value。 TextSqlNode类源码可以看出，指定了读取的 key 的名字就是”value”，所以我们在绑定参数时就只能叫 value 的名字 了。 补充非自增主键UUID获取 使用mysql的uuid()函数生成主键，需要修改表中id字段类型为string，长度设置成36位。order=BEFORE 执行思路： 先通过uuid()查询到主键，将主键输入 到sql语句中。 执行uuid()语句顺序相对于insert语句之前执行。 &lt;!--新增用户--&gt; &lt;insert id=&quot;insert&quot; parameterType=&quot;com.ecit.domain.User&quot; &gt; &lt;!-- 配置保存时获取插入的 id --&gt; &lt;selectKey keyColumn=&quot;id&quot; keyProperty=&quot;id&quot; order=&quot;BEFORE&quot; resultType=&quot;java.lang.String&quot;&gt; SELECT uuid(); &lt;/selectKey&gt; insert into user(id,username,age) values(#{id},#{username},#{age}) &lt;/insert&gt; 通过oracle的序列生成主键:&lt;insert id=&quot;insert&quot; parameterType=&quot;com.ecit.domain.User&quot; &gt; &lt;selectKey keyProperty=&quot;id&quot; order=&quot;BEFORE&quot; resultType=&quot;java.lang.String&quot;&gt;← SELECT 序列名.nextval( ) &lt;/selectKey&gt; insert into user(id,username,age) values(#{id},#{username},#{age}) &lt;/insert&gt; mybatis中SqlMapConfig.xml参数详解mybatis的全局配置文件SqlMapConfig.xml，配置内容如下： -properties (属性) -- property -settings (全局配置参数) -- setting -typeAliases (类型别名) -- typeAliase -- package -typeHandlers (类型处理器) -objectFactory (对象工厂) -plugins (插件) -environments (环境集合属性对象) --environment (环境子属性对象) ---trans actionManager (事务管理) ---dataSource ( 数据源) -mappers (映射器) -- mapper -- package properties属性 需求： 将数据库连接参数单独配置在db.properties中，只需要在SqlMapConfig.xml中加载db.properties的属性值。 在SqlMapConfig.xml中就不需要对数据库连接参数硬编码。 将数据库连接参数只配置在db.properties中，原因：方便对参数进行统一管理，其它xml可以引用该db.properties。 properties特性： 注意： MyBatis 将按照下面的顺序来加载属性： 在 properties 元素体内定义的属性首先被读取。 然后会读取properties 元素中resource或 url 加载的属性，它会覆盖已读取的同名属性。 最后读取parameterType传递的属性，它会覆盖已读取的同名属性在使用properties可以采用两种方式指定属性配置 第一种&lt;properties&gt; &lt;property name=&quot;jdbc.driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;jdbc.url&quot; value=&quot;jdbc:mysql://localhost:3306/testDB&quot;/&gt; &lt;property name=&quot;jdbc.username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;jdbc.password&quot; value=&quot;root&quot;/&gt; &lt;/properties&gt; 第二种在 classpath 下定义 db.properties 文件jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/testDB jdbc.username=root jdbc.password=root 再在SqlMapConfig.xml引入&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; &lt;!--加载属性文件--&gt; &lt;properties resource=&quot;db.properties&quot;&gt;&lt;/properties&gt; &lt;!-- 配置 mybatis 的环境 --&gt; &lt;environments default=&quot;mysql&quot;&gt; &lt;!-- 配置 mysql 的环境 --&gt; &lt;environment id=&quot;mysql&quot;&gt; &lt;!-- 配置事务的类型 --&gt; &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt; &lt;!-- 配置连接数据库的信息:用的是数据源(连接池) --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver}&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 告知 mybatis 映射配置的位置 --&gt; &lt;mappers&gt; &lt;mapper resource=&quot;com/ecit/dao/IUserDao.xml&quot;/&gt; &lt;/mappers&gt; &lt;/configuration&gt; properties的url属性使用&lt;!-- 配置连接数据库的信息 resource 属性:用于指定 properties 配置文件的位置，要求配置文件必须在类路径下 resource=&quot;jdbcConfig.properties&quot; url 属性: URL: Uniform Resource Locator 统一资源定位符 http://localhost:8080/mystroe/CategoryServlet URL 协议 主机 端口 URI URI:Uniform Resource Identifier 统一资源标识符 /mystroe/CategoryServlet 它是可以在 web 应用中唯一定位一个资源的路径 --&gt; &lt;properties url=&quot;file:///D:/Projects/mybatisCRUD/src/main/resources/db.properties&quot;&gt;&lt;/properties&gt; settings全局参数配置 mybatis框架在运行时可以调整一些运行参数。比如：开启二级缓存、开启延迟加载。 typeAliases（别名） 在mapper.xml中，定义很多的statement，statement需要parameterType指定输入参数的类型、需要resultType指定输出结果的映射类型。如果在指定类型时输入类型全路径，不方便进行开发，可以针对parameterType或resultType指定的类型定义一些别名，在mapper.xml中通过别名定义，方便开发。 自定义别名&lt;!-- 单个别名定义 --&gt; &lt;typeAlias alias=&quot;user&quot; type=&quot;com.ecit.domain.User&quot;/&gt; &lt;!-- 批量别名定义，扫描整个包下的类，别名为类名(首字母大写或小写都可以) --&gt; &lt;package name=&quot;com.ecit.domain&quot;/&gt; &lt;package name=&quot;其它包&quot;/&gt; &lt;/typeAliases&gt; mappers(映射器) 第一种：通过resource加载单个映射文件&lt;mapper resource=&quot;&quot;/&gt; 如： &lt;mapper resource=&quot;com/ecit/dao/IUserDao.xml&quot;/&gt; 第二种 通过mapper接口加载单个mapper&lt;mapper class=&quot;&quot;/&gt; 如： &lt;mapper class=&quot;com.ecit.dao.IUserDao&quot;/&gt; 第三种 批量加载mapper(推荐使用)注册指定包下的所有 mapper 接口 如:&lt;package name=&quot;com.ecit.dao&quot;/&gt; 注意:此种方法要求 mapper 接口名称和 mapper 映射文件名称相同，且放在同一个目录中。 mapper-xml parameterType指定输入参数类型 通过parameterType指定输入参数的类型，类型可以是简单类型、hashmap、pojo的包装类型 基本数据类型：#{参数} 获取参数中的值 复杂数据类型：#{属性名} ,map中则是#{key}resultType指定输出结果的类型 使用resultType进行输出映射，只有查询出来的列名和pojo中的属性名一致，该列才可以映射成功。 如果查询出来的列名和pojo中的属性名全部不一致，没有创建pojo对象。 只要查询出来的列名和pojo中的属性有一个一致，就会创建pojo对象。resultMap完成高级输出结果映射 如果查询出来的列名和pojo的属性名不一致，通过定义一个resultMap对列名和pojo属性名之间作一个映射关系。 定义resultMap 使用resultMap作为statement的输出映射类型使用resultType进行输出映射，只有查询出来的列名和pojo中的属性名一致，该列才可以映射成功。如果查询出来的列名和pojo的属性名不一致，通过定义一个resultMap对列名和pojo属性名之间作一个映射关系。 mybatis高级特性SQL片段 动态SQLmybatis核心 对sql语句进行灵活操作，通过表达式进行判断，对sql进行灵活拼接、组装。 动态ifList&lt;User&gt; findByUser(User user); &lt;select id=&quot;findByUser&quot; resultType=&quot;user&quot; parameterType=&quot;user&quot;&gt; select * from user where 1=1 &lt;if test=&quot;username!=null and username != '' &quot;&gt; and username like #{username} &lt;/if&gt; &lt;if test=&quot;address != null&quot;&gt; and address like #{address} &lt;/if&gt; &lt;/select&gt; 注意:&lt;if&gt;标签的 test 属性中写的是对象的属性名，如果是包装类的对象要使用 OGNL 表达式的写法。 另外要注意 where 1=1 的作用~! where标签为了简化上面where 1=1的条件拼装，我们可以采用标签来简化开发。 &lt;select id=&quot;findByUser&quot; resultType=&quot;user&quot; parameterType=&quot;user&quot;&gt; select * from user &lt;where&gt; &lt;if test=&quot;username!=null and username != '' &quot;&gt; and username like #{username} &lt;/if&gt; &lt;if test=&quot;address != null&quot;&gt; and address like #{address} &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; choose when otherwise 相当于JAVA的switch foreach in查询或者批量删除传入多个 id 查询用户信息，用下边两个 sql 实现: SELECT * FROM USER WHERE username LIKE '%张%' AND (id =10 OR id =9 OR id=12) SELECT * FROM USER WHERE username LIKE '%张%' AND id IN (10,9,12) 这样我们在进行范围查询时，就要将一个集合中的值，作为参数动态添加进来。 这样我们将如何进行参数的传递?在 QueryVo 中加入一个 List 集合用于封装参数 public class QueryVo implements Serializable { private List&lt;Integer&gt; ids; public List&lt;Integer&gt; getIds() { return ids; } public void setIds(List&lt;Integer&gt; ids) { this.ids = ids; } } &lt;!-- 查询所有用户在 id 的集合之中 --&gt; &lt;select id=&quot;findInIds&quot; resultType=&quot;user&quot; parameterType=&quot;queryvo&quot;&gt; &lt;!-- select * from user where id in (1,2,3,4,5); --&gt; &lt;include refid=&quot;defaultSql&quot;&gt;&lt;/include&gt; &lt;where&gt; &lt;if test=&quot;ids != null and ids.size() &gt; 0&quot;&gt; &lt;foreach collection=&quot;ids&quot; open=&quot;id in ( &quot; close=&quot;)&quot; item=&quot;uid&quot; separator=&quot;,&quot;&gt; #{uid} &lt;/foreach&gt; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; mybatis多表查询表之间的关系 一对多 用户和订单 一个用户可以下多个订单，多个订单属于同一个用户 一对一 人和身份证 一个人只能有一个身份证号,一个身份证号只能属于一个人 多对多 老师和学生 一个学生可以被多个老师教过,一个老师可以交多个学生 mybatis一对多案例用户和账户 一个用户可以有多个账户，一个账户只能属于一个用户(多个账户也可以属于同一个用户) 步骤: 建立两张表:用户表,账户表 ，让用户表和账户表之间具备一对多的关系:需要使用外键在账户表中添加 建立两个实体类:用户实体类和账户实体类，让用户和账户的实体类能体现出一对多的关系 建立两个配置文件:用户的配置文件、账户的配置文件 实现配置:当我们查询用户时,可以同时得到用户下所包含的账户信息;当我们查询账户时,可以同时得到账户的所属用户信息 SQL准备： CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `username` varchar(32) NOT NULL COMMENT '用户名称', `birthday` datetime DEFAULT NULL COMMENT '生日', `sex` char(1) DEFAULT NULL COMMENT '性别', `address` varchar(256) DEFAULT NULL COMMENT '地址', PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=49 DEFAULT CHARSET=utf8; CREATE TABLE `account` ( `id` int(11) NOT NULL COMMENT '编号', `uid` int(11) DEFAULT NULL COMMENT '用户编号', `money` double DEFAULT NULL COMMENT '金额', PRIMARY KEY (`id`), KEY `FK_Reference_8` (`uid`), CONSTRAINT `FK_Reference_8` FOREIGN KEY (`uid`) REFERENCES `user` (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; user表数据 account表数据 mybatis环境搭建,sqlMapConfig.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; &lt;!--加载属性文件--&gt; &lt;properties resource=&quot;db.properties&quot;&gt;&lt;/properties&gt; &lt;typeAliases&gt; &lt;package name=&quot;com.ecit.domain&quot;&gt;&lt;/package&gt; &lt;/typeAliases&gt; &lt;!-- 配置 mybatis 的环境 --&gt; &lt;environments default=&quot;mysql&quot;&gt; &lt;!-- 配置 mysql 的环境 --&gt; &lt;environment id=&quot;mysql&quot;&gt; &lt;!-- 配置事务的类型 --&gt; &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt; &lt;!-- 配置连接数据库的信息:用的是数据源(连接池) --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver}&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 告知 mybatis 映射配置的位置 --&gt; &lt;mappers&gt; &lt;package name=&quot;com.ecit.dao&quot;&gt;&lt;/package&gt; &lt;/mappers&gt; &lt;/configuration&gt; user,account实体对象 package com.ecit.domain; import lombok.Data; import java.io.Serializable; import java.util.Date; import java.util.List; @Data public class User implements Serializable { private Integer id; private String username; private String address; private String sex; private Date birthday; //一对多关系映射：主表实体应该包含从表实体的集合引用 private List&lt;Account&gt; accounts; } import lombok.Data; import java.io.Serializable; @Data public class Account implements Serializable { private Integer id; private Integer uid; private Double money; //从表实体应该包含一个主表实体的对象引用 private User user; } user表接口层 import com.ecit.domain.User; import java.util.List; /** * 用户的持久层接口 */ public interface IUserDao { /** * 查询所有用户，同时获取到用户下所有账户的信息 * @return */ List&lt;User&gt; findAll(); /** * 根据id查询用户信息 * @param userId * @return */ User findById(Integer userId); } IUserDAO示例一个用户有多个账户&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;com.ecit.dao.IUserDao&quot;&gt; &lt;!-- 定义User的resultMap--&gt; &lt;resultMap id=&quot;userAccountMap&quot; type=&quot;user&quot;&gt; &lt;!-- 等同,前者配置了别名,可简写 &lt;resultMap id=&quot;userAccountMap&quot; type=&quot;com.ecit.domain.User&quot;&gt;--&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;&gt;&lt;/id&gt; &lt;result property=&quot;username&quot; column=&quot;username&quot;&gt;&lt;/result&gt; &lt;result property=&quot;address&quot; column=&quot;address&quot;&gt;&lt;/result&gt; &lt;result property=&quot;sex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt; &lt;result property=&quot;birthday&quot; column=&quot;birthday&quot;&gt;&lt;/result&gt; &lt;!-- 配置user对象中accounts集合的映射 --&gt; &lt;collection property=&quot;accounts&quot; ofType=&quot;account&quot;&gt; &lt;!-- 等同,用了别名可简写account &lt;collection property=&quot;accounts&quot; ofType=&quot;com.ecit.domain.Account&quot;&gt;--&gt; &lt;id column=&quot;aid&quot; property=&quot;id&quot;&gt;&lt;/id&gt; &lt;result column=&quot;uid&quot; property=&quot;uid&quot;&gt;&lt;/result&gt; &lt;result column=&quot;money&quot; property=&quot;money&quot;&gt;&lt;/result&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;!-- 查询所有，一对多的示例 --&gt; &lt;select id=&quot;findAll&quot; resultMap=&quot;userAccountMap&quot;&gt; select u.*,a.id as aid,a.uid,a.money from user u left outer join account a on u.id = a.uid &lt;/select&gt; &lt;!-- 根据id查询用户 --&gt; &lt;select id=&quot;findById&quot; parameterType=&quot;INT&quot; resultType=&quot;user&quot;&gt; select * from user where id = #{uid} &lt;/select&gt; &lt;/mapper&gt; 测试结果: package com.ecit.dao; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import org.junit.After; import org.junit.Before; import java.io.InputStream; public class BaseTest { SqlSession session; InputStream in; IUserDao userDao; IAccountDao accountDao; @Before public void setUp() throws Exception { //1.读取配置文件 in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); //2.创建 SqlSessionFactory 的构建者对象 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); //3.使用构建者创建工厂对象SqlSessionFactory SqlSessionFactory factory = builder.build(in); //4.使用 SqlSessionFactory 生产 SqlSession 对象 session = factory.openSession(); //5.使用 SqlSession 创建 dao 接口的代理对象 userDao = session.getMapper(IUserDao.class); accountDao = session.getMapper(IAccountDao.class); } @After public void tearDown() throws Exception { session.commit(); //7.释放资源 session.close(); in.close(); } } import org.junit.Test; public class IUserDaoTest extends BaseTest{ @Test public void findAll() throws Exception { userDao.findAll().stream().forEach(item-&gt; System.out.println(item)); } } 输出结果: // User(id=46, username=小张, address=重庆, sex=男, birthday=Tue Mar 07 17:37:26 CST 2000, accounts=[Account(id=1, uid=46, money=1000.0, user=null), Account(id=3, uid=46, money=2000.0, user=null)]) // User(id=45, username=老张, address=绍兴, sex=男, birthday=Sun Mar 04 12:04:06 CST 1923, accounts=[Account(id=2, uid=45, money=1000.0, user=null)]) // User(id=41, username=老王, address=北京, sex=男, birthday=Sat Feb 27 17:47:08 CST 1965, accounts=[]) // User(id=42, username=小王, address=上海, sex=女, birthday=Wed Mar 02 15:09:37 CST 1955, accounts=[]) // User(id=43, username=小二王, address=杭州, sex=女, birthday=Thu Mar 04 11:34:34 CST 2010, accounts=[]) // User(id=48, username=小马, address=天津, sex=女, birthday=Sat Mar 08 11:44:00 CST 2008, accounts=[]) IAccountDao示例一对一&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;com.ecit.dao.IAccountDao&quot;&gt; &lt;!-- 定义封装account和user的resultMap --&gt; &lt;resultMap id=&quot;accountUserMap&quot; type=&quot;account&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;aid&quot;&gt;&lt;/id&gt; &lt;result property=&quot;uid&quot; column=&quot;uid&quot;&gt;&lt;/result&gt; &lt;result property=&quot;money&quot; column=&quot;money&quot;&gt;&lt;/result&gt; &lt;!-- 一对一的关系映射：配置封装user的内容--&gt; &lt;association property=&quot;user&quot; column=&quot;uid&quot; javaType=&quot;user&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;&gt;&lt;/id&gt; &lt;result column=&quot;username&quot; property=&quot;username&quot;&gt;&lt;/result&gt; &lt;result column=&quot;address&quot; property=&quot;address&quot;&gt;&lt;/result&gt; &lt;result column=&quot;sex&quot; property=&quot;sex&quot;&gt;&lt;/result&gt; &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;&gt;&lt;/result&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;!-- 查询所有 --&gt; &lt;select id=&quot;findAll&quot; resultMap=&quot;accountUserMap&quot;&gt; select u.*,a.id as aid,a.uid,a.money from account a , user u where u.id = a.uid; &lt;/select&gt; &lt;!--查询所有账户同时包含用户名和地址信息--&gt; &lt;select id=&quot;findAllAccount&quot; resultType=&quot;accountuser&quot;&gt; select a.*,u.username,u.address from account a , user u where u.id = a.uid; &lt;/select&gt; &lt;/mapper&gt; 测试结果： package com.ecit.dao; import org.junit.Test; public class IUserDaoTest extends BaseTest{ @Test public void findAll() throws Exception { userDao.findAll().stream().forEach(item-&gt; System.out.println(item)); } } 输出结果： Account(id=1, uid=46, money=1000.0, user=User(id=46, username=小张, address=重庆, sex=男, birthday=Tue Mar 07 17:37:26 CST 2000, accounts=null)) Account(id=2, uid=45, money=1000.0, user=User(id=45, username=老张, address=绍兴, sex=男, birthday=Sun Mar 04 12:04:06 CST 1923, accounts=null)) Account(id=3, uid=46, money=2000.0, user=User(id=46, username=小张, address=重庆, sex=男, birthday=Tue Mar 07 17:37:26 CST 2000, accounts=null)) mybatis多对多查询案例 用户和角色，一个用户可以有多个角色，一个角色可以赋予多个用户 步骤: 1、建立两张表:用户表，角色表，让用户表和角色表具有多对多的关系。需要使用中间表，中间表中包含各自的主键在中间表中是外键。 2、建立两个实体类:用户实体类和角色实体类，让用户和角色的实体类能体现出来多对多的关系，各自包含对方一个集合引用 3、建立两个配置文件，用户的配置文件，角色的配置文件 4、实现配置:当我们查询用户时，可以同时得到用户所包含的角色信息，当我们查询角色时，可以同时得到角色的所赋予的用户信息 sql准备 CREATE TABLE `role` ( `ID` int(11) NOT NULL COMMENT '编号', `ROLE_NAME` varchar(30) DEFAULT NULL COMMENT '角色名称', `ROLE_DESC` varchar(60) DEFAULT NULL COMMENT '角色描述', PRIMARY KEY (`ID`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE `user_role` ( `UID` int(11) NOT NULL COMMENT '用户编号', `RID` int(11) NOT NULL COMMENT '角色编号', PRIMARY KEY (`UID`,`RID`), KEY `FK_Reference_10` (`RID`), CONSTRAINT `FK_Reference_10` FOREIGN KEY (`RID`) REFERENCES `role` (`ID`), CONSTRAINT `FK_Reference_9` FOREIGN KEY (`UID`) REFERENCES `user` (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; user表数据 user_role表数据 role表数据 实体类关系 import lombok.Data; import java.io.Serializable; import java.util.Date; import java.util.List; @Data public class User implements Serializable { private Integer id; private String username; private String address; private String sex; private Date birthday; //多对多的关系映射：一个用户可以具备多个角色 private List&lt;Role&gt; roles; } import lombok.Data; import java.io.Serializable; import java.util.List; @Data public class Role implements Serializable { private Integer roleId; private String roleName; private String roleDesc; //多对多的关系映射：一个角色可以赋予多个用户 private List&lt;User&gt; users; } 接口层配置,IUserDao.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;com.ecit.dao.IUserDao&quot;&gt; &lt;!-- 定义User的resultMap--&gt; &lt;resultMap id=&quot;userMap&quot; type=&quot;user&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;&gt;&lt;/id&gt; &lt;result property=&quot;username&quot; column=&quot;username&quot;&gt;&lt;/result&gt; &lt;result property=&quot;address&quot; column=&quot;address&quot;&gt;&lt;/result&gt; &lt;result property=&quot;sex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt; &lt;result property=&quot;birthday&quot; column=&quot;birthday&quot;&gt;&lt;/result&gt; &lt;!-- 配置角色集合的映射 --&gt; &lt;collection property=&quot;roles&quot; ofType=&quot;role&quot;&gt; &lt;id property=&quot;roleId&quot; column=&quot;rid&quot;&gt;&lt;/id&gt; &lt;result property=&quot;roleName&quot; column=&quot;role_name&quot;&gt;&lt;/result&gt; &lt;result property=&quot;roleDesc&quot; column=&quot;role_desc&quot;&gt;&lt;/result&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;!-- 查询所有 --&gt; &lt;select id=&quot;findAll&quot; resultMap=&quot;userMap&quot;&gt; select u.*,r.id as rid,r.role_name,r.role_desc from user u left outer join user_role ur on u.id = ur.uid left outer join role r on r.id = ur.rid &lt;/select&gt; &lt;!-- 根据id查询用户 --&gt; &lt;select id=&quot;findById&quot; parameterType=&quot;INT&quot; resultType=&quot;user&quot;&gt; select * from user where id = #{uid} &lt;/select&gt; &lt;/mapper&gt; 接口层配置,IRoleDao.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;com.ecit.dao.IRoleDao&quot;&gt; &lt;!--定义role表的ResultMap--&gt; &lt;resultMap id=&quot;roleMap&quot; type=&quot;role&quot;&gt; &lt;id property=&quot;roleId&quot; column=&quot;rid&quot;&gt;&lt;/id&gt; &lt;result property=&quot;roleName&quot; column=&quot;role_name&quot;&gt;&lt;/result&gt; &lt;result property=&quot;roleDesc&quot; column=&quot;role_desc&quot;&gt;&lt;/result&gt; &lt;collection property=&quot;users&quot; ofType=&quot;user&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;&gt;&lt;/id&gt; &lt;result column=&quot;username&quot; property=&quot;username&quot;&gt;&lt;/result&gt; &lt;result column=&quot;address&quot; property=&quot;address&quot;&gt;&lt;/result&gt; &lt;result column=&quot;sex&quot; property=&quot;sex&quot;&gt;&lt;/result&gt; &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;&gt;&lt;/result&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;!--查询所有--&gt; &lt;select id=&quot;findAll&quot; resultMap=&quot;roleMap&quot;&gt; select u.*,r.id as rid,r.role_name,r.role_desc from role r left outer join user_role ur on r.id = ur.rid left outer join user u on u.id = ur.uid &lt;/select&gt; &lt;/mapper&gt; 测试结果： public class IUserDaoTest extends BaseTest{ @Test public void findAll() throws Exception { userDao.findAll().stream().forEach(item-&gt; System.out.println(item)); } } // 输出结果： // User(id=41, username=老王, address=北京, sex=男, birthday=Sat Feb 27 17:47:08 CST 1965, roles=[Role(roleId=1, roleName=院长, roleDesc=管理整个学院, users=null), Role(roleId=2, roleName=总裁, roleDesc=管理整个公司, users=null)]) // User(id=45, username=老张, address=绍兴, sex=男, birthday=Sun Mar 04 12:04:06 CST 1923, roles=[Role(roleId=1, roleName=院长, roleDesc=管理整个学院, users=null)]) // User(id=42, username=小王, address=上海, sex=女, birthday=Wed Mar 02 15:09:37 CST 1955, roles=[]) // User(id=43, username=小二王, address=杭州, sex=女, birthday=Thu Mar 04 11:34:34 CST 2010, roles=[]) // User(id=46, username=小张, address=重庆, sex=男, birthday=Tue Mar 07 17:37:26 CST 2000, roles=[]) // User(id=48, username=小马, address=天津, sex=女, birthday=Sat Mar 08 11:44:00 CST 2008, roles=[]) import org.junit.Test; public class IRoleDaoTest extends BaseTest { @Test public void findAll() throws Exception { iRoleDao.findAll().stream().forEach(item-&gt; System.out.println(item)); } } // 输出结果： // Role(roleId=1, roleName=院长, roleDesc=管理整个学院, users=[User(id=41, username=老王, address=北京, sex=男, birthday=Sat Feb 27 17:47:08 CST 1965, roles=null), User(id=45, username=老张, address=绍兴, sex=男, birthday=Sun Mar 04 12:04:06 CST 1923, roles=null)]) // Role(roleId=2, roleName=总裁, roleDesc=管理整个公司, users=[User(id=41, username=老王, address=北京, sex=男, birthday=Sat Feb 27 17:47:08 CST 1965, roles=null)]) // Role(roleId=3, roleName=校长, roleDesc=管理整个学校, users=[]) mybatis中的延迟加载 问题:在一对多中，当我们有一个用户，它有100个账户。 在查询用户的时候，要不要把关联的账户查出来? 在查询账户的时候，要不要把关联的用户查出来? 在查询用户时，用户下的账户信息应该是，什么时候使用，什么时候查询的。 在查询账户时，账户的所属用户信息应该是随着账户查询时-起查询出来。 什么是延迟加载 在真正使用数据时才发起查询，不用的时候不查询。按需加载(懒加载) 什么是立即加载 不管用不用，只要一调用方法，马上发起查询。在对应的四种表关系中: 一对多，多对一，一对一，多对多一对多，多对多:通常情况下我们都是采用延迟加载。多对一，一对一:通常情况下我们都是采用立即加载。 使用 assocation 实现延迟加载 需求:查询账户信息同时查询用户信息。 账户的持久层DAO接口public interface IAccountDao { /** * 查询所有账户，同时还要获取到当前账户的所属用户信息 * @return */ List&lt;Account&gt; findAll(); } 账户的持久层映射文件&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;com.ecit.dao.IAccountDao&quot;&gt; &lt;!-- 定义封装account和user的resultMap --&gt; &lt;resultMap id=&quot;accountUserMap&quot; type=&quot;account&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;aid&quot;&gt;&lt;/id&gt; &lt;result property=&quot;uid&quot; column=&quot;uid&quot;&gt;&lt;/result&gt; &lt;result property=&quot;money&quot; column=&quot;money&quot;&gt;&lt;/result&gt; &lt;!-- 一对一的关系映射：配置封装user的内容--&gt; &lt;association property=&quot;user&quot; column=&quot;uid&quot; javaType=&quot;user&quot; select=&quot;com.ecit.dao.IUserDao.findById&quot;&gt; &lt;!--select: 填写我们要调用的 select 映射的 id ;column : 填写我们要传递给 select 映射的参数--&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;!-- 查询所有 --&gt; &lt;select id=&quot;findAll&quot; resultMap=&quot;accountUserMap&quot;&gt; select * from account &lt;/select&gt; &lt;/mapper&gt; 用户的持久层接口和映射文件```javaimport com.ecit.domain.User;/** 用户的持久层接口 /public interface IUserDao { /* 根据id查询用户信息 @param userId @return */ User findById(Integer userId);}```xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;com.ecit.dao.IUserDao&quot;&gt; &lt;!-- 根据id查询用户 --&gt; &lt;select id=&quot;findById&quot; parameterType=&quot;INT&quot; resultType=&quot;user&quot;&gt; select * from user where id = #{uid} &lt;/select&gt; &lt;/mapper&gt; 开启Mybatis的延迟加载策略我们需要在 Mybatis 的配置文件 SqlMapConfig.xml 文件中添加延迟加载的配置。&lt;settings&gt; &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt; &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt; &lt;/settings&gt; 测试结果 @Test public void findAll() throws Exception { accountDao.findAll(); } //用户信息按需加载 @Test public void findAll2() throws Exception { accountDao.findAll().stream().forEach((item)-&gt;{System.out.println(item);}); } 使用 Collection 实现延迟加载 同样我们也可以在一对多关系配置的&lt;collection&gt;结点中配置延迟加载策略。 &lt;collection&gt;结点中也有 select 属性，column 属性。 需求:完成加载用户对象时，查询该用户所拥有的账户信息。 在User实体类中加入List&lt;Account&gt;属性import lombok.Data; import java.io.Serializable; import java.util.Date; import java.util.List; @Data public class User implements Serializable { private Integer id; private String username; private String address; private String sex; private Date birthday; private List&lt;Account&gt; accounts; } 编写用户和账户持久层接口的方法```javaimport com.ecit.domain.User;import java.util.List;/** 用户的持久层接口 /public interface IUserDao { List findAll();}public interface IAccountDao { /* 查询所有账户，同时还要获取到当前账户的所属用户信息 @return */ List findByUid(Integer uid);}``` 编写用户持久层映射配置&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;com.ecit.dao.IUserDao&quot;&gt; &lt;resultMap type=&quot;user&quot; id=&quot;userMap&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;&gt;&lt;/id&gt; &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt; &lt;result column=&quot;address&quot; property=&quot;address&quot;/&gt; &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt; &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;/&gt; &lt;!-- collection是用于建立一对多中集合属性的对应关系 ofType 用于指定集合元素的数据类型 select 是用于指定查询账户的唯一标识(账户的 dao 全限定类名加上方法名称) column 是用于指定使用哪个字段的值作为条件查询 --&gt; &lt;collection property=&quot;accounts&quot; ofType=&quot;account&quot; select=&quot;com.ecit.dao.IAccountDao.findByUid&quot; column=&quot;id&quot;&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;!-- 配置查询所有操作 --&gt; &lt;select id=&quot;findAll&quot; resultMap=&quot;userMap&quot;&gt; select * from user &lt;/select&gt; &lt;/mapper&gt; 编写账户持久层配置&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;com.ecit.dao.IAccountDao&quot;&gt; &lt;!-- 根据用户 id 查询账户信息 --&gt; &lt;select id=&quot;findByUid&quot; resultType=&quot;account&quot; parameterType=&quot;int&quot;&gt; select * from account where uid = #{uid} &lt;/select&gt; &lt;/mapper&gt; SqlMapConfig.xml懒加载机制配置&lt;settings&gt; &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt; &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt; &lt;/settings&gt; 测试效果 @Test public void findAll() throws Exception { userDao.findAll(); } @Test public void findAll2() throws Exception { userDao.findAll().stream().forEach(item-&gt; System.out.println(item)); } mybatis中的缓存 什么是缓存存在于内存中的临时数据。 为什么使用缓存减少和数据库的交互次数，提高执行效率。 什么样的数据能使用缓存，什么样的数据不能使用 适用于缓存:经常查询并且不经常改变的。数据的正确与否对最终结果影响不大的。 不适用于缓存:经常改变的数据数据的正确与否对最终结果影响很大的。例如: 商品的库存，银行的汇率，股市的牌价。 mybatis中的一级缓存sqlsession 一级缓存是 SqlSession 级别的缓存，只要 SqlSession 没有 flush 或 close，它就存在。 @Test public void findAll2() throws Exception { List&lt;User&gt; list1 = userDao.findAll(); List&lt;User&gt; list2 = userDao.findAll(); System.out.println(list1==list2?&quot;list1==list2?--&gt;一级缓存中同一份数据对象&quot;:&quot;ist1==list2?--&gt;不是一级缓存中的对象&quot;); session.clearCache(); List&lt;User&gt; list3 = userDao.findAll(); System.out.println(list3==list1?&quot;list3==list1?--&gt;一级缓存中同一份数据对象&quot;:&quot;list3==list1?--&gt;不是一级缓存中的对象&quot;); session.close(); session = factory.openSession(); userDao = session.getMapper(IUserDao.class); List&lt;User&gt; list5 = userDao.findAll(); System.out.println(list5==list1?&quot;list5==list1?--&gt;一级缓存中同一份数据对象&quot;:&quot;list5==list1?不是一级缓存中的对象&quot;); User user = new User(); user.setId(48); user.setUsername(&quot;小马哥&quot;); userDao.update(user); List&lt;User&gt; list6 = userDao.findAll(); System.out.println(list6==list5?&quot;list6==list5?--&gt;一级缓存中同一份数据对象&quot;:&quot;list6==list5?不是一级缓存中的对象&quot;); } // 输出结果： // list1==list2?--&gt;一级缓存中同一份数据对象 // list3==list1?--&gt;不是一级缓存中的对象 // list5==list1?不是一级缓存中的对象 // list6==list5?不是一级缓存中的对象 一级缓存是 SqlSession 范围的缓存，当调用 SqlSession 的修改，添加，删除，commit()，close()等方法时，就会清空一级缓存。测试效果：list1==list2?--&gt;一级缓存中同一份数据对象 list3==list1?--&gt;不是一级缓存中的对象 list5==list1?不是一级缓存中的对象 list6==list5?不是一级缓存中的对象 mybatis中的二级缓存mapper(namespace) 二级缓存是 mapper 映射级别的缓存，多个 SqlSession 去操作同一个 Mapper 映射的 sql 语句，多个SqlSession 可以共用二级缓存，二级缓存是跨 SqlSession 的。 二级缓存的开启与关闭&lt;settings&gt; &lt;!-- 开启二级缓存的支持 --&gt; &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; &lt;/settings&gt; &lt;!-- 因为 cacheEnabled 的取值默认就为 true，所以这一步可以省略不配置。为 true 代表开启二级缓存;为 false 代表不开启二级缓存。--&gt; 配置相关的 Mapper 映射文件&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;com.ecit.dao.IUserDao&quot;&gt; &lt;!--开启二级缓存--&gt; &lt;cache/&gt; &lt;resultMap type=&quot;user&quot; id=&quot;userMap&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;&gt;&lt;/id&gt; &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt; &lt;result column=&quot;address&quot; property=&quot;address&quot;/&gt; &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt; &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;/&gt; &lt;!-- collection是用于建立一对多中集合属性的对应关系 ofType 用于指定集合元素的数据类型 select 是用于指定查询账户的唯一标识(账户的 dao 全限定类名加上方法名称) column 是用于指定使用哪个字段的值作为条件查询 --&gt; &lt;collection property=&quot;accounts&quot; ofType=&quot;account&quot; select=&quot;com.ecit.dao.IAccountDao.findByUid&quot; column=&quot;id&quot;&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;!-- 配置查询所有操作 --&gt; &lt;select id=&quot;findAll&quot; resultMap=&quot;userMap&quot; useCache=&quot;true&quot;&gt; &lt;!--指定语句使用二级缓存--&gt; select * from user &lt;/select&gt; &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;user&quot; useCache=&quot;true&quot;&gt; select * from user WHERE id = #{id} &lt;/select&gt; &lt;/mapper&gt; 将 UserDao.xml 映射文件中的&lt;select&gt;标签中设置 useCache=”true”代表当前这个 statement 要使用二级缓存，如果不使用二级缓存可以设置为 false。注意:针对每次查询都需要最新的数据 sql，要设置成 useCache=false，禁用二级缓存。 @Test public void findUserById() throws Exception { User user1 = userDao.findUserById(48); System.out.println(user1); session.close(); session = factory.openSession(); userDao = session.getMapper(IUserDao.class); User user2 = userDao.findUserById(48); System.out.println(user2); } 注意二级缓存缓存的是散列内容，而非对象，缓存查询时，会根据存在的内容，重新序列化一个新对象 ehcache二级缓存 mybatis的特长是SQL操作，缓存数据管理不是其特长，为了提高缓存的性能，myBatis允许使用第三方缓存产品。ehcache就是其中的一种。 导入依赖库 &lt;dependency&gt; &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt; &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt; &lt;version&gt;1.2.1&lt;/version&gt; &lt;/dependency&gt; 在classpath下配置ehcache.xml&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:noNamespaceSchemaLocation=&quot;http://ehcache.org/ehcache.xsd&quot;&gt; &lt;diskStore path=&quot;java.io.tmpdir&quot;/&gt; &lt;defaultCache maxElementsInMemory=&quot;10000&quot; eternal=&quot;false&quot; timeToIdleSeconds=&quot;120&quot; timeToLiveSeconds=&quot;120&quot; maxElementsOnDisk=&quot;10000000&quot; diskExpiryThreadIntervalSeconds=&quot;120&quot; memoryStoreEvictionPolicy=&quot;LRU&quot;&gt; &lt;persistence strategy=&quot;localTempSwap&quot;/&gt; &lt;/defaultCache&gt; &lt;/ehcache&gt; SqlMapConfig.xml开启二级缓存开关 &lt;settings&gt; &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; &lt;/settings&gt; dao接口映射文件配置实现类&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;com.ecit.dao.IUserDao&quot;&gt; &lt;!--开启二级缓存,使用ehcache实现类--&gt; &lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;/&gt; &lt;resultMap type=&quot;user&quot; id=&quot;userMap&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;&gt;&lt;/id&gt; &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt; &lt;result column=&quot;address&quot; property=&quot;address&quot;/&gt; &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt; &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;/&gt; &lt;!-- collection是用于建立一对多中集合属性的对应关系 ofType 用于指定集合元素的数据类型 select 是用于指定查询账户的唯一标识(账户的 dao 全限定类名加上方法名称) column 是用于指定使用哪个字段的值作为条件查询 --&gt; &lt;collection property=&quot;accounts&quot; ofType=&quot;account&quot; select=&quot;com.ecit.dao.IAccountDao.findByUid&quot; column=&quot;id&quot;&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;!-- 配置查询所有操作 --&gt; &lt;select id=&quot;findAll&quot; resultMap=&quot;userMap&quot; useCache=&quot;true&quot;&gt; &lt;!--指定语句使用二级缓存--&gt; select * from user &lt;/select&gt; &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;user&quot; useCache=&quot;true&quot;&gt;&lt;!--指定语句使用二级缓存--&gt; select * from user WHERE id = #{id} &lt;/select&gt; &lt;/mapper&gt; 测试 @Test public void findUserById() throws Exception { User user1 = userDao.findUserById(48); System.out.println(user1); session.close(); session = factory.openSession(); userDao = session.getMapper(IUserDao.class); User user2 = userDao.findUserById(48); System.out.println(user2); System.out.println(System.getProperty(&quot;java.io.tmpdir&quot;)); } //注意查看 com.ecit.dao.IUserDao - Cache Hit Ratio [com.ecit.dao.IUserDao]: 0.5，说明生效了 mybatis和hibernate本质区别和应用场景← hibernate:是一个标准ORM框架(对象关系映射)。入门门槛较高的，不需要程序写sql，sql 语句自动生成了。对sql语句进行优化、修改比较困难的。 应用场景: 适用与需求变化不多的中小型项目，比如:后台管理系统，erp、 orm、oa mybatis:专注是sgl本身，需要程序员自己编写sg!语句，sgl 修改、优化比较方便。mybatis是一个不完全的ORM框架，虽然程序员自己写sgl，mybatis 也可以实现映射(输入映射、输出映射)。 应用场景: 适用与需求变化较多的项目，比如:互联网项目。企业进行技术选型，以低成本高回报作为技术选型的原则，根据项目组的技术力量进行选择。 使用Mybatis批量新增数据的三种具体实现 MySQL数据库对于批量插入的支持(适用于几十条和几百条数据插入的情景) 方式: 1 )借助foreach标签使用insert into table values() ，sql语句只编译一次 &lt;insert id=&quot;addPersons&quot;&gt; insert into user(username,password) VALUES &lt;foreach collection=&quot;users&quot; item=&quot;user&quot; separator=&quot;,&quot;&gt; (#{user.username},#{user.password}) &lt;/foreach&gt; &lt;/insert&gt; public int addPersons(@Param(&quot;users&quot;) List&lt;User&gt; persons); List&lt;User&gt; persons=new ArrayList&lt;User&gt;(); for (int i = 0; i &lt;1000 ; i++) { User person=new User(&quot;jerry&quot;+i,&quot;email@&quot;+i); persons.add(person); } personMapper.addPersons(persons); 2 )借助MySQL数据库连接属性allowMultiQueries=true,拼接在jdbc.url后面(不推荐，编译引擎多次编译sql语句) &lt;insert id=&quot;addPersons&quot;&gt; &lt;foreach collection=&quot;users&quot; item=&quot;person&quot; separator=&quot;;&quot;&gt; insert into user(username,password) VALUES (#{person.username},#{person.password}) &lt;/foreach&gt; &lt;/insert&gt; public int addPersons(@Param(&quot;users&quot;) List&lt;User&gt; persons); 可借助Executor的Batch批量添加,可与Spring框架整合,不要配置在全局的SqlMapConfig.xml里，会影响所有的插入语句，单独获取session,针对特殊的mapper(适用于几千条上万条数据需要批量插入的情景) &lt;insert id=&quot;addPerson&quot; parameterType=&quot;user&quot;&gt; insert into user(username,password) VALUES (#{username},#{password}) &lt;/insert&gt; public int addPerson(User user); @Test public void testBatchaddUsers() { //如果自动提交设置为true,将无法控制提交的条数，改为最后统一提交，可能导致内存溢出 SqlSession sqlSession = factory.openSession(ExecutorType.BATCH, false); PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class); try { for (int i = 0; i &lt; 10020; i++) { personMapper.addPerson(new User(&quot;jerry&quot; + i, &quot;bj&quot; + i)); if (i % 5000 == 0 &amp;&amp; i &gt; 0) { //手动每5000条提交一次，提交后无法回滚 sqlSession.commit(); //清理缓存，防止溢出 sqlSession.clearCache(); } } sqlSession.commit(); sqlSession.clearCache(); } catch (Exception e) { sqlSession.rollback(); }finally { sqlSession.close(); } } } Mybatis四大对象及插件原理 Mybatis核心对象 ParameterHandler:处理SQL 的参数对象 ```java public ParameterHandler newParameterHandler(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql) { ParameterHandler parameterHandler = mappedStatement.getLang().createParameterHandler(mappedStatement, parameterObject, boundSql); parameterHandler = (ParameterHandler)this.interceptorChain.pluginAll(parameterHandler); //被拦截器层层代理加强，返回一个ParameterHandler代理对象 return parameterHandler; } public Object pluginAll(Object target) { Interceptor interceptor; for(Iterator var2 = this.interceptors.iterator(); var2.hasNext(); target = interceptor.plugin(target)) { //层层拦截器，加强代理对象 interceptor = (Interceptor)var2.next(); } return target; } - ResultSetHandler :处理SQL的返回结果集 - StatementHandler:数据库的处理对象,用于执行SQL语句 - Executor:Mybatis的执行器 ,用于执行增删改查操作 - Mybatis插件原理及接口 - Mybatis的插件借助于责任链的模式进行对拦截的处理 - 使用动态代理对目标对象进行包装，达到拦截的目的 - 作用于Mybatis的作用域对象之上 - Mybatis插件接口-Interceptor - Intercept方法,插件的核心方法 - 使plugin方法,生成target的代理对象 - setProperties方法 ,配置所需参数 ### 插件的开发过程 - 确定拦截的签名 - 实现拦截方法 - 配置和运行 - 插件实例 **创建代理对象时,按照插件配置的顺序进行包装**,*执行目标方法后,是按照代理的逆向进行执行* ```xml &lt;plugins&gt; &lt;plugin interceptor=&quot;com.ecit.interceptor.FirstInterceptor&quot;&gt; &lt;property name=&quot;hello&quot; value=&quot;world&quot;&gt;&lt;/property&gt; &lt;/plugin&gt; &lt;plugin interceptor=&quot;com.ecit.interceptor.SecondInterceptor&quot;&gt; &lt;/plugin&gt; &lt;/plugins&gt; import org.apache.ibatis.executor.resultset.ResultSetHandler; import org.apache.ibatis.plugin.*; import java.sql.Statement; import java.util.Properties; @Intercepts({ @Signature(type = ResultSetHandler.class,method = &quot;handleResultSets&quot;,args = Statement.class) }) public class FirstInterceptor implements Interceptor { @Override public Object intercept(Invocation invocation) throws Throwable { System.out.println(&quot;拦截的目标对象1:&quot;+invocation.getTarget()); System.out.println(&quot;拦截的目标对象1 方法:&quot;+invocation. getMethod()); System.out.println(&quot;拦截的目标对象1 参数:&quot;+invocation. getArgs()); Object object=invocation.proceed(); return object; } @Override public Object plugin(Object o) { System. out. println(&quot;将要包装的目标对象1&quot;+o); return Plugin. wrap(o,this); } @Override public void setProperties(Properties properties) { System.out.println(&quot;插件配置的初始化参数1&quot;+properties); } } import org.apache.ibatis.executor.resultset.ResultSetHandler; import org.apache.ibatis.plugin.*; import java.sql.Statement; import java.util.Properties; @Intercepts({ @Signature(type = ResultSetHandler.class,method = &quot;handleResultSets&quot;,args = Statement.class) }) public class SecondInterceptor implements Interceptor { @Override public Object intercept(Invocation invocation) throws Throwable { System.out.println(&quot;拦截的目标对象2&quot;+invocation.getTarget()); Object object=invocation.proceed(); return object; } @Override public Object plugin(Object o) { System. out. println(&quot;将要包装的目标对象2&quot;+o); return Plugin.wrap(o,this); } @Override public void setProperties(Properties properties) { System.out.println(&quot;插件配置的初始化参数2&quot;+properties); } } 使用拦截器PageHelper进行分页 分页原理总结分页原理-规律 开始记录索引的规律 (当前页-1) * 每页的条数 一共有多少页:总记录%条数==0 ?总记录%条数: +1 PageHelper分页插件的使用 用到的分页插件库&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.0.3&lt;/version&gt; &lt;/dependency&gt; SqlMapConfig.xml配置分页插件 特别注意,新版拦截器是com.github.pagehelper.PageInterceptor。com.github.pagehelper.PageHelper现在是一个特殊的dialect实现类,是分页插件的默认实现类,提供了和以前相同的用法。&lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt; &lt;/plugin&gt; 拿一种使用示例，其它方式使用可参看官网详细介绍@Test public void testFindUserById() { Page&lt;User&gt; page = PageHelper.startPage(1,10); List&lt;User&gt; users = userDao.findAll(); for (User user:users ) { System.out.println(user.getId() + user.getUsername() + user.getPassword()); } System.out.println(page.getPageNum()) ;//current page System.out.println(page.getTotal());//total System.out.println(page.getPageSize()); PageHelper.startPage(2,10); List&lt;User&gt; user2 = userDao.findAll(); System.out.println(user2); System.out.println(page.getPageNum()) ;//current page System.out.println(page.getTotal());//total System.out.println(page.getPageSize()); }","link":"/2013/11/03/framework/%E6%8C%81%E4%B9%85%E5%B1%82%E6%A1%86%E6%9E%B6/mybatis/mybatis/"},{"title":"教学管理系统-数据库层面设计","text":"概念模型CDM(分析阶段)概念数据模型（CDM） CDM表现数据库的全部逻辑的结构,与任何的软件或数据储藏结构无关。一个概念模型经常包括在物理数据库中仍然不实现的数据对象。它给运行计划或业务活概念数据模型是最终用户对数据存储的看法，反映了用动的数据一个正式表现方式。 概念数据模型是最终用户对数据存储的看法，反映了用户的综合性信息需求。 不考虑物理实现细节，只考虑实之间的关系。 CDM是适合于系统分析阶段的工具。 物理模型PDM（设计阶段）物理模型PDM PDM是用于定义详细定义物理结构和数据查询的数据库设计工具。可以在PDM中使用不同类型的图表，这取决于所要设计的目标数据库的类型。 主要目的是把CDM中建立的现实世界模型生成特定的DBMS脚本，产生数据库中保存信息的存储结构，保证数据在数据库中的完整性和一致性。 PDM是适合于系统设计阶段的工具。","link":"/2017/06/01/framework/%E7%BB%83%E4%B9%A0%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95/%E6%95%99%E5%AD%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E7%AF%87-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B1%82%E9%9D%A2%E7%9A%84%E8%AE%BE%E8%AE%A1/"},{"title":"shiro第一篇","text":"shiro功能介绍 Apache Shiro是Java的一个安全(权限)框架。Shiro可以非常容易的开发出足够好的应用,其不仅可以用在JavaSE环境,也可以用在JavaEE环境。对比Spring Security，可能没有Spring Security做的功能强大，但是在实际工作时可能并不需要那么复杂的东西，所以使用小而简单的Shiro就足够了。对于它俩到底哪个好，这个不必纠结，能更简单的解决项目问题就好了。 Shiro功能如下： Authentication :身份认证/登录,验证用户是不是拥有相应的身份; Authorization :授权,即权限验证,验证某个已认证的用户是否拥有某个权限;即判断用户是否能进行什么操作,如:验证某个用户是否拥有某个角色。或者细粒度的验证某个用户对某个资源是否具有某个权限; Session Manager :会话管理,即用户登录后就是一次会话,在没有退出之前,它的所有信息都在会话中;会话可以是普通JavaSE环境,也可以是Web环境的; Cryptography :加密，保护数据的安全性,如密码加密存储到数据库，而不是明文存储; Web Support : Web支持,可以非常容易的集成到Web环境; Caching :缓存，比如用户登录后，其用户信息、拥有的角色/权限不必每次去查,这样可以提高效率; Concurrency : Shiro支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去; **Testing :**提供测试支持; **Run As :**允许个用户假装为另一个用户(如果他们允许)的身份进行访问; Remember Me :记住我，这个是非常常见的功能，即- -次登录后，下次再来的话不用登录了 下载:http://shiro.apache.org/ shiro架构 Subject:应用代码直接交互的对象是 Subject，也就是说 Shiro 的对外 API 核心就是 Subject。Subject 代表了当前“用户”， 这个用户不一定是一个具体的人，与当前应用交互的任何东西都是 Subject，如网络爬虫， 机器人等;与 Subject 的所有交互都会委托给 SecurityManager; Subject 其实是一个门面，SecurityManager 才是实际的执行者; Principal:身份信息(username)是主体(subject) 进行身份认证的标识，标识必须具有唯一性， 如用户名、手机号、邮箱地址等，一个主体可以有多个身份，但是必须有一个主身份(Primary Principal) credential:凭证信息(password)是只有主体自己知道的安全信息，如密码、证书等。 SecurityManager:安全管理器;即所有与安全有关的操作都会与 SecurityManager 交互;且其管理着所有 Subject;可以看出它是 Shiro 的核心，它负责与 Shiro 的其他组件进行交互，它相当于 SpringMVC 中 DispatcherServlet 的角色 **Realm:**Shiro 从 Realm 获取安全数据(如用户、角色、权限)，就是说 SecurityManager 要验证用户身份，那么它需要从 Realm 获取相应的用户 进行比较以确定用户身份是否合法;也需要从 Realm 得到用户相应的角色/权限进行验证用户是否能进行操作;可以把 Realm 看成 DataSource,由用户提供,所以一般在应用中都需要实现自己的 Realm **Authenticator:**负责 Subject 认证，是一个扩展点，可以自定义实现;可以使用认证 策略(Authentication Strategy)，即什么情况下算用户认证通过了; **Authorizer:**授权器、即访问控制器，用来决定主体是否有权限进行相应的操作;即控制着用户能访问应用中的哪些功能; **SessionManager:**管理 Session 生命周期的组件;而 Shiro 并不仅仅可以用在 Web 环境，也可以用在如普通的 JavaSE 环境 **CacheManager:**缓存控制器，来管理如用户、角色、权限等的缓存的;因为这些数据 基本上很少改变，放到缓存中后可以提高访问的性能 **Cryptography:**密码模块，Shiro 提高了一些常见的加密组件用于如密码加密/解密。 从shiro的内部与外部查看其架构 shiro实战环境依赖&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-all&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; URL匹配url匹配规则?: 匹配一个字符,如/admin? 将匹配/admin1,但不匹配/admin或/admin/ ; *: 匹配零个或多个字符串,如/admin* 将匹配/admin、/admin123 ,但不匹配/admin/1 ; **: 匹配路径中的零个或多个路径,如/admin/** 将匹配/admin/a 或 /admin/a/b URL匹配顺序URL权限采取第一次匹配优先的方式，即从头开始 使用第一个匹配的 url 模式对应的拦截器链。 – /bb/**=filter1 – /bb/aa=filter2 – /**=filter3 – 如果请求的url是“/bb/aa”，因为按照声明顺序进行匹 配，那么将使用 filter1 进行拦截。 shiro会话管理 Shiro 提供了完整的企业级会话管理功能，不依赖于底层容器(如web容器tomcat)，不管JavaSE还是JavaEE环境，都可以使用，提供了会话管理、会话事件监听、会话存储/持久化、容器无关的集群、失效/过期支持、对Web的透明支持、SSO单点登录的支持等特性。 三个会话管理器（SessionManager）实现DefaultSessionManager：DefaultSecurityManager 使用的默认实现，用于 JavaSE 环境； ServletContainerSessionManager：DefaultWebSecurityManager 使用的默认实现，用于 Web 环境，其直接使用 Servlet 容器的会话； DefaultWebSessionManager：用于 Web 环境的实现，可以替代 ServletContainerSessionManager，自己维护着会话，直接废弃了 Servlet 容器的会话管理。 会话相关的APISubject.getSession():即可获取会话;其等价于 Subject.getSession(true)，即如果当前没有创建 Session 对象会创建一个;Subject.getSession(false)，如果当前没有创建 Session 则返回 null session.getId():获取当前会话的唯一标识 session.getHost():获取当前Subject的主机地址 session.getTimeout() &amp; session.setTimeout(毫秒):获取/设置当 前Session的过期时间 session.getStartTimestamp() &amp; session.getLastAccessTime(): 获取会话的启动时间及最后访问时间;如果是 JavaSE 应用需要自己定 期调用 session.touch() 去更新最后访问时间;如果是 Web 应用，每 次进入 ShiroFilter 都会自动调用 session.touch() 来更新最后访问时间。 session.touch() &amp; session.stop():更新会话最后访问时间及销毁会话;当 Subject.logout()时会自动调用 stop 方法 来销毁会话。如果在web中调用 HttpSession.invalidate() 也会自动调用ShiroSession.stop 方法进行销毁Shiro的会话 session.setAttribute(key, val) &amp; session.getAttribute(key) &amp; session.removeAttribute(key):设置/获取/删除会话属 性;在整个会话范围内都可以对这些属性进行操作 会话监听器 会话监听器用于监听会话创建、过期及停止事件public interface SessionListener { void onStart(Session var1); void onStop(Session var1); void onExpiration(Session var1); } 会话验证 Shiro 提供了会话验证调度器，用于定期的验证会话是否已过期，如果过期将停止会话 出于性能考虑，一般情况下都是获取会话时来验证会话是 否过期并停止会话的;但是如在 web 环境中，如果用户不 主动退出是不知道会话是否过期的，因此需要定期的检测 会话是否过期，Shiro 提供了会话验证调度器 SessionValidationSchedulersessionValidationScheduler：会话验证调度器，sessionManager 默认就是使用 ExecutorServiceSessionValidationScheduler，其使用 JDK 的 ScheduledExecutorService 进行定期调度并验证会话是否过期； sessionValidationScheduler.interval：设置调度时间间隔，单位毫秒，默认就是 1 小时； sessionValidationScheduler.sessionManager：设置会话验证调度器进行会话验证时的会话管理器； sessionManager.globalSessionTimeout：设置全局会话超时时间，默认 30 分钟，即如果 30 分钟内没有访问会话将过期； sessionManager.sessionValidationSchedulerEnabled：是否开启会话验证器，默认是开启的； sessionManager.sessionValidationScheduler：设置会话验证调度器，默认就是使用 ExecutorServiceSessionValidationScheduler。 Shiro 也提供了使用Quartz会话验证调度器: QuartzSessionValidationScheduler SesssionDao AbstractSessionDAO 提供了 SessionDAO 的基础实现， 如生成会话ID等 CachingSessionDAO 提供了对开发者透明的会话缓存的 功能，需要设置相应的 CacheManager MemorySessionDAO 直接在内存中进行会话维护 EnterpriseCacheSessionDAO 提供了缓存功能的会话维 护，默认情况下使用 MapCache 实现，内部使用 ConcurrentHashMap 保存缓存的会话。 Shiro在Spring的会话管理（session） 1.可以配置一个属于自己的Session ID生成器,spring容器配置添加如下：&lt;!-- 定义Session ID生成管理器 --&gt; &lt;bean id=&quot;sessionIdGenerator&quot; class=&quot;org.apache.shiro.session.mgt.eis.JavaUuidSessionIdGenerator&quot; /&gt; 2.随后需要定义有一个会话的DAO处理，指的是你的会话的缓存位置，本次暂时将所有的会话数据保存在内存里面。会话保存处理：org.apache.shiro.session.mgt.eis.EnterpriseCacheSessionDAO&lt;!-- 配置Session DAO的操作处理 --&gt; &lt;bean id=&quot;sessionDAO&quot; class=&quot;org.apache.shiro.session.mgt.eis.EnterpriseCacheSessionDAO&quot;&gt; &lt;!-- 设置session缓存的名字，这个名字可以任意,注意对应 ehcache.xml里面的缓存名字 --&gt; &lt;property name=&quot;activeSessionsCacheName&quot; value=&quot;shiro-activeSessionCache&quot;/&gt; &lt;!-- 定义该Session DAO操作中所使用的ID生成器 --&gt; &lt;property name=&quot;sessionIdGenerator&quot; ref=&quot;sessionIdGenerator&quot;/&gt; &lt;/bean&gt; ehcache.xml配置如下：&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:noNamespaceSchemaLocation=&quot;http://ehcache.org/ehcache.xsd&quot;&gt; &lt;diskStore path=&quot;java.io.tmpdir&quot;/&gt; &lt;cache name=&quot;shiro-activeSessionCache&quot; maxElementsInMemory=&quot;1000&quot; eternal=&quot;false&quot; timeToIdleSeconds=&quot;1800&quot; timeToLiveSeconds=&quot;1800&quot; overflowToDisk=&quot;false&quot; diskPersistent=&quot;false&quot; statistics=&quot;true&quot; memoryStoreEvictionPolicy=&quot;LRU&quot;/&gt; &lt;/ehcache&gt; 3.现在只是定义了缓存所需要的组件，但是并没有定义session与客户端的之间的联系，为了进行有效的session管理所以还需要建立有一个Cookie的操作模版。处理Cookie：org.apache.shiro.web.servlet.SimpleCookie &lt;!-- 配置需要向Cookie中保存数据的配置模版 --&gt; &lt;bean id=&quot;sessionIdCookie&quot; class=&quot;org.apache.shiro.web.servlet.SimpleCookie&quot;&gt; &lt;!-- 在Tomcat运行下默认使用的Cookie的名字为JSESSIONID --&gt; &lt;constructor-arg value=&quot;ecit-session-id&quot;/&gt; &lt;!-- 保证该系统不会受到跨域的脚本操作供给 --&gt; &lt;property name=&quot;httpOnly&quot; value=&quot;true&quot;/&gt; &lt;!-- 定义Cookie的过期时间，单位为秒，如果设置为-1表示浏览器关闭，则Cookie消失 --&gt; &lt;property name=&quot;maxAge&quot; value=&quot;-1&quot;/&gt; &lt;!-- JSESSIONID的path为/用于多个系统共享JSESSIONID --&gt; &lt;!-- &lt;property name=&quot;path&quot; value=&quot;/&quot;/&gt; --&gt; &lt;/bean&gt; 4.定义会话管理器（sessionManager）操作类：org.apache.shiro.web.session.mgt.DefaultWebSessionManager； &lt;!-- 定义会话管理器的操作 --&gt; &lt;bean id=&quot;sessionManager&quot; class=&quot;org.apache.shiro.web.session.mgt.DefaultWebSessionManager&quot;&gt; &lt;!-- 定义的是全局的session会话超时时间，此操作会覆盖web.xml文件中的超时时间配置 --&gt; &lt;property name=&quot;globalSessionTimeout&quot; value=&quot;1000000&quot;/&gt; &lt;!-- 删除所有无效的Session对象，此时的session被保存在了内存里面 --&gt; &lt;property name=&quot;deleteInvalidSessions&quot; value=&quot;true&quot;/&gt; &lt;!-- 定义要使用的无效的Session定时调度器 --&gt; &lt;property name=&quot;sessionValidationScheduler&quot; ref=&quot;sessionValidationScheduler&quot;/&gt; &lt;!-- 需要让此session可以使用该定时调度器进行检测 --&gt; &lt;property name=&quot;sessionValidationSchedulerEnabled&quot; value=&quot;true&quot;/&gt; &lt;!-- 定义Session可以进行序列化的工具类 --&gt; &lt;property name=&quot;sessionDAO&quot; ref=&quot;sessionDAO&quot;/&gt; &lt;!-- 所有的session一定要将id设置到Cookie之中，需要提供有Cookie的操作模版 --&gt; &lt;property name=&quot;sessionIdCookie&quot; ref=&quot;sessionIdCookie&quot;/&gt; &lt;!-- 定义sessionIdCookie模版可以进行操作的启用 --&gt; &lt;property name=&quot;sessionIdCookieEnabled&quot; value=&quot;true&quot;/&gt; &lt;/bean&gt; 5.所有的session一定要在用户正确离开之后才能够进行资源的释放，但是用户如果不点注销，不能够进行session的清空处理，所以为了防止这样的问题，还需要增加有一个会话的验证调度器。调度器程序类：org.apache.shiro.session.mgt.quartz.QuartzSessionValidationScheduler&lt;!-- 配置session的定时验证检测程序类，以让无效的session释放 --&gt; &lt;bean id=&quot;sessionValidationScheduler&quot; class=&quot;org.apache.shiro.session.mgt.quartz.QuartzSessionValidationScheduler&quot;&gt; &lt;!-- 设置session的失效扫描间隔，单位为毫秒 --&gt; &lt;property name=&quot;sessionValidationInterval&quot; value=&quot;100000&quot;/&gt; &lt;!-- 随后还需要定义有一个会话管理器的程序类的引用 --&gt; &lt;property name=&quot;sessionManager&quot; ref=&quot;sessionManager&quot;/&gt; &lt;/bean&gt; 6.随后需要修改安全管理器：&lt;!--配置安全管理器SecurityManager --&gt; &lt;bean id=&quot;securityManager&quot; class=&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;&gt; &lt;property name=&quot;realm&quot; ref=&quot;userRealm&quot;/&gt; &lt;property name=&quot;cacheManager&quot; ref=&quot;cacheManager&quot;/&gt; &lt;property name=&quot;sessionManager&quot; ref=&quot;sessionManager&quot;/&gt; &lt;/bean&gt; 此时就表示当前WEB开发中的所有的session的处理操作都交由Shiro来进行操作控制。 Shiro在Spring的会话管理（session）- sessionDao数据库保存记录操作 1.添加session对象的序列化读写工具import org.apache.shiro.codec.Base64; import org.apache.shiro.session.Session; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; public class SerializableUtils { public static String serialize(Session session) { try { ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(session); return Base64.encodeToString(bos.toByteArray()); } catch (Exception e) { throw new RuntimeException(&quot;serialize session error&quot;, e); } } public static Session deserialize(String sessionStr) { try { ByteArrayInputStream bis = new ByteArrayInputStream( Base64.decode(sessionStr)); ObjectInputStream ois = new ObjectInputStream(bis); return (Session) ois.readObject(); } catch (Exception e) { throw new RuntimeException(&quot;deserialize session error&quot;, e); } } } 2.实现sessionDao接口import cn.ecit.shiro.utils.SerializableUtils; import org.apache.shiro.session.Session; import org.apache.shiro.session.mgt.ValidatingSession; import org.apache.shiro.session.mgt.eis.EnterpriseCacheSessionDAO; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.jdbc.core.JdbcTemplate; import org.springframework.stereotype.Repository; import java.io.Serializable; import java.util.List; @Repository public class MySessionDao extends EnterpriseCacheSessionDAO { @Autowired private JdbcTemplate jdbcTemplate = null; @Override protected Serializable doCreate(Session session) { Serializable sessionId = generateSessionId(session); assignSessionId(session, sessionId); String sql = &quot;insert into sessions(id, session) values(?,?)&quot;; jdbcTemplate.update(sql, sessionId, SerializableUtils.serialize(session)); return session.getId(); } @Override protected Session doReadSession(Serializable sessionId) { String sql = &quot;select session from sessions where id=?&quot;; List&lt;String&gt; sessionStrList = jdbcTemplate.queryForList(sql, String.class, sessionId); if (sessionStrList.size() == 0) return null; return SerializableUtils.deserialize(sessionStrList.get(0)); } @Override protected void doUpdate(Session session) { if (session instanceof ValidatingSession &amp;&amp; !((ValidatingSession) session).isValid()) { return; } String sql = &quot;update sessions set session=? where id=?&quot;; jdbcTemplate.update(sql, SerializableUtils.serialize(session), session.getId()); } @Override protected void doDelete(Session session) { String sql = &quot;delete from sessions where id=?&quot;; jdbcTemplate.update(sql, session.getId()); } } 3.修改Spring容器配置 sessionDao实现类&lt;!-- 配置会话 DAO的操作处理 --&gt; &lt;bean id=&quot;sessionDAO&quot; class=&quot;cn.ecit.shiro.dao.MySessionDao&quot;&gt; &lt;!-- 设置session缓存的名字，这个名字可以任意 --&gt; &lt;property name=&quot;activeSessionsCacheName&quot; value=&quot;shiro-activeSessionCache&quot;/&gt; &lt;!-- 定义该Session DAO操作中所使用的ID生成器 --&gt; &lt;property name=&quot;sessionIdGenerator&quot; ref=&quot;sessionIdGenerator&quot;/&gt; &lt;/bean&gt; 以上完结，会话记录就会更新在数据库里 与JavaSE简单集成示例shiro.ini认证授权 classpath下添加 shiro.ini[users] # 用户名是root,密码是secret，角色是 admin root = secret, admin # 用户zhangsan,密码666，同时拥有role1,role2两个角色 zhangsan = 666, role1, role2 [roles] # admin角色的用户拥有所有操作权限 admin = * # 有role1角色的用户，有所有用户操作的权限 role1 = user:* # 有role2角色的用户，有用户删除和新增操作 role2 = user:delete:user:create quickstart java示例```javaimport org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.;import org.apache.shiro.config.IniSecurityManagerFactory;import org.apache.shiro.mgt.SecurityManager;import org.apache.shiro.session.Session;import org.apache.shiro.subject.Subject;import org.apache.shiro.util.Factory;/* Simple Quickstart application showing how to use Shiro’s API. */public class Quickstart { public static void main(String[] args) { IniSecurityManagerFactory factory = new IniSecurityManagerFactory(“classpath:shiro.ini”); SecurityManager securityManager = factory.getInstance(); SecurityUtils.setSecurityManager(securityManager); Subject currentUser = SecurityUtils.getSubject(); Session session = currentUser.getSession(); session.setAttribute(“someKey”, “aValue”); String value = (String) session.getAttribute(“someKey”); if (value.equals(“aValue”)) { System.out.println(“—&gt; 测试session会话域 [“ + value + “]”); } if (!currentUser.isAuthenticated()) { UsernamePasswordToken token = new UsernamePasswordToken(“zhangsan”, “666”); // rememberme token.setRememberMe(true); try { currentUser.login(token); } catch (UnknownAccountException uae) { System.out.println(“—-&gt; 用户名不存在 “ + token.getPrincipal()); return; } catch (IncorrectCredentialsException ice) { System.out.println(“—-&gt; 密码错误”); return; } catch (LockedAccountException lae) { //用户被冻结了 } catch (AuthenticationException ae) { //其它异常 } } System.out.println(“—-&gt; 用户 [“ + currentUser.getPrincipal() + “] 登陆成功.”); //test a role: if (currentUser.hasRole(“role1”)) { System.out.println(“—-&gt; 当前用户拥有role1 角色!”); } else { System.out.println(“—-&gt; 当前用户不具备role1角色”); return; } //test a typed permission (not instance-level) if (currentUser.isPermitted(“user:add”)) { System.out.println(“—-&gt; 当前用户拥有 用户添加操作.”); } else { System.out.println(“当前不用不具备此操作.”); } //细粒度权限控制 if (currentUser.isPermitted(“user:delete:zhangsan”)) { System.out.println(“张三本人有用户的删除操作”); } else { System.out.println(“没用户删除操作权限”); } //判断当前用户是否拥有某个角色:返回true表示拥有，false表示没有 System. out. println ( currentUser.hasRole (“role1”)); //判断当前用户是否拥有一些角色:返回true表示全部拥有，false 表示不全部拥有 System. out. println (currentUser.hasAllRoles (Arrays.asList(“role1”,”role2”, “role3”))) ; //判断当前用户是否拥有一些角色:返回true表示全部拥有，false 表示不全部拥有 System. out. println (Arrays.toString(currentUser.hasRoles (Arrays.asList(“role1”, “role2”)))) ; //all done - log out! System.out.println(“—-&gt;” + currentUser.isAuthenticated()); currentUser.logout(); System.out.println(“—-&gt;” + currentUser.isAuthenticated()); System.exit(0); }}``` shiro认证过程 自定义realm完成认证授权(密码未加密存储) 核心realm接口 自定义CustomRealm示例import org.apache.shiro.authc.AuthenticationException; import org.apache.shiro.authc.AuthenticationInfo; import org.apache.shiro.authc.AuthenticationToken; import org.apache.shiro.authc.SimpleAuthenticationInfo; import org.apache.shiro.authz.AuthorizationInfo; import org.apache.shiro.realm.AuthorizingRealm; import org.apache.shiro.subject.PrincipalCollection; public class CustomRealm extends AuthorizingRealm{ @Override public String getName() { return this.getClass().getName(); } /** * 覆写授权 */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) { //传入参数: principals :用户认证凭证信息: //SimpleAuthenticationInfo:认证方法返回封装认证信息中第一个参数:用户信息(username)//当前登录用户名信息:用户凭证 String username = (String) principals. getPrimaryPrincipal () ; //模拟查询数据库: 查询用户实现指定的角色，以及用户权限 List&lt;String&gt; roles = new ArrayList&lt;String&gt;() ; //角色集合 List&lt;String&gt; permission = new ArrayList&lt;String&gt;(); //权限集合//假设用户在数据库中有role1角色 roles.add (&quot;role3&quot;) ; //假设用户在数据库 中拥有user:*权限 permission. add(&quot;user:*&quot;) ; //返回用户在数据库中的权限与角色 SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(); info.addRoles (roles); info.addStringPermissions(permission) ; return info; } /** * 覆写认证 */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException { String username = (String)authenticationToken.getPrincipal(); //模拟通过用户名查询数据库，将改用户对应数据查询返回: 账号与密码 //假设查询数据库返回数据是: zhangsan 666 if(!&quot;zhangsan&quot;.equals (username)) { return null; } String password = &quot;666&quot;; //info对象表示realm登录比对信息:参数1:用户信息(真实登录中是登录对象user对象)，参数2: 密码，参数3: 当前realm名字 SimpleAuthenticationInfo info = new SimpleAuthenticationInfo(username, password, getName ()) ; return info; } } 编写shiro-realm-customer.ini文件#自定义realm myRealm=com.ecit.security.CustomRealm #指定securityManager的realms实现 securityManager.realms=$myRealm 测试认证,授权示例import org.apache.shiro.SecurityUtils; import org.apache.shiro.authc.*; import org.apache.shiro.config.IniSecurityManagerFactory; import org.apache.shiro.mgt.SecurityManager; import org.apache.shiro.subject.Subject; import org.apache.shiro.util.Factory; public class QuickstartCustomerRealm { public static void main(String[] args) { Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(&quot;classpath:shiro-realm-customer.ini&quot;); SecurityManager securityManager = factory.getInstance(); SecurityUtils.setSecurityManager(securityManager); Subject currentUser = SecurityUtils.getSubject(); if (!currentUser.isAuthenticated()) { UsernamePasswordToken token = new UsernamePasswordToken(&quot;zhangsan&quot;, &quot;666&quot;); try { currentUser.login(token); } catch (UnknownAccountException uae) { System.out.println(&quot;用户名不存在&quot; + token.getPrincipal()); return; } catch (IncorrectCredentialsException ice) { System.out.println(&quot;密码错误 &quot;); return; } catch (AuthenticationException ae) { //unexpected condition? error? } } //进行授权操作时前提:用户必须通过认证 System. out. println (currentUser. isPermitted(&quot;user:delete&quot;)) ; //判断当前用户是否拥有某个角色:返回true表示拥有，false表示没有 System. out. println (currentUser. hasRole(&quot;role2&quot;)) ; System.out.println(&quot;----&gt;&quot; + currentUser.isAuthenticated()); currentUser.logout(); System.out.println(&quot;----&gt;&quot; + currentUser.isAuthenticated()); System.exit(0); } } realm密码加密(shiro-MD5加密核心) 散列算法一般用于生成数据的摘要信息，是一种不可逆的算法，一般适合存储密码之类的数据，常见的散列算法如MD5、SHA等。一般进行散列时最好提供一个salt (盐)，比如加密密码“admin”，产生的散列值是“21232f297a57a5a743894a0e4a801fc3”，可以到一些md5 解密网站很容易的通过散列值得到密码“admin”，即如果直接对密码进行散列相对来说破解更容易，此时我们可以加一些只有系统知道的干扰数据，如用户名和ID (即盐) ;这样散列的对象是“密码+用户名+ID”，这样生成的散列值相对来说更难破解。@Test public void testMD5() { String password = &quot;666&quot;; //密码: 明文 //加密: md5 Md5Hash md5Hash = new Md5Hash(password); //fae0b27c451c728867a567e8c1bb4e53 System.out.println(md5Hash); //加密: md5 +盐 md5Hash = new Md5Hash(password,&quot;zhangsan&quot;); //2f1f526e25fdefa341c7a302b47dd9df System.out.println(md5Hash); //加密: md5 +盐+散列次数 md5Hash = new Md5Hash(password,&quot;zhangsan&quot;, 3); //cd757bae8bd31da92c6b14c235668091 System.out.println(md5Hash); } 除了Md5外还有Sha256/Sha1/Sha512@Test public void testSHA1() { String password = &quot;666&quot;; String salt = &quot;zhangsan&quot;; //内部使用Java的 MessageDigest String simpleHash =new SimpleHash(&quot;SHA-1&quot;, password, salt).toString(); System.out.println(simpleHash); //加密: SHA-1 +盐+散列次数 simpleHash =new SimpleHash(&quot;SHA-1&quot;, password, salt,3).toString(); System.out.println(simpleHash); } @Test public void testSHA512() { String password = &quot;666&quot;; String salt = &quot;zhangsan&quot;; //内部使用Java的 MessageDigest String simpleHash =new SimpleHash(&quot;SHA-512&quot;, password, salt).toString(); //c5e7ea4b73da5aaccf48a4a2f2a5167803b41057a9f4dab0a839f96d34435b8c06b7251e91c3eb1c2439b11bf235571aa9c900f058e23f5dc6493f4b784e6812 System.out.println(simpleHash); //加密: SHA-1 +盐+散列次数 simpleHash =new SimpleHash(&quot;SHA-512&quot;, password, salt,3).toString(); //8a547800008b088817d471d36ed771eecb683ba32304993b823813f84f239722c4a830955a5670e357077484722e65f29cae550e09f347ef6543880c6b945cf9 System.out.println(simpleHash); } @Test public void testSHA256() { String password = &quot;666&quot;; String salt = &quot;zhangsan&quot;; //内部使用Java的 MessageDigest String simpleHash =new SimpleHash(&quot;SHA-256&quot;, password, salt).toString(); //df9899be7a62844417fa16c05f8994ede67f25bdf14cfa6231941ff863d5b9f5 System.out.println(simpleHash); //加密: SHA-1 +盐+散列次数 simpleHash =new SimpleHash(&quot;SHA-256&quot;, password, salt,3).toString(); //81a4636cfb7a72684eba8649ee664fe724e5c2ed4ba9043d52afcd4ac5672623 System.out.println(simpleHash); } 为了方便使用，Shiro 提供了 HashService，默认提供了 DefaultHashService 实现DefaultHashService hashService =new DefaultHashService(); //默认算法 SHA-512 hashService.setHashAlgorithmName(&quot;SHA-512&quot;); hashService.setPrivateSalt(new SimpleByteSource(&quot;zhangsan&quot;)); //私盐，默认无 hashService.setGeneratePublicSalt(true);//是否生成公盐，默认 false hashService.setRandomNumberGenerator(new SecureRandomNumberGenerator());//用于生成公盐。默认就这个 hashService.setHashIterations(1); //生成 Hash 值的迭代次数 HashRequest request =new HashRequest.Builder() .setAlgorithmName(&quot;MD5&quot;).setSource(ByteSource.Util.bytes(&quot;666&quot;)) .setSalt(ByteSource.Util.bytes(&quot;zhangsan&quot;)).setIterations(2).build(); String hex =hashService.computeHash(request).toHex(); System.out.println(hex); Shiro 还提供对称式加密/解密算法的支持，如 AES、Blowfish 等；当前还没有提供对非对称加密/解密算法支持，未来版本可能提供。@Test public void testAES() { AesCipherService aesCipherService =new AesCipherService(); aesCipherService.setKeySize(128); //设置 key 长度 //生成 key Key key = aesCipherService.generateNewKey(); String text = &quot;666&quot;; //加密 String encrptText = aesCipherService.encrypt(text.getBytes(), key.getEncoded()).toHex(); //encrptText:3b15d4e1b2a76081123c4e2a5a9379a03581aed4e5c5a546abc0c2e47c557264 System.out.println(&quot;encrptText:&quot; + encrptText); //解密 String text2 = new String(aesCipherService.decrypt(Hex.decode(encrptText), key.getEncoded()).getBytes()); System.out.println(text.equals(text2)); } Shiro 提供了 PasswordService 及 CredentialsMatcher 用于提供加密密码及验证密码服务。 Shiro 默认提供了 PasswordService 实现 DefaultPasswordService；CredentialsMatcher 实现PasswordMatcher及HashedCredentialsMatcher（更强大）。public interface PasswordService { //输入明文密码得到密文密码 String encryptPassword(ObjectplaintextPassword) throws IllegalArgumentException; } public interface CredentialsMatcher { //匹配用户输入的 token 的凭证（未加密）与系统提供的凭证（已加密） boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info); } 自定义realm完成认证授权(密码加密存储情况) 自定义加密的realmimport org.apache.shiro.authc.AuthenticationException; import org.apache.shiro.authc.AuthenticationInfo; import org.apache.shiro.authc.AuthenticationToken; import org.apache.shiro.authc.SimpleAuthenticationInfo; import org.apache.shiro.authz.AuthorizationInfo; import org.apache.shiro.realm.AuthorizingRealm; import org.apache.shiro.subject.PrincipalCollection; import org.apache.shiro.util.ByteSource; public class CustomHashPwdRealm extends AuthorizingRealm { @Override public String getName() { return this.getClass().getName(); } /** * 覆写授权 */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) { //传入参数: principals :用户认证凭证信息: //SimpleAuthenticationInfo:认证方法返回封装认证信息中第一个参数:用户信息(username)//当前登录用户名信息:用户凭证 String username = (String) principals. getPrimaryPrincipal () ; //模拟查询数据库: 查询用户实现指定的角色，以及用户权限 List&lt;String&gt; roles = new ArrayList&lt;String&gt;() ; //角色集合 List&lt;String&gt; permission = new ArrayList&lt;String&gt;(); //权限集合//假设用户在数据库中有role1角色 roles.add (&quot;role3&quot;) ; //假设用户在数据库 中拥有user:*权限 permission. add(&quot;user:*&quot;) ; //返回用户在数据库中的权限与角色 SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(); info.addRoles (roles); info.addStringPermissions(permission) ; return info; } /** * 覆写认证 */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException { String username = (String) authenticationToken.getPrincipal(); //模拟通过用户名查询数据库，将改用户对应数据查询返回: 账号与密码 //假设查询数据库返回数据是: zhangsan ,2f1f526e25fdefa341c7a302b47dd9df(666加密摘要信息) if (!&quot;zhangsan&quot;.equals(username)) { return null; } //模拟数据库中保存加密之后密文: 666 +账号(盐) +散列次数 String password = &quot;2f1f526e25fdefa341c7a302b47dd9df&quot;; //info对象表示realm登录比对信息:参数1:用户信息(真实登录中是登录对象user对象)，参数2: 密码，参数3:盐,参数4: 当前realm名字 SimpleAuthenticationInfo info = new SimpleAuthenticationInfo(username, password, ByteSource.Util.bytes(&quot;zhangsan&quot;), getName()); return info; } } 编写shiro-cryptography.ini文件[main] #定义凭证匹配器 credentialsMatcher=org.apache.shiro.authc.credential.HashedCredentialsMatcher #散列算法 credentialsMatcher.hashAlgorithmName=md5 #散列次数 credentialsMatcher.hashIterations=1 #自定义realm myRealm=com.ecit.security.CustomHashPwdRealm #将凭证匹配器设置到realm myRealm.credentialsMatcher=$credentialsMatcher #指定securityManager的realms实现 securityManager.realms=$myRealm 编写测试认证package com.ecit; import org.apache.shiro.SecurityUtils; import org.apache.shiro.authc.*; import org.apache.shiro.config.IniSecurityManagerFactory; import org.apache.shiro.mgt.SecurityManager; import org.apache.shiro.subject.Subject; import org.apache.shiro.util.Factory; public class QuickstartCustomerRealm { public static void main(String[] args) { Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(&quot;classpath:shiro-cryptography.ini&quot;); SecurityManager securityManager = factory.getInstance(); SecurityUtils.setSecurityManager(securityManager); Subject currentUser = SecurityUtils.getSubject(); if (!currentUser.isAuthenticated()) { UsernamePasswordToken token = new UsernamePasswordToken(&quot;zhangsan&quot;, &quot;666&quot;); try { currentUser.login(token); } catch (UnknownAccountException uae) { System.out.println(&quot;用户名不存在&quot; + token.getPrincipal()); return; } catch (IncorrectCredentialsException ice) { System.out.println(&quot;密码错误 &quot;); return; } catch (AuthenticationException ae) { //unexpected condition? error? } } System.out.println(&quot;----&gt;&quot; + currentUser.isAuthenticated()); currentUser.logout(); System.out.println(&quot;----&gt;&quot; + currentUser.isAuthenticated()); System.exit(0); } } 与WEB集成(通过ShiroFilter) Shiro 提供了与Web集成的支持，其通过一个ShiroFilter入口来拦截需要安全控制的URL，然后进行相应的控制 ShiroFilter 类似于如 Strut2/SpringMVC 这种web框架的前端控制器，是安全控制的入口点，其负责读取配置(如ini 配置文件)，然后判断URL 是否需要登录/权限等工作。 环境搭建初始化 需要用到的pom依赖：&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com._520it&lt;/groupId&gt; &lt;artifactId&gt;baseWebShiro&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;dependencies&gt; &lt;!-- serlvet-api --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-web&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;port&gt;80&lt;/port&gt; &lt;path&gt;/&lt;/path&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; web.xml配置(重要)&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:web=&quot;http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;3.0&quot;&gt; &lt;!--配置shiroFilter过滤器，拦截所有请求--&gt; &lt;context-param&gt; &lt;param-name&gt;shiroEnvironmentClass&lt;/param-name&gt; &lt;param-value&gt;org.apache.shiro.web.env.IniWebEnvironment&lt;/param-value&gt; &lt;/context-param&gt; &lt;context-param&gt; &lt;param-name&gt;shiroConfigLocations&lt;/param-name&gt; &lt;param-value&gt;classpath:shiro.ini&lt;/param-value&gt; &lt;/context-param&gt; &lt;!--从Shiro 1.2开始引入了Environment/WebEnvironment的概念，即由它们的实现提供相应的SecurityManager及其相应的依赖。ShiroFilter会自动找到Environment然后获取相应的依赖。--&gt; &lt;!--底层:返回反射创建shiroEnvironmentClass对象,调用其init方法.--&gt; &lt;!--shiroEnvironmentClass中的init方法创建SecurityManager实例并绑定到当前运行环境--&gt; &lt;listener&gt; &lt;listener-class&gt;org.apache.shiro.web.env.EnvironmentLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!--拦截所有的请求--&gt; &lt;filter&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.shiro.web.servlet.ShiroFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;!--拦截所有请求--&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;/web-app&gt; shiro.ini默认过滤器简称 优先级 简称 对应的Java过滤器类 描述 ① anon org.apache.shiro.web.filter.authc.AnonymousFilter anon:匿名拦截器，即不需要登录即可访问;一般用于 静态资源过滤;示例“/static/** =anon” ② authc org.apache.shiro.web.filter.authc.FormAuthenticationFilter authc:表示需要认证(登录)才能使用;示例“/**=authc”,主要属性: usernameParam:表单提交的用户名参数名(username);passwordParam:表单提交的密码参数名(password);rememberMeParam:表单提交的密码参数名(rememberMe); loginUrl:登录页面地址(/login.jsp);successUrl:登录成功后的默认重定向地址;failureKeyAttribute:登录失败后错误信息存储key(shiroLoginFailure) ③ authcBasic org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter authcBasic:Basic HTTP身份验证拦截器，主要属性: applicationName: 弹出登录框显示的信息( application) ⑤ noSessionCreation org.apache.shiro.web.filter.session.NoSessionCreationFilter 阻止在请求期间创建新的会话。以保证无状态的体验 ⑨ roles org.apache.shiro.web.filter.authz.RolesAuthorizationFilter roles:角色授权拦截器，验证用户是否拥有资源角色;示例“/admin/**=roles[admin]” ⑥ perms org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter perms:权限授权拦截器，验证用户是否拥有资源权限;示例“/user/create=perms[“user:create”]” ⑪ user org.apache.shiro.web.filter.authc.UserFilter user:用户拦截器， 用户已经身份验证/记住我登录的都可;示例“/index=user” ④ logout org.apache.shiro.web.filter.authc.LogoutFilter logout:退出拦截器，主要属性: redirectUrl: 退出成功后重定向的地址(/) ;示例“/logout=logout ⑦ port org.apache.shiro.web.filter.authz.PortFilter port:端口拦截器，主要属性: port (80) :可以通过的端口;示例“/test= port[80]”，如果用户访问该页面是非80，将自动将请求端口改为80并重定向到该80端口，其他路径/参数等都一样 ⑧ rest org.apache.shiro.web.filter.authz.HttpMethodPermissionFilter rest:rest风格拦截器，自动根据请求方法构建权限字符串(GET=read, POST=create,PUT=update,DELETE=delete,HEAD=read,TRACE=read,OPTIONS=read, MKCOL=create)构建权限字符串;示例“/users=rest[user]” ，会自动拼出“user:read,user:create,user:update,user:delete” 权限字符串进行权限匹配(所有都得匹配，isPermittedAll) ⑩ ssl org.apache.shiro.web.filter.authz.SslFilter ssl:SSL拦截器，只有请求协议是https才能通过;否则自动跳转会https端口(443) ;其他和port拦截器一样 示例shiro.ini[main] #默认是/login.jsp authc.loginUrl=/login #用户无需要的角色时跳转的页面 roles.unauthorizedUrl=/nopermission.jsp #用户无需要的权限时跳转的页面 perms.unauthorizedUrl=/nopermission.jsp #登出之后重定向的页面 logout.redirectUrl=/login [users] zhangsan=333,admin lisi=444,deptMgr [roles] admin=employee:*,department:* deptMgr=department:view [urls] #静态资源可以匿名访问 /static/**=anon #访问员工列表需要身份认证及需要拥有admin角色 /employee=authc,roles[admin] #访问部门列表需要身份认证及需要拥有department:view的权限 /department=authc,perms[&quot;department:view&quot;] #当请求loginOut,会被内置logout拦截器捕获并清除session /loginOut=logout #所有的请求都需要身份认证 /**=authc #另外如果某个拦截器不想使用了可以直接通过如下配置直接禁用: #perms.enabled=false login 的servlet逻辑 web集成shiro针对lgoin servlet不处理登陆成功(认证成功)，shiro认证成功会自动跳转到上一个请求路径import org.apache.shiro.authc.IncorrectCredentialsException; import org.apache.shiro.authc.UnknownAccountException; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(name = &quot;loginServlet&quot;, urlPatterns = &quot;/login&quot;) public class LoginServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doPost(req, resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //如果登陆失败从request中获取认证异常信息，shiroLoginFailure就是shiro异常类的全限定名 String exceptionClassName = (String) req.getAttribute(&quot;shiroLoginFailure&quot;); //根据shiro返回的异常类路径判断，抛出指定异常信息 if (exceptionClassName != null) { if (UnknownAccountException.class.getName().equals(exceptionClassName)) { //最终会拋给异常处理器 req.setAttribute(&quot;errorMsg&quot;, &quot;账号不存在&quot;); } else if (IncorrectCredentialsException.class.getName().equals(exceptionClassName)) { req.setAttribute(&quot;errorMsg&quot;, &quot;用户名/密码错误&quot;); } else { req.setAttribute(&quot;errorMsg&quot;, &quot;其他异常信息&quot;);//最终在异常处理器生成未知错误 } } //此方法不处理登陆成功(认证成功)，shiro认证成功会自动跳转到上一个请求路径 //登陆失败还到login页面 req.getRequestDispatcher(&quot;/WEB-INF/views/login.jsp&quot;).forward(req, resp); } } shiro jsp标签权限控制 标签名称 标签条件(均是显示标签内容) &lt;shiro:authenticated&gt; 登录之后 &lt;shiro:notAuthenticated&gt; 不在登录状态时 &lt;shiro:guest&gt; 用户在没有RememberMe时 &lt;shiro:user&gt; 用户在RememberMe时 &lt;shiro:hasAnyRoles name=”abc,123”&gt; 在有abc或者123角色时 &lt;shiro:hasRole name=”abc”&gt; 拥有角色abc &lt;shiro:lacksRole name=”abc”&gt; 没有角色abc &lt;shiro:hasPermission name=”abc”&gt; 拥有权限资源abc &lt;shiro:lacksPermission name=”abc”&gt; 没有abc权限资源 &lt;shiro:principal&gt; 显示用户身份名称 &lt;shiro:principal property=”username”/&gt; 显示用户身份中的属性值 示例一个部门列表标签：&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@taglib prefix=&quot;shiro&quot; uri=&quot;http://shiro.apache.org/tags&quot; %&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;部门列表&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;center&gt; &lt;h1&gt;部门列表&lt;/h1&gt; &lt;shiro:hasPermission name=&quot;department:add&quot;&gt; &lt;a href=&quot;/department?cmd=input&quot;&gt;新增&lt;/a&gt; &lt;/shiro:hasPermission&gt; &lt;br&gt; &lt;table border=&quot;1&quot;&gt; &lt;tbody&gt; &lt;tr&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;部门名称&lt;/th&gt; &lt;th&gt;&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;总裁&lt;/td&gt; &lt;td&gt; &lt;shiro:hasPermission name=&quot;department:edit&quot;&gt; &lt;a href=&quot;/department?cmd=input&amp;id=1&quot;&gt;编辑&lt;/a&gt; &lt;/shiro:hasPermission&gt; &lt;shiro:hasPermission name=&quot;department:delete&quot;&gt; &lt;a href=&quot;/department?cmd=delete&quot;&gt;删除&lt;/a&gt; &lt;/shiro:hasPermission&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/center&gt; &lt;/body&gt; &lt;/html&gt; 与Spring集成加入spring环境依赖&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.16&lt;/version&gt; &lt;/dependency&gt; &lt;!--servlet--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!--spring--&gt; &lt;!--spring框架核心的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.3.12.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--aop用到的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;4.3.12.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;aopalliance&lt;/groupId&gt; &lt;artifactId&gt;aopalliance&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.7&lt;/version&gt; &lt;/dependency&gt; &lt;!--Spring内置封装的JDBC操作工具类,数据库连接池--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;4.3.12.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--Spring内置的事物管理--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;4.3.12.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql数据库驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.45&lt;/version&gt; &lt;/dependency&gt; &lt;!--纯JUnit测试包--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--日志框架--&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt; &lt;/dependency&gt; &lt;!-- druid --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.14&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;4.0.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.0.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- jstl --&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- standard --&gt; &lt;dependency&gt; &lt;groupId&gt;taglibs&lt;/groupId&gt; &lt;artifactId&gt;standard&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--shiro-spring--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-all&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 配置配置web.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:web=&quot;http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;3.0&quot;&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath*:spring.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!--编码过滤器--&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- Shiro的过滤器（拦截所有请求） --&gt; &lt;!-- 这个过滤器只过滤，它什么功能都没有! 它什么都不做! 真正的过滤功能是在Spring中的过滤器完成的!!! 名字很重要:必需和shiro.xml中的过滤器名称一样 --&gt; &lt;filter&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;targetFilterLifecycle&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;/web-app&gt; 准备自定义realm-认证处理 第一种，不对密码加盐和散列次数强度的配置 自定义realm，不需要密码加强的@Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException { String username = (String)authenticationToken.getPrincipal(); //模拟通过用户名查询数据库，将改用户对应数据查询返回: 账号与密码 //假设查询数据库返回数据是: zhangsan 666 if(!&quot;zhangsan&quot;.equals (username)) { return null; } String password = &quot;666&quot;; //info对象表示realm登录比对信息:参数1:用户信息(真实登录中是登录对象user对象)，参数2: 密码，参数3: 当前realm名字 SimpleAuthenticationInfo info = new SimpleAuthenticationInfo(username, password, getName ()) ; return info; } 注意Spring集成shiro配置,要一致 &lt;!--引入shiro配置文件--&gt; &lt;!--配置自定义的realm--&gt; &lt;bean id=&quot;userRealm&quot; class=&quot;cn.ecit.shiro.realm.CustomRealm&quot;&gt;&lt;/bean&gt; &lt;!--配置安全管理器SecurityManager --&gt; &lt;bean id=&quot;securityManager&quot; class=&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;&gt; &lt;property name =&quot;realm&quot; ref=&quot;userRealm&quot;/&gt; &lt;/bean&gt; &lt;!--定义ShiroFilter --&gt; &lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt; &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot; /&gt; &lt;property name=&quot;loginUrl&quot; value=&quot;/login&quot;/&gt; &lt;property name=&quot;unauthorizedUrl&quot; value=&quot;/nopermission.jsp&quot;/&gt; &lt;property name=&quot;filterChainDefinitions&quot;&gt; &lt;value&gt; /**=authc &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; 第二种，要求对密码加盐和加强散列次数 自定义realm，密码加盐+散列的情况@Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException { String username = (String) authenticationToken.getPrincipal(); //模拟通过用户名查询数据库，将改用户对应数据查询返回: 账号与密码 //假设查询数据库返回数据是: zhangsan ,2f1f526e25fdefa341c7a302b47dd9df(666加密摘要信息) if (!&quot;zhangsan&quot;.equals(username)) { return null; } //模拟数据库中保存加密之后密文: 666 +账号(盐) +散列次数(3次)，可参考上文shiro-MD5核心加密 String password = &quot;cd757bae8bd31da92c6b14c235668091&quot;; //info对象表示realm登录比对信息:参数1:用户信息(真实登录中是登录对象user对象)，参数2: 密码，参数3:盐,参数4: 当前realm名字 SimpleAuthenticationInfo info = new SimpleAuthenticationInfo(username, password, ByteSource.Util.bytes(&quot;zhangsan&quot;), getName()); return info; } 与Spring集成shiro配置注意一致 &lt;!--引入shiro配置文件--&gt; &lt;!--配置自定义的realm--&gt; &lt;bean id=&quot;userRealm&quot; class=&quot;cn.ecit.shiro.realm.CustomHashPwdRealm&quot;&gt; &lt;!-- 配置MD5加密，若不进行MD5加密，这段代码不用 --&gt; &lt;property name=&quot;credentialsMatcher&quot;&gt; &lt;bean class=&quot;org.apache.shiro.authc.credential.HashedCredentialsMatcher&quot;&gt; &lt;!-- MD5加密 --&gt; &lt;property name=&quot;hashAlgorithmName&quot; value=&quot;MD5&quot;/&gt; &lt;!-- 加密次数 --&gt; &lt;property name=&quot;hashIterations&quot; value=&quot;3&quot;/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;!-- 配置MD5加密，若不进行MD5加密，这段代码不用 --&gt; &lt;/bean&gt; &lt;!--配置安全管理器SecurityManager --&gt; &lt;bean id=&quot;securityManager&quot; class=&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;&gt; &lt;property name =&quot;realm&quot; ref=&quot;userRealm&quot;/&gt; &lt;/bean&gt; &lt;!--定义ShiroFilter --&gt; &lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt; &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot; /&gt; &lt;property name=&quot;loginUrl&quot; value=&quot;/login&quot;/&gt; &lt;property name=&quot;unauthorizedUrl&quot; value=&quot;/nopermission.jsp&quot;/&gt; &lt;property name=&quot;filterChainDefinitions&quot;&gt; &lt;value&gt; /**=authc &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; 以上还需要注意两点，第一点是login控制器需要改写，第二点就是配置特殊的shiro异常处理机制 login控制器示例如下：@RequestMapping(&quot;/login&quot;) public String login(Model model, HttpServletRequest req) throws Exception{ //如果登陆失败从request中获取认证异常信息，shiroLoginFailure就是shiro异常类的全限定名 String exceptionClassName = (String) req.getAttribute(&quot;shiroLoginFailure&quot;); //根据shiro返回的异常类路径判断，抛出指定异常信息 if (exceptionClassName != null) { if (UnknownAccountException.class.getName().equals(exceptionClassName)) { //最终会拋给异常处理器 req.setAttribute(&quot;errorMsg&quot;, &quot;账号不存在&quot;); } else if (IncorrectCredentialsException.class.getName().equals(exceptionClassName)) { req.setAttribute(&quot;errorMsg&quot;, &quot;用户名/密码错误&quot;); } else { req.setAttribute(&quot;errorMsg&quot;, &quot;其他异常信息&quot;);//最终在异常处理器生成未知错误 } } //此方法不处理登陆成功(认证成功)，shiro认证成功会自动跳转到上一个请求路径 //登陆失败还到login页面 return &quot;forward:/login.jsp&quot;; } shiro异常处理&lt;!-- 定义需要特殊处理的异常，用类名或完全路径名作为key,异常页名作为值--&gt; &lt;!--shiro权限异常处理--&gt; &lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt; &lt;property name=&quot;exceptionMappings&quot;&gt; &lt;props&gt; &lt;prop key=&quot;org.apache.shiro.authz.UnauthorizedException&quot;&gt;redirect:/nopermission.jsp&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; shiro权限注解@RequiresAuthentication:表示当前Subject已经通过login 进行了身份验证;即 Subject.isAuthenticated() 返回 true @RequiresUser:表示当前 Subject 已经身份验证或者通过记 住我登录的。 @RequiresGuest:表示当前Subject没有身份验证或通过记住我登录过，即是游客身份。 @RequiresRoles(value={“admin”, “user”}, logical= Logical.AND):表示当前 Subject 需要角色 admin 和user @RequiresPermissions (value={“user:a”, “user:b”}, logical= Logical.OR):表示当前 Subject 需要权限 user:a 或 user:b。 自定义realm-静态授权处理 三中方式授权 授权方式 示例代码 优缺点 推荐指数 编程式 缺点:必须进入请求方法中才能判断是否有权限 0 jsp标签方式 缺点:虽然在页面上没有显式请求按钮，但是可以通过浏览器地址栏中输入请求访问 50 注解方式 优点，可以在请求进入方法之前进行权限控制 100 shiro注解方式AOP授权注意点 &lt;!--开启aop，对类代理--&gt; &lt;aop:config proxy-target-class=&quot;true&quot;&gt;&lt;/aop:config&gt; &lt;!--开启shiro注解支持--&gt; &lt;bean class=&quot;org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor&quot;&gt; &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot; /&gt; &lt;/bean&gt; 或者 &lt;!-- 保证实现了Shiro内部lifecycle函数的bean执行 --&gt; &lt;bean id=&quot;lifecycleBeanPostProcessor&quot; class=&quot;org.apache.shiro.spring.LifecycleBeanPostProcessor&quot;/&gt; &lt;!-- 开启Shiro注解 --&gt; &lt;bean class=&quot;org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator&quot; depends-on=&quot;lifecycleBeanPostProcessor&quot;/&gt; &lt;bean class=&quot;org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor&quot;&gt; &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;/&gt; &lt;/bean&gt; 以上开启AOP的shiro支持二选一即可，但是一定要配置在支持组件扫描包下,能够被扫描到shiro注解(Spring容器或 SpringMVC容器时)，否则可能导致shiro注解无效 静态授权模拟 @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) { String username = (String) principals.getPrimaryPrincipal() ; List&lt;String&gt; permissions = new ArrayList&lt;String&gt;() ; if (&quot;zhangsan&quot;.equals (username) ) { //员工编辑权限,静态操作方式 permissions.add (&quot;employee:edit&quot;) ; }else if (&quot;admin&quot;.equals(username)) { //拥有所有权限 permissions.add(&quot;*:*&quot;) ; } SimpleAuthorizationInfo info = new SimpleAuthorizationInfo() ; info.addStringPermissions (permissions) ; return info; } 自定义realm-动态授权处理 和上面一样需要开启shiro-AOP支持 改写自定义的realm,从数据获取角色，权限 ```java public class MyRealm extends AuthorizingRealm { @Autowired private UserService userService; /** 为登录用户授予权限和角色 / @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) { String userName = (String) principals.getPrimaryPrincipal(); SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo(); authorizationInfo.setRoles(userService.getRoles(userName)); authorizationInfo.setStringPermissions(userService.getPermissions(userName)); return authorizationInfo; } /* 验证当前登录用户 */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException { String userName = (String) token.getPrincipal(); User user = userService.getByUserName(userName); //使用md5加密 //当前realm对象的name String realmName = getName(); //盐值 ByteSource credenttialsSalt = ByteSource.Util.bytes(user.getUserName()); //封装用户信息，构建AuthenticationInfo对象并返回 AuthenticationInfo authcInfo = new SimpleAuthenticationInfo(user.getUserName(), user.getPassword(), credenttialsSalt, realmName); return authcInfo; //使用md5加密 //不加密 /* if (user != null) { AuthenticationInfo authcInfo = new SimpleAuthenticationInfo(user.getUserName(), user.getPassword(), &quot;xx&quot;); return authcInfo; } else { return null; } */ //不加密 } - 注意Spring容器更改成这个realm即可 #### 缓存支持 ```jsp 在请求中一旦进行权限的控制,如:@RequiresPermissions(&quot;employee:view&quot;)或 &lt;shiro:hasPermission name=&quot;employee:input&quot;&gt; 都去到Realm中的doGetAuthorizationInfo方法进行授权，我们授权信息应该要从数据库中查询的.如果每次授权都要去查询数据库就太频繁了,性能不好. 而且用户登陆后，授权信息一般很少变动,所有我们可以在第一 次授权后就把这些授权信息存到缓存中，下一次就直接从缓存中获取,避免频繁访问数据库. spring容器配置缓存ehcache支持 &lt;!--缓存管理器开始--&gt; &lt;bean id=&quot;cacheManager&quot; class=&quot;org.apache.shiro.cache.ehcache.EhCacheManager&quot;&gt; &lt;property name=&quot;cacheManager&quot; ref=&quot;ehCacheManager&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;ehCacheManager&quot; class=&quot;org.springframework.cache.ehcache.EhCacheManagerFactoryBean&quot;&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:shiro-ehcache.xml&quot;/&gt; &lt;property name=&quot;shared&quot; value=&quot;true&quot;&gt;&lt;/property&gt; &lt;/bean&gt; shiro-ehcache.xml配置信息 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:noNamespaceSchemaLocation=&quot;http://ehcache.org/ehcache.xsd&quot;&gt; &lt;diskStore path=&quot;java.io.tmpdir&quot;/&gt; &lt;defaultCache maxElementsInMemory=&quot;10000&quot; eternal=&quot;false&quot; timeToIdleSeconds=&quot;120&quot; timeToLiveSeconds=&quot;120&quot; maxElementsOnDisk=&quot;10000000&quot; diskExpiryThreadIntervalSeconds=&quot;120&quot; memoryStoreEvictionPolicy=&quot;LRU&quot;&gt; &lt;persistence strategy=&quot;localTempSwap&quot;/&gt; &lt;/defaultCache&gt; &lt;/ehcache&gt; spring容器配置 realm引用缓存管理器 &lt;!--配置安全管理器SecurityManager --&gt; &lt;bean id=&quot;securityManager&quot; class=&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;&gt; &lt;property name=&quot;realm&quot; ref=&quot;userRealm&quot;/&gt; &lt;property name=&quot;cacheManager&quot; ref=&quot;cacheManager&quot;/&gt; &lt;/bean&gt; 注意需要清除缓存的场景 如果用户正常退出,缓存自动清空。如果用户非正常退出,缓存自动清空。如果修改了用户的权限,而用户不退出系统,修改的权限无法立即生效。当用户权限修改后,用户再次登陆shiro会自动调用realm从数据库获取权限数据,如果在修改权限后想立即清除缓存则可以调用realm的clearCache方法清除缓存。 在realm中定义该方法: //清除缓存 public void clearCached() { PrincipalCollection principals = SecurityUtils.getSubject().getPrincipals(); super.clearCache(principals); } 在角色或权限service中,delete或者update方法去调用realm的清除缓存方法. Shiro在Spring的RememberMe设置（免登陆配置） RememberMe指的是记住我的功能，也就是说在使用RememberMe处理的时候就表示可以无需登录就可以进行操作访问了。整个的RememberMe的操作都是基于配置实现的。 RememberMe功能一定是需要在客户端保留有一个Cookie的数据，那么这个时候就一定要配置Cookie的操作模版。 让用户在一小时之内可以实现免登录的操作配置，而一小时之后就将消失1.cookie模板配置的添加&lt;!-- 配置需要向Cookie中保存数据的配置模版（RememberMe） --&gt; &lt;!-- 配置需要向Cookie中保存数据的配置模版（RememberMe） --&gt; &lt;bean id=&quot;rememberMeCookie&quot; class=&quot;org.apache.shiro.web.servlet.SimpleCookie&quot;&gt; &lt;!-- 设置Cookie在浏览器中保存内容的名字，由用户自己来设置 --&gt; &lt;constructor-arg value=&quot;ecit-RememberMe&quot;/&gt; &lt;!-- 保证该系统不会受到跨域的脚本操作供给 --&gt; &lt;property name=&quot;httpOnly&quot; value=&quot;true&quot;/&gt; &lt;!-- 定义Cookie的过期时间为一小时 7天 #{7 * 24 * 60 * 60} --&gt; &lt;property name=&quot;maxAge&quot; value=&quot;#{7 * 24 * 60 * 60}&quot;/&gt; &lt;/bean&gt; 2.随后还需要配置一个RememberMe的管理器：管理器的控制类：org.apache.shiro.web.mgt.CookieRememberMeManager&lt;!-- 定义RememberMe功能的程序管理类 --&gt; &lt;bean id=&quot;rememberMeManager&quot; class=&quot;org.apache.shiro.web.mgt.CookieRememberMeManager&quot;&gt; &lt;!--rememberMe 管理器，cipherKey 是加密 rememberMe Cookie 的密钥；默认 AES 算法；--&gt; &lt;property name=&quot;cipherKey&quot; value=&quot;#{T(org.apache.shiro.codec.Base64).decode('4AvVhmFLUs0KTA3Kprsdag==')}&quot;/&gt; &lt;!-- 定义在进行RememberMe功能实现的时候所需要使用到的Cookie的处理类 --&gt; &lt;property name=&quot;cookie&quot; ref=&quot;rememberMeCookie&quot;/&gt; &lt;/bean&gt; 3.在安全管理器里面进行RememberMe功能的加入&lt;!--配置安全管理器SecurityManager --&gt; &lt;bean id=&quot;securityManager&quot; class=&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;&gt; &lt;property name=&quot;realm&quot; ref=&quot;userRealm&quot;/&gt; &lt;property name=&quot;cacheManager&quot; ref=&quot;cacheManager&quot;/&gt; &lt;property name=&quot;sessionManager&quot; ref=&quot;sessionManager&quot;/&gt; &lt;property name=&quot;rememberMeManager&quot; ref=&quot;rememberMeManager&quot;/&gt; &lt;/bean&gt; 4.如果要进行RememberMe功能操作，实际上还需要表单上进行一个复选框的添加,这个复选框的内容是需要严格控制好的，只能够使用“true”；&lt;input type=&quot;checkbox&quot; name=&quot;rememberMe&quot; value=&quot;true&quot;&gt;记住密码&lt;br&gt; 5.修改登录控制器,注意要与你的login.jsp 或 login.action页面的参数值对应&lt;!-- 此处表示使用内置的表单登录控制验证 --&gt; &lt;bean id=&quot;formAuthenticationFilter&quot; class=&quot;org.apache.shiro.web.filter.authc.FormAuthenticationFilter&quot;&gt; &lt;!-- 定义出需要使用的参数，此参数与表单一一对应 --&gt; &lt;property name=&quot;usernameParam&quot; value=&quot;username&quot;/&gt; &lt;property name=&quot;passwordParam&quot; value=&quot;password&quot;/&gt; &lt;property name=&quot;rememberMeParam&quot; value=&quot;rememberMe&quot;/&gt; &lt;property name=&quot;loginUrl&quot; value=&quot;/login&quot;/&gt; &lt;/bean&gt; Shiro-集成验证码Kaptcha 为了防止通过程序进行暴力登录等, 系统在登录时都会增加验证码用来分区是人为登录还是使用程序登录.验证码的原理很简单: 在用户访问登录页面时请求服务器生成验证码, 服务器将生成的验证码保存至SESSION后生成验证码图片并显示在登录页面, 由于程序识别图片内容的成功率较低, 而人可以很快识别图片中的内容, 以此减少非人为的登录等非法操作. 技术发展到今天, 程序识别图片内容的成功率越来越高, 验证码的交互形式也越来越多. 本文已最简单的图片验证码为例, 讲解Shiro中如何实现集成验证码 集成Kaptcha Kaptcha是谷歌开源的一个验证码插件, 通过在Web.xml中配置内置的Servlet即可实现生成验证码.&lt;dependency&gt; &lt;groupId&gt;com.github.penggle&lt;/groupId&gt; &lt;artifactId&gt;kaptcha&lt;/artifactId&gt; &lt;version&gt;2.3.2&lt;/version&gt; &lt;/dependency&gt; Web.xml增加Kaptcha内置Servlet配置&lt;servlet&gt; &lt;servlet-name&gt;Kaptcha&lt;/servlet-name&gt; &lt;servlet-class&gt;com.google.code.kaptcha.servlet.KaptchaServlet&lt;/servlet-class&gt; &lt;!-- 参数: 验证码图片高度 --&gt; &lt;init-param&gt; &lt;param-name&gt;kaptcha.image.width&lt;/param-name&gt; &lt;param-value&gt;200&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;Kaptcha&lt;/servlet-name&gt; &lt;url-pattern&gt;/kaptcha&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet&gt; &lt;servlet-name&gt;Kaptcha&lt;/servlet-name&gt; &lt;servlet-class&gt;com.google.code.kaptcha.servlet.KaptchaServlet&lt;/servlet-class&gt; &lt;!-- 参数: 验证码图片高度 --&gt; &lt;init-param&gt; &lt;param-name&gt;kaptcha.image.width&lt;/param-name&gt; &lt;param-value&gt;200&lt;/param-value&gt; &lt;param-name&gt;kaptcha.border&lt;/param-name&gt; &lt;param-value&gt;yes&lt;/param-value&gt; &lt;param-name&gt;kaptcha.border.color&lt;/param-name&gt; &lt;param-value&gt;#FFFF00&lt;/param-value&gt; &lt;param-name&gt;kaptcha.background.clear.from&lt;/param-name&gt; &lt;param-value&gt;yellow&lt;/param-value&gt; &lt;param-name&gt;kaptcha.background.clear.to&lt;/param-name&gt; &lt;param-value&gt;red&lt;/param-value&gt; &lt;param-name&gt;kaptcha.obscurificator.impl&lt;/param-name&gt; &lt;param-value&gt;com.google.code.kaptcha.impl.ShadowGimpy&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;Kaptcha&lt;/servlet-name&gt; &lt;url-pattern&gt;/imgVerCode&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; Kaptcha内置的属性可以使用init-param进行配置, 下面列出常用的配置信息, 更多请参考官方文档: kaptcha.border 是否有边框, 默认有 kaptcha.border.color 边框颜色, 使用RGB值或white, red等颜色单次, 默认黑色 kaptcha.border.thickness 边框宽度, 默认1px kaptcha.image.width 验证码图片宽度 kaptcha.image.height 验证码图片高度 kaptcha.textproducer.char.string 验证码字符内容, 默认abcde2345678gfynmnpwx kaptcha.textproducer.char.length 验证码字符数量, 默认5 kaptcha.textproducer.font.names 字体名称, 默认Arial/Courier, kaptcha.textproducer.font.size 字体大小, 默认40px kaptcha.textproducer.font.color 字体颜色, 默认黑色 kaptcha.session.key 保存SESSION时的KEY, 默认KAPTCHA_SESSION_KEY kaptcha.background.clear.from 背景渐变色起始颜色, RGB色值, 默认浅灰 kaptcha.background.clear.to 背景渐变色结束颜色, RGB色值, 默认白色 需要自定义一个“org.apache.shiro.web.filter.authc.FormAuthenticationFilter”它的子类，而后覆写该类中的指定方法。 package cn.ecit.shiro.filter; import org.apache.shiro.web.filter.authc.FormAuthenticationFilter; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpSession; public class CustomerFormAuthenticationFilter extends FormAuthenticationFilter { private String codeParam = &quot;code&quot;; @Override protected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception { // 1、如果要想取得在Session中出现的验证码，则必须取得HttpSession接口对象 HttpServletRequest req = (HttpServletRequest) request ; HttpSession session = req.getSession() ; // 取得当前的session对象 String rand = (String) session.getAttribute(&quot;KAPTCHA_SESSION_KEY&quot;) ; // 取得谷歌默认session中对应key的验证码值 // 2、取得用户提交表单过来的验证码数据 String code = request.getParameter(codeParam) ; if (rand == null || code == null || &quot;&quot;.equals(rand) || &quot;&quot;.equals(code)) { request.setAttribute(&quot;errorMsg&quot;, &quot;验证码不允许为空！&quot;); return true; // 拒绝访问，不再进行用户名或密码的检测 } else { if (!code.equalsIgnoreCase(rand)) { // 验证码输入错误 request.setAttribute(&quot;errorMsg&quot;, &quot;验证码输入错误！&quot;); return true ; } } return super.onAccessDenied(request, response); // 操作继续向后执行 } public void setCodeParam(String codeParam) { this.codeParam = codeParam; } public String getCodeParam() { return codeParam; } } 修改已有的表单登录检测器： &lt;!-- 此处表示使用内置的表单登录控制验证 --&gt; &lt;bean id=&quot;formAuthenticationFilter&quot; class=&quot;cn.ecit.shiro.filter.CustomerFormAuthenticationFilter&quot;&gt; &lt;!-- 定义出需要使用的参数，此参数与表单一一对应 --&gt; &lt;property name=&quot;usernameParam&quot; value=&quot;username&quot;/&gt; &lt;property name=&quot;passwordParam&quot; value=&quot;password&quot;/&gt; &lt;property name=&quot;rememberMeParam&quot; value=&quot;rememberMe&quot;/&gt; &lt;property name=&quot;codeParam&quot; value=&quot;code&quot;/&gt; &lt;property name=&quot;loginUrl&quot; value=&quot;/login&quot;/&gt; &lt;/bean&gt; 修改shiroFilter，把验证码获取添加为 anon访问，注意anon路径的排在前面，过滤器执行的顺序性 &lt;!--定义ShiroFilter --&gt; &lt;!-- /department = user 表示访问该地址的用户是身份验证通过或 RememberMe 登录的都可以--&gt; &lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt; &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;/&gt; &lt;property name=&quot;loginUrl&quot; value=&quot;/login.jsp&quot;/&gt; &lt;property name=&quot;unauthorizedUrl&quot; value=&quot;/nopermission.jsp&quot;/&gt; &lt;property name=&quot;filterChainDefinitions&quot;&gt; &lt;value&gt; /logout = logout /imgVerCode = anon /login = formAuthenticationFilter /department = user /** = authc &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; 登录页面调整，login.jsp &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html;charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css&quot;&gt; &lt;script src=&quot;https://cdn.staticfile.org/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; body { padding: 10px; } #inputtext1, #inputtext1{ width: 100%; } #login{ width: 300px; margin:0px auto; padding-top: 60px; } #flushimg{ text-decoration: underline; } #butt{ width: 60%; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;login&quot;&gt; &lt;form action=&quot;/login&quot; method=&quot;post&quot;&gt; &lt;h2 align=&quot;center&quot;&gt;登录系统&lt;/h2&gt;&lt;br/&gt;&lt;br/&gt; &lt;span style=&quot;color: red;&quot;&gt;${errorMsg}&lt;/span&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; class=&quot;form-control&quot; id=&quot;inputtext1&quot; required autofocus placeholder=&quot;-----请输入用户名-----&quot;/&gt;&lt;br/&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; class=&quot;form-control&quot; id=&quot;inputtext2&quot; required placeholder=&quot;----请输入用户密码----&quot;/&gt;&lt;br/&gt; &lt;div id=&quot;flushimg&quot;&gt; &lt;img alt=&quot;验证码&quot; onclick=&quot;this.src='/imgVerCode?d=' + new Date().getTime()&quot; src=&quot;/imgVerCode&quot; /&gt; &lt;a&gt;看不清？点击图片刷新一下&lt;/a&gt; &lt;/div&gt; &lt;input type=&quot;text&quot; name=&quot;code&quot; class=&quot;form-control&quot; required placeholder=&quot;-----请输入验证码-----&quot; /&gt; &lt;input type=&quot;checkbox&quot; name=&quot;rememberMe&quot;/&gt;记住我&lt;br/&gt; &lt;div style=&quot;width: 100%;text-align: center;&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;登 录&quot; id=&quot;butt&quot; class=&quot;btn btn-success&quot; /&gt;&lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 测试效果： Shiro限制同一账号登录人数与剔除 在某些项目中可能会遇到如每个账户同时只能有一个人登录或几个人同时登录，如果同时有多人登录：要么不让后者登录；要么踢出前者登录（强制退出）。比如 spring security 就直接提供了相应的功能；Shiro 的话没有提供默认实现，不过可以很容易的在 Shiro 中加入这个功能。通过 Shiro Filter 机制扩展 KickoutSessionControlFilter 完成。 KickoutSessionControlFilter实现示例```javapackage cn.ecit.shiro.filter;import org.apache.shiro.cache.Cache;import org.apache.shiro.cache.CacheManager;import org.apache.shiro.session.Session;import org.apache.shiro.session.mgt.DefaultSessionKey;import org.apache.shiro.session.mgt.SessionManager;import org.apache.shiro.subject.Subject;import org.apache.shiro.web.filter.AccessControlFilter;import org.apache.shiro.web.util.WebUtils;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import java.io.Serializable;import java.util.Deque;import java.util.LinkedList;public class KickoutSessionControlFilter extends AccessControlFilter { private String kickoutUrl; //踢出后到的地址 private boolean kickoutAfter = false; //踢出之前登录的/之后登录的用户 默认踢出之前登录的用户 private int maxSession = 1; //同一个帐号最大会话数 默认1 private SessionManager sessionManager; private Cache&lt;String, Deque&gt; cache; public void setKickoutUrl(String kickoutUrl) { this.kickoutUrl = kickoutUrl; } public void setKickoutAfter(boolean kickoutAfter) { this.kickoutAfter = kickoutAfter; } public void setMaxSession(int maxSession) { this.maxSession = maxSession; } public void setSessionManager(SessionManager sessionManager) { this.sessionManager = sessionManager; } public void setCacheManager(CacheManager cacheManager) { this.cache = cacheManager.getCache(“shiro-kickout-session”); } @Override protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception { return false; } @Override protected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception { Subject subject = getSubject(request, response); if (!subject.isAuthenticated() &amp;&amp; !subject.isRemembered()) { //如果没有登录，直接结束之后的流程 return true; } Session session = subject.getSession(); String username = (String) subject.getPrincipal(); Serializable sessionId = session.getId(); // 同步控制 Deque deque = cache.get(username); if (deque == null) { deque = new LinkedList(); cache.put(username, deque); } //如果队列里没有此sessionId，且用户没有被踢出；放入队列 if (!deque.contains(sessionId) &amp;&amp; session.getAttribute(“kickout”) == null) { deque.push(sessionId); } //如果队列里的sessionId数超出最大会话数，开始踢人 while (deque.size() &gt; maxSession) { Serializable kickoutSessionId = null; if (kickoutAfter) { //如果踢出后者 kickoutSessionId = deque.removeFirst(); } else { //否则踢出前者 kickoutSessionId = deque.removeLast(); } try { Session kickoutSession = sessionManager.getSession(new DefaultSessionKey(kickoutSessionId)); if (kickoutSession != null) { //设置会话的kickout属性表示踢出了 kickoutSession.setAttribute(“kickout”, true); } } catch (Exception e) {//ignore exception } } //如果被踢出了，直接退出，重定向到踢出后的地址 if (session.getAttribute(“kickout”) != null) { //会话被踢出了 try { System.out.println(“会话被踢出了,强制下线:sessionId” + subject.getSession().getId()); subject.logout(); } catch (Exception e) { //ignore } saveRequest(request); WebUtils.issueRedirect(request, response, kickoutUrl); return false; } return true; } } &gt;此处使用了 Cache 缓存用户名—会话 id 之间的关系;如果量比较大可以考虑如持久化到数 据库/其他带持久化的 Cache 中;另外此处没有并发控制的同步实现，可以考虑根据用户名 获取锁来控制，减少锁的粒度。 - kickoutSessionControlFilter在Spring容器配置 ```xml &lt;bean id=&quot;kickoutSessionControlFilter&quot; class=&quot;cn.ecit.shiro.filter.KickoutSessionControlFilter&quot;&gt; &lt;property name=&quot;cacheManager&quot; ref=&quot;cacheManager&quot;/&gt; &lt;property name=&quot;sessionManager&quot; ref=&quot;sessionManager&quot;/&gt; &lt;property name=&quot;kickoutAfter&quot; value=&quot;false&quot;/&gt; &lt;property name=&quot;maxSession&quot; value=&quot;1&quot;/&gt; &lt;property name=&quot;kickoutUrl&quot; value=&quot;/login.jsp&quot;/&gt; &lt;/bean&gt; &lt;!-- cacheManager：使用 cacheManager 获取相应的 cache 来缓存用户登录的会话；用于保存用户—会话之间的关系的； sessionManager：用于根据会话 ID，获取会话进行踢出操作的； kickoutAfter：是否踢出后来登录的，默认是 false；即后者登录的用户踢出前者登录的用户； maxSession：同一个用户最大的会话数，默认 1；比如 2 的意思是同一个用户允许最多同时两个人登录； kickoutUrl：被踢出后重定向到的地址； --&gt; shiroFilter 配置,此处配置除了登录等之外的地址都走 kickout 拦截器进行并发登录控制。&lt;!--定义ShiroFilter --&gt; &lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt; &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;/&gt; &lt;property name=&quot;loginUrl&quot; value=&quot;/login.jsp&quot;/&gt; &lt;property name=&quot;unauthorizedUrl&quot; value=&quot;/nopermission.jsp&quot;/&gt; &lt;property name=&quot;filterChainDefinitions&quot;&gt; &lt;value&gt; /logout = logout /imgVerCode = anon /login = formAuthenticationFilter /department = user /** = kickout,authc &lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;filters&quot;&gt; &lt;map&gt; &lt;entry key=&quot;kickout&quot; value-ref=&quot;kickoutSessionControlFilter&quot;/&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt; 以上完结，就可以打开两个浏览器，用同一个账号登录测试是否被踢出一个 附录shiro与Spring集成-spring.xml全部配置&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:jee=&quot;http://www.springframework.org/schema/jee&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;!--1:引入数据源配置文件--&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot; system-properties-mode=&quot;NEVER&quot;/&gt; &lt;context:component-scan base-package=&quot;cn.ecit.shiro.dao&quot;/&gt; &lt;!--2：配置数据源--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; init-method=&quot;init&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driverClassName}&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--引入shiro配置文件--&gt; &lt;!--配置自定义的realm--&gt; &lt;bean id=&quot;userRealm&quot; class=&quot;cn.ecit.shiro.realm.CustomHashPwdRealm&quot;&gt; &lt;!-- 配置MD5加密，若不进行MD5加密，这段代码不用 --&gt; &lt;property name=&quot;credentialsMatcher&quot;&gt; &lt;bean class=&quot;org.apache.shiro.authc.credential.HashedCredentialsMatcher&quot;&gt; &lt;!-- MD5加密 --&gt; &lt;property name=&quot;hashAlgorithmName&quot; value=&quot;MD5&quot;/&gt; &lt;!-- 加密次数 --&gt; &lt;property name=&quot;hashIterations&quot; value=&quot;3&quot;/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;!-- 配置MD5加密，若不进行MD5加密，这段代码不用 --&gt; &lt;/bean&gt; &lt;!--配置安全管理器SecurityManager --&gt; &lt;bean id=&quot;securityManager&quot; class=&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;&gt; &lt;property name=&quot;realm&quot; ref=&quot;userRealm&quot;/&gt; &lt;property name=&quot;cacheManager&quot; ref=&quot;cacheManager&quot;/&gt; &lt;property name=&quot;sessionManager&quot; ref=&quot;sessionManager&quot;/&gt; &lt;property name=&quot;rememberMeManager&quot; ref=&quot;rememberMeManager&quot;/&gt; &lt;/bean&gt; &lt;!--定义ShiroFilter --&gt; &lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt; &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;/&gt; &lt;property name=&quot;loginUrl&quot; value=&quot;/login.jsp&quot;/&gt; &lt;property name=&quot;unauthorizedUrl&quot; value=&quot;/nopermission.jsp&quot;/&gt; &lt;property name=&quot;filterChainDefinitions&quot;&gt; &lt;value&gt; /logout = logout /imgVerCode = anon /login = formAuthenticationFilter /department = user /** = kickout,authc &lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;filters&quot;&gt; &lt;map&gt; &lt;entry key=&quot;kickout&quot; value-ref=&quot;kickoutSessionControlFilter&quot;/&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 定义需要特殊处理的异常，用类名或完全路径名作为key,异常页名作为值--&gt; &lt;!--shiro权限异常处理--&gt; &lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt; &lt;property name=&quot;exceptionMappings&quot;&gt; &lt;props&gt; &lt;prop key=&quot;org.apache.shiro.authz.UnauthorizedException&quot;&gt;redirect:/nopermission.jsp&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!--缓存管理器开始--&gt; &lt;bean id=&quot;cacheManager&quot; class=&quot;org.apache.shiro.cache.ehcache.EhCacheManager&quot;&gt; &lt;property name=&quot;cacheManager&quot; ref=&quot;ehCacheManager&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;ehCacheManager&quot; class=&quot;org.springframework.cache.ehcache.EhCacheManagerFactoryBean&quot;&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:shiro-ehcache.xml&quot;/&gt; &lt;property name=&quot;shared&quot; value=&quot;true&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 会话ID生成器 --&gt; &lt;bean id=&quot;sessionIdGenerator&quot; class=&quot;org.apache.shiro.session.mgt.eis.JavaUuidSessionIdGenerator&quot;/&gt; &lt;!-- 配置会话 DAO的操作处理 --&gt; &lt;bean id=&quot;sessionDAO&quot; class=&quot;cn.ecit.shiro.dao.MySessionDao&quot;&gt; &lt;!-- 设置session缓存的名字，这个名字可以任意 --&gt; &lt;property name=&quot;activeSessionsCacheName&quot; value=&quot;shiro-activeSessionCache&quot;/&gt; &lt;!-- 定义该Session DAO操作中所使用的ID生成器 --&gt; &lt;property name=&quot;sessionIdGenerator&quot; ref=&quot;sessionIdGenerator&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置需要向Cookie中保存数据的配置模版 --&gt; &lt;bean id=&quot;sessionIdCookie&quot; class=&quot;org.apache.shiro.web.servlet.SimpleCookie&quot;&gt; &lt;!-- 在Tomcat运行下默认使用的Cookie的名字为JSESSIONID --&gt; &lt;constructor-arg value=&quot;ecit-session-id&quot;/&gt; &lt;!-- 保证该系统不会受到跨域的脚本操作供给 --&gt; &lt;property name=&quot;httpOnly&quot; value=&quot;true&quot;/&gt; &lt;!-- 定义Cookie的过期时间，单位为秒，如果设置为-1表示浏览器关闭，则Cookie消失,演示5分钟 --&gt; &lt;property name=&quot;maxAge&quot; value=&quot;-1&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置需要向Cookie中保存数据的配置模版（RememberMe） --&gt; &lt;bean id=&quot;rememberMeCookie&quot; class=&quot;org.apache.shiro.web.servlet.SimpleCookie&quot;&gt; &lt;!-- 设置Cookie在浏览器中保存内容的名字，由用户自己来设置 --&gt; &lt;constructor-arg value=&quot;ecit-RememberMe&quot;/&gt; &lt;!-- 保证该系统不会受到跨域的脚本操作供给 --&gt; &lt;property name=&quot;httpOnly&quot; value=&quot;true&quot;/&gt; &lt;!-- 定义Cookie的过期时间为一小时 7天 #{7 * 24 * 60 * 60} --&gt; &lt;property name=&quot;maxAge&quot; value=&quot;#{7 * 24 * 60 * 60}&quot;/&gt; &lt;/bean&gt; &lt;!-- 定义会话管理器的操作 --&gt; &lt;bean id=&quot;sessionManager&quot; class=&quot;org.apache.shiro.web.session.mgt.DefaultWebSessionManager&quot;&gt; &lt;!-- 定义的是全局的session会话超时时间，此操作会覆盖web.xml文件中的超时时间配置 --&gt; &lt;!-- 全局的会话信息时间,,单位为毫秒 30分钟 --&gt; &lt;property name=&quot;globalSessionTimeout&quot; value=&quot;1800000&quot;/&gt; &lt;!-- 删除所有无效的Session对象，此时的session被保存在了内存里面 --&gt; &lt;property name=&quot;deleteInvalidSessions&quot; value=&quot;true&quot;/&gt; &lt;!-- 定义要使用的无效的Session定时调度器 --&gt; &lt;property name=&quot;sessionValidationScheduler&quot; ref=&quot;sessionValidationScheduler&quot;/&gt; &lt;!-- 需要让此session可以使用该定时调度器进行检测 --&gt; &lt;property name=&quot;sessionValidationSchedulerEnabled&quot; value=&quot;true&quot;/&gt; &lt;!-- 定义Session可以进行序列化的工具类 --&gt; &lt;property name=&quot;sessionDAO&quot; ref=&quot;sessionDAO&quot;/&gt; &lt;!-- 所有的session一定要将id设置到Cookie之中，需要提供有Cookie的操作模版 --&gt; &lt;property name=&quot;sessionIdCookie&quot; ref=&quot;sessionIdCookie&quot;/&gt; &lt;!-- 定义sessionIdCookie模版可以进行操作的启用 --&gt; &lt;property name=&quot;sessionIdCookieEnabled&quot; value=&quot;true&quot;/&gt; &lt;!-- 去掉URL中的JSESSIONID --&gt; &lt;property name=&quot;sessionIdUrlRewritingEnabled&quot; value=&quot;true&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置session的定时验证检测程序类，以让无效的session释放 --&gt; &lt;bean id=&quot;sessionValidationScheduler&quot; class=&quot;org.apache.shiro.session.mgt.quartz.QuartzSessionValidationScheduler&quot;&gt; &lt;!-- 设置session的失效扫描间隔，单位为毫秒 --&gt; &lt;property name=&quot;sessionValidationInterval&quot; value=&quot;60000&quot;/&gt; &lt;!-- 随后还需要定义有一个会话管理器的程序类的引用 --&gt; &lt;property name=&quot;sessionManager&quot; ref=&quot;sessionManager&quot;/&gt; &lt;/bean&gt; &lt;!-- 定义RememberMe功能的程序管理类 --&gt; &lt;bean id=&quot;rememberMeManager&quot; class=&quot;org.apache.shiro.web.mgt.CookieRememberMeManager&quot;&gt; &lt;!--rememberMe 管理器，cipherKey 是加密 rememberMe Cookie 的密钥；默认 AES 算法；--&gt; &lt;property name=&quot;cipherKey&quot; value=&quot;#{T(org.apache.shiro.codec.Base64).decode('4AvVhmFLUs0KTA3Kprsdag==')}&quot;/&gt; &lt;!-- 定义在进行RememberMe功能实现的时候所需要使用到的Cookie的处理类 --&gt; &lt;property name=&quot;cookie&quot; ref=&quot;rememberMeCookie&quot;/&gt; &lt;/bean&gt; &lt;!-- 此处表示使用内置的表单登录控制验证 --&gt; &lt;bean id=&quot;formAuthenticationFilter&quot; class=&quot;cn.ecit.shiro.filter.CustomerFormAuthenticationFilter&quot;&gt; &lt;!-- 定义出需要使用的参数，此参数与表单一一对应 --&gt; &lt;property name=&quot;usernameParam&quot; value=&quot;username&quot;/&gt; &lt;property name=&quot;passwordParam&quot; value=&quot;password&quot;/&gt; &lt;property name=&quot;rememberMeParam&quot; value=&quot;rememberMe&quot;/&gt; &lt;property name=&quot;codeParam&quot; value=&quot;code&quot;/&gt; &lt;property name=&quot;loginUrl&quot; value=&quot;/login&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;kickoutSessionControlFilter&quot; class=&quot;cn.ecit.shiro.filter.KickoutSessionControlFilter&quot;&gt; &lt;property name=&quot;cacheManager&quot; ref=&quot;cacheManager&quot;/&gt; &lt;property name=&quot;sessionManager&quot; ref=&quot;sessionManager&quot;/&gt; &lt;property name=&quot;kickoutAfter&quot; value=&quot;false&quot;/&gt; &lt;property name=&quot;maxSession&quot; value=&quot;1&quot;/&gt; &lt;property name=&quot;kickoutUrl&quot; value=&quot;/login.jsp&quot;/&gt; &lt;/bean&gt; &lt;/beans&gt; shiro与Spring集成-mvc.xml全部配置&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:jee=&quot;http://www.springframework.org/schema/jee&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd &quot;&gt; &lt;!--1:配置DI注解解析器--&gt; &lt;context:annotation-config/&gt; &lt;!--2:配置IoC注解解析器--&gt; &lt;context:component-scan base-package=&quot;cn.ecit.shiro.web.controller&quot;/&gt; &lt;!--3：配置mvc注解解析器--&gt; &lt;mvc:annotation-driven/&gt; &lt;!--4：静态资源处理--&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!--5：配置视图解析器--&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/views/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt; &lt;!-- 保证实现了Shiro内部lifecycle函数的bean执行 --&gt; &lt;bean id=&quot;lifecycleBeanPostProcessor&quot; class=&quot;org.apache.shiro.spring.LifecycleBeanPostProcessor&quot;/&gt; &lt;!-- 开启Shiro注解 --&gt; &lt;bean class=&quot;org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator&quot; depends-on=&quot;lifecycleBeanPostProcessor&quot;/&gt; &lt;bean class=&quot;org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor&quot;&gt; &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;/&gt; &lt;/bean&gt; &lt;/beans&gt; shiro与Spring集成-shiro-ehcache.xml全部配置&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:noNamespaceSchemaLocation=&quot;http://ehcache.org/ehcache.xsd&quot;&gt; &lt;diskStore path=&quot;java.io.tmpdir&quot;/&gt; &lt;defaultCache maxElementsInMemory=&quot;10000&quot; eternal=&quot;false&quot; timeToIdleSeconds=&quot;120&quot; timeToLiveSeconds=&quot;120&quot; maxElementsOnDisk=&quot;10000000&quot; diskExpiryThreadIntervalSeconds=&quot;120&quot; memoryStoreEvictionPolicy=&quot;LRU&quot;&gt; &lt;persistence strategy=&quot;localTempSwap&quot;/&gt; &lt;/defaultCache&gt; &lt;cache name=&quot;shiro-activeSessionCache&quot; maxElementsInMemory=&quot;1000&quot; eternal=&quot;false&quot; timeToIdleSeconds=&quot;1800&quot; timeToLiveSeconds=&quot;1800&quot; overflowToDisk=&quot;false&quot; diskPersistent=&quot;false&quot; statistics=&quot;true&quot; memoryStoreEvictionPolicy=&quot;LRU&quot;/&gt; &lt;/ehcache&gt; shiro与Spring集成-web.xml配置&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:web=&quot;http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;3.0&quot;&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath*:spring.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;listener&gt; &lt;listener-class&gt;cn.ecit.shiro.utils.MySessionListener1&lt;/listener-class&gt; &lt;/listener&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet&gt; &lt;servlet-name&gt;Kaptcha&lt;/servlet-name&gt; &lt;servlet-class&gt;com.google.code.kaptcha.servlet.KaptchaServlet&lt;/servlet-class&gt; &lt;!-- 参数: 验证码图片高度 --&gt; &lt;init-param&gt; &lt;param-name&gt;kaptcha.image.width&lt;/param-name&gt; &lt;param-value&gt;200&lt;/param-value&gt; &lt;param-name&gt;kaptcha.border&lt;/param-name&gt; &lt;param-value&gt;yes&lt;/param-value&gt; &lt;param-name&gt;kaptcha.border.color&lt;/param-name&gt; &lt;param-value&gt;#FFFF00&lt;/param-value&gt; &lt;param-name&gt;kaptcha.background.clear.from&lt;/param-name&gt; &lt;param-value&gt;yellow&lt;/param-value&gt; &lt;param-name&gt;kaptcha.background.clear.to&lt;/param-name&gt; &lt;param-value&gt;red&lt;/param-value&gt; &lt;param-name&gt;kaptcha.obscurificator.impl&lt;/param-name&gt; &lt;param-value&gt;com.google.code.kaptcha.impl.ShadowGimpy&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;Kaptcha&lt;/servlet-name&gt; &lt;url-pattern&gt;/imgVerCode&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!--编码过滤器--&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- Shiro的过滤器（拦截所有请求） --&gt; &lt;!-- 这个过滤器只过滤，它什么功能都没有! 它什么都不做! 真正的过滤功能是在Spring中的过滤器完成的!!! 名字很重要:必需和shiro.xml中的过滤器名称一样 --&gt; &lt;filter&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;targetFilterLifecycle&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;/web-app&gt; shiro与Spring集成-所用到的pom依赖&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.wolfcode&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;name&gt;shiro-spring Maven Webapp&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.16&lt;/version&gt; &lt;/dependency&gt; &lt;!--servlet--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!--spring--&gt; &lt;!--spring框架核心的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.3.12.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--aop用到的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;4.3.12.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;aopalliance&lt;/groupId&gt; &lt;artifactId&gt;aopalliance&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.7&lt;/version&gt; &lt;/dependency&gt; &lt;!--Spring内置封装的JDBC操作工具类,数据库连接池--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;4.3.12.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--Spring内置的事物管理--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;4.3.12.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql数据库驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.45&lt;/version&gt; &lt;/dependency&gt; &lt;!--纯JUnit测试包--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--日志框架--&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt; &lt;/dependency&gt; &lt;!-- druid --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.14&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;4.0.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.0.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--shiro-spring--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-all&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.github.penggle/kaptcha --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.penggle&lt;/groupId&gt; &lt;artifactId&gt;kaptcha&lt;/artifactId&gt; &lt;version&gt;2.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;shiro-spring&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;port&gt;80&lt;/port&gt; &lt;path&gt;/&lt;/path&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; 推荐shiro书籍","link":"/2017/12/15/framework/security/shiro/shiro%E7%AC%AC%E4%B8%80%E7%AF%87/"},{"title":"Tomcat的结构配置","text":"Tomcat的目录结构 修改端口号tomcat安装完，默认的端口是8080,如果现在要想修改端口号的话，则可以打开Tomcat目录中的conf/server.xml文件： &lt;Connector port=&quot;80&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot;&gt; port tomcat作为一个网络server端,它需要暴露一个socket端口来accept客户端的链接,可以通过port指定. protocol 使用的网络协议,表示tomcat使用何种方式来接受和处理client端请求,“HTTP/1.1”是默认值,等效于”org.apache.coyote.http11.Http11Protocol”;还有熟悉的”AJP/1.3”;关于HTTP和AJP两种方式的区别和性能优劣可以参见其他文档. 在Tomcat 6.0之后,还提供了NIO的方式,可以有效的提升性能,特别是在大量长连接/数据上传+下载等web应用中.此时portocal=”org.apache.coyote.http11.Http11NioProtocol”. connectionTimeout 当client与tomcat建立连接之后,在”connectionTimeout”时间之内,仍然没有得到client的请求数据,此时连接将会被断开.此值的设定需要考虑到网络稳定型,同时也有性能的考虑.它和tcp的配置选项中的”socket_timeout”仍有区别,connectionTimeout只会在链接建立之后,得到client发送http-request信息前有效. maxHeaderCount http请求中header的最大个数,默认为100,”-1”表示不限制,通常不会关注此属性,不过在一些设计”扭曲”的web应用中,使用header传递大量参数(:post)和校验信息时,可能需要调整此值.如果请求中的header个数超过此限定值,请求将会被拒绝. maxParameterCount http-get请求中允许传递的查询字符串的最大个数,尽管各种http浏览器(proxy工具)都会对http-get请求的长度和查询字符串的个数有限制,你仍然可以通过tomcat再次设定合适的值.parameter个数越多,事实上对tomcat的内存开支更大,很多时候处于安全或者实用的角度考虑,maxParameterCount的值都不会太大.默认值为10000,”-1”表示无限制.如果请求中参数的个数超过限定值,请求将会被拒绝. maxPostSize http-post请求中数据(body)的最大尺寸,单位:byte,默认值为2M.这对一些表单提交(较多文本域)有影响.可以适度调整此值,大文件上传一般会在client拆分成小文件,而不是直接发送. URIEncoding http-get请求中,使用何种字符集对查询字符串进行编码,默认为”iso-8859-1”. useBodyEncodingForURI 是否使用”Content-type”中指定的编码方式对http-get请求中查询字符串进行编码.如果为”true”,将会忽略”URIEncoding”配置项,转而使用header中”content-Type”指定的编码方式. maxThreads 用于接收和处理client端请求的最大线程数,tomcat底层将采取线程池的方式来处理客户端请求,此参数标识这线程池的尺寸.maxThreads意味着tomcat能够并发执行request的个数.此值默认为200.一般情况下,在production环境中(根据物理机器配置,或者虚拟机的限制来做参考值),通常会有微调.较大的值并不能提升tomcat的负载能力,事实上”200”个线程数,已经足够大了.本人的线上环境为maxThreads=120. compression是否对http相应数据启用Gzip压缩,可选值为”off”或者”on”;这是一个值得商榷的参数;如果开启压缩,意味着较少的网络传输量,但是将消耗一定的CPU.如果你的应用有较高的CPU性能结余,且响应数据均是一些文本字符串,那么开启压缩,会有较大的收益. 配置虚拟目录 在Tomcat服务器的配置中，最重要的就是配置虚拟目录的操作，每一个虚拟目录都保存了一个完整的web项目。 一个虚拟目录中必须包含WEB-INF/web.xml文件，此文件可以直接从已有的项目中复制出来。 增加配置虚拟目录节点： 找到Tomcat目录中的conf/server.xml 在 &lt;Host /&gt;上一行，添加下面内容，注意d:\\app1， 必须要建立有 WEB-INF/web.xml文件 &lt;Context path=&quot;/app1&quot; docBase=&quot;d:\\app1&quot; /&gt; path:为浏览器上的输入路径 http://127.0.0.1:8080/app1,此名称**必须要有 斜杠开头，否则tomcat闪退关闭。docBase:配置项目的磁盘路径，此目录下必须有WEB-INF/web.xml文件**查看服务器目录列表是否关闭了到tomcat的 conf目录下找到 web.xml，搜索到 一个 listings，安全性考虑 一定要把此值设置为false，小结 Tomcat是一个免费WEB容器 项目的发布需要配置虚拟目录，所有的配置都在server.xml中完成 交互性是动态WEB的最大特点。 虚拟目录对比原来 &lt;?xml version='1.0' encoding='utf-8'?&gt; &lt;Server port=&quot;8005&quot; shutdown=&quot;SHUTDOWN&quot;&gt; &lt;!--APR library loader. Documentation at /docs/apr.html --&gt; &lt;Listener className=&quot;org.apache.catalina.core.AprLifecycleListener&quot; SSLEngine=&quot;on&quot; /&gt; &lt;!--Initialize Jasper prior to webapps are loaded. Documentation at /docs/jasper-howto.html --&gt; &lt;Listener className=&quot;org.apache.catalina.core.JasperListener&quot; /&gt; &lt;!-- Prevent memory leaks due to use of particular java/javax APIs--&gt; &lt;Listener className=&quot;org.apache.catalina.core.JreMemoryLeakPreventionListener&quot; /&gt; &lt;!-- JMX Support for the Tomcat server. Documentation at /docs/non-existent.html --&gt; &lt;Listener className=&quot;org.apache.catalina.mbeans.ServerLifecycleListener&quot; /&gt; &lt;Listener className=&quot;org.apache.catalina.mbeans.GlobalResourcesLifecycleListener&quot; /&gt; &lt;GlobalNamingResources&gt; &lt;Resource name=&quot;UserDatabase&quot; auth=&quot;Container&quot; type=&quot;org.apache.catalina.UserDatabase&quot; description=&quot;User database that can be updated and saved&quot; factory=&quot;org.apache.catalina.users.MemoryUserDatabaseFactory&quot; pathname=&quot;conf/tomcat-users.xml&quot; /&gt; &lt;/GlobalNamingResources&gt; &lt;Service name=&quot;Catalina&quot;&gt; &lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; &lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt; &lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot; jvmRoute=&quot;tomcat2&quot;&gt; &lt;Realm className=&quot;org.apache.catalina.realm.UserDatabaseRealm&quot; resourceName=&quot;UserDatabase&quot;/&gt; &lt;Host name=&quot;localhost&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot; xmlValidation=&quot;false&quot; xmlNamespaceAware=&quot;false&quot;&gt; &lt;/Host&gt; &lt;/Engine&gt; &lt;/Service&gt; &lt;/Server&gt; 添加虚拟目录的 server.xml &lt;?xml version='1.0' encoding='utf-8'?&gt; &lt;Server port=&quot;8005&quot; shutdown=&quot;SHUTDOWN&quot;&gt; &lt;!--APR library loader. Documentation at /docs/apr.html --&gt; &lt;Listener className=&quot;org.apache.catalina.core.AprLifecycleListener&quot; SSLEngine=&quot;on&quot; /&gt; &lt;!--Initialize Jasper prior to webapps are loaded. Documentation at /docs/jasper-howto.html --&gt; &lt;Listener className=&quot;org.apache.catalina.core.JasperListener&quot; /&gt; &lt;!-- Prevent memory leaks due to use of particular java/javax APIs--&gt; &lt;Listener className=&quot;org.apache.catalina.core.JreMemoryLeakPreventionListener&quot; /&gt; &lt;!-- JMX Support for the Tomcat server. Documentation at /docs/non-existent.html --&gt; &lt;Listener className=&quot;org.apache.catalina.mbeans.ServerLifecycleListener&quot; /&gt; &lt;Listener className=&quot;org.apache.catalina.mbeans.GlobalResourcesLifecycleListener&quot; /&gt; &lt;GlobalNamingResources&gt; &lt;Resource name=&quot;UserDatabase&quot; auth=&quot;Container&quot; type=&quot;org.apache.catalina.UserDatabase&quot; description=&quot;User database that can be updated and saved&quot; factory=&quot;org.apache.catalina.users.MemoryUserDatabaseFactory&quot; pathname=&quot;conf/tomcat-users.xml&quot; /&gt; &lt;/GlobalNamingResources&gt; &lt;Service name=&quot;Catalina&quot;&gt; &lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; &lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt; &lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot; jvmRoute=&quot;tomcat1&quot;&gt; &lt;Realm className=&quot;org.apache.catalina.realm.UserDatabaseRealm&quot; resourceName=&quot;UserDatabase&quot;/&gt; &lt;!-- Define the default virtual host Note: XML Schema validation will not work with Xerces 2.2. --&gt; &lt;Host name=&quot;localhost&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot; xmlValidation=&quot;false&quot; xmlNamespaceAware=&quot;false&quot;&gt; &lt;Context path=&quot;/test&quot; docBase=&quot;/Users/sxm/Desktop/test&quot; /&gt; &lt;/Host&gt; &lt;/Engine&gt; &lt;/Service&gt; &lt;/Server&gt;","link":"/2014/10/07/javaee/web%E5%AE%B9%E5%99%A8/tomcat/tomcat-%E7%BB%93%E6%9E%84%E9%85%8D%E7%BD%AE/"},{"title":"tomcat7配置nio和线程池","text":"Tomcat7 优化配置配置tomcat管理员账户tomcat 的conf/ tomcat-users.xml下添加用户： &lt;role rolename=&quot;manager&quot;/&gt; &lt;role rolename=&quot;manager-gui&quot;/&gt; &lt;role rolename=&quot;admin&quot;/&gt; &lt;role rolename=&quot;admin-gui&quot;/&gt; &lt;user username=&quot;tomcat&quot; password=&quot;tomcat&quot; roles=&quot;admin-gui,admin,manager-gui,manager&quot;/&gt; tomcat的3种运行模式tomcat的运行模式有3种： 1、bio 默认的模式,性能非常低下,没有经过任何优化处理和支持. 2、nio 利用java的异步io护理技术,no blocking IO技术. 3、apr 安装起来最困难,但是从操作系统级别来解决异步的IO问题,大幅度的提高性能. 启动nio模式修改server.xml里的Connector节点,修改protocol为org.apache.coyote.http11.Http11NioProtocol 执行器(线程池)在tomcat中每一个用户请求都是一个线程，所以可以使用线程池提高性能。 开启并且使用最佳实践 &lt;Executor name=&quot;tomcatThreadPool&quot; namePrefix=&quot;catalina-exec-&quot; maxThreads=&quot;800&quot; minSpareThreads=&quot;100&quot; maxQueueSize=&quot;100&quot; prestartminSpareThreads=&quot;true&quot;/&gt; &lt;Connector executor=&quot;tomcatThreadPool&quot; port=&quot;8080&quot; protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; 运行示例效果： 连接器（Connector）Connector是Tomcat接收请求的入口，每个Connector有自己专属的监听端口Connector有两种：HTTP Connector和AJP Connector最佳实践 &lt;Connector executor=&quot;tomcatThreadPool&quot; port=&quot;8080&quot; protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; enableLookups=&quot;false&quot; maxPostSize=&quot;10485760&quot; URIEncoding=&quot;UTF-8&quot; acceptCount=&quot;100&quot; acceptorThreadCount=&quot;2&quot; disableUploadTimeout=&quot;true&quot; maxConnections=&quot;10000&quot; SSLEnabled=&quot;false&quot; /&gt; 禁用AJP连接器AJP（Apache JServer Protocol）AJPv13协议是面向包的。WEB服务器和Servlet容器通过TCP连接来交互；为了节省SOCKET创建的昂贵代价，WEB服务器会尝试维护一个永久TCP连接到servlet容器，并且在多个请求和响应周期过程会重用连接。","link":"/2016/12/08/javaee/web%E5%AE%B9%E5%99%A8/tomcat/tomcat%E9%85%8D%E7%BD%AEnio%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/"},{"title":"tomcat集群配置安装","text":"osx系统默认已经装过 Apache默认的moduls目录路径 /usr/libexec/apache2默认的配置文件路径 /etc/apache2默认的日志文件 ErrorLog “/private/var/log/apache2/error_log”默认的访问目录 DocumentRoot “/Library/WebServer/Documents”默认的启动命令 /usr/sbin/httpd 自己手动安装的 httpd-2.4.29brew install httpd安装的路径，配置都在一个目录下 ：/usr/local/Cellar/httpd/2.4.29_1moduls目录： /usr/local/Cellar/httpd/2.4.29_1/lib/httpd/modules配置文件: /usr/local/etc/httpd tomcat集群示意图 Apache + mod_jk + tomcat 实现的负载均衡负载均衡器在一些大公司采用F5负载均衡交换机作为负载均衡服务器，然后将请求转发给 tomcat但是F5设备动辄几十万，所以一些小公司采用采用开源的 apache或 Nginx来实现负载均衡 软件apache是 apache的http服务器，用于消息转发，mod_jk 也叫JK，这是一款 Apache./IIS用来连接后台 Tomcat的连接器，支持集群和负载均衡 安装 apache服务器 下载地址: http://archive.apache.org/dist/httpd/下载mod_jk(osx,针对系统环境来选) 地址:http://archive.apache.org/dist/tomcat/tomcat-connectors/jk/binaries/macosx/配置mod_jk和 apache将下载后的 mod_jk-1.2.25-httpd-2.2.6.so(要和自己系统版本匹配) 放到 modules目录下,然后在/conf目录下创建一个 mod_jk.conf 在 mod_jk.conf中添加如下内容 ###### 加载 mod_jk Module LoadModule jk_module lib/httpd/modules/mod_jk.so ###### 指定 workers.properties文件路径 JkWorkersFile /usr/local/etc/httpd/workers.properties ###### 定那些请求交给 tomcat处理&quot; controller&quot;为在 workers. propertise里指定的负载分配控制器名 JkMount /* controller **ps:apache2以后版本都是手动编译 mod_jk** **下载tomcat-connectors** https://tomcat.apache.org/download-connectors.cgi 或者 http://mirrors.shu.edu.cn/apache/tomcat/tomcat-connectors/jk/tomcat-connectors-1.2.42-src.tar.gz 解压进到 native目录 ，编译 ./configure --with-apxs=/usr/local/Cellar/httpd/2.4.29_1//bin/apxs &amp;&amp; make 再次进入到apache2目录就可以看到 mod_jk.so ,把它拷贝到httpd的moduls目录下 配置 conf/workers.properties#server worker.list = controller #==========tomcat1====== #ajp13端口号,在 tomcat下 server.xm1配置,默认8080 worker.tomcat1.port=8009 #tomcat的主机地址,如不为本机,请填写ip地址 worker.tomcat1.host=localhost #协议类型 worker.tomcat1.type=ajp13 #server的加权比重,值越高,分得的请求越多。1 worker.tomcat1.lbfactor=1 #####==========tomcat2============ worker.tomcat2.port=9009 worker.tomcat2.host=localhost worker.tomcat2.type=ajp13 worker.tomcat2.lbfactor=1 #####=================controller负载均衡控制器================ #####负载均衡控制器类型，1bfactor是负载均衡因数 worker.controller.type=lb #####===============指定分担请求的tomcat列表===================== worker.controller.balanced_workers=tomcat1,tomcat2 #####===============粘性session(默认是打开的)当该属性值=true(或1时)，代表session是粘性的，即同一session在集群中的同一个节点上处理,session不跨越节点.在集群环境中，一般将该值设置为false worker.controller.sticky_session=false #####==============设置用于负载均衡的server的session可否共享,1:共享 worker.controller.sticky_session_force=1 最后在 conf/httpd.conf添加如下内容:Include /usr/local/etc/httpd/mod_jk.conf到此负载均衡服务器配置完成 配置tomcat，开启集群修改tomcat1 conf\\server.xml，在配置中添加 jvmRoute=”tomcat1”,名称与worker.controller.balanced_workers=tomcat1,tomcat2对应 然后再下添加如下内容： &lt;Cluster className=&quot;org.apache.catalina.ha.tcp.SimpleTcpCluster&quot; channelSendOptions=&quot;8&quot;&gt; &lt;Manager className=&quot;org.apache.catalina.ha.session.DeltaManager&quot; expireSessionsOnShutdown=&quot;false&quot; notifyListenersOnReplication=&quot;true&quot;/&gt; &lt;Channel className=&quot;org.apache.catalina.tribes.group.GroupChannel&quot;&gt; &lt;Membership className=&quot;org.apache.catalina.tribes.membership.McastService&quot; address=&quot;228.0.0.4&quot; port=&quot;45564&quot; frequency=&quot;500&quot; dropTime=&quot;3000&quot;/&gt; &lt;Receiver className=&quot;org.apache.catalina.tribes.transport.nio.NioReceiver&quot; address=&quot;auto&quot; port=&quot;4000&quot; autoBind=&quot;100&quot; selectorTimeout=&quot;5000&quot; maxThreads=&quot;6&quot;/&gt; &lt;Sender className=&quot;org.apache.catalina.tribes.transport.ReplicationTransmitter&quot;&gt; &lt;Transport className=&quot;org.apache.catalina.tribes.transport.nio.PooledParallelSender&quot;/&gt; &lt;/Sender&gt; &lt;Interceptor className=&quot;org.apache.catalina.tribes.group.interceptors.TcpFailureDetector&quot;/&gt; &lt;Interceptor className=&quot;org.apache.catalina.tribes.group.interceptors.MessageDispatch15Interceptor&quot;/&gt; &lt;/Channel&gt; &lt;Valve className=&quot;org.apache.catalina.ha.tcp.ReplicationValve&quot; filter=&quot;&quot;/&gt; &lt;Valve className=&quot;org.apache.catalina.ha.session.JvmRouteBinderValve&quot;/&gt; &lt;Deployer className=&quot;org.apache.catalina.ha.deploy.FarmWarDeployer&quot; tempDir=&quot;/tmp/war-temp/&quot; deployDir=&quot;/tmp/war-deploy/&quot; watchDir=&quot;/tmp/war-listen/&quot; watchEnabled=&quot;false&quot;/&gt; &lt;ClusterListener className=&quot;org.apache.catalina.ha.session.JvmRouteSessionIDBinderListener&quot;/&gt; &lt;ClusterListener className=&quot;org.apache.catalina.ha.session.ClusterSessionListener&quot;/&gt; &lt;/Cluster&gt; 同理开启 tomcat2的集群注意在一台模拟时避免端口冲突，修改端口与第一台tomcat的不同shutdown 对应的端口可修改为 9005connector 对应的端口可改为 9080ajp 对应的端口可改为 9009 要与workers.properties保持一致 测试 重启apache /usr/local/Cellar/httpd/2.4.29_1/bin/httpd -k start 启动tomcat1 和 tomcat2要么先配置 JAVA_OPTS=”-Djava.net.preferIPv4Stack=true”要么在 控制台临时 export JAVA_OPTS=”-Djava.net.preferIPv4Stack=true”./catalina.sh run 在浏览器访问 http://localhost/ 会出现 mod_jk log 可在 /usr/local/Cellar/httpd/2.4.29_1/logs 下查看 测试session共享 TestServletimport javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; public class TestServlet extends HttpServlet { private static final long serialVersionUID = -4508299817031218675L; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doPost(request, response); } public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String method = request.getParameter(&quot;method&quot;); String key = request.getParameter(&quot;key&quot;); if(!&quot;&quot;.equals(key)){ if(&quot;add&quot;.equals(method)){ String value = request.getParameter(&quot;value&quot;); request.getSession().setAttribute(key, value); } else { request.getSession().removeAttribute(key); } } response.sendRedirect(request.getContextPath()); } } index.jsp&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt; &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;pragma&quot; content=&quot;no-cache&quot;&gt; &lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache&quot;&gt; &lt;meta http-equiv=&quot;expires&quot; content=&quot;0&quot;&gt; &lt;meta http-equiv=&quot;keywords&quot; content=&quot;keyword1,keyword2,keyword3&quot;&gt; &lt;meta http-equiv=&quot;description&quot; content=&quot;This is my page&quot;&gt; &lt;!-- &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;styles.css&quot;&gt; --&gt; &lt;/head&gt; &lt;body&gt; server info : ${pageContext.request.localAddr}:${pageContext.request.localPort} &lt;br&gt; &lt;br&gt; session ID : ${pageContext.session.id} &lt;br&gt; &lt;br&gt; session属性列表 &lt;table border=&quot;1&quot; width=&quot;450px&quot;&gt; &lt;tr&gt; &lt;th&gt;key&lt;/th&gt;&lt;th&gt;value&lt;/th&gt; &lt;/tr&gt; &lt;c:forEach items=&quot;${pageContext.session.attributeNames}&quot; var=&quot;attr&quot;&gt; &lt;tr&gt; &lt;td align=&quot;center&quot;&gt;${attr}&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;${sessionScope[attr]}&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/table&gt; &lt;br&gt; 添加： &lt;form action=&quot;${pageContext.request.contextPath}/servlet/TestServlet?method=add&quot; method=&quot;post&quot;&gt; key:&lt;input type=&quot;text&quot; name=&quot;key&quot;&gt;value:&lt;input type=&quot;text&quot; name=&quot;value&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;添加&quot;&gt; &lt;/form&gt; 移除： &lt;form action=&quot;${pageContext.request.contextPath}/servlet/TestServlet?method=del&quot; method=&quot;post&quot;&gt; key:&lt;input type=&quot;text&quot; name=&quot;key&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;移除&quot;&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 打包成 test.war可以直接放到 tomcat1/webapps 和 tomcat2/webapps集群session共享效果 节点插拔测试：停掉tomcat1，刷新多次后发现就剩一个tomcat2后仍然可以继续运行,重启tomcat1,session可同步","link":"/2014/10/08/javaee/web%E5%AE%B9%E5%99%A8/tomcat/tomcat%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"},{"title":"RocketMQ-核心功能","text":"1. MQ介绍1.1 作用消息队列是一种“先进先出”的数据结构应用场景主要包含以下3个方面 应用解耦 系统的耦合性越高，容错性就越低。以电商应用为例，用户创建订单后，如果耦合调用库存系统、物流系统、支付系统，任何一个子系统出了故障或者因为升级等原因暂时不可用，都会造成下单操作异常，影响用户使用体验。使用消息队列解耦合。比如物流系统发生故障，需要几分钟才能来修复，在这段时间内，物流系统要处理的数据被缓存到消息队列中，用户的下单操作正常完成。当物流系统恢复后，补充处理存在消息队列中的订单消息即可，终端系统感知不到物流系统发生过几分钟故障。 流量削峰 应用系统如果遇到系统请求流量的瞬间猛增，有可能会将系统压垮。有了消息队列可以将大量请求缓存起来，分散到很长一段时间处理，这样可以大大提到系统的稳定性和用户体验。一般情况，为了保证系统的稳定性，如果系统负载超过阈值，就会阻止用户请求，这会影响用户体验，而如果使用消息队列将请求缓存起来，等待系统处理完毕后通知用户下单完毕，这样总比不能下单体验要好。处于经济考量目的:业务系统正常时段的QPS如果是1000，流量最高峰是10000，为了应对流量高峰配置高性能的服务器显然不划算，这时可以使用消息队列对峰值流量削峰 数据分发 通过消息队列可以让数据在多个系统更加之间进行流通。数据的产生方不需要关心谁来使用数据，只需要将数据发送到消息队列，数据使用方直接在消息队列中直接获取数据即可 1.2 注意事项及MQ优点和缺点优点：解耦、削峰、数据分发 缺点包含以下几点： 系统可用性降低系统引入的外部依赖越多，系统稳定性越差。一旦MQ宕机，就会对业务造成影响。如何保证MQ的高可用？ 系统复杂度提高MQ的加入大大增加了系统的复杂度，以前系统间是同步的远程调用，现在是通过MQ进行异步调用。如何保证消息没有被重复消费？怎么处理消息丢失情况？那么保证消息传递的顺序性？ 一致性问题A系统处理完业务，通过MQ给B、C、D三个系统发消息数据，如果B系统、C系统处理成功，D系统处理失败。如何保证消息数据处理的一致性？ 1.3 各MQ产品比较常见的MQ产品包括Kafka、ActiveMQ、RabbitMQ、RocketMQ。 2. RocketMQ环境搭建RocketMQ是阿里巴巴2016年MQ中间件，使用Java语言开发，在阿里内部，RocketMQ承接了例如“双11”等高并发场景的消息流转，能够处理万亿级别的消息。 2.1 环境准备以RocketMQ版本：4.4.0为例.rocketmq-all-4.4.0-bin-release下载地址：http://archive.apache.org/dist/rocketmq/环境要求： Linux64位系统 JDK1.8(64位) 源码安装需要安装Maven 3.2.x 2.2 安装RocketMQ2.2.1 安装步骤以二进制包方式安装 解压安装包 进入安装目录 2.2.2 目录介绍 bin：启动脚本，包括shell脚本和CMD脚本 conf：实例配置文件 ，包括broker配置文件、logback配置文件等 lib：依赖jar包，包括Netty、commons-lang、FastJSON等 2.3 启动RocketMQ 启动NameServer# 1.启动NameServer nohup sh bin/mqnamesrv &amp; # 2.查看启动日志 tail -f ~/logs/rocketmqlogs/namesrv.log 启动Broker# 1.启动Broker nohup sh bin/mqbroker -n localhost:9876 &amp; # 2.查看启动日志 tail -f ~/logs/rocketmqlogs/broker.log 问题描述：RocketMQ默认的虚拟机内存较大，启动Broker如果因为内存不足失败，需要编辑如下两个配置文件，修改JVM内存大小编辑bin目录下的 runbroker.sh和runserver.sh修改默认JVM大小vi runbroker.shvi runserver.sh单机演示参考设置：JAVA_OPT=&quot;${JAVA_OPT} -server -Xms256m -Xmx256m -Xmn128m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m&quot; 2.4 测试RocketMQ2.4.1 发送消息# 1.设置环境变量 export NAMESRV_ADDR=localhost:9876 # 2.使用安装包的Demo发送消息 sh bin/tools.sh org.apache.rocketmq.example.quickstart.Producer 2.4.2接收消息# 1.设置环境变量 export NAMESRV_ADDR=localhost:9876 # 2.接收消息 sh bin/tools.sh org.apache.rocketmq.example.quickstart.Consumer 2.5 关闭RocketMQ# 1.关闭NameServer sh bin/mqshutdown namesrv # 2.关闭Broker sh bin/mqshutdown broker 3. RocketMQ高可用集群搭建3.1 集群各角色介绍 Producer：消息的发送者；举例：发信者 Consumer：消息接收者；举例：收信者 Broker：暂存和传输消息；举例：邮局 NameServer：管理Broker；举例：各个邮局的管理机构 Topic：区分消息的种类；一个发送者可以发送消息给一个或者多个Topic；一个消息的接收者可以订阅一个或者多个Topic消息 Message Queue：相当于是Topic的分区；用于并行发送和接收消息 3.2 集群搭建模式3.2.1 集群特点 NameServer是一个几乎无状态节点，可集群部署，节点之间无任何信息同步。 Broker部署相对复杂，Broker分为Master与Slave，一个Master可以对应多个Slave，但是一个Slave只能对应一个Master，Master与Slave的对应关系通过指定相同的BrokerName，不同的BrokerId来定义，BrokerId为0表示Master，非0表示Slave。Master也可以部署多个。每个Broker与NameServer集群中的所有节点建立长连接，定时注册Topic信息到所有NameServer。 Producer与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer取Topic路由信息，并向提供Topic服务的Master建立长连接，且定时向Master发送心跳。Producer完全无状态，可集群部署。 Consumer与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer取Topic路由信息，并向提供Topic服务的Master、Slave建立长连接，且定时向Master、Slave发送心跳。Consumer既可以从Master订阅消息，也可以从Slave订阅消息，订阅规则由Broker配置决定。 3.2.2 集群模式 单Master模式这种方式风险较大，一旦Broker重启或者宕机时，会导致整个服务不可用。不建议线上环境使用,可以用于本地测试。 多Master模式一个集群无Slave，全是Master，例如2个Master或者3个Master，这种模式的优缺点如下：**优点:**配置简单，单个Master宕机或重启维护对应用无影响，在磁盘配置为RAID10时，即使机器宕机不可恢复情况下，由于RAID10磁盘非常可靠，消息也不会丢（异步刷盘丢失少量消息，同步刷盘一条不丢），性能最高；缺点：单台机器宕机期间，这台机器上未被消费的消息在机器恢复之前不可订阅，消息实时性会受到影响。 多Master多Slave模式（异步）每个Master配置一个Slave，有多对Master-Slave，HA采用异步复制方式，主备有短暂消息延迟（毫秒级），这种模式的优缺点如下：优点：即使磁盘损坏，消息丢失的非常少，且消息实时性不会受影响，同时Master宕机后，消费者仍然可以从Slave消费，而且此过程对应用透明，不需要人工干预，性能同多Master模式几乎一样；缺点：Master宕机，磁盘损坏情况下会丢失少量消息。 多Master多Slave模式（同步）每个Master配置一个Slave，有多对Master-Slave，HA采用同步双写方式，即只有主备都写成功，才向应用返回成功，这种模式的优缺点如下：优点：数据与服务都无单点故障，Master宕机情况下，消息无延迟，服务可用性与数据可用性都非常高；缺点：性能比异步复制模式略低（大约低10%左右），发送单个消息的RT会略高，且目前版本在主节点宕机后，备机不能自动切换为主机。 3.3 双主双从集群搭建3.3.1总体架构消息高可用采用2m-2s（同步双写）方式 3.3.2集群工作流程 启动NameServer，NameServer起来后监听端口（默认9876），等待Broker、Producer、Consumer连上来，相当于一个路由控制中心。 Broker启动，跟所有的NameServer保持长连接，定时发送心跳包。心跳包中包含当前Broker信息(IP+端口等)以及存储所有Topic信息。注册成功后，NameServer集群中就有Topic跟Broker的映射关系。 收发消息前，先创建Topic，创建Topic时需要指定该Topic要存储在哪些Broker上，也可以在发送消息时自动创建Topic。 Producer发送消息，启动时先跟NameServer集群中的其中一台建立长连接，并从NameServer中获取当前发送的Topic存在哪些Broker上，轮询从队列列表中选择一个队列，然后与队列所在的Broker建立长连接从而向Broker发消息。 Consumer跟Producer类似，跟其中一台NameServer建立长连接，获取当前订阅Topic存在哪些Broker上，然后直接跟Broker建立连接通道，开始消费消息。 3.3.3 服务器环境 序号 IP 角色 架构模式 1 192.168.25.135 nameserver、brokerserver Master1、Slave2 2 192.168.25.138 nameserver、brokerserver Master2、Slave1 3.3.4 Host添加信息 vim /etc/hosts 配置如下： # nameserver 192.168.25.135 rocketmq-nameserver1 192.168.25.138 rocketmq-nameserver2 # broker 192.168.25.135 rocketmq-master1 192.168.25.135 rocketmq-slave2 192.168.25.138 rocketmq-master2 192.168.25.138 rocketmq-slave1 完成配置后，重启网卡 systemctl restart network 3.3.5 防火墙配置宿主机需要远程访问虚拟机的rocketmq服务和web服务，需要开放相关的端口号，简单粗暴的方式是直接关闭防火墙 # 关闭防火墙 systemctl stop firewalld.service # 查看防火墙的状态 firewall-cmd --state # 禁止firewall开机启动 systemctl disable firewalld.service 或者为了安全，只开放特定的端口号，RocketMQ默认使用3个端口：9876 、10911 、11011 。如果防火墙没有关闭的话，那么防火墙就必须开放这些端口： nameserver 默认使用 9876 端口master 默认使用 10911 端口slave 默认使用11011 端口 执行以下命令： # 开放name server默认端口 firewall-cmd --remove-port=9876/tcp --permanent # 开放master默认端口 firewall-cmd --remove-port=10911/tcp --permanent # 开放slave默认端口 (当前集群模式可不开启) firewall-cmd --remove-port=11011/tcp --permanent # 重启防火墙 firewall-cmd --reload 3.3.6 环境变量配置vim /etc/profile 在profile文件的末尾加入如下命令 #set rocketmq ROCKETMQ_HOME=/usr/local/rocketmq/rocketmq-all-4.4.0-bin-release PATH=$PATH:$ROCKETMQ_HOME/bin export ROCKETMQ_HOME PATH 输入:wq! 保存并退出， 并使得配置立刻生效： source /etc/profile 3.3.7 创建消息存储路径mkdir /usr/local/rocketmq/store mkdir /usr/local/rocketmq/store/commitlog mkdir /usr/local/rocketmq/store/consumequeue mkdir /usr/local/rocketmq/store/index 3.3.8 broker配置文件1) master1服务器：192.168.25.135 vi /usr/soft/rocketmq/conf/2m-2s-sync/broker-a.properties 修改配置如下： #所属集群名字 brokerClusterName=rocketmq-cluster #broker名字，注意此处不同的配置文件填写的不一样 brokerName=broker-a #0 表示 Master，&gt;0 表示 Slave brokerId=0 #nameServer地址，分号分割 namesrvAddr=rocketmq-nameserver1:9876;rocketmq-nameserver2:9876 #在发送消息时，自动创建服务器不存在的topic，默认创建的队列数 defaultTopicQueueNums=4 #是否允许 Broker 自动创建Topic，建议线下开启，线上关闭 autoCreateTopicEnable=true #是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭 autoCreateSubscriptionGroup=true #Broker 对外服务的监听端口 listenPort=10911 #删除文件时间点，默认凌晨 4点 deleteWhen=04 #文件保留时间，默认 48 小时 fileReservedTime=120 #commitLog每个文件的大小默认1G mapedFileSizeCommitLog=1073741824 #ConsumeQueue每个文件默认存30W条，根据业务情况调整 mapedFileSizeConsumeQueue=300000 #destroyMapedFileIntervalForcibly=120000 #redeleteHangedFileInterval=120000 #检测物理文件磁盘空间 diskMaxUsedSpaceRatio=88 #存储路径 storePathRootDir=/usr/local/rocketmq/store #commitLog 存储路径 storePathCommitLog=/usr/local/rocketmq/store/commitlog #消费队列存储路径存储路径 storePathConsumeQueue=/usr/local/rocketmq/store/consumequeue #消息索引存储路径 storePathIndex=/usr/local/rocketmq/store/index #checkpoint 文件存储路径 storeCheckpoint=/usr/local/rocketmq/store/checkpoint #abort 文件存储路径 abortFile=/usr/local/rocketmq/store/abort #限制的消息大小 maxMessageSize=65536 #flushCommitLogLeastPages=4 #flushConsumeQueueLeastPages=2 #flushCommitLogThoroughInterval=10000 #flushConsumeQueueThoroughInterval=60000 #Broker 的角色 #- ASYNC_MASTER 异步复制Master #- SYNC_MASTER 同步双写Master #- SLAVE brokerRole=SYNC_MASTER #刷盘方式 #- ASYNC_FLUSH 异步刷盘 #- SYNC_FLUSH 同步刷盘 flushDiskType=SYNC_FLUSH #checkTransactionMessageEnable=false #发消息线程池数量 #sendMessageThreadPoolNums=128 #拉消息线程池数量 #pullMessageThreadPoolNums=128 2) slave2服务器：192.168.25.135 vi /usr/soft/rocketmq/conf/2m-2s-sync/broker-b-s.properties 修改配置如下： #所属集群名字 brokerClusterName=rocketmq-cluster #broker名字，注意此处不同的配置文件填写的不一样 brokerName=broker-b #0 表示 Master，&gt;0 表示 Slave brokerId=1 #nameServer地址，分号分割 namesrvAddr=rocketmq-nameserver1:9876;rocketmq-nameserver2:9876 #在发送消息时，自动创建服务器不存在的topic，默认创建的队列数 defaultTopicQueueNums=4 #是否允许 Broker 自动创建Topic，建议线下开启，线上关闭 autoCreateTopicEnable=true #是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭 autoCreateSubscriptionGroup=true #Broker 对外服务的监听端口 listenPort=11011 #删除文件时间点，默认凌晨 4点 deleteWhen=04 #文件保留时间，默认 48 小时 fileReservedTime=120 #commitLog每个文件的大小默认1G mapedFileSizeCommitLog=1073741824 #ConsumeQueue每个文件默认存30W条，根据业务情况调整 mapedFileSizeConsumeQueue=300000 #destroyMapedFileIntervalForcibly=120000 #redeleteHangedFileInterval=120000 #检测物理文件磁盘空间 diskMaxUsedSpaceRatio=88 #存储路径 storePathRootDir=/usr/local/rocketmq/store #commitLog 存储路径 storePathCommitLog=/usr/local/rocketmq/store/commitlog #消费队列存储路径存储路径 storePathConsumeQueue=/usr/local/rocketmq/store/consumequeue #消息索引存储路径 storePathIndex=/usr/local/rocketmq/store/index #checkpoint 文件存储路径 storeCheckpoint=/usr/local/rocketmq/store/checkpoint #abort 文件存储路径 abortFile=/usr/local/rocketmq/store/abort #限制的消息大小 maxMessageSize=65536 #flushCommitLogLeastPages=4 #flushConsumeQueueLeastPages=2 #flushCommitLogThoroughInterval=10000 #flushConsumeQueueThoroughInterval=60000 #Broker 的角色 #- ASYNC_MASTER 异步复制Master #- SYNC_MASTER 同步双写Master #- SLAVE brokerRole=SLAVE #刷盘方式 #- ASYNC_FLUSH 异步刷盘 #- SYNC_FLUSH 同步刷盘 flushDiskType=ASYNC_FLUSH #checkTransactionMessageEnable=false #发消息线程池数量 #sendMessageThreadPoolNums=128 #拉消息线程池数量 #pullMessageThreadPoolNums=128 3) master2服务器：192.168.25.138 vi /usr/soft/rocketmq/conf/2m-2s-sync/broker-b.properties 修改配置如下: #所属集群名字 brokerClusterName=rocketmq-cluster #broker名字，注意此处不同的配置文件填写的不一样 brokerName=broker-b #0 表示 Master，&gt;0 表示 Slave brokerId=0 #nameServer地址，分号分割 namesrvAddr=rocketmq-nameserver1:9876;rocketmq-nameserver2:9876 #在发送消息时，自动创建服务器不存在的topic，默认创建的队列数 defaultTopicQueueNums=4 #是否允许 Broker 自动创建Topic，建议线下开启，线上关闭 autoCreateTopicEnable=true #是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭 autoCreateSubscriptionGroup=true #Broker 对外服务的监听端口 listenPort=10911 #删除文件时间点，默认凌晨 4点 deleteWhen=04 #文件保留时间，默认 48 小时 fileReservedTime=120 #commitLog每个文件的大小默认1G mapedFileSizeCommitLog=1073741824 #ConsumeQueue每个文件默认存30W条，根据业务情况调整 mapedFileSizeConsumeQueue=300000 #destroyMapedFileIntervalForcibly=120000 #redeleteHangedFileInterval=120000 #检测物理文件磁盘空间 diskMaxUsedSpaceRatio=88 #存储路径 storePathRootDir=/usr/local/rocketmq/store #commitLog 存储路径 storePathCommitLog=/usr/local/rocketmq/store/commitlog #消费队列存储路径存储路径 storePathConsumeQueue=/usr/local/rocketmq/store/consumequeue #消息索引存储路径 storePathIndex=/usr/local/rocketmq/store/index #checkpoint 文件存储路径 storeCheckpoint=/usr/local/rocketmq/store/checkpoint #abort 文件存储路径 abortFile=/usr/local/rocketmq/store/abort #限制的消息大小 maxMessageSize=65536 #flushCommitLogLeastPages=4 #flushConsumeQueueLeastPages=2 #flushCommitLogThoroughInterval=10000 #flushConsumeQueueThoroughInterval=60000 #Broker 的角色 #- ASYNC_MASTER 异步复制Master #- SYNC_MASTER 同步双写Master #- SLAVE brokerRole=SYNC_MASTER #刷盘方式 #- ASYNC_FLUSH 异步刷盘 #- SYNC_FLUSH 同步刷盘 flushDiskType=SYNC_FLUSH #checkTransactionMessageEnable=false #发消息线程池数量 #sendMessageThreadPoolNums=128 #拉消息线程池数量 #pullMessageThreadPoolNums=128 4) slave1服务器：192.168.25.138 vi /usr/soft/rocketmq/conf/2m-2s-sync/broker-a-s.properties 修改配置如下： #所属集群名字 brokerClusterName=rocketmq-cluster #broker名字，注意此处不同的配置文件填写的不一样 brokerName=broker-a #0 表示 Master，&gt;0 表示 Slave brokerId=1 #nameServer地址，分号分割 namesrvAddr=rocketmq-nameserver1:9876;rocketmq-nameserver2:9876 #在发送消息时，自动创建服务器不存在的topic，默认创建的队列数 defaultTopicQueueNums=4 #是否允许 Broker 自动创建Topic，建议线下开启，线上关闭 autoCreateTopicEnable=true #是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭 autoCreateSubscriptionGroup=true #Broker 对外服务的监听端口 listenPort=11011 #删除文件时间点，默认凌晨 4点 deleteWhen=04 #文件保留时间，默认 48 小时 fileReservedTime=120 #commitLog每个文件的大小默认1G mapedFileSizeCommitLog=1073741824 #ConsumeQueue每个文件默认存30W条，根据业务情况调整 mapedFileSizeConsumeQueue=300000 #destroyMapedFileIntervalForcibly=120000 #redeleteHangedFileInterval=120000 #检测物理文件磁盘空间 diskMaxUsedSpaceRatio=88 #存储路径 storePathRootDir=/usr/local/rocketmq/store #commitLog 存储路径 storePathCommitLog=/usr/local/rocketmq/store/commitlog #消费队列存储路径存储路径 storePathConsumeQueue=/usr/local/rocketmq/store/consumequeue #消息索引存储路径 storePathIndex=/usr/local/rocketmq/store/index #checkpoint 文件存储路径 storeCheckpoint=/usr/local/rocketmq/store/checkpoint #abort 文件存储路径 abortFile=/usr/local/rocketmq/store/abort #限制的消息大小 maxMessageSize=65536 #flushCommitLogLeastPages=4 #flushConsumeQueueLeastPages=2 #flushCommitLogThoroughInterval=10000 #flushConsumeQueueThoroughInterval=60000 #Broker 的角色 #- ASYNC_MASTER 异步复制Master #- SYNC_MASTER 同步双写Master #- SLAVE brokerRole=SLAVE #刷盘方式 #- ASYNC_FLUSH 异步刷盘 #- SYNC_FLUSH 同步刷盘 flushDiskType=ASYNC_FLUSH #checkTransactionMessageEnable=false #发消息线程池数量 #sendMessageThreadPoolNums=128 #拉消息线程池数量 #pullMessageThreadPoolNums=128 3.3.9修改启动脚本文件1）runbroker.shvi /usr/local/rocketmq/bin/runbroker.sh 需要根据内存大小进行适当的对JVM参数进行调整： #=================================================== # 开发环境配置 JVM Configuration JAVA_OPT=&quot;${JAVA_OPT} -server -Xms256m -Xmx256m -Xmn128m&quot; 2）runserver.shvim /usr/local/rocketmq/bin/runserver.sh JAVA_OPT=&quot;${JAVA_OPT} -server -Xms256m -Xmx256m -Xmn128m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m&quot; 3.3.10 启动服务1）启动NameServe集群分别在192.168.25.135和192.168.25.138启动NameServer cd /usr/local/rocketmq/bin nohup sh mqnamesrv &amp; 2）启动Broker集群 在192.168.25.135上启动master1和slave2 master1： cd /usr/local/rocketmq/bin nohup sh mqbroker -c /usr/local/rocketmq/conf/2m-2s-sync/broker-a.properties &amp; slave2： cd /usr/local/rocketmq/bin nohup sh mqbroker -c /usr/local/rocketmq/conf/2m-2s-sync/broker-b-s.properties &amp; 在192.168.25.138上启动master2和slave2 master2 cd /usr/local/rocketmq/bin nohup sh mqbroker -c /usr/local/rocketmq/conf/2m-2s-sync/broker-b.properties &amp; slave1 cd /usr/local/rocketmq/bin nohup sh mqbroker -c /usr/local/rocketmq/conf/2m-2s-sync/broker-a-s.properties &amp; 3.4 集群监控平台4. 各种消息发送案例4.1 同步消息4.2 异步消息4.3 单向消息4.4 顺序消息4.5 批量消息4.6 过滤消息4.7 事务消息","link":"/2018/09/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/mq/rocketmq/rocketmq%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD/"},{"title":"Vue基础","text":"Vue介绍Vue认识 Vue是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面， 当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。 前端框架三巨头:Vue.js、React.js、AngularJS，vue.js以其轻量易用著称，vue.js和React.js发展速度最快。 **渐进式:**可以选择性的使用该框架的一个或一些组件，这些组件的使用也不需要将框架全部组件都应用;而且用了这些组件也不要求你的系统全部都使用该框架。 官网:https://cn.vuejs.org/参考:https://cn.vuejs.org/v2/guide/ MVVM模式 M:即Model，模型，包括数据和一些基本操作 V:即View，视图，页面渲染结果 VM:即View-Model，模型与视图间的双向操作(无需开发人员干涉) 在MVVM之前，开发人员从后端获取需要的数据模型，然后要通过DOM操作Model渲染到View中。而后当用户操作 视图，我们还需要通过DOM获取View中的数据，然后同步到Model中。而MVVM中的VM要做的事情就是把DOM操作完全封装起来，开发人员不用再关心Model和View之间是如何互相影响 的:只要Model发生了改变，View上自然就会表现出来。 当用户修改了View，Model中的数据也会跟着改变。把开发人员从繁琐的DOM操作中解放出来，把关注点放在如何操作Model上。 vue安装三种方式下载到本地安装下载地址:https://github.com/vuejs/vue 解压，在 dist 可得到vue.js文件。 CDN远程引入或者也可以直接使用公共的CDN(内容分发网络)服务: &lt;!-- 生产环境版本，优化了尺寸和速度 --&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt; npm安装(推荐) 一般切换到项目目录，先初始化 npm包管理器 npm init -y，此时，会在项目目录下出现一个package.json文件。这是对项目的基本描述信息。例如名称、版本等，有点类似java中的pom文件。 安装Vue，输入命令:npm install vue –save(save 的意思是将模块安装到项目目录下，并在package文件的dependencies节点写入依赖)。然后就会在项目目录发现一个node_modules目录，并且在下面有一个vue目录库。 Vue实例及其常见属性每个Vue应用都是通过Vue函数创建一个新的Vue实例开始的:&lt;script&gt; var app = new Vue({ //选项，在构造函数中传入一个对象，并且在对象中声明各种Vue需要的数据和方法，包括: // el // data // methods }); &lt;/script&gt; 模板或元素 每个Vue实例都需要关联一段Html模板，Vue会基于此模板进行视图渲染;可以通过el属性来指定。例如一段html模板:&lt;div id=&quot;appContent&quot;&gt; &lt;/div&gt; 然后创建Vue实例，关联这个div&lt;script&gt; var app = new Vue({ el:&quot;#appContent&quot; }); &lt;/script&gt; 数据 当Vue实例被创建时，它会尝试获取在data中定义的所有属性，用于视图的渲染，并且监视data中的属性变化，当 data发生改变，所有相关的视图都将重新渲染，这就是“响应式“系统。&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;appContent&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;num&quot;&gt; &lt;h2&gt;{{name}} 为国为民,侠之大者,拥有 {{num}} 种绝世武功&lt;/h2&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue({ el:&quot;#appContent&quot;, data:{ name:&quot;郭靖&quot;, num:1 } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 方法&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot; xmlns:v-on=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;appContent&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;num&quot;&gt; &lt;h2&gt;{{name}} 为国为民,侠之大者,拥有 {{num}} 种绝世武功&lt;/h2&gt; &lt;button v-on:click=&quot;add&quot;&gt;点我&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue({ el:&quot;#appContent&quot;, data:{ name:&quot;郭靖&quot;, num:1 }, methods:{ add:function () { console.log(&quot;被点击了&quot;) } } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; Vue的生命周期的钩子函数生命周期 每个 Vue 实例在被创建时都要经过一系列的初始化过程 :创建实例，装载模板，渲染模板等。Vue为生命周期中的 每个状态都设置了钩子函数(监听函数)。每当Vue实例处于不同的生命周期时，对应的函数就会被触发调用。 所有的生命周期钩子自动绑定 this 上下文到实例中，因此你可以访问数据，对属性和方法进行运算。这意味 着你不能使用箭头函数来定义一个生命周期方法 (例如 created: () =&gt; this.fetchTodos() )。这是因为箭 头函数绑定了父上下文，因此 this 与你期待的 Vue 实例不同， this.fetchTodos 的行为未定义。 钩子函数 例如:created代表在vue实例创建后;可以在Vue中定义一个created函数，代表这个时期的构造函数:&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot; xmlns:v-on=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;appContent&quot;&gt; &lt;h2&gt;{{name}} 为国为民,侠之大者,拥有 {{num}} 种绝世武功&lt;/h2&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue({ el:&quot;#appContent&quot;, data:{ name:&quot;&quot;, num:1 }, created(){ //此钩子函数一般用于网络请求数据后,初始化数据 this.name=&quot;郭靖&quot;;//this 就是当前的Vue实例，在Vue对象内部，必须使用 this 才能访问到Vue中定义的data内属性、方法等。 this.num = 4; } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 跑马灯效果&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot; xmlns:v-on=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;appContent&quot;&gt; &lt;h6&gt;{{msg}}&lt;/h6&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue({ el: &quot;#appContent&quot;, data:{ msg:&quot;今日积分大调整!&quot; }, created(){ setInterval(() =&gt; { var start = this.msg.substring(0, 1) // 获取到 后面的所有字符 var end = this.msg.substring(1) // 重新拼接得到新的字符串，并赋值给 this.msg this.msg = end + start }, 400) } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; vue常见指令 指令 (Directives) 是带有 v- 前缀的特殊属性。例如在入门案例中的v-model，代表双向绑定。 插值表达式花括号 格式：{{表达式}} 说明: 该表达式支持JS语法，可以调用js内置函数(必须有返回值) 表达式必须有返回结果。例如 1 + 1，没有结果的表达式不允许使用，如:var a = 1 + 1; 可以直接获取Vue实例中定义的数据或函数 插值闪烁(网络抖动或网速特别慢时才能出现) 使用&amp;#123;&amp;#123;&amp;#125;&amp;#125;方式在网速较慢时会出现问题。在数据未加载完成时，页面会显示出原始的 &amp;#123;&amp;#123;&amp;#125;&amp;#125;，加载完毕后才显示正确数据，称为插值闪烁。(最新vue是几乎没有此问题): 【解决方案】使用v-text和v-html指令来替代&amp;#123;&amp;#123;&amp;#125;&amp;#125; 。v-text：将数据输出到元素内部，如果输出的数据有HTML代码，会作为普通文本输出，推荐使用v-text；v-html：将数据输出到元素内部，如果输出的数据有HTML代码，会被渲染。 v-model 刚才的v-text和v-html可以看做是单向绑定，数据影响了视图渲染，但是反过来就不行。接下来学习的v-model是双向绑定，视图(View)和模型(Model)之间会互相影响。 既然是双向绑定，一定是在视图中可以修改数据，这样就限定了视图的元素类型。目前v-model的可使用元素有: input select textarea checkbox radio components(Vue中的自定义组件)基本上除了最后一项，其它都是表单的输入项。示例:&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot; xmlns:v-on=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;appContent&quot;&gt; &lt;input type=&quot;checkbox&quot; value=&quot;Java&quot; v-model=&quot;language&quot;&gt;Java&lt;br&gt; &lt;input type=&quot;checkbox&quot; value=&quot;PHP&quot; v-model=&quot;language&quot;&gt;PHP&lt;br&gt; &lt;input type=&quot;checkbox&quot; value=&quot;Swift&quot; v-model=&quot;language&quot;&gt;Swift&lt;br&gt; &lt;h2&gt;你选择了:{{language.join(\",\")}} &lt;/h2&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue({ el:&quot;#appContent&quot;, data:{ language:[] } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 多个 checkbox 对应一个model时，model的类型是一个数组， 单个checkbox值是boolean类型 radio对应的值是input的value值 input 和textarea 默认对应的model是字符串 select 单选对应字符串，多选对应也是数组 v-on v-on指令用于给页面元素绑定事件。v-on:事件名=&quot;js片段或函数名&quot; //或者简写为： @事件名=&quot;js片段或函数名&quot; //例如 v-on:click='add' 可以简写为 @click='add' 事件修饰符在事件处理程序中调用 event.preventDefault() 或 event.stopPropagation() 是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是:方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。 为了解决这个问题，Vue.js 为 v-on 提供了事件修饰符。之前提过，修饰符是由点开头的指令后缀来表示的。 .stop :阻止事件冒泡 .prevent :阻止默认事件发生 .capture :使用事件捕获模式 .self :只有元素自身触发事件才执行。(冒泡或捕获的都不执行) .once :只执行一次&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot; xmlns:v-on=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;appContent&quot;&gt; &lt;!--直接写js片段--&gt; &lt;button @click=&quot;num++&quot;&gt;增加&lt;/button&gt; &lt;!--使用函数名，该函数必须要在vue实例中定义--&gt; &lt;button @click=&quot;decrement&quot;&gt;减少&lt;/button&gt; &lt;h2&gt; num = {{num}} &lt;/h2&gt; &lt;hr&gt; 事件冒泡测试:&lt;br&gt; &lt;div style=&quot;background-color: lightblue;width: 100px;height: 100px&quot; @click=&quot;print('你点击了div')&quot;&gt; &lt;button @click.stop=&quot;print('点击了button')&quot;&gt;点我试试&lt;/button&gt; &lt;/div&gt; &lt;br&gt;阻止默认事件:&lt;br&gt; &lt;a href=&quot;http://www.ecit.cn&quot; @click.prevent=&quot;print('点击超链接')&quot;&gt;ecit&lt;/a&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue({ el: &quot;#appContent&quot;, data:{ num:1 }, methods:{ decrement(){ this.num--; }, print(msg){ console.log(msg) } } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; v-for 遍历数据渲染页面是非常常用的需求，Vue中通过v-for指令来实现。 遍历数组v-for=&quot;item in items&quot; items:要遍历的数组，需要在vue的data中定义好。 item:循环变量&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot; xmlns:v-on=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;appContent&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;user in users&quot;&gt;{{user.name}}--{{user.age}}--{{user.gender}}&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue({ el: &quot;#appContent&quot;, data:{ users:[ {&quot;name&quot;:&quot;杨过&quot;,&quot;age&quot;:20,&quot;gender&quot;:&quot;男&quot;}, {&quot;name&quot;:&quot;小龙女&quot;,&quot;age&quot;:24,&quot;gender&quot;:&quot;女&quot;}, {&quot;name&quot;:&quot;郭靖&quot;,&quot;age&quot;:40,&quot;gender&quot;:&quot;男&quot;} ] }, }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 数组角标 在遍历的过程中，如果需要知道数组角标，可以指定第二个参数:v-for=&quot;(item,index) in items&quot; items:要迭代的数组 item:迭代得到的数组元素别名 index:迭代到的当前元素索引，从0开始。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot; xmlns:v-on=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;appContent&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;(user,index) in users&quot;&gt;{{index}}---{{user.name}}--{{user.age}}--{{user.gender}}&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue({ el: &quot;#appContent&quot;, data:{ users:[ {&quot;name&quot;:&quot;杨过&quot;,&quot;age&quot;:20,&quot;gender&quot;:&quot;男&quot;}, {&quot;name&quot;:&quot;小龙女&quot;,&quot;age&quot;:24,&quot;gender&quot;:&quot;女&quot;}, {&quot;name&quot;:&quot;郭靖&quot;,&quot;age&quot;:40,&quot;gender&quot;:&quot;男&quot;} ] }, }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 遍历对象 v-for除了可以迭代数组，也可以迭代对象。语法基本类似v-for=&quot;value in object&quot; v-for=&quot;(value,key) in object&quot; v-for=&quot;(value,key,index) in object&quot; 1个参数时，得到的是对象的值 2个参数时，第一个是值，第二个是键 3个参数时，第三个是索引，从0开始 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot; xmlns:v-on=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;appContent&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;(user,index) in users&quot;&gt;{{index}}---{{user.name}}--{{user.age}}--{{user.gender}}&lt;/li&gt; &lt;/ul&gt; &lt;ul&gt; &lt;li v-for=&quot;(value,key,index) in person&quot;&gt;{{index}}--{{key}}--{{value}}&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue({ el: &quot;#appContent&quot;, data:{ users:[ {&quot;name&quot;:&quot;杨过&quot;,&quot;age&quot;:20,&quot;gender&quot;:&quot;男&quot;}, {&quot;name&quot;:&quot;小龙女&quot;,&quot;age&quot;:24,&quot;gender&quot;:&quot;女&quot;}, {&quot;name&quot;:&quot;郭靖&quot;,&quot;age&quot;:40,&quot;gender&quot;:&quot;男&quot;} ], person:{&quot;name&quot;:&quot;黄蓉&quot;, &quot;age&quot;:37, &quot;address&quot;:&quot;桃花岛&quot;} }, }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; key当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将 不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过 的每个元素。如果使用key这个功能可以有效的提高渲染的效率;key一般使用在遍历完后，又增、减集合元素的时候更有意义。但是要实现这个功能，你需要给Vue一些提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。理想的 key 值是每项都有的且唯一的 id。 也就是key是该项的唯一标识。示例： &lt;ul&gt; &lt;li v-for=&quot;(item,index) in items&quot; :key=&quot;index&quot;&gt;&lt;/li&gt; &lt;/ul&gt; 这里使用了一个特殊语法: :key=””，它可以让你读取vue中的属性，并赋值给key属性 这里绑定的key是数组的索引，应该是唯一的 v-if和v-showv-if v-if，顾名思义，条件判断。当得到结果为true时，所在的元素才会被渲染。 可以使用 v-else 指令来表示 v-if 的“else 块”: 当v-if和v-for出现在一起时，v-for优先级更高。也就是说，会先遍历，再判断条件。 v-else-if ，顾名思义，充当 v-if 的“else-if 块”，可以连续使用:v-if=&quot;布尔表达式&quot; 示例：&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot; xmlns:v-on=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;appContent&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;(user,index) in users&quot; v-if=&quot;user.gender=='女'&quot; style=&quot;background-color: red&quot;&gt;{{index}}---{{user.name}}--{{user.age}}--{{user.gender}}&lt;/li&gt; &lt;li v-else style=&quot;background-color: aqua&quot;&gt;{{index}}---{{user.name}}--{{user.age}}--{{user.gender}}&lt;/li&gt; &lt;/ul&gt; &lt;ul&gt; &lt;li v-for=&quot;(value,key,index) in person&quot;&gt;{{index}}--{{key}}--{{value}}&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue({ el: &quot;#appContent&quot;, data:{ users:[ {&quot;name&quot;:&quot;杨过&quot;,&quot;age&quot;:20,&quot;gender&quot;:&quot;男&quot;}, {&quot;name&quot;:&quot;小龙女&quot;,&quot;age&quot;:24,&quot;gender&quot;:&quot;女&quot;}, {&quot;name&quot;:&quot;郭靖&quot;,&quot;age&quot;:40,&quot;gender&quot;:&quot;男&quot;} ] }, }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; v-show 另一个用于根据条件展示元素的选项是 v-show 指令。用法大致一样. 不同的是带有 v-show 的元素始终会被渲染并保留在 DOM 中。 v-show 只是简单地切换元素的 CSS 属性 display 。 v-bind 属性上使用vue数据 因为插值表达式不能用在标签的属性中。语法：v-bind:属性名=&quot;Vue中的变量&quot; &lt;div v-bind:class=&quot;color&quot;&gt;&lt;/div&gt; &lt;!-- 不过，v-bind太麻烦，因此可以省略，直接写成: :属性名='属性值' ，即 --&gt; &lt;div :class=&quot;color&quot;&gt;&lt;/div&gt; Vue对class属性进行了特殊处理，可以接收数组或对象格式 vue计算属性和watch监控计算属性在插值表达式中使用js表达式是非常方便的，而且也经常被用到。但是如果表达式的内容很长，就会显得不够优雅，而且后期维护起来也不方便，例如下面的场景，有一个日期的数据，但是是毫秒值 var app = new Vue({ el:&quot;#app&quot;, //el即element，要渲染的页面元素 data: { birthday:1429032123201 }, computed:{ birth(){ const date = new Date(this.birthday); return date.getFullYear() + &quot;-&quot; + (date.getMonth()+1) + &quot;-&quot; + date.getDay(); } } }); watch监控 watch可以让我们监控一个值的变化。从而做出相应的反应。&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot; xmlns:v-on=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;appContent&quot;&gt; &lt;input v-model=&quot;msg&quot;/&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue({ el: &quot;#appContent&quot;, data:{ msg:&quot;Hello&quot; }, watch:{ msg(newValue, oldValue){ console.log(&quot;新值:&quot; + newValue + &quot;;旧值:&quot; + oldValue); } } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 深度监控 如果监控的是一个对象，需要进行深度监控，才能监控到对象中属性的变化，例如:&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot; xmlns:v-on=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;appContent&quot;&gt; &lt;input v-model=&quot;msg&quot;/&gt; &lt;br/&gt; &lt;input v-model=&quot;person.name&quot;&gt;&lt;br&gt; &lt;input v-model=&quot;person.age&quot;&gt; &lt;button @click=&quot;person.age++&quot;&gt;+&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue({ el: &quot;#appContent&quot;, data: { msg: &quot;Hello&quot;, person: {&quot;name&quot;: &quot;令狐冲&quot;, &quot;age&quot;: 22} }, watch: { msg(newValue, oldValue){ console.log(&quot;新值:&quot; + newValue + &quot;;旧值:&quot; + oldValue); }, person: { //开启深度监控，可以监控到对象属性值的变化 deep: true, //监控的处理方法 handler(obj){ console.log(&quot;name = &quot; + obj.name + &quot;, age=&quot; + obj.age); } } } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; Vue组件 在大型应用开发的时候，页面可以划分成很多部分。往往不同的页面，也会有相同的部分。例如可能会有相同的头部导航。 但是如果每个页面都独自开发，这无疑增加了开发的成本。所以会把页面的不同部分拆分成独立的组件，然后在不同 页面就可以共享这些组件，避免重复开发。 定义全局组件 通过Vue的component方法来定义一个全局组件。 组件其实也是一个Vue实例，因此它在定义时也会接收:data、methods、生命周期函数等 不同的是组件不会与页面的元素绑定，否则就无法复用了，因此没有el属性。 但是组件渲染需要html模板，所以增加了template属性，值就是HTML模板 全局组件定义完毕，任何vue实例都可以直接在HTML中通过组件名称来使用组件了。 data的定义方式比较特殊，必须是一个函数。&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot; xmlns:v-on=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;appContent&quot;&gt; &lt;counter&gt;&lt;/counter&gt; &lt;/div&gt; &lt;script&gt; //定义组件 const counter = { template: &quot;&lt;button @click='num++'&gt;你点击了{{num}}次;我记住了&lt;/button&gt;&quot;, data(){ return {num: 0} } }; //全局注册组件;参数1:组件名称，参数2:组件 Vue.component(&quot;counter&quot;, counter); var app = new Vue({ el: &quot;#appContent&quot; }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 局部注册 一旦全局注册，就意味着即便以后你不再使用这个组件，它依然会随着Vue的加载而加载。 因此，对于一些并不频繁使用的组件，会采用局部注册。 先在外部定义一个对象，结构与创建组件时传递的第二个参数一致: 然后在Vue中使用它:```html Title //定义组件 const counter = { template: \"你点击了次;我记住了\", data(){ return {num: 0} } }; var app = new Vue({ el: “#appContent”, //局部注册组件 components: { counter: counter } }); ``` 组件通信父向子传递props 简单字符串```html //定义组件 const introduce = { template:”Vue基础“, //定义接收父组件的属性 props:[“title”] }; //全局注册组件：在所有的vue实例中都可以使用组件 //参数1：组件名称，参数2：具体的组件 Vue.component(“introduce”, introduce); var app = new Vue({ el:”#app”, data:{ msg:”父组件的msg属性数据内容” } }); - 父组件将数组更新传递到子组件 ```html &lt;div id=&quot;app&quot;&gt; &lt;!--使用组件--&gt; &lt;my-list :items=&quot;lessons&quot; &gt;&lt;/my-list&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; //定义组件 const myList = { template:` &lt;ul&gt; &lt;li v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;{{item.id}}--{{item.name}}&lt;/li&gt; &lt;/ul&gt;`, //定义接收父组件的属性 props:{ items:{ //数据类型，如果是数组则是Array，如果是对象则是Object type:Array, //默认值 default:[] } } }; var app = new Vue({ el:&quot;#app&quot;, data:{ msg:&quot;父组件的msg属性数据内容&quot;, lessons:[ {&quot;id&quot;:1, &quot;name&quot;:&quot;Java&quot;}, {&quot;id&quot;:2, &quot;name&quot;:&quot;Php&quot;}, {&quot;id&quot;:3, &quot;name&quot;:&quot;前端&quot;} ] }, components:{ myList } }); &lt;/script&gt; 子向父的通信 vue提供了一个内置的this.$emit函数，用来调用父组件绑定的函数&lt;div id=&quot;app&quot;&gt; &lt;h2&gt;num = {{num}}&lt;/h2&gt; &lt;!--使用组件--&gt; &lt;counter @plus=&quot;numPlus&quot; @reduce=&quot;numReduce&quot; :snum=&quot;num&quot;&gt;&lt;/counter&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; //定义组件 const counter = { template:` &lt;div&gt; &lt;button @click='incrNum'&gt;+&lt;/button&gt; &lt;button @click='decrNum'&gt;-&lt;/button&gt; &lt;/div&gt; `, props:[&quot;snum&quot;], methods:{ //递增 incrNum(){ //调用到父组件中的方法 return this.$emit(&quot;plus&quot;); }, decrNum(){ //调用到父组件中的方法 return this.$emit(&quot;reduce&quot;); } } }; //全局注册组件：在所有的vue实例中都可以使用组件 //参数1：组件名称，参数2：具体的组件 //Vue.component(&quot;counter&quot;, counter); var app = new Vue({ el:&quot;#app&quot;, components:{ counter: counter }, data:{ num:0 }, methods:{ numPlus(){ this.num++; }, numReduce(){ this.num--; } } }); &lt;/script&gt; Vue网络框架-axios发送异步请求获取数据 Vuejs 并没有直接处理ajax的组件，但可以使用axios或vue-resource组件实现对异步请求的操作。 vue-resource是Vue.js的插件提供了使用XMLHttpRequest或JSONP进行Web请求和处理响应的服务。 当vue更新 到 2.0之后，作者就宣告不再对vue-resource更新，而是推荐axios。 Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。 npm install axios 或者也可以直接使用公共的CDN(内容分发网络)服务: &lt;!-- 开发环境版本，包含了用帮助的命令行警告 --&gt; &lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt; axios应用axios可以使用的方法有: axios(config) axios.get(url[, config]) axios.delete(url[, config]) axios.head(url[, config]) axios.post(url[, data[, config]]) axios.put(url[, data[, config]]) axios.patch(url[, data[, config]]) config请求配置 { // `url` 是用于请求的服务器 URL url: '/user', // `method` 是创建请求时使用的方法 method: 'get', // 默认是 get // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。 // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL baseURL: 'https://some-domain.com/api/', // `transformRequest` 允许在向服务器发送前，修改请求数据 // 只能用在 'PUT', 'POST' 和 'PATCH' 这几个请求方法 // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream transformRequest: [function (data) { // 对 data 进行任意转换处理 return data; }], // `transformResponse` 在传递给 then/catch 前，允许修改响应数据 transformResponse: [function (data) { // 对 data 进行任意转换处理 return data; }], // `headers` 是即将被发送的自定义请求头 headers: { 'X-Requested-With': 'XMLHttpRequest', 'Content-Type': 'application/json' }, // `params` 是即将与请求一起发送的 URL 参数 // 必须是一个无格式对象(plain object)或 URLSearchParams 对象 params: { ID: 12345 }, // `data` 是作为请求主体被发送的数据 // 只适用于这些请求方法 'PUT', 'POST', 和 'PATCH' // 在没有设置 `transformRequest` 时，必须是以下类型之一: // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams // - 浏览器专属:FormData, File, Blob // - Node 专属: Stream data: { firstName: 'Fred' }, // `timeout` 指定请求超时的毫秒数(0 表示无超时时间) // 如果请求话费了超过 `timeout` 的时间，请求将被中断 timeout: 1000, // `withCredentials` 表示跨域请求时是否需要使用凭证 withCredentials: false, // 默认的 // `responseType` 表示服务器响应的数据类型，可以是 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream' responseType: 'json', // 默认的 // `maxContentLength` 定义允许的响应内容的最大尺寸 maxContentLength: 2000, // `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否 则，promise 将被 rejecte validateStatus: function (status) { return status &gt;= 200 &amp;&amp; status &lt; 300; // 默认的 }, // `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目 // 如果设置为0，将不会 follow 任何重定向 maxRedirects: 5 // 默认的 } 响应结构 { // `data` 由服务器提供的响应 data: {}, // `status` 来自服务器响应的 HTTP 状态码 status: 200, // `statusText` 来自服务器响应的 HTTP 状态信息 statusText: 'OK', // `headers` 服务器响应的头 headers: {}, // `config` 是为请求提供的配置信息 config: {} } 使用 then 时，你将接收下面这样的响应: axios.get('/user/12345').then(function(response) { console.log(response.data); console.log(response.status); console.log(response.statusText); console.log(response.headers); console.log(response.config); }); 示例： &lt;script&gt; var app = new Vue({ el:&quot;#app&quot;, data: { users:[] }, created(){ //加载数据 axios({ method:&quot;get&quot;, url: &quot;data.json&quot; }).then((res)=&gt;{ console.log(res); //将获取数据设置到users属性 app.users = res.data; }).catch(error=&gt;{ alert(error); }); } }); &lt;/script&gt; axios.post(&quot;data.json&quot;).then(res=&gt;{ console.log(res); //将数据赋值到vue实例中的数据属性users； //不能使用this，在axios回调函数中表示窗口，不是vue实例 app.users = res.data; }).catch(err=&gt;alert(err)); axios.get(&quot;http://localhost/user/8&quot;).then(res=&gt;{ console.log(res.data); }).catch(err=&gt;alert(err)); nrm的安装使用作用：提供了一些最常用的NPM包镜像地址，能够让我们快速的切换安装包时候的服务器地址；什么是镜像：原来包刚一开始是只存在于国外的NPM服务器，但是由于网络原因，经常访问不到，这时候，我们可以在国内，创建一个和官网完全一样的NPM服务器，只不过，数据都是从人家那里拿过来的，除此之外，使用方式完全一样； 1.运行npm i nrm -g全局安装nrm包； 2.使用nrm ls查看当前所有可用的镜像源地址以及当前所使用的镜像源地址； 3.使用nrm use npm或nrm use taobao切换不同的镜像源地址； 注意： nrm 只是单纯的提供了几个常用的 下载包的 URL地址，并能够让我们在 这几个 地址之间，很方便的进行切换，但是，我们每次装包的时候，使用的 装包工具，都是 npm","link":"/2018/03/01/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/vue/vue%E5%9F%BA%E7%A1%80/"},{"title":"基于vue组件库(移动端MintUI，PC端elementUI)","text":"Mint UI(移动端) 饿了么团队开源一个基于vue 组件库,适用于移动端开发使用 安装// 安装 # Vue 1.x npm install mint-ui@1 -S # Vue 2.0 npm install mint-ui -S 引入// 引入全部组件 import Vue from 'vue'; import Mint from 'mint-ui'; import 'mint-ui/lib/style.css';//导入样式 Vue.use(Mint); // 按需引入部分组件 import { Cell, Checklist } from 'mint-ui'; Vue.component(Cell.name, Cell); Vue.component(Checklist.name, Checklist); 在页面组件种直接使用&lt;mt-button type=&quot;primary&quot; size=&quot;large&quot;&gt;primary&lt;/mt-button&gt; 按需引入 借助 babel-plugin-component，我们可以只引入需要的组件，以达到减小项目体积的目的。首先，安装 babel-plugin-component：npm install babel-plugin-component -D 然后，将 .babelrc 修改为：&quot;plugins&quot;: [[&quot;component&quot;, [ { &quot;libraryName&quot;: &quot;mint-ui&quot;, &quot;style&quot;: true } ]]] 如果你只希望引入部分组件，比如 Button 和 Cell，那么需要在 main.js 中写入以下内容：```jsimport Vue from ‘vue’import { Button, Cell } from ‘mint-ui’import App from ‘./App.vue’Vue.component(Button.name, Button)Vue.component(Cell.name, Cell)/* 或写为 Vue.use(Button) Vue.use(Cell) */new Vue({ el: ‘#app’, components: { App }})``` elementUI(PC端) 饿了么团队开源一个基于vue 组件库,适用于PC端开发 使用: 1.安装 element-ui npm i element-ui -D 等同 npm install element-ui --save-dev // i -&gt; install // D -&gt; --save-dev // S -&gt; --save 2.引入 main.js 入口文件import ElementUI from 'element-ui' import 'element-ui/lib/theme-default/index.css' 3.使用组件Vue.use(ElementUI) 按需加载相应组件: 1 babel-plugin-component cnpm install babel-plugin-component -D 2 .babelrc文件里面新增一个配置&quot;plugins&quot;: [[&quot;component&quot;, [ { &quot;libraryName&quot;: &quot;element-ui&quot;, &quot;styleLibraryName&quot;: &quot;theme-default&quot; } ]]] 3 想用哪个组件就用哪个 引入: import {Button,Radio} from 'element-ui' 使用: a). Vue.component(Button.name, Button); 个人不太喜欢 b). Vue.use(Button); √ MUI 代码片段(不同于MintUI) 注意： MUI 不同于 Mint-UI，MUI只是开发出来的一套好用的代码片段，里面提供了配套的样式、配套的HTML代码段，类似于 Bootstrap； 而 Mint-UI，是真正的组件库，是使用 Vue 技术封装出来的 成套的组件，可以无缝的和 VUE项目进行集成开发；因此，从体验上来说， Mint-UI体验更好，因为这是别人帮我们开发好的现成的Vue组件；从体验上来说， MUI和Bootstrap类似；理论上，任何项目都可以使用 MUI 或 Bootstrap，但是，MInt-UI只适用于Vue项目； 注意： MUI 并不能使用 npm 去下载，需要自己手动从 github 上，下载现成的包，自己解压出来，然后手动拷贝到项目中使用；官网首页文档地址 具体使用 1.导入 MUI 的样式表：import '../lib/mui/css/mui.min.css' 2.在webpack.config.js中添加新的loader规则：{ test: /\\.(png|jpg|gif|ttf)$/, use: 'url-loader' } 3.根据官方提供的文档和example，尝试使用相关的组件","link":"/2018/03/07/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/vue/%E5%9F%BA%E4%BA%8Evue%E7%BB%84%E4%BB%B6%E5%BA%93/"},{"title":"bootstrap第一篇","text":"CSS定位及应用","link":"/2015/02/01/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/bootstrap/bootstrap01/"},{"title":"在线教育平台案例","text":"初始化html,CSS&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;在线教育&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; /* 样式 */ /* css初始化 */ * { margin: 0; padding: 0; /* 清除内外边距 */ } ul { list-style: none; /* 去掉列表样式小点 */ } .clearfix:before, .clearfix:after { /* 清除浮动 */ display: table; content: &quot;&quot;; } .clearfix:after { clear: both; } .clearfix { *zoom: 1; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 确定版心和各个模块","link":"/2018/11/04/%E5%89%8D%E7%AB%AF/%E9%A1%B9%E7%9B%AE%E6%A1%88%E4%BE%8B/%E5%9C%A8%E7%BA%BF%E6%95%99%E8%82%B2%E5%B9%B3%E5%8F%B0/online-edu/"},{"title":"JUnit单元测试","text":"JUnit介绍 单元测试就是针对最小的功能单元编写测试代码。Java程序最小的功能单元是方法，因此，对Java程序进行单元测试就是针对单个Java方法的测试。 JUnit是一个开源的Java语言的单元测试框架，专门针对Java设计，使用最广泛。JUnit是事实上的单元测试的标准框架. 使用JUnit编写单元测试的好处在于，我们可以非常简单地组织测试代码，并随时运行它们，JUnit就会给出成功的测试和失败的测试，还可以生成测试报告，不仅包含测试的成功率，还可以统计测试的代码覆盖率，即被测试的代码本身有多少经过了测试。对于高质量的代码来说，测试覆盖率应该在80%以上。 JUnit要遵循的规范 一是单元测试代码本身必须非常简单，能一下看明白，决不能再为测试代码编写测试； 二是每个单元测试应当互相独立，不依赖运行的顺序； 三是测试时不但要覆盖常用测试用例，还要特别注意测试边界条件，例如输入为0，null，空字符串””等情况。 JUnit框架使用 官方wiki地址:https://github.com/junit-team/junit4/wiki/Download-and-Install 两种使用方式： 直接下载jar包放到项目的lib目录，添加至classpath 通过maven的pom文件依赖&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; Junit3和Junit4两者之间的区别是非常明显的 在Junit3中，如果某个类需要是测试类，必须将其继承于TestCase,如果某个方法需要是测试方法，必须让这个方法通过testXX开头，在junit3中，如果希望指定某个测试方法运行之前运行某个初始化方法，这个方法的名称必须是setUp,如果希望在某个测试方法运行之后运行某个释放资源的方法，这个方法的名称必须是tearDown 在Junit4中，一个POJO类就是一个测试类，测试方法通过@Test来标识，初始化方法通过@Before，释放资源的方法通过@After来标注。但是为了让junit4中的测试类在Junit3中也可以使用，习惯于把初始化方法命名为setUp，释放资源的方法命名为tearDown，测试方法也同样以test开头 JUnit的两种主要版本是JUnit 3.8和JUnit 4，前者使用反射，后者使用反射和注解 JUnit3单元测试 引入pom文件 &lt;!-- https://mvnrepository.com/artifact/junit/junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; 编写pojo package com.ecit.test; public class Calculator { public int add(int a, int b) { return a + b; } public int subtract(int a, int b) { return a - b; } public int multiply(int a, int b) { return a * b; } public int divide(int a, int b) { return a / b; } } 编写pojo类的测试类```javapackage com.ecit.test;import junit.framework.Assert;import junit.framework.TestCase;public class CalculatorTest extends TestCase{ //测试类必须继承于TestCase类。 private Calculator calculator = null; @Override protected void setUp() throws Exception { //初始化需要用到的资源 calculator = new Calculator(); } @Override protected void tearDown() throws Exception { //释放资源 super.tearDown(); } public void testAdd() { int result = calculator.add(1, 2); // 判断方法的返回结果 Assert.assertEquals(3, result);// 第一个参数是期望值，第二个参数是要验证的值 } public void testSubtract() { int result = calculator.subtract(1, 2); // 判断方法的返回结果 Assert.assertEquals(-1, result);// 第一个参数是期望值，第二个参数是要验证的值 } public void testMultiply() { int result = calculator.multiply(2, 3); // 判断方法的返回结果 Assert.assertEquals(6, result);// 第一个参数是期望值，第二个参数是要验证的值 } public void testDivide() { int result = calculator.divide(12, 3); // 判断方法的返回结果 Assert.assertEquals(“除法有问题”,4, result);//第一个参数是错误提示 第二个参数是期望值，第三个参数是要验证的值 } } - 命令行进行Junit单元测试 **JUnit3命令行命令执行如下** ```shell mkdir -p ./target/classes &amp;&amp; javac -d ./target/classes/ -cp .:/Users/sxm/.m2/repository/junit/junit/3.8.1/junit-3.8.1.jar src/test/java/com/ecit/test/CalculatorTest.java src/main/java/com/ecit/test/Calculator.java &amp;&amp; java -cp .:./target/classes:/Users/sxm/.m2/repository/junit/junit/3.8.1/junit-3.8.1.jar junit.textui.TestRunner com.ecit.test.CalculatorTest 其它版本的JUnit命令行测试 对于JUnit 5.x java -jar junit-platform-console-standalone-&lt;version&gt;.jar &lt;Options&gt; 对于JUnit 4.X，它确实是： java -cp .:/usr/share/java/junit.jar org.junit.runner.JUnitCore [test class name] 但是，如果您使用的是JUnit 3.X，请注意类名称是不同的 java -cp .:/usr/share/java/junit.jar junit.textui.TestRunner [test class name] maven方式需要添加以下测试插件依赖 &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;configuration&gt; &lt;reuseForks&gt;false&lt;/reuseForks&gt; &lt;forkCount&gt;1&lt;/forkCount&gt; &lt;/configuration&gt; &lt;/plugin&gt; mvn clean test 或//如果您希望在控制台中看到堆栈跟踪（如果有）而不是target \\ surefire-reports文件夹中的报告文件，请将用户属性surefire.useFile设置为false mvn clean test -Dtest=your.package.TestClassName -Dsurefire.useFile=false gradle方式gradle test 或 gradle test --tests your.package.TestClassName JUnit4单元测试 JUnit4单元测试无需再继承TestCase，测试方法通过@Test来标识，初始化方法通过@Before，释放资源的方法通过@After来标注。 断言Assert的类 执行任意一个方法之前都会执行setUp方法 @Before public void setUp() { cal = new Calculator(); } 加了@Test表示该方法是一个单元测试方法 @Test public void testAdd() { int expectedValue = 34;//期望值 int rel = cal.add(12,22);//实际值 /* * 以下就是一个简单的断言的编写 * 第一个参数是如果出错给出的提示信息 * 第二个参数表示方法执行完成之后预期的一个值 * 第三个参数表示实际值 */ //Assert.assertEquals(&quot;加法有问题&quot;, rel, 34); /** * 当进行了静态导入之后，import static org.junit.Assert.*; * Assert中的所有静态方法就不用在添加类名来调用 * 这样可以有效的兼容junit3 */ assertEquals(&quot;加法有问题&quot;, expectedValue,rel); } 表示这个测试类应该抛出ArithmeticException,如果不抛出就报错 @Test(expected=ArithmeticException.class) public void testDivideException() { int rel = cal.divide(20,0); } 表示这个方法应该在300毫秒内执行结束才算是正确 @Test(timeout=300) public void testTime() { try { Thread.sleep(200); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(&quot;abc&quot;); } JUnit4新断言-Hamcrest的常用方法 JUnit中的部分断言的可读性并不是很好，有时我们不得不自己编写表达式并断言其结果，并且因为我们没有提供失败的信息，当这个断言失败时只会抛出java.lang.AssertionError，无法知道到底是哪一部分出错 JUnit4.4引入了Hamcrest框架，Hamcest提供了一套匹配符Matcher，这些匹配符更接近自然语言，可读性高，更加灵活。并且使用全新的断言语法：assertThat，结合Hamcest提供的匹配符，只用这一个方法，就可以实现所有的测试 assertThat语法assertThat(T actual, Matcher matcher); assertThat(String reason, T actual, Matcher matcher); 其中reason为断言失败时的输出信息，actual为断言的值或对象，matcher为断言的匹配器，里面的逻辑决定了给定的actual对象满不满足断言 Hamcrest提供了一个有用的匹配库一定要先引用Hamcrest的pom &lt;!-- 注意依赖按以下顺序且jnunit4.4后才支持，不然会出现找不到匹配方法 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.hamcrest&lt;/groupId&gt; &lt;artifactId&gt;hamcrest-all&lt;/artifactId&gt; &lt;version&gt;1.3&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.4&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; 核心 anything - 总是匹配,如果你不关心测试下的对象是什么是有用的 describedAs - 添加一个定制的失败表述装饰器 is - 改进可读性装饰器 - 见下 “Sugar” 逻辑【Logical】 allOf- 如果所有匹配器都匹配才匹配(像 Java &amp;&amp;) anyOf - 如果任何匹配器匹配就匹配 (像 Java ||) not - 如果包装的匹配器不匹配器时匹配,反之亦然 对象 equalTo - 测试对象相等使用Object.equals方法 hasToString - 测试Object.toString方法 instanceOf, isCompatibleType - 测试类型 notNullValue, nullValue - 测试null sameInstance - 测试对象实例 Beans hasProperty - 测试JavaBeans属性 集合 array - 测试一个数组元素test an array’s elements against an array of matchers hasEntry, hasKey, hasValue - 测试一个Map包含一个实体,键或者值 hasItem, hasItems - 测试一个集合包含一个元素 hasItemInArray - 测试一个数组包含一个元素 数字 closeTo - 测试浮点值接近给定的值 greaterThan, greaterThanOrEqualTo, lessThan, lessThanOrEqualTo - 测试次序 文本 equalToIgnoringCase - 测试字符串相等忽略大小写 equalToIgnoringWhiteSpace - 测试字符串忽略空白 containsString, endsWith, startsWith - 测试字符串匹配 @Test public void testHamcrest() { //首先需要静态导入import static org.hamcrest.Matchers.*; //判断50是否大于20并且小于60，具体的hamcrest的比较参数可以在文档中查询 assertThat(50,allOf(greaterThan(20),lessThan(60))); //判断某个字符串是否以另一个字符串结尾 assertThat(&quot;abc.txt&quot;,endsWith(&quot;txt&quot;)); } 终端执行命令 mkdir -p ./target/classes &amp;&amp; javac -d ./target/classes/ -cp .:/Users/sxm/.m2/repository/junit/junit/4.11/junit-4.11.jar:/Users/sxm/.m2/repository/org/hamcrest/hamcrest-all/1.3/hamcrest-all-1.3.jar src/test/java/com/ecit/test/CalculatorTest.java src/main/java/com/ecit/test/Calculator.java &amp;&amp; java -cp .:./target/classes:/Users/sxm/.m2/repository/junit/junit/4.11/junit-4.11.jar:/Users/sxm/.m2/repository/org/hamcrest/hamcrest-all/1.3/hamcrest-all-1.3.jar org.junit.runner.JUnitCore com.ecit.test.CalculatorTest 或者 mvn clean test TestSuite测试一组import org.junit.runner.RunWith; import org.junit.runners.Suite; import org.junit.runners.Suite.SuiteClasses; //RunWith表示这个类是一个suite的类 @RunWith(Suite.class) //说明这个类中包含哪些测试组件 @SuiteClasses({TestA.class, TestB.class, TestCalcuate.class}) public class TestSuite { /* * 测试原则： * 1、建议创建一个专门的source folder--&gt;test来编写测试类代码 * 2、测试类的包应该保持和需要测试的类一致 * 3、测试单元中的每一个测试方法都必须可以独立执行，没有顺序 * 测试方法之间不能有任何的依赖性 */ } 测试驱动开发 正常的开发流程编码—&gt;测试—&gt;重复—&gt;提交 基于测试驱动的开发测试—&gt;编码—&gt;重复—&gt;提交先写了测试之后，由于测试的覆盖率要求为100%，所以就会让代码中可能存在的分支都进行测试，这样先写测试单元，可以为将来的代码提供一种有效的参考 Cobertura 测量测试覆盖率 需要引入pom依赖 &lt;dependency&gt; &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt; &lt;artifactId&gt;cobertura-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.7&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; 配置maven插件 &lt;plugin&gt; &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt; &lt;artifactId&gt;cobertura-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.7&lt;/version&gt; &lt;/plugin&gt; 我们执行以下maven命令 mvn cobertura:cobertura ,执行完后会在target目录里找到site目录,用浏览器打开里面的index.html,这就是测试用例执行完后cobertura-maven-plugin得出的覆盖率报告. stub桩思想测试对数据库状态的隔离 dbunit用来隔离数据库的访问 &lt;dependency&gt; &lt;groupId&gt;org.dbunit&lt;/groupId&gt; &lt;artifactId&gt;dbunit&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; dbunit使用示例 创建dbunit的测试数据xml文件 &lt;?xml version=&quot;1.o&quot;encoding=&quot;UTF-8&quot;?&gt; &lt;dataset&gt; &lt;t_user id=&quot;1&quot; username=&quot;admin&quot; password-=&quot;123&quot; nickname=&quot;超级管理员&quot;/&gt; &lt;/dataset&gt; 创建dbunit的Connectiondbunit的Connection是用来对数据文件进行操作的，这个Connection必须依赖于目前项目中所使用的Connection 创建dbunit的测试数据person.xml文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;dataset&gt; &lt;person id=&quot;1&quot; fname=&quot;admin&quot; lname=&quot;admin&quot; age=&quot;12&quot; sex=&quot;1&quot;/&gt; &lt;/dataset&gt; 相应的dbunit测试用例示例**(测试前和测试后数据库数据状态一致，测试中会把数据库数据清除用xml数据插入数据来测试)** import java.io.File; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.FileWriter; import java.io.IOException; import java.io.InputStream; import java.sql.SQLException; import com.ecit.utils.DbUtil; import junit.framework.Assert; import org.dbunit.DatabaseUnitException; import org.dbunit.database.DatabaseConnection; import org.dbunit.database.IDatabaseConnection; import org.dbunit.database.QueryDataSet; import org.dbunit.dataset.DataSetException; import org.dbunit.dataset.IDataSet; import org.dbunit.dataset.xml.FlatXmlDataSet; import org.dbunit.dataset.xml.FlatXmlProducer; import org.dbunit.operation.DatabaseOperation; import org.junit.AfterClass; import org.junit.BeforeClass; import org.xml.sax.InputSource; public class AbstractDbUnitTestCase { public static IDatabaseConnection dbunitCon; private File tempFile; @BeforeClass public static void init() throws DatabaseUnitException, SQLException { dbunitCon = new DatabaseConnection(DbUtil.getConnection()); } protected IDataSet createDateSet(String tname) throws DataSetException { InputStream is = AbstractDbUnitTestCase .class .getClassLoader().getResourceAsStream(tname+&quot;.xml&quot;); Assert.assertNotNull(&quot;dbunit的基本数据文件不存在&quot;,is); return new FlatXmlDataSet(new FlatXmlProducer(new InputSource(is))); } protected void backupAllTable() throws SQLException, IOException, DataSetException { IDataSet ds = dbunitCon.createDataSet(); writeBackupFile(ds); } private void writeBackupFile(IDataSet ds) throws IOException, DataSetException { tempFile = File.createTempFile(&quot;back&quot;,&quot;xml&quot;); FlatXmlDataSet.write(ds, new FileWriter(tempFile)); } protected void backupCustomTable(String[] tname) throws DataSetException, IOException { QueryDataSet ds = new QueryDataSet(dbunitCon); for(String str:tname) { ds.addTable(str); } writeBackupFile(ds); } protected void bakcupOneTable(String tname) throws DataSetException, IOException { backupCustomTable(new String[]{tname}); } protected void resumeTable() throws FileNotFoundException, DatabaseUnitException, SQLException { IDataSet ds = new FlatXmlDataSet(new FlatXmlProducer(new InputSource(new FileInputStream(tempFile)))); DatabaseOperation.CLEAN_INSERT.execute(dbunitCon, ds); } @AfterClass public static void destory() { try { if(dbunitCon!=null) dbunitCon.close(); } catch (SQLException e) { e.printStackTrace(); } } } import com.ecit.dao.UserDao; import com.ecit.pojo.User; import com.ecit.service.IUserService; import com.ecit.service.UserService; import org.dbunit.DatabaseUnitException; import org.dbunit.dataset.DataSetException; import org.dbunit.dataset.IDataSet; import org.dbunit.operation.DatabaseOperation; import org.junit.After; import org.junit.Assert; import org.junit.Before; import org.junit.Test; import java.io.FileNotFoundException; import java.io.IOException; import java.sql.SQLException; import static org.junit.Assert.assertEquals; public class TestUserDbunitService extends AbstractDbUnitTestCase{ private IUserService us; private IDataSet ds; @Before public void setUp() throws DataSetException, IOException { //初始化 us = new UserService(new UserDao()); bakcupOneTable(&quot;person&quot;); ds = createDateSet(&quot;person&quot;); } @Test public void testLoad() throws DatabaseUnitException, SQLException { DatabaseOperation.CLEAN_INSERT.execute(dbunitCon,ds); User tu = us.load(&quot;admin&quot;); assertEquals(tu.getId(), 1); assertEquals(tu.getFname(), &quot;admin&quot;); assertEquals(tu.getLname(), &quot;admin&quot;); assertEquals(tu.getAge(), 12); assertEquals(tu.getSex(), 1); } @Test public void testDelete() throws DatabaseUnitException, SQLException { DatabaseOperation.CLEAN_INSERT.execute(dbunitCon, ds); us.delete(&quot;admin&quot;); User tu = us.load(&quot;admin&quot;); Assert.assertNull(tu); } @After public void tearDown() throws FileNotFoundException, DatabaseUnitException, SQLException { resumeTable(); } } mockmock对象用来对一些未实现关联对象的类进行测试的对象 mock和stub的区别 mock关注的是交互 stub关注的是状态 EasyMock就是实现Mock对象的框架 用到的pom依赖 &lt;dependency&gt; &lt;groupId&gt;org.easymock&lt;/groupId&gt; &lt;artifactId&gt;easymock&lt;/artifactId&gt; &lt;version&gt;4.0.2&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; 关联伪代码强调次数，不强调顺序 public class UserService implements IUserService { private IUserDao userDao; public UserService(IUserDao userDao) { this.userDao = userDao; } @Override public User load(String username) { userDao.delete(&quot;abc&quot;); //涉及下面EasyMock.verify(ud) 次数问题 userDao.load(&quot;asd&quot;); return userDao.load(username); } } @Test public void testLoad() { //1、创建DAO的Mock对象，目前就进入了record阶段 IUserDao ud = EasyMock.createMock(IUserDao.class); User u = new User(1,&quot;admin&quot;,&quot;123&quot;,12,1); //2、记录ud可能会发生的操作的结果 /* * 以下代码所指的是，当在dao中调用了load方法并且参数为admin的时候，返回值是u对象 */ //必须把交互的所有过程都记录下来 EasyMock.expect(ud.load(&quot;asd&quot;)).andReturn(u); ud.delete(&quot;abc&quot;); //以下用来操作没有返回值的方法 EasyMock.expectLastCall(); EasyMock.expect(ud.load(&quot;admin&quot;)).andReturn(u); //3、进入测试阶段，也就是replay阶段 EasyMock.replay(ud); //创建Service和DAO的关联 IUserService us = new UserService(ud); //完成测试 User tu = us.load(&quot;admin&quot;); EntitiesHelper.assertUser(tu,u); //3、验证交互关系是否正确,会到关联的userDao里看调用次数是否有ud.load(&quot;asd&quot;)，ud.delete(&quot;abc&quot;)，ud.load(&quot;admin&quot;)，没有则测试不通过，关注次数不关注先后顺序 EasyMock.verify(ud); } 关联伪代码强调顺序和次序否则不通过public class UserService implements IUserService { private IUserDao userDao; public UserService(IUserDao userDao) { this.userDao = userDao; } @Override public User load(String username) { userDao.load(&quot;asd&quot;); userDao.delete(&quot;abc&quot;); //严格mock策略强调关联userDao的调用顺序和次数 return userDao.load(username); } } @Test public void testLoadStrictMock() { //1、创建DAO的Mock对象，目前就进入了record阶段 IUserDao ud = EasyMock.createStrictMock(IUserDao.class);//意味着强调重现的顺序和次数 User u = new User(1,&quot;admin&quot;,&quot;123&quot;,12,1); EasyMock.expect(ud.load(&quot;asd&quot;)).andReturn(u); //使用的createStrictMock,方法的顺序不一致，所以会抛出异常 ud.delete(&quot;abc&quot;); EasyMock.expectLastCall(); EasyMock.expect(ud.load(&quot;admin&quot;)).andReturn(u); EasyMock.replay(ud); //创建Service和DAO的关联 IUserService us = new UserService(ud); //完成测试 User tu = us.load(&quot;admin&quot;); EntitiesHelper.assertUser(tu,u); //3、验证交互关系是否正确 EasyMock.verify(ud); //验证关联userDao的顺序和次数 } 涉及一组调用的组件场景使用mockControl @Test public void test03() { /** * 此时只会分别来判断s1和s2的顺序，如果两个接口中的方法调用顺序一致 * 就不会报错，而具体的交互的顺序的确不一致 */ s1 = createStrictMock(IService1.class); s2 = createStrictMock(IService2.class); s1.method1(); expectLastCall(); s1.method2(); expectLastCall(); s2.method3(); expectLastCall(); s2.method4(); expectLastCall(); replay(s1,s2); ms.setS1(s1); ms.setS2(s2); ms.m2(); verify(s1,s2); } /** * 使用mockControl可以检查一组调用对象之间的关系 * 所以如果希望使用Strict的方式，而且依赖了两个类以上，这两个依赖类应该通过control的方式创建 */ @Test public void test05() { //可以通过control来创建一组mock IMocksControl mc = createStrictControl(); s1 = mc.createMock(IService1.class); s2 = mc.createMock(IService2.class); s1.method1(); expectLastCall(); s1.method2(); expectLastCall(); s2.method3(); expectLastCall(); s2.method4(); expectLastCall(); //让mock控制器中的进行操作 mc.replay(); ms.setS1(s1); ms.setS2(s2); ms.m2(); //验证mock控制器中的所有mock调用 mc.verify(); } 其它补充例子 public class TestUserServiceByEasyMock { private IUserService us; private IUserDao ud; private User baseUser; @Before public void setUp() { ud = createStrictMock(IUserDao.class); us = new UserService(ud); baseUser = new User(1,&quot;admin&quot;,&quot;123&quot;,&quot;管理员&quot;); } @Test public void testLoad() { expect(ud.load(&quot;admin&quot;)).andReturn(baseUser); replay(ud); User tu = us.load(&quot;admin&quot;); EntitiesHelper.assertUser(tu, baseUser); verify(ud); } @Test public void testDelete() { ud.delete(&quot;admin&quot;); expectLastCall(); replay(ud); us.delete(&quot;admin&quot;); verify(ud); } @Test public void testAddNotExistUser() { expect(ud.load(baseUser.getUsername())).andReturn(null); ud.add(baseUser); expectLastCall(); replay(ud); us.add(baseUser); verify(ud); } @Test(expected=UserException.class) public void testAddExistUser() { expect(ud.load(baseUser.getUsername())).andReturn(baseUser); ud.add(baseUser); expectLastCall(); replay(ud); us.add(baseUser); verify(ud); } @Test public void testLoginOk() { String username = &quot;admin&quot;; String password = &quot;123&quot;; expect(ud.load(username)).andReturn(baseUser); replay(ud); User tu = us.login(username, password); EntitiesHelper.assertUser(tu, baseUser); } @Test(expected=UserException.class) public void testLoginUsernameError() { String username = &quot;admin1&quot;; String password = &quot;123&quot;; expect(ud.load(username)).andReturn(null); replay(ud); User tu = us.login(username, password); EntitiesHelper.assertUser(tu, baseUser); } @Test(expected=UserException.class) public void testLoginPasswordError() { String username = &quot;admin&quot;; String password = &quot;1234&quot;; expect(ud.load(username)).andReturn(baseUser); replay(ud); User tu = us.login(username, password); EntitiesHelper.assertUser(tu, baseUser); } } cactus基于容器的测试cactus可以完成模拟J2EE的容器做测试可以测试Servlet,JSP,Filter和EJBcactus主要是基于junit3.8来进行操作的，并不支持junit4中的annotation; 当测试DAO时我们可以使用DBUnit来进行对数据库的隔离,当我们测试Service的时候可以使用EasyMock来模拟DAO的实现进行Service和DAO的隔离,虽然我们测试Servlet的时候也可以使用EasyMock来对Session,Request等来进行模拟,但实际上我们会发现,使用Mock来模拟Servlet只能测试简单的Servlet,例如Session,Request,Parameter等,对一些Servlet的返回值,返回了什么View等,测试起来还是力不从心,使用Cactus可以产生模拟的容器来对Servlet进行测试,大大减低了测试难度和提高了测试效率 需要依赖的pom文件 &lt;dependency&gt; &lt;groupId&gt;org.apache.cactus&lt;/groupId&gt; &lt;artifactId&gt;cactus.core.framework.uberjar.javaEE.15&lt;/artifactId&gt; &lt;version&gt;1.8.1&lt;/version&gt; &lt;/dependency&gt; 添加cactus.properties,Log4j.properties,cactus.properties示例： cactus.contextURL=http://localhost:8080/cactus/ 依赖服务器先启动场景如tomcat1.先配置web.xml,添加一个org.apache.cactus.server.ServletTestRedirector对象 &lt;servlet&gt; &lt;servlet-name&gt;ServletRedirector&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.cactus.server.ServletTestRedirector&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;ServletRedirector&lt;/servlet-name&gt; &lt;url-pattern&gt;/ServletRedirector&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 2.准备待测的servlet mport javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.HttpSession; import com.ecit.pojo.User; public class LoginServlet extends HttpServlet { private static final long serialVersionUID = 1L; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { resp.setContentType(&quot;text/html;charset=utf-8&quot;); resp.getWriter().println(&quot;&lt;table&gt;&lt;tr&gt;&lt;td&gt;111&lt;/td&gt;&lt;td&gt;222&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&quot;); resp.getWriter().flush(); } public boolean isLogin(HttpServletRequest req) { HttpSession session = req.getSession(); if(session==null) return false; User u = (User)session.getAttribute(&quot;loginUser&quot;); if(u==null) return false; return true; } } 3.准备测试类 import java.io.IOException; import javax.servlet.ServletException; import junit.framework.Assert; import org.apache.cactus.ServletTestCase; import org.apache.cactus.WebRequest; import org.xml.sax.SAXException; import com.meterware.httpunit.WebResponse; import zttc.itat.model.User; /** * 只要写了一个类继承于 ServletTestCase，就会拥有相应的request等方法 * 需要注意的一点就是：此时junit4中的Annotation全部不起作用 * 就得按照junit3的方法来:setUp和tearDown用来做初始化和结束释放资源 * testXX用来做测试 * */ public class TestLoginServletByCactus extends ServletTestCase { private LoginServlet servlet; //begin是在客户端执行的 public void beginNoSession(WebRequest request) { request.setAutomaticSession(false); request.addParameter(&quot;username&quot;, &quot;hyy&quot;); } //在服务器端执行 public void setUp() { servlet = new LoginServlet(); } public void testNoSession() { //服务器端执行 Assert.assertFalse(servlet.isLogin(request)); Assert.assertEquals(request.getParameter(&quot;username&quot;),&quot;hyy&quot;); } public void testSessionNoUser() { Assert.assertFalse(servlet.isLogin(request)); } public void testSessionHasUser() { session.setAttribute(&quot;loginUser&quot;, new User()); Assert.assertTrue(servlet.isLogin(request)); } public void testDoGet() throws ServletException, IOException { servlet.doGet(request, response); } //客户端执行 public void endDoGet(WebResponse resp) { try { Assert.assertEquals(resp.getTables()[0].getCellAsText(0,0),&quot;111&quot;); Assert.assertEquals(resp.getTables()[0].getCellAsText(0,1),&quot;222&quot;); } catch (SAXException e) { e.printStackTrace(); } } }","link":"/2016/12/18/%E5%B7%A5%E5%85%B7/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/JUnit/Junit-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"},{"title":"gradle初步认识","text":"gradle简单介绍 gradle是一款最新的，功能最强大的构建工具，用它逼格更高，maven，ant能做的，它都能做，甚至更多；gradle使用程序代替传统的XML配置，项目构建更灵活；它有更丰富的插件库，提升自动化构建技术深度，完善Android，Java开发体系 gradle quickstart领域特定语言DSL介绍Groovy初探Groovy优势","link":"/2018/07/03/%E5%B7%A5%E5%85%B7/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/gradle/gradle%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86-01/"},{"title":"MySQL第四篇--引擎篇","text":"一般规范 每个表都有自己的主键 字段尽量定义为 NOT NULL（考虑到后期用索引,最好not null） 尽量为每个字段添加备注 数据库字段统一小写，单词之间使用下划线分隔 使用 INNODB存储引擎 可以使用 varchar的字段尽可能不使用TEXT、BLOB类型 表字符集选择UTF8 第一范式：有主键，具有原子性，字段不可分割 第二范式：完全依赖，没有部分依赖 第三范式：没有传递依赖 数据库设计尽量遵循三范式，但是还是根据实际情况进行取舍，有时可能会拿冗余换速度，最终用目的要满足客户需求。 存储引擎SHOW ENGINES 数据库存储引擎是数据库底层软件组织，数据库管理系统(DBMS)使用数据引擎进行创建、查询、 更新和删 除数据。 不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎，还可以获得特定的功能。现在许多不同的数据库管理系统都支持多种不同的数据引擎。 存储引擎主要有: 1. MyIsam , 2. InnoDB, 3. Memory, 4. Archive, 5. Federated 。 Mysql 在 V5.5.5 之前默认存储引擎是 MyISAM;在此之后默认存储引擎是 InnoDB MyISAM存储引擎MyISAM 引擎没有提供对数据库事务的支持，也不支持行级锁和外键， 因此当 INSERT(插入)或 UPDATE(更 新)数据时即写操作需要锁定整个表，效率便会低一些。 MyISAM 执行读取操作的速度很快，而且不占用大量的内存和存储资源。在设计之初就预想数据组织成有固 定长度的记录，按顺序存储的。---MyISAM 是一种静态索引结构。 • 它管理的表具有以下特征: – 使用三个文件表示每个表: • 格式文件 — 存储表结构的定义(mytable.frm) • 数据文件 — 存储表行的内容(mytable.MYD) • 索引文件 — 存储表上索引(mytable.MYI) – 灵活的 AUTO_INCREMENT 字段处理 – 可被转换为压缩、只读表来节省空间 – 不支持事务 InnoDB存储引擎InnoDB 底层存储结构为 B+树， B 树的每个节点对应 innodb 的一个 page，page 大小是固定的， 一般设为16k。其中非叶子节点只有键值，叶子节点包含完成数据 它管理的表具有下列主要特征: – 每个 InnoDB 表在数据库目录中以.frm 格式文件表示 – InnoDB 表空间被用于存储表的内容 – 提供一组用来记录事务性活动的日志文件 – 用 COMMIT(提交)、SAVEPOINT 及 ROLLBACK(回滚)支持事务处理 – 提供全 ACID 兼容 – 在 MySQL 服务器崩溃后提供自动恢复 – 多版本(MVCC)和行级锁定 – 支持外键及引用的完整性，包括级联删除和更新 • 适用场景: – 经常更新的表，适合处理多重并发的更新请求。 – 支持事务。 – 可以从灾难中恢复(通过 bin-log 日志等)。 – 外键约束。只有他支持外键。 – 支持自动增加列属性 auto_increment。 – Innodb 支持事务，支持行级锁，更好的恢复性，高并发下性能更好。 MEMORY存储引擎Memory(也叫 HEAP)堆内存:使用存在内存中的内容来创建表。每个 MEMORY 表只实际对应一个磁盘文 件。MEMORY 类型的表访问非常得快，因为它的数据是放在内存中的，并且默认使用 HASH 索引。但是一旦服 务关闭，表中的数据就会丢失掉。 Memory 同时支持散列索引和 B 树索引，B 树索引可以使用部分查询和通配查 询，也可以使用&lt;,&gt;和&gt;=等操作符方便数据挖掘，散列索引相等的比较快但是对于范围的比较慢很多。 • 使用 MEMORY 存储引擎的表，其数据存储在内存中，且行的长度固定，这两个特点使得 MEMORY 存储引擎 非常快。 • MEMORY 存储引擎管理的表具有下列特征: – 在数据库目录内，每个表均以.frm 格式的文件表示。 – 表数据及索引被存储在内存中。 – 表级锁机制。 – 不能包含 TEXT 或 BLOB 字段。 • MEMORY 存储引擎以前被称为 HEAP 引擎。 TokuDBTokuDB底层存储结构为FractalTre(e节点带数分形树据),FractalTree的结构与B+树有些类似,在FractalTree 中，每一个 child 指针除了需要指向一个 child 节点外，还会带有一个 Message Buffer ，这个 Message Buffer 是一个 FIFO 的队列，用来缓存更新操作。 例如，一次插入操作只需要落在某节点的 Message Buffer 就可以马上返回了，并不需要搜索到叶子节点。这些 缓存的更新会在查询时或后台异步合并应用到对应的节点中。 TokuDB 在线添加索引，不影响读写操作, 非常快的写入性能， Fractal-tree 在事务实现上有优势。他主要适用于 访问频率不高的数据或历史数据归档。 InnoDB和MyIsam的对比两者的区别: 1. count 运算上的区别: 因为 MyISAM 缓存有表 meta-data(行数等)，因此在做 COUNT(*)时对于一个结构很好 的查询是不需要消耗多少资源的。而对于 InnoDB 来说，则没有这种缓存 2. 是否支持事务和崩溃后的安全恢复: MyISAM 强调的是性能，每次查询具有原子性,其执行数度比 InnoDB 类型 更快，但是不提供事务支持。但是 InnoDB 提供事务支持事务，外部键等高级数据库功能。 具有事务 (commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。 3. 是否支持外键: MyISAM 不支持，而 InnoDB 支持。 4.是否支持行级锁 : MyISAM 只有表级锁(table-level locking)，而 InnoDB 支持行级锁(row-level locking)和表级锁, 默认为行级锁。 MyISAM 更适合读密集的表，而 InnoDB 更适合写密集的的表。 在数据库做主从分离的情况下，经常选择 MyISAM 作为主库的存储引擎。 一般来说，如果需要事务支持，并且有较高的并发读取频率(MyISAM 的表锁的粒度太大，所以当该表写并发 量较高时，要等待的查询就会很多了)，InnoDB 是不错的选择。如果你的数据量很大(MyISAM 支持压缩特性可以 减少磁盘的空间占用)，而且不需要支持事务时，MyISAM 是最好的选择","link":"/2016/10/10/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL%E7%AC%AC%E5%9B%9B%E7%AF%87--%E5%BC%95%E6%93%8E%E7%AF%87/"},{"title":"SonarQube代码质量检测","text":"密码信息操作系统：root / root；sonar / sonar；(zhangxiaoxi / zhangxiaoxi) 数据库：root / root； Ubuntu更换阿里源# 备份原来的源 sudo cp /etc/apt/sources.list /etc/apt/sources_init.list # 更换源 sudo vi /etc/apt/sources.list # 将阿里源复制进去 deb http://mirrors.aliyun.com/ubuntu/ xenial main deb-src http://mirrors.aliyun.com/ubuntu/ xenial main deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main deb http://mirrors.aliyun.com/ubuntu/ xenial universe deb-src http://mirrors.aliyun.com/ubuntu/ xenial universe deb http://mirrors.aliyun.com/ubuntu/ xenial-updates universe deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates universe deb http://mirrors.aliyun.com/ubuntu/ xenial-security main deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main deb http://mirrors.aliyun.com/ubuntu/ xenial-security universe deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security universe # 更新源 sudo apt-get update # 更新软件 sudo apt-get upgrade 安装OpenJDK# 更新软件包列表 sudo apt-get udpate # 安装openjdk-8-jdk sudo apt-get install openjdk-8-jdk # 如果安装失败，可以使用--fix-missing修复 sudo apt-get install openjdk-8-jdk --fix-missing # 查询是否安装成功 java -version Ubuntu 18.04安装Java JDK8三种方式 首次登陆Ubuntu设置root密码# 修改密码 sudo passwd # 输入两次新密码，OK 安装mysql5.7sudo apt-get udpate # mysql-server sudo apt-get install mysql-server # mysql-client sudo apt install mysql-client # dev sudo apt install libmysqlclient-dev # 查看情况 sudo netstat -tap | grep mysql 修改mysql root密码# 切换root用户 su # 登陆mysql mysql # 打开数据库名字为mysql的数据库 use mysql # 修改mysql的密码 update user set authentication_string=PASSWORD(&quot;root&quot;)where user='root'; # 输入 update user set plugin=&quot;mysql_native_password&quot;; # 刷新权限 flush privileges; # 退出mysql命令行 quit; # 重新打开Ubuntu18.04终端，正常使用其他用户登录mysql mysql -uroot -p Ubuntu18.04下安装mysql5.7超详细步骤 创建sonar数据库mysql -uroot -p CREATE DATABASE sonar DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci; CREATE USER 'sonar' IDENTIFIED BY 'sonar'; GRANT ALL ON sonar.* TO 'sonar'@'%' IDENTIFIED BY 'sonar'; GRANT ALL ON sonar.* TO 'sonar'@'localhost' IDENTIFIED BY 'sonar'; FLUSH PRIVILEGES; 在Ubuntu 18.04上搭建SonarQube服务 上传SonarQube软件包到服务器scp sonarqube-6.7.7.zip sonar@192.168.56.130:/home/sonar 解压zip包# 没有unzip，需要安装 sudo apt install unzip # 解压 unzip sonarqube-6.7.7.zip 配置环境变量# 使用vim编辑 sudo vim /etc/profile # 添加内容 SONAR_HOME=&quot;/home/sonar/sonarqube-6.7.7/&quot; # 重启环境变量 . /etc/profile 在Ubuntu 18.04上搭建SonarQube服务 配置数据库。修改/conf/sonar.properties文件内容（都是取消注释，稍微修改就可以了）sonar.jdbc.username=root sonar.jdbc.password=root sonar.jdbc.url=jdbc:mysql://localhost:3306/sonar?useUnicode=true&amp;characterEncoding=utf8&amp;rewriteBatchedStatements=true&amp;useConfigs=maxPerformance&amp;useSSL=false sonar.web.host=0.0.0.0 sonar.web.context=/sonar sonar.web.port=9000 命令启动SonarQube，并检查SonarQube的启动状态cd sonarqube-6.7.7/bin/linux-x86-64 # 启动 ./sonar.sh start # 检查状态 ./sonar.sh status 访问浏览器输入：http://虚拟机IP:9000/sonar 即可访问SonarQube主页。 默认管理账户是：admin / admin 安装插件插件页面： 网址：https://docs.sonarqube.org/display/PLUG/Plugin+Library 下载相关插件jar包，放入/home/sonar/sonarqube-6.7.7/extensions/plugins/目录下 maven配置在MAVEN_HOME/conf/settings.xml中添加配置 &lt;!-- sonar相关配置 --&gt; &lt;pluginGroups&gt; &lt;pluginGroup&gt;org.sonarsource.scanner.maven&lt;/pluginGroup&gt; &lt;/pluginGroups&gt; &lt;profiles&gt; &lt;profile&gt; &lt;id&gt;sonar&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;properties&gt; &lt;sonar.host.url&gt;http://10.211.55.12:9000/sonar&lt;/sonar.host.url&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;/profiles&gt; 使用mvn sonar:sonar命令执行代码分析Run/Debug Configurations -&gt; Maven -&gt; sonar:sonar 执行代码分析","link":"/2015/08/03/%E5%B7%A5%E5%85%B7/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/Ubuntu1804%E5%AE%89%E8%A3%85SonarQube/"},{"title":"java日志框架","text":"日志文件引申的问题问题: 1.控制日志输出的内容和格式 2.控制日志输出的位置 3.日志优化:异步日志，日志文件的归档和压缩 4.日志系统的维护 5.面向接口开发 -- 日志的门面 为什么要用日志框架因为软件系统发展到今天已经很复杂了，特别是服务器端软件，涉及到的知识，内容，问题太多。在某 些方面使用别人成熟的框架，就相当于让别人帮你完成一些基础工作，你只需要集中精力完成系统的业 务逻辑设计。而且框架一般是成熟，稳健的，他可以处理系统很多细节问题，比如，事务处理，安全 性，数据流控制等问题。还有框架一般都经过很多人使用，所以结构很好，所以扩展性也很好，而且它 是不断升级的，你可以直接享受别人升级代码带来的好处. 现有的日志框架日志实现: JUL(java util logging)、logback、log4j、log4j2 日志门面: JCL(Jakarta Commons Logging)、slf4j( Simple Logging Facade for Java) JUL全称Java util Logging是java原生的日志框架，使用时不需要另外引用第三方类库，相对其他日志框架使用方便，学习简单，能够在小型应用中灵活使用。 Loggers:被称为记录器，应用程序通过获取Logger对象，调用其API来来发布日志信息。Logger 通常时应用程序访问日志系统的入口程序。 Appenders:也被称为Handlers，每个Logger都会关联一组Handlers，Logger会将日志交给关联 Handlers处理，由Handlers负责将日志做记录。Handlers在此是一个抽象，其具体的实现决定了 日志记录的位置可 以是控制台、文件、网络上的其他日志服务或操作系统日志等。 Layouts:也被称为Formatters，它负责对日志事件中的数据进行转换和格式化。Layouts决定了数据在一条日志记录中的最终形式。 Level:每条日志消息都有一个关联的日志级别。该级别粗略指导了日志消息的重要性和紧迫，我可以将Level和Loggers，Appenders做关联以便于我们过滤消息。 Filters:过滤器，根据需要定制哪些信息会被记录，哪些信息会被放过。 总结一下就是: 用户使用Logger来进行日志记录，Logger持有若干个Handler，日志的输出操作是由Handler完成的。 在Handler在输出日志前，会经过Filter的过滤，判断哪些日志级别过滤放行哪些拦截，Handler会将日 志内容输出到指定位置(日志文件、控制台等)。Handler在输出日志时会使用Layout，将输出内容进 行排版 架构介绍 使用示例 public class JULTest { @Test public void testQuick() throws Exception { // 1.创建日志记录器对象 Logger logger = Logger.getLogger(&quot;com.itheima.log.JULTest&quot;); // 2.日志记录输出 logger.info(&quot;hello jul&quot;); logger.log(Level.INFO, &quot;info msg&quot;); String name = &quot;jack&quot;; Integer age = 18; logger.log(Level.INFO, &quot;用户信息：{0},{1}&quot;, new Object[]{name, age}); } } jul中定义的日志级别 java.util.logging.Level中定义了日志的级别: SEVERE(最高值) WARNING INFO (默认级别) CONFIG FINE FINER FINEST(最低值) 还有两个特殊的级别: OFF，可用来关闭日志记录。 ALL，启用所有消息的日志记录。 @Test public void testLogLevel() throws Exception { // 1.获取日志对象 Logger logger = Logger.getLogger(&quot;com.itheima.log.QuickTest&quot;); // 2.日志记录输出 logger.severe(&quot;severe&quot;); logger.warning(&quot;warning&quot;); logger.info(&quot;info&quot;); logger.config(&quot;cofnig&quot;); logger.fine(&quot;fine&quot;); logger.finer(&quot;finer&quot;); logger.finest(&quot;finest&quot;); } 自定义日志级别配置 @Test public void testLogConfig() throws Exception { // 1.创建日志记录器对象 Logger logger = Logger.getLogger(&quot;com.itheima.log.JULTest&quot;); // 一、自定义日志级别 // a.关闭系统默认配置 logger.setUseParentHandlers(false); // b.创建handler对象 ConsoleHandler consoleHandler = new ConsoleHandler(); // c.创建formatter对象 SimpleFormatter simpleFormatter = new SimpleFormatter(); // d.进行关联 consoleHandler.setFormatter(simpleFormatter); logger.addHandler(consoleHandler); // e.设置日志级别 logger.setLevel(Level.ALL); consoleHandler.setLevel(Level.ALL); // 二、输出到日志文件 FileHandler fileHandler = new FileHandler(&quot;d:/logs/jul.log&quot;); fileHandler.setFormatter(simpleFormatter); logger.addHandler(fileHandler); // 2.日志记录输出 logger.severe(&quot;severe&quot;); logger.warning(&quot;warning&quot;); logger.info(&quot;info&quot;); logger.config(&quot;config&quot;); logger.fine(&quot;fine&quot;); logger.finer(&quot;finer&quot;); logger.finest(&quot;finest&quot;); Logger之间的父子关系JUL中Logger之间存在父子关系，这种父子关系通过树状结构存储，JUL在初始化时会创建一个顶层 RootLogger作为所有Logger父Logger，存储上作为树状结构的根节点。并父子关系通过路径来关联。 import java.util.logging.ConsoleHandler; import java.util.logging.Level; import java.util.logging.Logger; import java.util.logging.SimpleFormatter; public class TestLog { @Test public void testLogParent() throws Exception { // 日志记录器对象父子关系 Logger logger1 = Logger.getLogger(&quot;com.ecit.service.xx.log&quot;); Logger logger2 = Logger.getLogger(&quot;com.ecit&quot;); System.out.println(logger1.getParent() == logger2);//true // 所有日志记录器对象的顶级父元素 class为java.util.logging.LogManager$RootLogger name为&quot;&quot; System.out.println(&quot;logger2 parent:&quot; + logger2.getParent() + &quot;，name:&quot; + logger2.getParent().getName()); // 一、自定义日志级别 // a.关闭系统默认配置 logger2.setUseParentHandlers(false); // b.创建handler对象 ConsoleHandler consoleHandler = new ConsoleHandler(); // c.创建formatter对象 SimpleFormatter simpleFormatter = new SimpleFormatter(); // d.进行关联 consoleHandler.setFormatter(simpleFormatter); logger2.addHandler(consoleHandler); // e.设置日志级别 logger2.setLevel(Level.ALL); consoleHandler.setLevel(Level.ALL); // 测试日志记录器对象父子关系 logger1.severe(&quot;severe&quot;); logger1.warning(&quot;warning&quot;); logger1.info(&quot;info&quot;); logger1.config(&quot;config&quot;); logger1.fine(&quot;fine&quot;); logger1.finer(&quot;finer&quot;); logger1.finest(&quot;finest&quot;); } } JUL日志的配置文件默认配置文件路径 $JAVAHOME\\jre\\lib\\logging.properties ## RootLogger使用的处理器(获取时设置) handlers= java.util.logging.ConsoleHandler # RootLogger日志等级 .level= INFO ## 自定义Logger com.ecit.handlers= java.util.logging.FileHandler # 自定义Logger日志等级 com.ecit.level= INFO # 忽略父日志设置 com.ecit.useParentHandlers=false ## 控制台处理器 # 输出日志级别 java.util.logging.ConsoleHandler.level = INFO # 输出日志格式 java.util.logging.ConsoleHandler.formatter = java.util.logging.SimpleFormatter ## 文件处理器 # 输出日志级别 java.util.logging.FileHandler.level=INFO # 输出日志格式 java.util.logging.FileHandler.formatter = java.util.logging.SimpleFormatter # 输出日志文件路径 java.util.logging.FileHandler.pattern = /java%u.log # 输出日志文件限制大小(50000字节) java.util.logging.FileHandler.limit = 50000 # 输出日志文件限制个数 java.util.logging.FileHandler.count = 10 # 输出日志文件 是否是追加 java.util.logging.FileHandler.append=true 日志原理解析1.初始化LogManager a.LogManager加载logging.properties配置 b.添加Logger到LogManager 2.从单例LogManager获取Logger 3.设置级别Level，并指定日志记录LogRecord 4.Filter提供了日志级别之外更细粒度的控制 5.Handler是用来处理日志输出位置 6.Formatter是用来格式化LogRecord的 示例:@Test public void testProperties() throws Exception { // 读取自定义配置文件 InputStream in = JULTest.class.getClassLoader().getResourceAsStream(&quot;logging.properties&quot;); // 获取日志管理器对象 LogManager logManager = LogManager.getLogManager(); // 通过日志管理器加载配置文件 logManager.readConfiguration(in); Logger logger = Logger.getLogger(&quot;com.ecit.log.JULTest&quot;); logger.severe(&quot;severe&quot;); logger.warning(&quot;warning&quot;); logger.info(&quot;info&quot;); logger.config(&quot;config&quot;); logger.fine(&quot;fine&quot;); logger.finer(&quot;finer&quot;); logger.finest(&quot;finest&quot;); } LOG4J 学习Log4j是Apache下的一款开源的日志框架，通过在项目中使用 Log4J，我们可以控制日志信息输出到控 制台、文件、甚至是数据库中。我们可以控制每一条日志的输出格式，通过定义日志的输出级别，可以 更灵活的控制日志的输出过程。方便项目的调试 官方网站: http://logging.apache.org/log4j/1.2/ 需要pom依赖 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 日志的级别 每个Logger都被了一个日志级别(log level)，用来控制日志信息的输出。日志级别从高到低分 为: fatal 指出每个严重的错误事件将会导致应用程序的退出。 error 指出虽然发生错误事件，但仍然不影响系统的继续运行。 warn 表明会出现潜在的错误情形。 info 一般和在粗粒度级别上，强调应用程序的运行全程。 debug 一般用于细粒度级别上，对调试应用程序非常有帮助。 trace 是程序追踪，可以用于输出程序运行中的变量，显示执行的流程。 还有两个特殊的级别: OFF，可用来关闭日志记录。 ALL，启用所有消息的日志记录。 注:一般只使用4个级别，优先级从高到低为 ERROR &gt; WARN &gt; INFO &gt; DEBUG 示例： public class Log4jTest { @Test public void testQuick() throws Exception { // 初始化系统配置，不需要配置文件 BasicConfigurator.configure(); // 日志级别 logger.fatal(&quot;fatal&quot;); // 严重错误，一般会造成系统崩溃和终止运行 logger.error(&quot;error&quot;); // 错误信息，但不会影响系统运行 logger.warn(&quot;warn&quot;); // 警告信息，可能会发生问题 logger.info(&quot;info&quot;);// 程序运行信息，数据库的连接、网络、IO操作等 logger.debug(&quot;debug&quot;);// 调试信息，一般在开发阶段使用，记录程序的变量、参数等 logger.trace(&quot;trace&quot;);// 追踪信息，记录程序的所有流程信息 // 创建日志记录器对象 Logger logger = Logger.getLogger(Log4jTest.class); // 日志记录输出 logger.info(&quot;hello log4j&quot;); } } Log4j组件 Log4J 主要由 Loggers (日志记录器)、Appenders(输出端)和 Layout(日志格式化器)组成。其中 Loggers 控制日志的输出级别与日志是否输出; Appenders 指定日志的输出方式(输出到控制台、文件 等); Layout 控制日志信息的输出格式 Loggers 日志记录器，负责收集处理日志记录，实例的命名就是类“XX”的full quailied name(类的全限定名)， Logger的名字大小写敏感，其命名有继承机制:例如:name为org.apache.commons的logger会继承 name为org.apache的logger。 Log4J中有一个特殊的logger叫做“root”，他是所有logger的根，也就意味着其他所有的logger都会直接 或者间接地继承自root。root logger可以用Logger.getRootLogger()方法获取。 但是，自log4j 1.2版以来， Logger 类已经取代了 Category 类。对于熟悉早期版本的log4j的人来说， Logger 类可以被视为 Category 类的别名 Layouts 布局器 Layouts用于控制日志输出内容的格式，让我们可以使用各种需要的格式输出日志。Log4j常用的Layouts: 格式化器类型 作用 HTMLLayout 格式化日志输出为HTML表格形式 SimpleLayout 简单的日志输出格式化，打印的日志格式为（info - message） PatternLayout 最强大的格式化期，可以根据自定义格式输出日志，如果没有指定转换格式， 就是用默认的转换格式 Layout的格式 在 log4j.properties 配置文件中，我们定义了日志输出级别与输出端，在输出端中分别配置日志的输出格式。 log4j 采用类似 C 语言的 printf 函数的打印格式格式化日志信息，具体的占位符及其含义如下: %m 输出代码中指定的日志信息 %p 输出优先级，及 DEBUG、INFO 等 %n 换行符(Windows平台的换行符为 &quot;\\n&quot;，Unix 平台为 &quot;\\n&quot;) %r 输出自应用启动到输出该 log 信息耗费的毫秒数 %c 输出打印语句所属的类的全名 %t 输出产生该日志的线程全名 %d 输出服务器当前时间，默认为 ISO8601，也可以指定格式，如:%d{yyyy年MM月dd日HH:mm:ss} %l 输出日志时间发生的位置，包括类名、线程、及在代码中的行数。如:Test.main(Test.java:10) %F 输出日志消息产生时所在的文件名称 %L 输出代码中的行号 %% 输出一个 &quot;%&quot; 字符 可以在 % 与字符之间加上修饰符来控制最小宽度、最大宽度和文本的对其方式。如: %5c 输出category名称，最小宽度是5，category&lt;5，默认的情况下右对齐 %-5c 输出category名称，最小宽度是5，category&lt;5，&quot;-&quot;号指定左对齐,会有空格 %.5c 输出category名称，最大宽度是5，category&gt;5，就会将左边多出的字符截掉，&lt;5不会有空格 %20.30c category名称&lt;20补空格，并且右对齐，&gt;30字符，就从左边交远销出的字符截掉 Appenders Appender 用来指定日志输出到哪个地方，可以同时指定日志的输出目的地。Log4j 常用的输出目的地 有以下几种: 输出端类型 作用 ConsoleAppender 将日志输出到控制台 FileAppender 将日志输出到文件中 DailyRollingFileAppender 将日志输出到一个日志文件，并且每天输出到一个新的文件 RollingFileAppender 将日志信息输出到一个日志文件，并且指定文件的尺寸，当文件大 小达到指定尺寸时，会自动把文件改名，同时产生一个新的文件 JDBCAppender 把日志信息保存到数据库中 Appender的输出控制台，文件，数据库 #指定日志的输出级别与输出端 log4j.rootLogger=INFO,Console #控制台输出配置 log4j.appender.Console=org.apache.log4j.ConsoleAppender log4j.appender.Console.layout=org.apache.log4j.PatternLayout log4j.appender.Console.layout.ConversionPattern=%d [%t] %-5p [%c] - %m%n #文件输出配置 log4j.appender.A = org.apache.log4j.DailyRollingFileAppender #指定日志的输出路径 log4j.appender.A.File = D:/log.txt log4j.appender.A.Append = true #使用自定义日志格式化器 log4j.appender.A.layout = org.apache.log4j.PatternLayout #指定日志的输出格式 log4j.appender.A.layout.ConversionPattern = %-d{yyyy-MM-dd HH:mm:ss} [%t:%r] - [%p] %m%n #指定日志的文件编码 log4j.appender.A.encoding=UTF-8 #mysql log4j.appender.logDB=org.apache.log4j.jdbc.JDBCAppender log4j.appender.logDB.layout=org.apache.log4j.PatternLayout log4j.appender.logDB.Driver=com.mysql.jdbc.Driver log4j.appender.logDB.URL=jdbc:mysql://localhost:3306/test log4j.appender.logDB.User=root log4j.appender.logDB.Password=root log4j.appender.logDB.Sql=INSERT INTO log(project_name,create_date,level,category,file_name,thread_name,line,all_category,message) values('itcast','%d{yyyy-MM-ddHH:mm:ss}','%p','%c','%F','%t','%L','%l','%m') CREATE TABLE `log` ( `log_id` int(11) NOT NULL AUTO_INCREMENT, `project_name` varchar(255) DEFAULT NULL COMMENT '目项名', `create_date` varchar(255) DEFAULT NULL COMMENT '创建时间', `level` varchar(255) DEFAULT NULL COMMENT '优先级', `category` varchar(255) DEFAULT NULL COMMENT '所在类的全名', `file_name` varchar(255) DEFAULT NULL COMMENT '输出日志消息产生时所在的文件名称 ', `thread_name` varchar(255) DEFAULT NULL COMMENT '日志事件的线程名', `line` varchar(255) DEFAULT NULL COMMENT '号行', `all_category` varchar(255) DEFAULT NULL COMMENT '日志事件的发生位置', `message` varchar(4000) DEFAULT NULL COMMENT '输出代码中指定的消息', PRIMARY KEY (`log_id`) ); 自定义Logger,log4j.properties配置信息示例 # RootLogger配置,指定日志级别=trace，使用的 apeender 为console log4j.rootLogger = trace,console # 自定义 logger 对象设置 log4j.logger.com.itheima = info,console log4j.logger.org.apache = error # 指定控制台日志输出的 appender log4j.appender.console = org.apache.log4j.ConsoleAppender # 指定消息格式 layout log4j.appender.console.layout = org.apache.log4j.PatternLayout # 指定消息格式的内容 log4j.appender.console.layout.conversionPattern = [%-10p]%r %l %d{yyyy-MM-dd HH:mm:ss.SSS} %m%n # %m 输出代码中指定的日志信息 # %p 输出优先级，及 DEBUG、INFO 等 # %n 换行符（Windows平台的换行符为 &quot;\\n&quot;，Unix 平台为 &quot;\\n&quot;） # %r 输出自应用启动到输出该 log 信息耗费的毫秒数 # %c 输出打印语句所属的类的全名 # %t 输出产生该日志的线程全名 # %d 输出服务器当前时间，默认为 ISO8601，也可以指定格式，如：%d{yyyy年MM月dd日 HH:mm:ss} # %l 输出日志时间发生的位置，包括类名、线程、及在代码中的行数。如：Test.main(Test.java:10) # %F 输出日志消息产生时所在的文件名称 # %L 输出代码中的行号 # %% 输出一个 &quot;%&quot; 字符 # 日志文件输出的 appender 对象 log4j.appender.file = org.apache.log4j.FileAppender # 指定消息格式 layout log4j.appender.file.layout = org.apache.log4j.PatternLayout # 指定消息格式的内容 log4j.appender.file.layout.conversionPattern = [%-10p]%r %l %d{yyyy-MM-dd HH:mm:ss.SSS} %m%n # 指定日志文件保存路径 log4j.appender.file.file = /logs/log4j.log # 指定日志文件的字符集 log4j.appender.file.encoding = UTF-8 # 按照文件大小拆分的 appender 对象 # 日志文件输出的 appender 对象 log4j.appender.rollingFile = org.apache.log4j.RollingFileAppender # 指定消息格式 layout log4j.appender.rollingFile.layout = org.apache.log4j.PatternLayout # 指定消息格式的内容 log4j.appender.rollingFile.layout.conversionPattern = [%-10p]%r %l %d{yyyy-MM-dd HH:mm:ss.SSS} %m%n # 指定日志文件保存路径 log4j.appender.rollingFile.file = /logs/log4j.log # 指定日志文件的字符集 log4j.appender.rollingFile.encoding = UTF-8 # 指定日志文件内容的大小 log4j.appender.rollingFile.maxFileSize = 1MB # 指定日志文件的数量 log4j.appender.rollingFile.maxBackupIndex = 10 # 按照时间规则拆分的 appender 对象 log4j.appender.dailyFile = org.apache.log4j.DailyRollingFileAppender # 指定消息格式 layout log4j.appender.dailyFile.layout = org.apache.log4j.PatternLayout # 指定消息格式的内容 log4j.appender.dailyFile.layout.conversionPattern = [%-10p]%r %l %d{yyyy-MM-dd HH:mm:ss.SSS} %m%n # 指定日志文件保存路径 log4j.appender.dailyFile.file = /logs/log4j.log # 指定日志文件的字符集 log4j.appender.dailyFile.encoding = UTF-8 # 指定日期拆分规则 log4j.appender.dailyFile.datePattern = '.'yyyy-MM-dd-HH-mm-ss #mysql log4j.appender.logDB=org.apache.log4j.jdbc.JDBCAppender log4j.appender.logDB.layout=org.apache.log4j.PatternLayout log4j.appender.logDB.Driver=com.mysql.jdbc.Driver log4j.appender.logDB.URL=jdbc:mysql://localhost:3306/test log4j.appender.logDB.User=root log4j.appender.logDB.Password=root log4j.appender.logDB.Sql=INSERT INTO log(project_name,create_date,level,category,file_name,thread_name,line,all_category,message) values('itcast','%d{yyyy-MM-dd HH:mm:ss}','%p','%c','%F','%t','%L','%l','%m') ```java @Test public void testCustomLogger() throws Exception { // 自定义 com.ecit 包测试 Logger logger1 = Logger.getLogger(Log4jTest.class); logger1.fatal(&quot;fatal&quot;); // 严重错误，一般会造成系统崩溃和终止运行 logger1.error(&quot;error&quot;); // 错误信息，但不会影响系统运行 logger1.warn(&quot;warn&quot;); // 警告信息，可能会发生问题 logger1.info(&quot;info&quot;); // 程序运行信息，数据库的连接、网络、IO操作等 logger1.debug(&quot;debug&quot;); // 调试信息，一般在开发阶段使用，记录程序的变量、参数等 logger1.trace(&quot;trace&quot;); // 追踪信息，记录程序的所有流程信息 } ```","link":"/2015/08/04/framework/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E7%AC%AC%E4%B8%80%E7%AF%87/"},{"title":"技术框架工具效率篇汇总","text":"函数式编程流式编程线程池精进资源关闭工具集验证框架实用工具开发神器自测工具三种方式的特点 ◆Checkstyle:检查源文件，主要关注格式 ◆FindBugs:基于Bug Patterns概念，检查.class文件中的潜在Bug ◆PMD:基于静态规则集，检查源文件中的潜在问题 idea插件 ◆QAPlug-Checkstyle ◆QAPlug-FindBugs ◆QAPlug-PMD SonarQube是一个用于代码质量管理的开源平台，用于管理源代码的质量。支持七个维度，二十几种编程语言。通过自动代码审查工具，可检测代码中的措误，漏洞和代码异味。可以与您现有的工作流程集成，以实现跨项目分支和请求的连续代码检查。","link":"/2018/11/03/%E5%89%8D%E7%AB%AF/%E9%A1%B9%E7%9B%AE%E6%A1%88%E4%BE%8B/%E5%9C%A8%E7%BA%BF%E6%95%99%E8%82%B2%E5%B9%B3%E5%8F%B0/%E6%95%88%E7%8E%87%E7%AF%87%E6%B1%87%E6%80%BB/"}],"tags":[{"name":"PHP","slug":"PHP","link":"/tags/PHP/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"Groovy","slug":"Groovy","link":"/tags/Groovy/"},{"name":"终端命令","slug":"终端命令","link":"/tags/%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4/"},{"name":"Homebrew","slug":"Homebrew","link":"/tags/Homebrew/"},{"name":"MAC","slug":"MAC","link":"/tags/MAC/"},{"name":"JAVASE语法","slug":"JAVASE语法","link":"/tags/JAVASE%E8%AF%AD%E6%B3%95/"},{"name":"JAVASE高级特性","slug":"JAVASE高级特性","link":"/tags/JAVASE%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"},{"name":"Properties","slug":"Properties","link":"/tags/Properties/"},{"name":"stream","slug":"stream","link":"/tags/stream/"},{"name":"国际化应用","slug":"国际化应用","link":"/tags/%E5%9B%BD%E9%99%85%E5%8C%96%E5%BA%94%E7%94%A8/"},{"name":"反射机制","slug":"反射机制","link":"/tags/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"},{"name":"泛型","slug":"泛型","link":"/tags/%E6%B3%9B%E5%9E%8B/"},{"name":"网络编程","slug":"网络编程","link":"/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"JVM","slug":"JVM","link":"/tags/JVM/"},{"name":"正则表达式","slug":"正则表达式","link":"/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"react native","slug":"react-native","link":"/tags/react-native/"},{"name":"node","slug":"node","link":"/tags/node/"},{"name":"产品","slug":"产品","link":"/tags/%E4%BA%A7%E5%93%81/"},{"name":"工具","slug":"工具","link":"/tags/%E5%B7%A5%E5%85%B7/"},{"name":"Photoshop","slug":"Photoshop","link":"/tags/Photoshop/"},{"name":"UML","slug":"UML","link":"/tags/UML/"},{"name":"小程序","slug":"小程序","link":"/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"三方支付","slug":"三方支付","link":"/tags/%E4%B8%89%E6%96%B9%E6%94%AF%E4%BB%98/"},{"name":"英语天地","slug":"英语天地","link":"/tags/%E8%8B%B1%E8%AF%AD%E5%A4%A9%E5%9C%B0/"},{"name":"代理设计模式","slug":"代理设计模式","link":"/tags/%E4%BB%A3%E7%90%86%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"反射","slug":"反射","link":"/tags/%E5%8F%8D%E5%B0%84/"},{"name":"单例模式","slug":"单例模式","link":"/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"name":"线程安全","slug":"线程安全","link":"/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"},{"name":"solr","slug":"solr","link":"/tags/solr/"},{"name":"lucene","slug":"lucene","link":"/tags/lucene/"},{"name":"SpringMVC","slug":"SpringMVC","link":"/tags/SpringMVC/"},{"name":"springboot","slug":"springboot","link":"/tags/springboot/"},{"name":"springcloud","slug":"springcloud","link":"/tags/springcloud/"},{"name":"权限管理","slug":"权限管理","link":"/tags/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"},{"name":"业务领域","slug":"业务领域","link":"/tags/%E4%B8%9A%E5%8A%A1%E9%A2%86%E5%9F%9F/"},{"name":"中间件","slug":"中间件","link":"/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"vsftpd","slug":"vsftpd","link":"/tags/vsftpd/"},{"name":"nginx","slug":"nginx","link":"/tags/nginx/"},{"name":"redis","slug":"redis","link":"/tags/redis/"},{"name":"NOSQL","slug":"NOSQL","link":"/tags/NOSQL/"},{"name":"kafka","slug":"kafka","link":"/tags/kafka/"},{"name":"zookeeper","slug":"zookeeper","link":"/tags/zookeeper/"},{"name":"NFS","slug":"NFS","link":"/tags/NFS/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"前端","slug":"前端","link":"/tags/%E5%89%8D%E7%AB%AF/"},{"name":"react","slug":"react","link":"/tags/react/"},{"name":"XML解析器","slug":"XML解析器","link":"/tags/XML%E8%A7%A3%E6%9E%90%E5%99%A8/"},{"name":"XML","slug":"XML","link":"/tags/XML/"},{"name":"前端项目构建工具","slug":"前端项目构建工具","link":"/tags/%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"},{"name":"jmeter","slug":"jmeter","link":"/tags/jmeter/"},{"name":"持久层","slug":"持久层","link":"/tags/%E6%8C%81%E4%B9%85%E5%B1%82/"},{"name":"数据库ID生成设计","slug":"数据库ID生成设计","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93ID%E7%94%9F%E6%88%90%E8%AE%BE%E8%AE%A1/"},{"name":"数据库设计","slug":"数据库设计","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/"},{"name":"WEB容器","slug":"WEB容器","link":"/tags/WEB%E5%AE%B9%E5%99%A8/"},{"name":"RocketMQ","slug":"RocketMQ","link":"/tags/RocketMQ/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"bootstrap","slug":"bootstrap","link":"/tags/bootstrap/"},{"name":"前端案例","slug":"前端案例","link":"/tags/%E5%89%8D%E7%AB%AF%E6%A1%88%E4%BE%8B/"},{"name":"单元测试","slug":"单元测试","link":"/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"},{"name":"gradle","slug":"gradle","link":"/tags/gradle/"},{"name":"日志框架","slug":"日志框架","link":"/tags/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6/"},{"name":"利器","slug":"利器","link":"/tags/%E5%88%A9%E5%99%A8/"}],"categories":[{"name":"PHP","slug":"PHP","link":"/categories/PHP/"},{"name":"C语言","slug":"C语言","link":"/categories/C%E8%AF%AD%E8%A8%80/"},{"name":"整体了解","slug":"PHP/整体了解","link":"/categories/PHP/%E6%95%B4%E4%BD%93%E4%BA%86%E8%A7%A3/"},{"name":"docker","slug":"docker","link":"/categories/docker/"},{"name":"Groovy","slug":"Groovy","link":"/categories/Groovy/"},{"name":"JAVAEE","slug":"JAVAEE","link":"/categories/JAVAEE/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"MAC","slug":"MAC","link":"/categories/MAC/"},{"name":"JAVASE","slug":"JAVASE","link":"/categories/JAVASE/"},{"name":"JavaScript","slug":"前端/JavaScript","link":"/categories/%E5%89%8D%E7%AB%AF/JavaScript/"},{"name":"Homebrew","slug":"MAC/Homebrew","link":"/categories/MAC/Homebrew/"},{"name":"彩蛋闲聊","slug":"MAC/彩蛋闲聊","link":"/categories/MAC/%E5%BD%A9%E8%9B%8B%E9%97%B2%E8%81%8A/"},{"name":"数据持久层","slug":"数据持久层","link":"/categories/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%B1%82/"},{"name":"JVM","slug":"JVM","link":"/categories/JVM/"},{"name":"高级特性","slug":"JAVASE/高级特性","link":"/categories/JAVASE/%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"},{"name":"新特性","slug":"JAVASE/新特性","link":"/categories/JAVASE/%E6%96%B0%E7%89%B9%E6%80%A7/"},{"name":"图形界面","slug":"JAVASE/图形界面","link":"/categories/JAVASE/%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2/"},{"name":"队列与栈","slug":"JAVASE/队列与栈","link":"/categories/JAVASE/%E9%98%9F%E5%88%97%E4%B8%8E%E6%A0%88/"},{"name":"IO流","slug":"JAVASE/IO流","link":"/categories/JAVASE/IO%E6%B5%81/"},{"name":"软件设计","slug":"软件设计","link":"/categories/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/"},{"name":"JDBC","slug":"JAVASE/JDBC","link":"/categories/JAVASE/JDBC/"},{"name":"react native","slug":"react-native","link":"/categories/react-native/"},{"name":"常用类库","slug":"JAVASE/常用类库","link":"/categories/JAVASE/%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%BA%93/"},{"name":"node","slug":"node","link":"/categories/node/"},{"name":"产品心得","slug":"产品心得","link":"/categories/%E4%BA%A7%E5%93%81%E5%BF%83%E5%BE%97/"},{"name":"安卓","slug":"安卓","link":"/categories/%E5%AE%89%E5%8D%93/"},{"name":"国际化应用","slug":"JAVASE/国际化应用","link":"/categories/JAVASE/%E5%9B%BD%E9%99%85%E5%8C%96%E5%BA%94%E7%94%A8/"},{"name":"工具","slug":"工具","link":"/categories/%E5%B7%A5%E5%85%B7/"},{"name":"基础语法","slug":"JAVASE/基础语法","link":"/categories/JAVASE/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"name":"建模","slug":"建模","link":"/categories/%E5%BB%BA%E6%A8%A1/"},{"name":"微信开放平台","slug":"微信开放平台","link":"/categories/%E5%BE%AE%E4%BF%A1%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0/"},{"name":"多线程","slug":"JAVASE/多线程","link":"/categories/JAVASE/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"数据结构","slug":"数据结构","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"异常机制","slug":"JAVASE/异常机制","link":"/categories/JAVASE/%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6/"},{"name":"计算机原理","slug":"计算机原理","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"},{"name":"面向对象","slug":"JAVASE/面向对象","link":"/categories/JAVASE/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"英语天地","slug":"英语天地","link":"/categories/%E8%8B%B1%E8%AF%AD%E5%A4%A9%E5%9C%B0/"},{"name":"设计模式","slug":"JAVASE/设计模式","link":"/categories/JAVASE/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"设计模式","slug":"设计模式","link":"/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"网络编程","slug":"JAVASE/网络编程","link":"/categories/JAVASE/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"集合","slug":"JAVASE/集合","link":"/categories/JAVASE/%E9%9B%86%E5%90%88/"},{"name":"随笔","slug":"随笔","link":"/categories/%E9%9A%8F%E7%AC%94/"},{"name":"数据库连接池","slug":"数据持久层/数据库连接池","link":"/categories/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%B1%82/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/"},{"name":"网络爬虫","slug":"网络爬虫","link":"/categories/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"},{"name":"框架","slug":"框架","link":"/categories/%E6%A1%86%E6%9E%B6/"},{"name":"微服务","slug":"微服务","link":"/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"业务领域","slug":"业务领域","link":"/categories/%E4%B8%9A%E5%8A%A1%E9%A2%86%E5%9F%9F/"},{"name":"中间件","slug":"中间件","link":"/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"CSS","slug":"前端/CSS","link":"/categories/%E5%89%8D%E7%AB%AF/CSS/"},{"name":"HTML","slug":"前端/HTML","link":"/categories/%E5%89%8D%E7%AB%AF/HTML/"},{"name":"react","slug":"前端/react","link":"/categories/%E5%89%8D%E7%AB%AF/react/"},{"name":"Photoshop","slug":"工具/Photoshop","link":"/categories/%E5%B7%A5%E5%85%B7/Photoshop/"},{"name":"XML","slug":"前端/XML","link":"/categories/%E5%89%8D%E7%AB%AF/XML/"},{"name":"项目构建工具","slug":"前端/项目构建工具","link":"/categories/%E5%89%8D%E7%AB%AF/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"},{"name":"数据库","slug":"数据库","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"UML","slug":"建模/UML","link":"/categories/%E5%BB%BA%E6%A8%A1/UML/"},{"name":"微信小程序","slug":"微信开放平台/微信小程序","link":"/categories/%E5%BE%AE%E4%BF%A1%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"测试专栏","slug":"测试专栏","link":"/categories/%E6%B5%8B%E8%AF%95%E4%B8%93%E6%A0%8F/"},{"name":"commons-dbutils工具类","slug":"数据持久层/commons-dbutils工具类","link":"/categories/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%B1%82/commons-dbutils%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"name":"微信支付","slug":"微信开放平台/微信支付","link":"/categories/%E5%BE%AE%E4%BF%A1%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98/"},{"name":"项目","slug":"项目","link":"/categories/%E9%A1%B9%E7%9B%AE/"},{"name":"概论和复杂度","slug":"数据结构/概论和复杂度","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A6%82%E8%AE%BA%E5%92%8C%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"name":"Vue","slug":"前端/Vue","link":"/categories/%E5%89%8D%E7%AB%AF/Vue/"},{"name":"bootstrap","slug":"前端/bootstrap","link":"/categories/%E5%89%8D%E7%AB%AF/bootstrap/"},{"name":"前端项目","slug":"前端项目","link":"/categories/%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE/"},{"name":"项目构建管理","slug":"项目构建管理","link":"/categories/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E7%AE%A1%E7%90%86/"},{"name":"gradle","slug":"工具/gradle","link":"/categories/%E5%B7%A5%E5%85%B7/gradle/"},{"name":"汇编","slug":"计算机原理/汇编","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/%E6%B1%87%E7%BC%96/"},{"name":"结构型模式","slug":"设计模式/结构型模式","link":"/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"设计模式/行为型模式","link":"/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"右脑开发","slug":"随笔/右脑开发","link":"/categories/%E9%9A%8F%E7%AC%94/%E5%8F%B3%E8%84%91%E5%BC%80%E5%8F%91/"},{"name":"全文检索","slug":"框架/全文检索","link":"/categories/%E6%A1%86%E6%9E%B6/%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/"},{"name":"SpringBatch","slug":"框架/SpringBatch","link":"/categories/%E6%A1%86%E6%9E%B6/SpringBatch/"},{"name":"spring","slug":"框架/spring","link":"/categories/%E6%A1%86%E6%9E%B6/spring/"},{"name":"SpringMVC","slug":"框架/SpringMVC","link":"/categories/%E6%A1%86%E6%9E%B6/SpringMVC/"},{"name":"springboot框架","slug":"微服务/springboot框架","link":"/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/springboot%E6%A1%86%E6%9E%B6/"},{"name":"SpringCloud","slug":"微服务/SpringCloud","link":"/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/SpringCloud/"},{"name":"nginx","slug":"中间件/nginx","link":"/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/nginx/"},{"name":"nosql","slug":"中间件/nosql","link":"/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/nosql/"},{"name":"NFS网络文件系统","slug":"中间件/NFS网络文件系统","link":"/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/NFS%E7%BD%91%E7%BB%9C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"name":"后台模板","slug":"前端/HTML/后台模板","link":"/categories/%E5%89%8D%E7%AB%AF/HTML/%E5%90%8E%E5%8F%B0%E6%A8%A1%E6%9D%BF/"},{"name":"MySQL","slug":"数据库/MySQL","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"},{"name":"嵌入式数据库","slug":"数据库/嵌入式数据库","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"安全框架","slug":"框架/安全框架","link":"/categories/%E6%A1%86%E6%9E%B6/%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6/"},{"name":"数据持久层","slug":"框架/数据持久层","link":"/categories/%E6%A1%86%E6%9E%B6/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%B1%82/"},{"name":"消息中间件-RocketMQ","slug":"中间件/消息中间件-RocketMQ","link":"/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-RocketMQ/"},{"name":"在线教育平台案例","slug":"前端项目/在线教育平台案例","link":"/categories/%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE/%E5%9C%A8%E7%BA%BF%E6%95%99%E8%82%B2%E5%B9%B3%E5%8F%B0%E6%A1%88%E4%BE%8B/"},{"name":"JUnit","slug":"项目构建管理/JUnit","link":"/categories/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E7%AE%A1%E7%90%86/JUnit/"},{"name":"solr","slug":"框架/全文检索/solr","link":"/categories/%E6%A1%86%E6%9E%B6/%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/solr/"},{"name":"lucene","slug":"框架/全文检索/lucene","link":"/categories/%E6%A1%86%E6%9E%B6/%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/lucene/"},{"name":"redis","slug":"中间件/nosql/redis","link":"/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/nosql/redis/"},{"name":"shiro","slug":"框架/安全框架/shiro","link":"/categories/%E6%A1%86%E6%9E%B6/%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6/shiro/"},{"name":"spring-security","slug":"框架/安全框架/spring-security","link":"/categories/%E6%A1%86%E6%9E%B6/%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6/spring-security/"},{"name":"mybatis框架","slug":"框架/数据持久层/mybatis框架","link":"/categories/%E6%A1%86%E6%9E%B6/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%B1%82/mybatis%E6%A1%86%E6%9E%B6/"},{"name":"日志框架","slug":"日志框架","link":"/categories/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6/"},{"name":"效率","slug":"项目/效率","link":"/categories/%E9%A1%B9%E7%9B%AE/%E6%95%88%E7%8E%87/"}]}